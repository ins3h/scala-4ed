<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Programming in Scala, 4th Edition</title>
    <style type="text/css">
      html { color: #3a3a3a; line-height: 1.45; font-size: 18px }
      a { text-decoration: none; border-bottom: 1px solid #ddd; color: #222 }
      a:hover { border-bottom: 0 }
      #toc a { border-bottom: 0 }
      img { max-width: 98% }
      h1, h2, h3, h4, h5 { font-family: sans-serif; font-weight: 400 }
      h5 { font-size: .9rem; text-transform: uppercase; color: #666 }
      h4 { font-size: 1.19rem; color: #f62}
      h3 { font-size: 1.42rem; color: #26d !important }
      h2 { font-size: 1.69rem; }
      h1 { font-size: 2rem; }
      h2 + h1 { font-size: 1.69rem; }
      .vem { color: #26f }
      .typename { color: rgb(103,0,154) }
      .quotedstring { color: rgb(205,123,0) }
      .literal { color: #13d }
      .comment { color: #aaa; font-style: italic }
      pre { margin-left: 2rem; background: linear-gradient(rgba(239,255,255,.8), rgba(249,255,255,.8), rgba(239,255,255,.8)) }
      div.h.annotator-wrapper { display: none }
      div.annotator-wrapper.cover { position: relative; }
      div.annotator-wrapper.cover:before { position: absolute; display: block; top: 0; left: 0; right: 0; bottom: 0; z-index: -5; opacity: .08; content: ' '; background: url(cover.jpg) top right no-repeat; }
    </style>
  </head>
  <body>
    <div class="js">
      <span onclick="f('0')">&#x24FF;</span>
      <span onclick="f('1')">&#x2460;</span>
      <span onclick="f('2')">&#x2461;</span>
      <span onclick="f('3')">&#x2462;</span>
      <span onclick="f('4')">&#x2463;</span>
      <span onclick="f('5')">&#x2464;</span>
      <span onclick="f('6')">&#x2465;</span>
      <span onclick="f('7')">&#x2466;</span>
      <span onclick="f('8')">&#x2467;</span>
      <span onclick="f('9')">&#x2468;</span>
      <span onclick="clear()">&#x23F9;</span>
      <style type="text/css">
        .js span { display: inline-block; margin-left: 1rem }
      </style>
      <script type="text/javascript">
        let kw = '';
        function clear() { kw = '' }
        function f(s) { 
          kw += s;
          if (kw === '4191982') {
            Array.from(document.querySelectorAll('div.h.annotator-wrapper')).forEach(div => {
              const a = ' ' + div.getAttribute('class') + ' ';
              div.setAttribute('class', a.replace(' h ', '').trim());
            });
            Array.from(document.querySelectorAll('div.js')).forEach(div => {
              div.style.display = 'none';
            });
          }
        }
      </script>
    </div>
    <div class="h annotator-wrapper">
      <h1><a id="TOC">Table of Contents</a></h1>
      <div id="toc">
        <table><tr><td>
          <div class="tocentry"> <a href="#front2">Foreword</a></div>
          <div class="tocentry"> <a href="#front3">Acknowledgments</a></div>
          <div class="tocentry"> <a href="#front4">Introduction</a></div>
          <div class="tocentry"> <a href="#chap-a-scalable-language">1. A Scalable Language</a></div>
          <div class="tocentry"> <a href="#chap-first-steps-in-scala">2. First Steps in Scala</a></div>
          <div class="tocentry"> <a href="#chap-next-steps-in-scala">3. Next Steps in Scala</a></div>
          <div class="tocentry"> <a href="#chap-classes-and-objects">4. Classes and Objects</a></div>
          <div class="tocentry"> <a href="#chap-basic-types-and-operations">5. Basic Types and Operations</a></div>
          <div class="tocentry"> <a href="#chap-functional-objects">6. Functional Objects</a></div>
          <div class="tocentry"> <a href="#chap-built-in-control-structures">7. Built-in Control Structures</a></div>
          <div class="tocentry"> <a href="#chap-functions-and-closures">8. Functions and Closures</a></div>
          <div class="tocentry"> <a href="#chap-control-abstraction">9. Control Abstraction</a></div>
          <div class="tocentry"> <a href="#chap-composition-and-inheritance">10. Composition and Inheritance</a></div>
          <div class="tocentry"> <a href="#chap-scalas-hierarchy">11. Scala's Hierarchy</a></div>
          <div class="tocentry"> <a href="#chap-traits">12. Traits</a></div>
          <div class="tocentry"> <a href="#chap-packages-and-imports">13. Packages and Imports</a></div>
          <div class="tocentry"> <a href="#chap-assertions-and-tests">14. Assertions and Tests</a></div>
          <div class="tocentry"> <a href="#chap-case-classes-and-pattern-matching">15. Case Classes and Pattern Matching</a></div>
          <div class="tocentry"> <a href="#chap-working-with-lists">16. Working with Lists</a></div>
          <div class="tocentry"> <a href="#chap-working-with-other-collections">17. Working with Other Collections</a></div>
          <div class="tocentry"> <a href="#chap-mutable-objects">18. Mutable Objects</a></div>
          <div class="tocentry"> <a href="#chap-type-parameterization">19. Type Parameterization</a></div>
        </td><td style="padding-left: 2em">
          <div class="tocentry"> <a href="#chap-abstract-members">20. Abstract Members</a></div>
          <div class="tocentry"> <a href="#chap-implicit-conversions-and-parameters">21. Implicit Conversions and Parameters</a></div>
          <div class="tocentry"> <a href="#chap-implementing-lists">22. Implementing Lists</a></div>
          <div class="tocentry"> <a href="#chap-for-expressions-revisited.html">23. For Expressions Revisited</a></div>
          <div class="tocentry"> <a href="#chap-collections-in-depth">24. Collections in Depth</a></div>
          <div class="tocentry"> <a href="#chap-the-architecture-of-scala-collections">25. The Architecture of Scala Collections</a></div>
          <div class="tocentry"> <a href="#chap-extractors">26. Extractors</a></div>
          <div class="tocentry"> <a href="#chap-annotations">27. Annotations</a></div>
          <div class="tocentry"> <a href="#chap-working-with-xml">28. Working with XML</a></div>
          <div class="tocentry"> <a href="#chap-modular-programming-using-objects">29. Modular Programming Using Objects</a></div>
          <div class="tocentry"> <a href="#chap-object-equality">30. Object Equality</a></div>
          <div class="tocentry"> <a href="#chap-combining-scala-and-java">31. Combining Scala and Java</a></div>
          <div class="tocentry"> <a href="#chap-futures-and-concurrency">32. Futures and Concurrency</a></div>
          <div class="tocentry"> <a href="#chap-combinator-parsing">33. Combinator Parsing</a></div>
          <div class="tocentry"> <a href="#chap-gui-programming">34. GUI Programming</a></div>
          <div class="tocentry"> <a href="#chap-the-scells-spreadsheet">35. The <span class="code">SCells</span> Spreadsheet</a></div>
          <div class="tocentry"> <a href="scala-scripts-on-unix-and-windows.html">A. Scala Scripts on Unix and Windows</a></div>
          <div class="tocentry"> <a href="#glossaryanchor">Glossary</a></div>
          <div class="tocentry"> <a href="#biblioanchor">Bibliography</a></div>
          <div class="tocentry"> <a href="about-the-authors.html">About the Authors</a></div>
          <div class="tocentry"> <a href="#indexanchor">Index</a></div>
        </td></tr></table>
      </div>
    </div>
    <div class="h annotator-wrapper">
      <h2><a id="front2"></a></h2>
      <h1>Foreword</h1>
      <p>When I sat down in 2004, at the start of my programming career, and chose a little-known language called Scala, I couldn't have realized what a voyage of exploration and discovery I was about to begin.</p>
      <p>At the start, my experience using Scala was much the same as other languages I had tried: trial and error, experimentation and discovery, misconceptions then enlightenment. In those days, we had very little material to learn from: no tutorials, blogs, or experienced users to teach us. We certainly did not have a resource like <span class="textit">Programming in Scala</span>. We just had a language with a wonderful set of new features that nobody was fully certain how to use. It was at once empowering and bewildering!</p>
      <p>My background as a Java programmer set me up with certain expectations, but the day-to-day routine of coding in Scala <span class="textit">felt</span> different. I remember some early formative adventures with Scala, working on a medium-sized project with one other person. I would decide to undertake a refactoring—discovering and learning new features and patterns at a steady pace made this quite common—and I would go through several iterations of compilation. Each time, the compiler would report a list of errors to me, along with line numbers. And each time I would go to the line number, work out what was wrong, change the code to fix the errors (or more often, move them elsewhere). But at every step, the compiler was guiding me directly to the problem. Sometimes, several days of these repetitions would pass without a single successful compilation. But after gradually reducing the number of compile errors from a hundred to a dozen to one, and finally down to zero—a successful compilation—I would come to run the heavily-refactored software for the first time.</p>
      <p>And, against expectation, it would work the first time. As a young programmer with only prior experience of Java, Perl, Pascal, BASIC, PHP, and JavaScript, I can't overstate what an impression this made upon me.</p>
      <p>At the first Scala World conference I organized in 2015, Rúnar Bjarnason gave the opening keynote in which he claimed that "constraints liberate and liberties constrain." Never is this more evident than during compilation with Scala: the knowledge that <span class="code">scalac</span> enforces a comprehensive set of constraints whose purpose is to save the programmer from predictable runtime errors—the worst errors—should be liberating to any programmer. It should fill that programmer with the confidence to experiment, explore, and embark upon ambitious changes even in the absence of a comprehensive test suite.</p>
      <p>Over the years since then, I have continued to learn Scala, to this day discovering new possibilities, nuances, and interesting interactions between multiple features. I don't know of any other language with the depth to infatuate its users for so many years.</p>
      <p>Scala is about to embark on a period of great change. The next major version, Scala 3, will be almost as much of an upgrade from Scala 2 as the upgrade I made fifteen years ago from Java. Much of the everyday experience of programming in Scala will remain the same, but a new repertoire of features cutting across all areas of the language will become available to us. At the time of writing, widespread adoption of Scala 3 is still a few years away, and Scala 2 will be continue to be the de facto version of Scala for the foreseeable future.</p>
      <p>The latest release of Scala 2, version 2.13, covered extensively in this book, introduces a new collections library to the standard library, redesigned for simplicity to incorporate many of the lessons learned since the last major redesign that came with Scala 2.8. These new collections will cross-compile on both Scala 2 and 3, so will form the basis for much of the code we write well into the next decade, and with so much excitement around the next release of Scala, this is a great time to pick up <span class="textit">Programming in Scala</span> and start learning!</p>
      <p><!-- \hfill --> Jon Pretty<br> Kraków, Poland<br> September 12, 2019</p>
    </div>
    <div class="h annotator-wrapper">
      <h2><a id="front3"></a></h2>
      <h1>Acknowledgments</h1>
      <p>Many people have contributed to this book and to the material it covers. We are grateful to all of them.</p>
      <p>Scala itself has been a collective effort of many people. The design and the implementation of version 1.0 was helped by Philippe Altherr, Vincent Cremet, Gilles Dubochet, Burak Emir, Stéphane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik Stenman, and Matthias Zenger. Phil Bagwell, Antonio Cunei, Iulian Dragos, Gilles Dubochet, Miguel Garcia, Philipp Haller, Sean McDirmid, Ingo Maier, Donna Malayeri, Adriaan Moors, Hubert Plociniczak, Paul Phillips, Aleksandar Prokopec, Tiark Rompf, Lukas Rytz, and Geoffrey Washburn joined in the effort to develop the second and current version of the language and tools.</p>
      <p>Gilad Bracha, Nathan Bronson, Caoyuan, Aemon Cannon, Craig Chambers, Chris Conrad, Erik Ernst, Matthias Felleisen, Mark Harrah, Shriram Krishnamurti, Gary Leavens, David MacIver, Sebastian Maneth, Rickard Nilsson, Erik Meijer, Lalit Pant, David Pollak, Jon Pretty, Klaus Ostermann, Jorge Ortiz, Didier Rémy, Miles Sabin, Vijay Saraswat, Daniel Spiewak, James Strachan, Don Syme, Erik Torreborre, Mads Torgersen, Philip Wadler, Jamie Webb, John Williams, Kevin Wright, and Jason Zaugg have shaped the design of the language by graciously sharing their ideas with us in lively and inspiring discussions, by contributing important pieces of code to the open source effort, as well as through comments on previous versions of this document. The contributors to the Scala mailing list have also given very useful feedback that helped us improve the language and its tools.</p>
      <p>George Berger has worked tremendously to make the build process and the web presence for the book work smoothly. As a result this project has been delightfully free of technical snafus.</p>
      <p>Many people gave us valuable feedback on early versions of the text. Thanks goes to Eric Armstrong, George Berger, Alex Blewitt, Gilad Bracha, William Cook, Bruce Eckel, Stéphane Micheloud, Todd Millstein, David Pollak, Frank Sommers, Philip Wadler, and Matthias Zenger. Thanks also to the Silicon Valley Patterns group for their very helpful review: Dave Astels, Tracy Bialik, John Brewer, Andrew Chase, Bradford Cross, Raoul Duke, John P. Eurich, Steven Ganz, Phil Goodwin, Ralph Jocham, Yan-Fa Li, Tao Ma, Jeffery Miller, Suresh Pai, Russ Rufer, Dave W. Smith, Scott Turnquest, Walter Vannini, Darlene Wallach, and Jonathan Andrew Wolter. And we'd like to thank Dewayne Johnson and Kim Leedy for their help with the cover art, and Frank Sommers for his work on the index.</p>
      <p>We'd also like to extend a special thanks to all of our readers who contributed comments. Your comments were very helpful to us in shaping this into an even better book. We couldn't print the names of everyone who contributed comments, but here are the names of readers who submitted at least five comments during the eBook PrePrint® stage by clicking on the Suggest link, sorted first by the highest total number of comments submitted, then alphabetically. Thanks goes to: David Biesack, Donn Stephan, Mats Henricson, Rob Dickens, Blair Zajac, Tony Sloane, Nigel Harrison, Javier Diaz Soto, William Heelan, Justin Forder, Gregor Purdy, Colin Perkins, Bjarte S. Karlsen, Ervin Varga, Eric Willigers, Mark Hayes, Martin Elwin, Calum MacLean, Jonathan Wolter, Les Pruszynski, Seth Tisue, Andrei Formiga, Dmitry Grigoriev, George Berger, Howard Lovatt, John P. Eurich, Marius Scurtescu, Jeff Ervin, Jamie Webb, Kurt Zoglmann, Dean Wampler, Nikolaj Lindberg, Peter McLain, Arkadiusz Stryjski, Shanky Surana, Craig Bordelon, Alexandre Patry, Filip Moens, Fred Janon, Jeff Heon, Boris Lorbeer, Jim Menard, Tim Azzopardi, Thomas Jung, Walter Chang, Jeroen Dijkmeijer, Casey Bowman, Martin Smith, Richard Dallaway, Antony Stubbs, Lars Westergren, Maarten Hazewinkel, Matt Russell, Remigiusz Michalowski, Andrew Tolopko, Curtis Stanford, Joshua Cough, Zemian Deng, Christopher Rodrigues Macias, Juan Miguel Garcia Lopez, Michel Schinz, Peter Moore, Randolph Kahle, Vladimir Kelman, Daniel Gronau, Dirk Detering, Hiroaki Nakamura, Ole Hougaard, Bhaskar Maddala, David Bernard, Derek Mahar, George Kollias, Kristian Nordal, Normen Mueller, Rafael Ferreira, Binil Thomas, John Nilsson, Jorge Ortiz, Marcus Schulte, Vadim Gerassimov, Cameron Taggart, Jon-Anders Teigen, Silvestre Zabala, Will McQueen, and Sam Owen.</p>
      <p>We would also like to thank those who submitted comments and errata after the first two editions were published, including Felix Siegrist, Lothar Meyer-Lerbs, Diethard Michaelis, Roshan Dawrani, Donn Stephan, William Uther, Francisco Reverbel, Jim Balter, and Freek de Bruijn, Ambrose Laing, Sekhar Prabhala, Levon Saldamli, Andrew Bursavich, Hjalmar Peters, Thomas Fehr, Alain O'Dea, Rob Dickens, Tim Taylor, Christian Sternagel, Michel Parisien, Joel Neely, Brian McKeon, Thomas Fehr, Joseph Elliott, Gabriel da Silva Ribeiro, Thomas Fehr, Pablo Ripolles, Douglas Gaylor, Kevin Squire, Harry-Anton Talvik, Christopher Simpkins, Martin Witmann-Funk, Jim Balter, Peter Foster, Craig Bordelon, Heinz-Peter Gumm, Peter Chapin, Kevin Wright, Ananthan Srinivasan, Omar Kilani, Donn Stephan, Guenther Waffler.</p>
      <p>Lex would like to thank Aaron Abrams, Jason Adams, Henry and Emily Crutcher, Joey Gibson, Gunnar Hillert, Matthew Link, Toby Reyelts, Jason Snape, John and Melinda Weathers, and all of the Atlanta Scala Enthusiasts for many helpful discussions about the language design, its mathematical underpinnings, and how to present Scala to working engineers.</p>
      <p>A special thanks to Dave Briccetti and Adriaan Moors for reviewing the third edition, and to Marconi Lanna for not only reviewing, but providing motivation for the third edition by giving a talk entitled "What's new since <span class="textit">Programming in Scala</span>."</p>
      <p>Bill would like to thank Gary Cornell, Greg Doench, Andy Hunt, Mike Leonard, Tyler Ortman, Bill Pollock, Dave Thomas, and Adam Wright for providing insight and advice on book publishing. Bill would also like to thank Dick Wall for collaborating on our <span class="textit">Stairway to Scala</span> course, which is in great part based on this book. Our many years of experience teaching <span class="textit">Stairway to Scala</span> helped make this book better. Lastly, Bill would like to thank Darlene Gruendl and Samantha Woolf for their help in getting the third edition completed.</p>
      <p>Finally, we would like to thank Julien Richard-Foy for his work to bring the fourth edition of this book up to date with Scala 2.13, in particular the new collections redesign.</p>
    </div>
    <div class="h annotator-wrapper">
      <h2><a id="front4"></a></h2>
      <h1>Introduction</h1>
      <p>This book is a tutorial for the Scala programming language, written by people directly involved in the development of Scala. Our goal is that by reading this book, you can learn everything you need to be a productive Scala programmer. All examples in this book compile with Scala version 2.13.1.</p>
      <h3>Who should read this book</h3>
      <p>The main target audience for this book is programmers who want to learn to program in Scala. If you want to do your next software project in Scala, then this is the book for you. In addition, the book should be interesting to programmers wishing to expand their horizons by learning new concepts. If you're a Java programmer, for example, reading this book will expose you to many concepts from functional programming as well as advanced object-oriented ideas. We believe learning about Scala, and the ideas behind it, can help you become a better programmer in general.</p>
      <p>General programming knowledge is assumed. While Scala is a fine first programming language, this is not the book to use to learn programming.</p>
      <p>On the other hand, no specific knowledge of programming languages is required. Even though most people use Scala on the Java platform, this book does not presume you know anything about Java. However, we expect many readers to be familiar with Java, and so we sometimes compare Scala to Java to help such readers understand the differences.</p>
      <h3>How to use this book</h3>
      <p>Because the main purpose of this book is to serve as a tutorial, the recommended way to read this book is in chapter order, from front to back. We have tried hard to introduce one topic at a time, and explain new topics only in terms of topics we've already introduced. Thus, if you skip to the back to get an early peek at something, you may find it explained in terms of concepts you don't quite understand. To the extent you read the chapters in order, we think you'll find it quite straightforward to gain competency in Scala, one step at a time.</p>
      <p>If you see a term you do not know, be sure to check the glossary and the index. Many readers will skim parts of the book, and that is just fine. The glossary and index can help you backtrack whenever you skim over something too quickly.</p>
      <p>After you have read the book once, it should also serve as a language reference. There is a formal specification of the Scala language, but<a id="i1552805019-1"></a> the language specification tries for precision at the expense of readability. Although this book doesn't cover every detail of Scala, it is quite comprehensive and should serve as an approachable language reference as you become more adept at programming in Scala.</p>
      <h3>How to learn Scala</h3>
      <p>You will learn a lot about Scala simply by reading this book from cover to cover. You can learn Scala faster and more thoroughly, though, if you do a few extra things.</p>
      <p>First of all, you can take advantage of the many program examples included in the book. Typing them in yourself is a way to force your mind through each line of code. Trying variations is a way to make them more fun and to make sure you really understand how they work.</p>
      <p>Second, keep in touch with the numerous online forums. That way, you and other Scala enthusiasts can help each other. There are numerous mailing lists, discussion forums, a chat room, a wiki, and multiple Scala-specific article feeds. Take some time to find ones that fit your information needs. You will spend a lot less time stuck on little problems, so you can spend your time on deeper, more important questions.</p>
      <p>Finally, once you have read enough, take on a programming project of your own. Work on a small program from scratch or develop an add-in to a larger program. You can only go so far by reading.</p>
      <h3>EBook features</h3>
      <p>This book is available in both paper and PDF eBook form. The eBook is not simply an electronic copy of the paper version of the book. While the content is the same as in the paper version, the eBook has been carefully designed and optimized for reading on a computer screen.</p>
      <p>The first thing to notice is that most references within the eBook are hyperlinked. If you select a reference to a chapter, figure, or glossary entry, your PDF viewer should take you immediately to the selected item so that you do not have to flip around to find it.</p>
      <p>Additionally, at the bottom of each page in the eBook are a number of navigation links. The Cover, Overview, and Contents links take you to the front matter of the book. The Glossary and Index links take you to reference parts of the book. Finally, the Discuss link takes you to an online forum where you discuss questions with other readers, the authors, and the larger Scala community. If you find a typo, or something you think could be explained better, please click on the Suggest link, which will take you to an online web application where you can give the authors feedback.</p>
      <p>Although the same pages appear in the eBook as in the printed book, blank pages are removed and the remaining pages renumbered. The pages are numbered differently so that it is easier for you to determine PDF page numbers when printing only a portion of the eBook. The pages in the eBook are, therefore, numbered exactly as your PDF viewer will number them.</p>
      <h3>Typographic conventions</h3>
      <p>The first time a <em>term</em> is used, it is italicized. Small code examples, such as <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span>, are written inline with a mono-spaced font. Larger code examples are put into mono-spaced quotation blocks like this:</p> <pre>  <code class="vem">def</code>&nbsp;hello()&nbsp;=&nbsp;{
  &nbsp;&nbsp;println(<code class="quotedstring">"Hello,&nbsp;world!"</code>)
  }
</pre>
      <p>When interactive shells are shown, responses from the shell are shown in a lighter font:</p> <pre>  scala&gt;&nbsp;<code class="literal">3</code>&nbsp;+&nbsp;<code class="literal">4</code>
  <code class="output">res0:&nbsp;Int&nbsp;=&nbsp;7</code>
</pre>
      <h3>Content overview</h3>
      <ul>
        <li><a href="#chap-a-scalable-language">Chapter 1</a> "A Scalable Language," gives an overview of Scala's design as well as the reasoning, and history, behind it.<br><br> </li>
        <li><a href="#chap-first-steps-in-scala">Chapter 2</a> "First Steps in Scala," shows you how to do a number of basic programming tasks in Scala, without going into great detail about how they work. The goal of this chapter is to get your fingers started typing and running Scala code.<br><br> </li>
        <li><a href="#chap-next-steps-in-scala">Chapter 3</a> "Next Steps in Scala," shows you several more basic programming tasks that will help you get up to speed quickly in Scala. After completing this chapter, you should be able to start using Scala for simple scripting tasks.<br><br> </li>
        <li><a href="#chap-classes-and-objects">Chapter 4</a> "Classes and Objects," starts the in-depth coverage of Scala with a description of its basic object-oriented building blocks and instructions on how to compile and run a Scala application.<br><br> </li>
        <li><a href="#chap-basic-types-and-operations">Chapter 5</a> "Basic Types and Operations," covers Scala's basic types, their literals, the operations you can perform on them, how precedence and associativity works, and what rich wrappers are.<br><br> </li>
        <li><a href="#chap-functional-objects">Chapter 6</a> "Functional Objects," dives more deeply into the object-oriented features of Scala, using functional (<i>i.e.</i>, immutable) rational numbers as an example.<br><br> </li>
        <li><a href="#chap-built-in-control-structures">Chapter 7</a> "Built-in Control Structures," shows you how to use Scala's built-in control structures: <span class="code">if</span>, <span class="code">while</span>, <span class="code">for</span>, <span class="code">try</span>, and <span class="code">match</span>.<br><br> </li>
        <li><a href="#chap-functions-and-closures">Chapter 8</a> "Functions and Closures," provides in-depth coverage of functions, the basic building block of functional languages.<br><br> </li>
        <li><a href="#chap-control-abstraction">Chapter 9</a> "Control Abstraction," shows how to augment Scala's basic control structures by defining your own control abstractions.<br><br> </li>
        <li><a href="#chap-composition-and-inheritance">Chapter 10</a> "Composition and Inheritance," discusses more of Scala's support for object-oriented programming. The topics are not as fundamental as those in Chapter 4, but they frequently arise in practice.<br><br> </li>
        <li><a href="#chap-scalas-hierarchy">Chapter 11</a> "Scala's Hierarchy," explains Scala's inheritance hierarchy and discusses its universal methods and bottom types.<br><br> </li>
        <li><a href="#chap-traits">Chapter 12</a> "Traits," covers Scala's mechanism for mixin composition. The chapter shows how traits work, describes common uses, and explains how traits improve on traditional multiple inheritance.<br><br> </li>
        <li><a href="#chap-packages-and-imports">Chapter 13</a> "Packages and Imports," discusses issues with programming in the large, including top-level packages, import statements, and access control modifiers like <span class="code">protected</span> and <span class="code">private</span>.<br><br> </li>
        <li><a href="#chap-assertions-and-tests">Chapter 14</a> "Assertions and Tests," shows Scala's assertion mechanism and gives a tour of several tools available for writing tests in Scala, focusing on ScalaTest in particular.<br><br> </li>
        <li><a href="#chap-case-classes-and-pattern-matching">Chapter 15</a> "Case Classes and Pattern Matching," introduces twin constructs that support you when writing regular, non-encapsulated data structures. Case classes and pattern matching are particularly helpful for tree-like recursive data.<br><br> </li>
        <li><a href="#chap-working-with-lists">Chapter 16</a> "Working with Lists," explains in detail lists, which are probably the most commonly used data structure in Scala programs.<br><br> </li>
        <li><a href="#chap-working-with-other-collections">Chapter 17</a> "Working with Other Collections," shows you how to use the basic Scala collections, such as lists, arrays, tuples, sets, and maps.<br><br> </li>
        <li><a href="#chap-mutable-objects">Chapter 18</a> "Mutable Objects," explains mutable objects and the syntax Scala provides to express them. The chapter concludes with a case study on discrete event simulation, which shows some mutable objects in action.<br><br> </li>
        <li><a href="#chap-type-parameterization">Chapter 19</a> "Type Parameterization," explains some of the techniques for information hiding introduced in Chapter 13 by means of a concrete example: the design of a class for purely functional queues. The chapter builds up to a description of variance of type parameters and how it interacts with information hiding.<br><br> </li>
        <li><a href="#chap-abstract-members">Chapter 20</a> "Abstract Members," describes all kinds of abstract members that Scala supports; not only methods, but also fields and types, can be declared abstract.<br><br> </li>
        <li><a href="#chap-implicit-conversions-and-parameters">Chapter 21</a> "Implicit Conversions and Parameters," covers two constructs that can help you omit tedious details from source code, letting the compiler supply them instead.<br><br> </li>
        <li><a href="#chap-implementing-lists">Chapter 22</a> "Implementing Lists," describes the implementation of class <span class="code">List</span>. It is important to understand how lists work in Scala, and furthermore the implementation demonstrates the use of several of Scala's features.<br><br> </li>
        <li><a href="#chap-for-expressions-revisited.html">Chapter 23</a> "For Expressions Revisited," shows how <span class="code">for</span> expressions are translated to invocations of <span class="code">map</span>, <span class="code">flatMap</span>, <span class="code">filter</span>, and <span class="code">foreach</span>.<br><br> </li>
        <li><a href="#chap-collections-in-depth">Chapter 24</a> "Collections in Depth," gives a detailed tour of the collections library.<br><br> </li>
        <li><a href="#chap-the-architecture-of-scala-collections">Chapter 25</a> "The Architecture of Scala Collections," shows how the collection library is built and how you can implement your own collections.<br><br> </li>
        <li><a href="#chap-extractors">Chapter 26</a> "Extractors," shows how to pattern match against arbitrary classes, not just case classes.<br><br> </li>
        <li><a href="#chap-annotations">Chapter 27</a> "Annotations," shows how to work with language extension via annotation. The chapter describes several standard annotations and shows you how to make your own.<br><br> </li>
        <li><a href="#chap-working-with-xml">Chapter 28</a> "Working with XML," explains how to process XML in Scala. The chapter shows you idioms for generating XML, parsing it, and processing it once it is parsed.<br><br> </li>
        <li><a href="#chap-modular-programming-using-objects">Chapter 29</a> "Modular Programming Using Objects," shows how you can use Scala's objects as a modules system.<br><br> </li>
        <li><a href="#chap-object-equality">Chapter 30</a> "Object Equality," points out several issues to consider when writing an <span class="code">equals</span> method. There are several pitfalls to avoid.<br><br> </li>
        <li><a href="#chap-combining-scala-and-java">Chapter 31</a> "Combining Scala and Java," discusses issues that arise when combining Scala and Java together in the same project, and suggests ways to deal with them.<br><br> </li>
        <li><a href="#chap-futures-and-concurrency">Chapter 32</a> "Futures and Concurrency," shows you how to use Scala's <span class="code">Future</span>. Although you can use the Java platform's concurrency primitives and libraries for Scala programs, futures can help you avoid the deadlocks and race conditions that plague the traditional "threads and locks" approach to concurrency.<br><br> </li>
        <li><a href="#chap-combinator-parsing">Chapter 33</a> "Combinator Parsing," shows how to build parsers using Scala's library of parser combinators.<br><br> </li>
        <li><a href="#chap-gui-programming">Chapter 34</a> "GUI Programming," gives a quick tour of a Scala library that simplifies GUI programming with Swing.<br><br> </li>
        <li><a href="#chap-the-scells-spreadsheet">Chapter 35</a> "The <span class="code">SCells</span> Spreadsheet," ties everything together by showing a complete spreadsheet application written in Scala.<br><br> </li>
      </ul>
      <h3>Resources</h3>
      <p>At <a href="http://www.scala-lang.org">http://www.scala-lang.org</a>, the main website for Scala, you'll find the latest Scala release and links to documentation and community resources. For a more condensed page of links to Scala resources, visit this book's website: <a href="http://booksites.artima.com/programming_in_scala_4ed">http://booksites.artima.com/programming_in_scala_4ed</a>. To interact with other readers of this book, check out the Programming in Scala Forum, at: <a href="http://www.artima.com/forums/forum.jsp?forum=282">http://www.artima.com/forums/forum.jsp?forum=282</a>.</p>
      <h3>Source code</h3>
      <p>You can download a ZIP file containing the source code of this book, which is released under the Apache 2.0 open source license, from the book's website:<a id="i742232475-1"></a><a id="i1840350167-1"></a><a id="i1878821113-1"></a> <a href="http://booksites.artima.com/programming_in_scala_4ed">http://booksites.artima.com/programming_in_scala_4ed</a>.</p>
      <h3>Errata</h3>
      <p>Although this book has been heavily reviewed and checked, errors will<a id="i-1149733563-1"></a> inevitably slip through. For a (hopefully short) list of errata for this book, visit <a href="http://booksites.artima.com/programming_in_scala_4ed/errata">http://booksites.artima.com/programming_in_scala_4ed/errata</a>.<br> If you find an error, please report it at the above URL, so that we can fix it in a future printing or edition of this book.</p>
      <div style="text-align: center"> <span style="font-size:xx-large">Programming in Scala, Fourth Edition <span style="font-size:large"> <br> <span style="font-size:x-large"> Fourth Edition</span> </span></span>
      </div>
      <div style="text-align: center; font-size:x-large">
      </div>
      <div style="text-align: center">
        <p><span style="font-size:medium"><span class="code">println("Hello,</span>&nbsp;<span class="code">reader!")</span></span></p>
      </div>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-a-scalable-language">Chapter 1</a></h2>
      <h1>A Scalable Language</h1>
      <p>The name Scala stands for "scalable language." The language is so named because it was designed to grow with the demands of its users. You can apply Scala to a wide range of programming tasks, from writing small scripts to building large systems.<a href="#footnotemain1-1">[1]</a></p>
      <p>Scala is easy to get into. It runs on the standard Java platform and interoperates<a id="i648458520-1"></a><a id="i239541118-1"></a><a id="i1157110682-1"></a><a id="i1003002536-1"></a> seamlessly with all Java libraries. It's quite a good language for writing scripts that pull together Java components. But it can apply its strengths even more when used for building large systems and frameworks of reusable components.</p>
      <p>Technically, Scala is a blend of object-oriented and functional programming concepts in a statically typed language<a id="i-1150036974-1"></a><a id="i717865003-1"></a>. The fusion of object-oriented and functional programming shows up in many different aspects of Scala; it is probably more pervasive than in any other widely used language. The two programming styles have complementary strengths when it comes to scalability. Scala's functional programming constructs make it easy to build interesting things quickly from simple parts. Its object-oriented constructs make it easy to structure larger systems and adapt them to new demands. The combination of both styles in Scala makes it possible to express new kinds of programming patterns and component abstractions. It also leads to a legible and concise programming style. And because it is so malleable, programming in Scala can be a lot of fun.</p>
      <p>This initial chapter answers the question, "Why Scala?" It gives a high-level view of Scala's design and the reasoning behind it. After reading the chapter you should have a basic feel for what Scala is and what kinds of tasks it might help you accomplish. Although this book is a Scala tutorial, this chapter isn't really part of the tutorial. If you're eager to start writing some Scala code, you should jump ahead to <a href="#chap-first-steps-in-scala">Chapter 2</a>.</p>
      <h3 id="sec-a-language-that-grows-on-you">1.1 A language that grows on you</h3>
      <p>Programs of different sizes tend to require different programming constructs. Consider, for example, the following small Scala program:</p> <pre>  <code class="vem">var</code>&nbsp;capital&nbsp;=&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"US"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Washington"</code>,&nbsp;<code class="quotedstring">"France"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Paris"</code>)
  <br>  capital&nbsp;+=&nbsp;(<code class="quotedstring">"Japan"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Tokyo"</code>)
  <br>  println(capital(<code class="quotedstring">"France"</code>))&nbsp;
</pre>
      <p>This program sets up a map from countries to their capitals, modifies the map by adding a new binding <span class="code">("Japan"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">"Tokyo")</span>, and prints the capital associated with the country France.<a href="#footnotemain1-2">[2]</a> The notation in this example is high level, to the point, and not cluttered with extraneous semicolons or type annotations.<a id="i-2107785776-1"></a><a id="i1449766718-1"></a> Indeed, the feel is that of a modern "scripting" language like Perl,<a id="i389811529-1"></a> Python,<a id="i-1190645252-1"></a> or Ruby.<a id="i-1999895874-1"></a> One common characteristic of these languages, which is relevant for the example above, is that they each support an "associative map" construct<a id="i733051324-1"></a> in the syntax of the language.</p>
      <p>Associative maps are very useful because they help keep programs legible and concise, but sometimes you might not agree with their "one size fits all" philosophy because you need to control the properties of the maps you use in your program in a more fine-grained way. Scala gives you this fine-grained control if you need it, because maps in Scala are not language syntax. They are library abstractions that you can extend and adapt.</p>
      <p>In the above program, you'll get a default <span class="code">Map</span> implementation, but you can easily change that. You could for example specify a particular implementation, such as a <span class="code">HashMap</span> or a <span class="code">TreeMap</span>, or invoke the <span class="code">par</span> method to obtain a <span class="code">ParMap</span> that executes operations in parallel. You<a id="i-1874383620-1"></a><a id="i-1964267956-1"></a> could specify a default value for the map, or you could override any other method of the map you create. In each case, you can use the same easy access syntax for maps as in the example above.</p>
      <p>This example shows that Scala can give you both convenience and flexibility. Scala has a set of convenient constructs that help you get started quickly and let you program in a pleasantly concise style. At the same time, you have the assurance that you will not outgrow the language. You can always tailor the program to your requirements, because everything is based on library modules that you can select and adapt as needed.</p>
      <h4>Growing new types</h4>
      <p><a id="sec-growing-new-types"></a></p>
      <p>Eric Raymond<a id="i-1761921411-1"></a> introduced the cathedral and bazaar as two metaphors of software development.<a href="#footnotemain1-3">[3]</a><a id="i-1761921411-2"></a> The cathedral is a near-perfect building that takes a long time to build. Once built, it stays unchanged for a long time. The bazaar, by contrast, is adapted and extended each day by the people working in it. In Raymond's work the bazaar is a metaphor for open-source software development. Guy Steele noted in a talk on "growing a language" that the same distinction can be applied to language design.<a href="#footnotemain1-4">[4]</a><a id="i1916394333-1"></a> Scala is much more like a bazaar than a cathedral, in the sense that it is designed to be extended and adapted by the people programming in it. Instead of providing all constructs you might ever need in one "perfectly complete" language, Scala puts the tools for building such constructs into your hands.<a id="i294325658-1"></a></p>
      <p>Here's an example. Many applications need a type of integer that can become arbitrarily large without overflow or "wrap-around" of arithmetic operations. Scala defines such a type in library class <span class="code">scala.math.BigInt</span>.<a id="i1989635823-1"></a> Here is the definition of a method using that type, which calculates the factorial of a passed integer value:<a href="#footnotemain1-5">[5]</a></p> <pre>  <code class="vem">def</code>&nbsp;factorial(x:&nbsp;<code class="typename">BigInt</code>):&nbsp;<code class="typename">BigInt</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="literal">1</code>&nbsp;<code class="vem">else</code>&nbsp;x&nbsp;*&nbsp;factorial(x&nbsp;-&nbsp;<code class="literal">1</code>)
</pre>
      <p>Now, if you call <span class="code">factorial(30)</span> you would get:</p> <pre>  <code class="literal">265252859812191058636308480000000</code>
</pre>
      <p><span class="code">BigInt</span> looks like a built-in type because you can use integer literals and operators such as <span class="code">*</span> and <span class="code">-</span> with values of that type. Yet it is just a class that happens to be defined in Scala's standard library.<a href="#footnotemain1-6">[6]</a> If the class were missing, it would be straightforward for any Scala programmer to write an implementation, for instance, by wrapping Java's class <span class="code">java.math.BigInteger</span> (in fact that's how Scala's <span class="code">BigInt</span> class is implemented).<a id="i1854396478-1"></a></p>
      <p>Of course, you could also use Java's class directly. But the result is not nearly as pleasant, because although Java allows you to create new types, those types don't feel much like native language support:</p> <pre>  <code class="vem">import</code>&nbsp;java.math.BigInteger
  <br>  <code class="vem">def</code>&nbsp;factorial(x:&nbsp;<code class="typename">BigInteger</code>):&nbsp;<code class="typename">BigInteger</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;BigInteger.ZERO)
  &nbsp;&nbsp;&nbsp;&nbsp;BigInteger.ONE
  &nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;x.multiply(factorial(x.subtract(BigInteger.ONE)))
</pre>
      <p><span class="code">BigInt</span> is representative of many other number-like types—big decimals, complex numbers, rational numbers, confidence intervals, polynomials—the list goes on. Some programming languages implement some of these types natively. For instance, Lisp,<a id="i-503250946-1"></a> Haskell,<a id="i-1250113500-1"></a> and Python<a id="i-1190645252-2"></a> implement big integers; Fortran<a id="i1138419364-1"></a> and Python implement complex numbers. But any language that attempted to implement all of these abstractions at the same time would simply become too big to be manageable. What's more, even if such a language were to exist, some applications would surely benefit from other number-like types that were not supplied. So the approach of attempting to provide everything in one language doesn't scale very well. Instead, Scala allows users to grow and adapt the language in the directions they need by defining easy-to-use libraries that <span style="font-style:italic">feel</span> like native language support.</p>
      <h4>Growing new control constructs</h4>
      <p>The previous example demonstrates that Scala lets you add new types that can be used as conveniently as built-in types. The same extension principle also applies to control structures. This kind of extensibility is illustrated by Akka,<a id="i2042656-1"></a><a id="i-1422944994-1"></a> a Scala API for "actor-based" concurrent programming.</p>
      <p>As multicore<a id="i-1206501288-1"></a> processors continue to proliferate in the coming years, achieving acceptable performance may increasingly require that you exploit more<a id="i-2128194469-1"></a> parallelism in your applications. Often, this will mean rewriting your code so that computations are distributed over several concurrent threads. Unfortunately, creating dependable multi-threaded applications has proven challenging in practice. Java's threading model is built around shared memory and locking, a model that is often difficult to reason about, especially as systems scale up in size and complexity. It is hard to be sure you don't have a race condition or deadlock lurking—something that didn't show up during testing, but<a id="i503639951-1"></a> might just show up in production. An arguably safer alternative is a message passing architecture, such as the "actors" approach used by the Erlang<a id="i-1028679267-1"></a> programming language.<a id="i-122023144-1"></a></p>
      <p>Java comes with a rich, thread-based concurrency library. Scala programs can use it like any other Java API. However, Akka is an additional Scala library that implements an actor model similar to Erlang's.<a id="i-1422944994-2"></a><a id="i1338746414-1"></a></p>
      <p>Actors are concurrency abstractions that can be implemented on top of threads. They communicate by sending messages to each other. An actor can perform two basic operations, message send and receive. The send operation, denoted by an exclamation point<a id="i1971465955-1"></a><a id="i-1037720528-1"></a> (<span class="code">!</span>), sends a message to an actor. Here's an example in which the actor is named <span class="code">recipient</span>:</p> <pre>  recipient&nbsp;!&nbsp;msg
</pre>
      <p>A send is asynchronous; that is, the sending actor can proceed immediately, without waiting for the message to be received and processed. Every actor has a <span style="font-style:italic">mailbox</span> in which incoming messages are queued. An actor handles messages that have arrived in its mailbox via a <span class="code">receive</span> block:<a id="i1209206976-1"></a></p> <pre>  <code class="vem">def</code>&nbsp;receive&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Msg1</code>&nbsp;=&gt;&nbsp;...&nbsp;<code class="comment">//&nbsp;handle&nbsp;Msg1</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Msg2</code>&nbsp;=&gt;&nbsp;...&nbsp;<code class="comment">//&nbsp;handle&nbsp;Msg2</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;...</code>
  }
</pre>
      <p>A receive block consists of a number of cases that each query the mailbox with a message pattern. The first message in the mailbox that matches any of the cases is selected, and the corresponding action is performed on it. Once the mailbox does not contain any messages, the actor suspends and waits for further incoming messages.</p>
      <p>As an example, here is a simple Akka actor implementing a<a id="i2042656-2"></a> checksum calculator service:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ChecksumActor</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Actor</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;receive&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Data</code>(byte)&nbsp;=&gt;&nbsp;sum&nbsp;+=&nbsp;byte
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">GetChecksum</code>(requester)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;checksum&nbsp;=&nbsp;<code style="font-size:large">~</code>(sum&nbsp;&amp;&nbsp;<code class="literal">0xFF</code>)&nbsp;+&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requester&nbsp;!&nbsp;checksum
  &nbsp;&nbsp;}
  }
</pre>
      <p>This actor first defines a local variable named <span class="code">sum</span> with initial value zero. It defines a <span class="code">receive</span> block that will handle messages. If it receives a <span class="code">Data</span> message, it adds the contained <span class="code">byte</span> to the <span class="code">sum</span> variable. If it receives a <span class="code">GetChecksum</span> message, it calculates a checksum from the current value of <span class="code">sum</span> and sends the result back to the <span class="code">requester</span> using the message send <span class="code">requester</span>&nbsp;<span class="code">!</span>&nbsp;<span class="code">checksum</span>. The <span class="code">requester</span> field is sent in the <span class="code">GetChecksum</span> message; it usually refers to the actor that made the request.</p>
      <p>We don't expect you to fully understand the actor example at this point. Rather, what's significant about this example for the topic of scalability is that neither the <span class="code">receive</span> block nor message send (<span class="code">!</span>) are built-in operations in Scala. Even though the <span class="code">receive</span> block may look and act very much like a built-in control construct, it is in fact a method defined in Akka's actors library. Likewise, even though `<span class="code">!</span>' looks like a built-in operator, it too is just a method defined in the Akka actors library. Both of these constructs are completely independent of the Scala programming language.</p>
      <p>The <span class="code">receive</span> block and send (<span class="code">!</span>) syntax look in Scala much like they look in Erlang, but in Erlang, these constructs are built into the language. Akka also implements most of Erlang's other concurrent programming constructs, such as monitoring failed actors and time-outs. All in all, the actor model has turned out to be a very pleasant means for expressing concurrent and distributed computations. Even though they must be defined in a library, actors can feel like an integral part of the Scala language.</p>
      <p>This example illustrates that you can "grow" the Scala language in new directions even as specialized as concurrent programming. To be sure, you need good architects and programmers to do this. But the crucial thing is that it is feasible—you can design and implement abstractions in Scala that address radically new application domains, yet still feel like native language support when used.</p>
      <h3>1.2 What makes Scala scalable?</h3>
      <p>Scalability is influenced by many factors, ranging from syntax details<a id="i741587120-1"></a><a id="i-885663216-1"></a> to component abstraction constructs. If we were forced to name just one aspect of Scala that helps scalability, though, we'd pick its combination of object-oriented and functional programming (well, we cheated, that's really two aspects, but they are intertwined).</p>
      <p>Scala goes further than all other well-known languages in fusing object-oriented and functional programming into a uniform language design. For instance, where other languages might have objects and functions as two different concepts, in Scala a function value <span style="font-style:italic"> is</span> an object. Function types are classes that can be inherited by subclasses. This might seem nothing more than an academic nicety, but it has deep consequences for scalability. In fact the actor concept shown previously could not have been implemented without this unification of functions and objects. This section gives an overview of Scala's way of blending object-oriented and functional concepts.</p>
      <h4>Scala is object-oriented</h4>
      <p>Object-oriented programming has been immensely successful. Starting<a id="i717865003-2"></a> from Simula<a id="i1623537733-1"></a> in the mid-60s and Smalltalk in the 70s, it is now available in more languages than not. In some domains, objects have taken over completely. While there is not a precise definition of what object-oriented means, there is clearly something about objects that appeals to programmers.</p>
      <p>In principle, the motivation for object-oriented programming is very simple: all but the most trivial programs need some sort of structure. The most straightforward way to do this is to put data and operations into some form of containers. The great idea of object-oriented programming is to make these containers fully general, so that they can contain operations as well as data, and that they are themselves values that can be stored in other containers, or passed as parameters to operations. Such containers are called objects. Alan Kay,<a id="i438821039-1"></a> the inventor of Smalltalk,<a id="i-817657147-1"></a> remarked that in this way the simplest object has the same construction principle as a full computer: it combines data with operations under a formalized interface.<a href="#footnotemain1-7">[7]</a> So objects have a lot to do with language scalability: the same techniques apply to the construction of small as well as large programs.</p>
      <p>Even though object-oriented programming has been mainstream for a long time, there are relatively few languages that have followed Smalltalk in pushing this construction principle to its logical conclusion. For instance, many languages admit values that are not objects, such as the primitive values in Java. Or they allow static fields and methods that are not members of any object. These deviations from the pure idea of object-oriented programming look quite harmless at first, but they have an annoying tendency to complicate things and limit scalability.</p>
      <p>By contrast, Scala is an object-oriented language in pure form: every value is an object and every operation is a method call. For example, when you say <span class="code">1</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span> in Scala, you are actually invoking a method named <span class="code">+</span> defined in class <span class="code">Int</span>. You can define methods with operator-like names that clients of your API can then use in operator notation. This is how Akka's actors<a id="i2042656-3"></a><a id="i-1422944994-3"></a> API enables you to use expressions such as <span class="code">requester</span>&nbsp;<span class="code">!</span>&nbsp;<span class="code">checksum</span> shown in the previous example: `<span class="code">!</span>' is a method of the <span class="code">Actor</span> class.</p>
      <p>Scala is more advanced than most other languages when it comes to composing objects. An example is Scala's <span class="textit"><a href="#g110621198"><em>trait</em>s</a></span>. Traits are like interfaces in Java, but they can also have method implementations and even fields.<a href="#footnotemain1-8">[8]</a> Objects are constructed by <span style="font-style:italic">mixin composition</span>, which takes the members of a class and adds the members of a number of traits to them. In this way, different aspects of classes can be encapsulated in different traits. This looks a bit like multiple inheritance, but differs when it comes to the details. Unlike a class, a trait can add some new functionality to an unspecified superclass. This makes traits more "pluggable" than classes. In particular, it avoids the classical "diamond inheritance" problems of multiple inheritance, which arise when the same class is inherited via several different paths.</p>
      <h4>Scala is functional</h4>
      <p>In addition to being a pure object-oriented language, Scala is also a<a id="i1689782844-1"></a> full-blown functional language. The ideas of functional programming are older than (electronic) computers. Their foundation was laid in Alonzo Church's<a id="i1963891034-1"></a> lambda calculus,<a id="i878901123-1"></a> which he developed in the 1930s. The first functional programming language was Lisp,<a id="i-503250946-2"></a> which dates from the late 50s. Other popular functional languages are Scheme,<a id="i1475575635-1"></a> SML,<a id="i-175084922-1"></a> Erlang,<a id="i-1028679267-2"></a> Haskell,<a id="i-1250113500-2"></a> OCaml,<a id="i-1496851060-1"></a> and F#.<a id="i724459531-1"></a> For a long time, functional programming has been a bit on the sidelines—popular in academia, but not that widely used in industry. However, in recent years, there has been an increased interest in functional programming languages and techniques.</p>
      <p>Functional programming is guided by two main ideas.<a id="i-1849814556-1"></a> The first idea is that functions are first-class values.<a id="i-1098728772-1"></a> In a functional language, a function is a value of the same status as, say, an integer or a string. You can pass functions as arguments to other functions, return them as results from functions, or store them in variables. You can also define a function inside another function, just as you can define an integer value inside a function. And you can define functions without giving them a name, sprinkling your code with function literals as easily as you might write integer literals like <span class="code">42</span>.</p>
      <p>Functions that are first-class values provide a convenient means for abstracting over operations and creating new control structures.<a id="i14092899-1"></a> This generalization of functions provides great expressiveness, which often leads to very legible and concise programs. It also plays an important role for scalability. As an example, the ScalaTest<a id="i122343128-1"></a> testing library offers an <span class="code">eventually</span><a id="i903380834-1"></a> construct that takes a function as an argument. It is used like this:</p> <pre>  <code class="vem">val</code>&nbsp;xs&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">3</code>
  <code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;xs.iterator
  eventually&nbsp;{&nbsp;it.next()&nbsp;shouldBe&nbsp;<code class="literal">3</code>&nbsp;}
</pre>
      <p>The code inside <span class="code">eventually</span>—the assertion, <span class="code">it.next()</span>&nbsp;<span class="code">shouldBe</span>&nbsp;<span class="code">3</span>—is wrapped in a function that is passed unexecuted to the <span class="code">eventually</span> method. For a configured amount of time, <span class="code">eventually</span> will repeatedly execute the function until the assertion succeeds.</p>
      <p>In most traditional languages, by contrast, functions are not values. Languages that do have function values often relegate them to second-class status. For example, the function pointers of C<a id="i395906709-1"></a> and C++<a id="i916374005-1"></a> do not have the same status as non-functional values in those languages: Function pointers can only refer to global functions, they do not allow you to define first-class nested functions that refer to some values in their environment. Nor do they allow you to define unnamed function literals.</p>
      <p>The second main idea of functional programming is that the operations of a program should map input values to output values rather than change data in place. To see the difference, consider the implementation of strings in Ruby<a id="i-1999895874-2"></a> and Java.<a id="i2012001632-1"></a> In Ruby, a string is an array of characters. Characters in a string can be changed individually. For instance you can change a semicolon character in a string to a period inside the same string object. In Java and Scala, on the other hand, a string is a sequence of characters in the mathematical sense. Replacing a character in a string using an expression like <span class="code">s.replace(';',</span>&nbsp;<span class="code">'.')</span> yields a new string object, which is different from <span class="code">s</span>. Another way of expressing this is that strings are immutable<a id="i507699202-1"></a> in Java whereas they are mutable in Ruby. So looking at just strings, Java is a functional language, whereas Ruby is not. Immutable data structures are one of the cornerstones of functional programming. The Scala libraries define many more immutable data types on top of those found in the Java APIs. For instance, Scala has immutable lists, tuples, maps, and sets.</p>
      <p>Another way of stating this second idea of functional programming is that methods should not have any <span style="font-style:italic">side effects</span>.<a id="i18918201-1"></a> They should communicate with their environment only by taking arguments and returning results. For instance, the <span class="code">replace</span> method in Java's <span class="code">String</span> class fits this description. It takes a string and two characters and yields a new string where all occurrences of one character are replaced by the other. There is no other effect of calling <span class="code">replace</span>. Methods like <span class="code">replace</span> are called <a href="#g-1825668081"><em>referentially transparent</em></a>,<a id="i-1825668081-1"></a> which means that for any given input the method call could be replaced by its result without affecting the program's semantics.</p>
      <p>Functional languages encourage immutable data structures and referentially transparent methods. Some functional languages even require them. Scala gives you a choice. When you want to, you can write in an <span style="font-style:italic"> imperative</span> style, which is what programming with mutable data and side effects is called. But Scala generally makes it easy to avoid imperative constructs when you want because good functional alternatives exist.</p>
      <h3>1.3 Why Scala?</h3>
      <p>Is Scala for you? You will have to see and decide for yourself. We have found that there are actually many reasons besides scalability to like programming in Scala. Four of the most important aspects will be discussed in this section: compatibility, brevity, high-level abstractions, and advanced static typing.</p>
      <h4>Scala is compatible</h4>
      <p>Scala doesn't require you to leap backwards off the Java platform to<a id="i239541118-2"></a><a id="i1128780868-1"></a><a id="i1003002536-2"></a> step forward from the Java language. It allows you to add value to existing code—to build on what you already have—because it was designed for seamless interoperability with Java.<a href="#footnotemain1-9">[9]</a> Scala programs compile to JVM bytecodes. Their run-time performance is usually on par with<a id="i1751980831-1"></a> Java programs. Scala code can call Java methods, access Java fields, inherit from Java classes, and implement Java interfaces. None of this requires special syntax, explicit interface descriptions, or glue code. In fact, almost all Scala code makes heavy use of Java libraries, often without programmers being aware of this fact.</p>
      <p>Another aspect of full interoperability is that Scala heavily re-uses Java types. Scala's <span class="code">Int</span>s are represented as Java primitive integers of type <span class="code">int</span>, <span class="code">Float</span>s are represented as <span class="code">float</span>s, <span class="code">Boolean</span>s as <span class="code">boolean</span>s, and so on. Scala arrays are mapped to Java arrays. Scala also re-uses many of the standard Java library types. For instance, the type of a string literal <span class="code">"abc"</span> in Scala is <span class="code">java.lang.String</span>, and a thrown exception must be a subclass of <span class="code">java.lang.Throwable</span>.</p>
      <p>Scala not only re-uses Java's types, but also "dresses them up" to make them nicer. For instance, Scala's strings support methods like <span class="code">toInt</span> or <span class="code">toFloat</span>, which convert the string to an integer or<a id="i2133819883-1"></a> floating-point number. So you can write <span class="code">str.toInt</span> instead of <span class="code">Integer.parseInt(str)</span>. How can this be achieved without breaking interoperability? Java's <span class="code">String</span> class certainly has no <span class="code">toInt</span> method! In fact, Scala has a very general solution to solve this tension between advanced library design and interoperability. Scala lets you define <span style="font-style:italic">implicit conversions</span>,<a id="i456777265-1"></a><a id="i-1068906551-1"></a> which are always applied when types would not normally match up, or when non-existing members are selected. In the case above, when looking for a <span class="code">toInt</span> method on a string, the Scala compiler will find no such member of class <span class="code">String</span>, but it will find an implicit conversion that converts a Java <span class="code">String</span> to an instance of the Scala class <span class="code">StringOps</span>, which does define such a member. The conversion will then be applied implicitly before performing the <span class="code">toInt</span> operation.</p>
      <p>Scala code can also be invoked from Java code. This is sometimes a bit more subtle, because Scala is a richer language than Java, so some of Scala's more advanced features need to be encoded before they can be mapped to Java. <a href="#chap-combining-scala-and-java">Chapter 31</a> explains the details.</p>
      <h4>Scala is concise</h4>
      <p>Scala programs tend to be short. Scala programmers have reported<a id="i-486479055-1"></a><a id="i-1605476771-1"></a> reductions in number of lines of up to a factor of ten compared to Java. These might be extreme cases. A more conservative estimate would be that a typical Scala program should have about half the number of lines of the same program written in Java. Fewer lines of code mean not only less typing, but also less effort at reading and understanding programs and fewer possibilities of defects. There are several factors that contribute to this reduction in lines of code.</p>
      <p>First, Scala's syntax avoids some of the boilerplate that burdens Java programs. For instance, semicolons are optional in Scala and are usually left out. There are also several other areas where Scala's syntax is less noisy. As an example, compare how you write classes and constructors in Java and Scala. In Java, a class with a constructor often looks like this:</p> <pre>  //&nbsp;this&nbsp;is&nbsp;Java
  class&nbsp;MyClass&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;index;
  &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MyClass(int&nbsp;index,&nbsp;String&nbsp;name)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.index&nbsp;=&nbsp;index;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }
</pre>
      <p>In Scala, you would likely write this instead:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">MyClass</code>(index:&nbsp;<code class="typename">Int</code>,&nbsp;name:&nbsp;<code class="typename">String</code>)
</pre>
      <p>Given this code, the Scala compiler will produce a class that has two private instance variables, an <span class="code">Int</span> named <span class="code">index</span> and a <span class="code">String</span> named <span class="code">name</span>, and a constructor that takes initial values for those variables as parameters. The code of this constructor will initialize the two instance variables with the values passed as parameters. In short, you get essentially the same functionality as the more verbose Java version.<a href="#footnotemain1-10">[10]</a> The Scala class is quicker to write, easier to read, and most importantly, less error prone than the Java class.</p>
      <p>Scala's type inference is another factor that contributes to its conciseness. Repetitive type information can be left out, so programs become less cluttered and more readable.</p>
      <p>But probably the most important key to compact code is code you don't have to write because it is done in a library for you. Scala gives you many tools to define powerful libraries that let you capture and factor out common behavior. For instance, different aspects of library classes can be separated out into traits, which can then be mixed together in flexible ways. Or, library methods can be parameterized with operations, which lets you define constructs that are, in effect, your own control structures. Together, these constructs allow the definition of libraries that are both high-level and flexible to use.</p>
      <h4>Scala is high-level</h4>
      <p><a id="subsec-scala-is-high-level"></a></p>
      <p>Programmers are constantly grappling with complexity.<a id="i1993414356-1"></a> To program productively, you must understand the code on which you are working. Overly complex code has been the downfall of many a software project. Unfortunately, important software usually has complex requirements. Such complexity can't be avoided; it must instead be managed.</p>
      <p>Scala helps you manage complexity by letting you raise the level of abstraction in the interfaces you design and use. As an example, imagine you have a <span class="code">String</span> variable <span class="code">name</span>, and you want to find out whether or not that <span class="code">String</span> contains an upper case character. Prior to Java 8, you might have written a loop, like this:</p> <pre>  boolean&nbsp;nameHasUpperCase&nbsp;=&nbsp;false;&nbsp;&nbsp;//&nbsp;this&nbsp;is&nbsp;Java
  for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;name.length();&nbsp;++i)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Character.isUpperCase(name.charAt(i)))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nameHasUpperCase&nbsp;=&nbsp;true;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }
</pre>
      <p>Whereas in Scala, you could write this:<a id="i-1394554846-1"></a></p> <pre>  <code class="vem">val</code>&nbsp;nameHasUpperCase&nbsp;=&nbsp;name.exists(_.isUpper)&nbsp;
</pre>
      <p>The Java code treats strings as low-level entities that are stepped through character by character in a loop. The Scala code treats the same strings as higher-level sequences of characters that can be queried with <a href="#g-1348032073"><em>predicates</em></a>.<a id="i1160678812-1"></a><a id="i-468400421-1"></a> Clearly the Scala code is much shorter and—for trained eyes—easier to understand than the Java code. So the Scala code weighs less heavily on the total complexity budget. It also gives you less opportunity to make mistakes.</p>
      <p>The predicate <span class="code">_.isUpper</span> is an example of a function literal in Scala.<a href="#footnotemain1-11">[11]</a> It describes a function that takes a character argument (represented by the underscore character) and tests whether it is an upper case letter.<a href="#footnotemain1-12">[12]</a></p>
      <p>Java 8 introduced support for <span class="textit">lambdas</span> and <span class="textit">streams</span>, which enable you to perform a similar operation in Java. Here's what it might look like:</p> <pre>  boolean&nbsp;nameHasUpperCase&nbsp;=&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;This&nbsp;is&nbsp;Java&nbsp;8</code>
  &nbsp;&nbsp;&nbsp;&nbsp;name.chars().anyMatch(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int&nbsp;ch)&nbsp;-&gt;&nbsp;Character.isUpperCase((char)&nbsp;ch)
  &nbsp;&nbsp;&nbsp;&nbsp;);
</pre>
      <p>Although a great improvement over earlier versions of Java, the Java 8 code is still more verbose than the equivalent Scala code. This extra "heaviness" of Java code, as well as Java's long tradition of loops, may encourage many Java programmers in need of new methods like <span class="code">exists</span> to just write out loops and live with the increased complexity in their code.</p>
      <p>On the other hand, function literals in Scala are really lightweight, so they are used frequently. As you get to know Scala better you'll find more and more opportunities to define and use your own control abstractions. You'll find that this helps avoid code duplication and thus keeps your programs shorter and clearer.<a id="i-1950695486-1"></a></p>
      <p>Scala's functional programming style also offers high-level <span style="font-style:italic"> reasoning principles</span> for programming. The key idea is that functions are referentially transparent—a function application is characterized only by its result. You can, therefore, freely exchange a function application with the function's right hand side (<i>i.e.</i>, its body, which follows the equals sign) without worrying about any hidden side effects. This principle gives many useful laws that you can employ to better understand or to refactor your code. As an example, take once more the <span class="code">exists</span> method described above. This method should satisfy the following law: for every sequence <span class="code">s</span> and for every pair of predicates <span class="code">p</span> and <span class="code">q</span> it should hold that</p> <pre>  s.exists(p)&nbsp;||&nbsp;s.exists(q)&nbsp;==&nbsp;s.exists(x&nbsp;=&gt;&nbsp;p(x)&nbsp;||&nbsp;q(x))&nbsp;
</pre>
      <p>That is, querying the same sequence with two predicates <span class="code">p</span> and <span class="code">q</span> and or-ing the results is the same as querying with a single predicate that tests at the same time for <span class="code">p</span> or for <span class="code">q</span>. A law like this is clearly useful for writing and refactoring programs. However, if <span class="code">exists</span> had side effects, it would in general not be correct to assume such a law because the left hand side executes <span class="code">exists</span> twice for each sequence element whereas the right hand side executes it only once per element. So this is an example where purely functional code leads to more laws that are useful for understanding and refactoring your code.</p>
      <p>The functional programming style also eliminates aliasing problems encountered in imperative programming. Aliasing happens when multiple variables refer to the same object. It gives rise to some thorny questions and complications. For instance, does changing a field <span class="code">r.x</span> also affect <span class="code">s.x</span>? It does if <span class="code">r</span> and <span class="code">s</span> refer to the same object. In practice it is often very difficult to trace such aliases. Immutable data, on the other hand, can be shared freely, because a copy is indistinguishable from a shared reference. This advantage is particularly crucial when writing concurrent code. (This is why Java has immutable strings.)</p>
      <h4>Scala is statically typed</h4>
      <p>A static type system classifies variables and expressions according to<a id="i587655017-1"></a><a id="i1417392593-1"></a> the kinds of values they hold and compute. Scala stands out as a language with a very advanced static type system. Starting from a system of nested class types much like Java's, it allows you to parameterize types with <span style="font-style:italic">generics</span>, to combine types using <span style="font-style:italic">intersections</span>, and to hide details of types using <span style="font-style:italic">abstract types</span>.<a href="#footnotemain1-13">[13]</a> These give a strong foundation for building and composing your own types, so that you can design interfaces that are at the same time safe and flexible to use.</p>
      <p>If you like dynamic languages, such as Perl, Python, Ruby, or Groovy,<a id="i716433724-1"></a><a id="i2012339474-1"></a> you might find it a bit strange that Scala's static type system is listed as one of its strong points. After all, the absence of a static type system has been cited by some as a major advantage of dynamic languages. The most common arguments against static types are that they make programs too verbose, prevent programmers from expressing themselves as they wish, and make impossible certain patterns of dynamic modifications of software systems. However, often these arguments do not go against the idea of static types in general, but against specific type systems, which are perceived to be too verbose or too inflexible. For instance, Alan Kay, the inventor of the Smalltalk language, once remarked: "I'm not against types, but I don't know of any type systems that aren't a complete pain, so I still like dynamic typing."<a href="#footnotemain1-14">[14]</a></p>
      <p>We hope to convince you in this book that Scala's type system is far from being a "complete pain." In fact, it addresses nicely two of the usual concerns about static typing: Verbosity is avoided through type inference, and flexibility is gained through pattern matching and several new ways to write and compose types. With these impediments out of the way, the classical benefits of static type systems can be better appreciated. Among the most important of these benefits are verifiable properties of program abstractions, safe refactorings, and better documentation.</p>
      <p><b><span style="font-style:italic">Verifiable properties.</span></b> Static type systems can prove the absence<a id="i-1604465616-1"></a><a id="i-1721532539-1"></a> of certain run-time errors. For instance, they can prove properties like: Booleans are never added to integers; private variables are not accessed from outside their class; functions are applied to the right number of arguments; only strings are ever added to a set of strings.</p>
      <p>Other kinds of errors are not detected by today's static type systems. For instance, they will usually not detect non-terminating functions, array bounds violations, or divisions by zero. They will also not detect that your program does not conform to its specification (assuming there is a spec, that is!). Static type systems have therefore been dismissed by some as not being very useful. The argument goes that since such type systems can only detect simple errors, whereas unit tests provide more extensive coverage, why bother with static types at all? We believe that these arguments miss the point. Although a static type system certainly cannot <em>replace</em> unit testing, it can reduce the number of unit tests needed by taking care of some properties that would otherwise need to be tested. Likewise, unit testing cannot replace static typing. After all, as Edsger Dijkstra said,<a id="i-765987414-1"></a> testing can only prove the presence of errors, never their absence.<a href="#footnotemain1-15">[15]</a> So the guarantees that static typing gives may be simple, but they are real guarantees of a form no amount of testing can deliver.</p>
      <p><b><span style="font-style:italic">Safe refactorings.</span></b> A static type system provides a safety<a id="i1149458246-1"></a> net that lets you make changes to a codebase with a high degree of confidence. Consider for instance a refactoring that adds an additional parameter to a method. In a statically typed language you can do the change, re-compile your system, and simply fix all lines that cause a type error. Once you have finished with this, you are sure to have found all places that need to be changed. The same holds for many other simple refactorings, like changing a method name or moving methods from one class to another. In all cases a static type check will provide enough assurance that the new system works just like the old.</p>
      <p><b><span style="font-style:italic">Documentation.</span></b> Static types are program documentation that is checked by the compiler for correctness. Unlike a normal comment, a type annotation<a id="i-2107785776-2"></a><a id="i1449766718-2"></a> can never be out of date (at least not if the source file that contains it has recently passed a compiler). Furthermore, compilers and integrated development environments (IDEs) can make use of type annotations to provide better context help. For instance, an IDE can display all the members available for a selection by determining the static type of the expression on which the selection is made and looking up all members of that type.</p>
      <p>Even though static types are generally useful for program documentation, they can sometimes be annoying when they clutter the program. Typically, useful documentation is what readers of a program cannot easily derive by themselves. In a method definition like:</p> <pre>  <code class="vem">def</code>&nbsp;f(x:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;...&nbsp;&nbsp;
</pre>
      <p>it's useful to know that <span class="code">f</span>'s argument should be a <span class="code">String</span>. On the other hand, at least one of the two annotations in the following example is annoying:</p> <pre>  <code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">HashMap[Int,&nbsp;String]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">HashMap[Int,&nbsp;String]</code>()
</pre>
      <p>Clearly, it should be enough to say just once that <span class="code">x</span> is a <span class="code">HashMap</span> with <span class="code">Int</span>s as keys and <span class="code">String</span>s as values; there's no need to repeat the same phrase twice.</p>
      <p>Scala has a very sophisticated type inference system that lets you omit almost all<a id="i-219390285-1"></a><a id="i-24732165-1"></a> type information that's usually considered annoying. In the previous example, the following two less annoying alternatives would work just as well:</p> <pre>  <code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">HashMap[Int,&nbsp;String]</code>()
  <code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Map[Int,&nbsp;String]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">HashMap</code>()&nbsp;
</pre>
      <p>Type inference in Scala can go quite far. In fact, it's not uncommon for user code to have no explicit types at all. Therefore, Scala programs often look a bit like programs written in a dynamically typed<a id="i716433724-2"></a><a id="i2012339474-2"></a> scripting language. This holds particularly for client application code, which glues together pre-written library components. It's less true for the library components themselves, because these often employ fairly sophisticated types to allow flexible usage patterns. This is only natural. After all, the type signatures of the members that make up the interface of a reusable component should be explicitly given, because they constitute an essential part of the contract between the component and its clients.</p>
      <h3>1.4 Scala's roots</h3>
      <p>Scala's design has been influenced by many programming languages and<a id="i-1148185415-1"></a> ideas in programming language research. In fact, only a few features of Scala are genuinely new; most have been already applied in some form in other languages. Scala's innovations come primarily from how its constructs are put together. In this section, we list the main influences on Scala's design. The list cannot be exhaustive—there are simply too many smart ideas around in programming language design to enumerate them all here.</p>
      <p>At the surface level, Scala adopts a large part of the syntax of Java and C#, which in turn borrowed most of their syntactic conventions from C and C++. Expressions, statements, and blocks are mostly as in Java, as is the syntax of classes, packages and imports.<a href="#footnotemain1-16">[16]</a> Besides syntax, Scala adopts other elements of Java, such as its basic types, its class libraries, and its execution model.</p>
      <p>Scala also owes much to other languages. Its uniform object model was pioneered by Smalltalk and taken up subsequently by Ruby. Its idea of universal nesting (almost every construct in Scala can be nested inside any other construct) is also present in Algol, Simula, and, more recently, in Beta and gbeta. Its uniform access principle for method invocation and field selection comes from Eiffel. Its approach to functional programming is quite similar in spirit to the ML family of languages, which has SML, OCaml, and F# as prominent members. Many higher-order functions in Scala's standard library are also present in ML or Haskell. Scala's implicit parameters were motivated by Haskell's type classes; they achieve analogous results in a more classical object-oriented setting. Scala's main actor-based concurrency library, Akka, was heavily inspired by Erlang.</p>
      <p>Scala is not the first language to emphasize scalability and extensibility. The historic root of extensible languages that can span different application areas is Peter Landin's 1966 paper,<a id="i-440292728-1"></a> "The Next 700 Programming Languages."<a href="#footnotemain1-17">[17]</a> (The language described in this paper, Iswim, stands beside Lisp as one of the pioneering functional languages.) The specific idea of treating an infix operator as a function can be traced back to Iswim and Smalltalk. Another important idea is to permit a function literal (or block) as a parameter, which enables libraries to define control structures. Again, this goes back to Iswim and Smalltalk. Smalltalk and Lisp both have a flexible syntax that has been applied extensively for building internal domain-specific languages.<a id="i-837225081-1"></a> C++ is another scalable language that can be adapted and extended through operator overloading and its template system; compared to Scala it is built on a lower-level, more systems-oriented core. Scala is also not the first language to integrate functional and object-oriented programming, although it probably goes furthest in this direction. Other languages that have integrated some elements of functional programming into object-oriented programming (OOP) include Ruby, Smalltalk, and Python. On the Java platform, Pizza,<a id="i-1058604016-1"></a> Nice,<a id="i-241957733-1"></a> Multi-Java<a id="i-1250478654-1"></a>—and Java 8 itself—have all extended a Java-like core with functional ideas. There are also primarily functional languages that have acquired an object system; examples are OCaml, F#, and PLT-Scheme.<a id="i-1496851060-2"></a><a id="i724459531-2"></a><a id="i383911262-1"></a></p>
      <p>Scala has also contributed some innovations to the field of programming languages. For instance, its abstract types provide a more object-oriented alternative to generic types, its traits allow for flexible component assembly, and its extractors provide a representation-independent way to do pattern matching. These innovations have been presented in papers at programming language conferences in recent years.<a href="#footnotemain1-18">[18]</a></p>
      <h3>1.5 Conclusion</h3>
      <p>In this chapter, we gave you a glimpse of what Scala is and how it might help you in your programming. To be sure, Scala is not a silver bullet that will magically make you more productive. To advance, you will need to apply Scala artfully, and that will require some learning and practice. If you're coming to Scala from Java, the most challenging aspects of learning Scala may involve Scala's type system (which is richer than Java's) and its support for functional programming. The goal of this book is to guide you gently up Scala's learning curve, one step at a time. We think you'll find it a rewarding intellectual experience that will expand your horizons and make you think differently about program design. Hopefully, you will also gain pleasure and inspiration from programming in Scala.</p>
      <p>In the next chapter, we'll get you started writing some Scala code.</p>
      <hr>
      <h4>Footnotes for Chapter 1:</h4>
      <p><a id="footnotemain1-1"></a>[1] Scala is pronounced <em>skah-lah</em>.<a id="i-269622320-1"></a><a id="i341209608-1"></a></p>
      <p><a id="footnotemain1-2"></a>[2] Please bear with us if you don't understand all the details of this program. They will be explained in the next two chapters.</p>
      <p><a id="footnotemain1-3"></a>[3] Raymond, <em>The Cathedral and the Bazaar</em>. <a href="#raymond-cathedral">[Ray99]</a></p>
      <p><a id="footnotemain1-4"></a>[4] Steele, "Growing a language." <a href="#steele-growing">[Ste99]</a><a id="i-1799668152-1"></a></p>
      <p><a id="footnotemain1-5"></a>[5] <span class="code">factorial(x)</span>, or <span class="code">x!</span>&nbsp;in mathematical notation, is the result of computing <span class="code">1</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">...</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">x</span>, with <span class="code">0!</span> defined to be <span class="code">1</span>.</p>
      <p><a id="footnotemain1-6"></a>[6] Scala comes with a standard library, some of which will be covered in this book. For more information, you can also consult the library's Scaladoc documentation, which is available in the distribution and online at <span class="code">http://www.scala-lang.org</span>.</p>
      <p><a id="footnotemain1-7"></a>[7] Kay, "The Early History of Smalltalk." <a href="#kay-early">[Kay96]</a></p>
      <p><a id="footnotemain1-8"></a>[8] Starting with Java 8, interfaces can have default method implementations, but these do not offer all the features of Scala's traits.</p>
      <p><a id="footnotemain1-9"></a>[9] Originally, there was an implementation of Scala that ran on the .NET platform, but it is no longer active.<a id="i77181-1"></a> More recently, an implementation of Scala that runs on JavaScript, Scala.js,<a id="i-827373807-1"></a> has become increasingly popular.</p>
      <p><a id="footnotemain1-10"></a>[10] The only real difference is that the instance variables produced in the Scala case will be final. You'll learn how to make them non-final in <a href="#sec-parametric-fields">Section 10.6</a>.</p>
      <p><a id="footnotemain1-11"></a>[11] A function literal can be called a <em>predicate</em> if its result type is <span class="code">Boolean</span>.</p>
      <p><a id="footnotemain1-12"></a>[12] This use of the underscore as a placeholder for arguments is described in <a href="#sec-placeholder-syntax">Section 8.5</a>.</p>
      <p><a id="footnotemain1-13"></a>[13] Generics are discussed in <a href="#chap-type-parameterization">Chapter 19</a>; intersections (<i>e.g.</i>, <span class="code">A</span>&nbsp;<span class="code">with</span>&nbsp;<span class="code">B</span>&nbsp;<span class="code">with</span>&nbsp;<span class="code">C</span>) in <a href="#chap-traits">Chapter 12</a>; and abstract types in <a href="#chap-abstract-members">Chapter 20</a>.</p>
      <p><a id="footnotemain1-14"></a>[14] Kay, in an email on the meaning of object-oriented programming. <a href="#kay-dynamic">[Kay03]</a></p>
      <p><a id="footnotemain1-15"></a>[15] Dijkstra, "Notes on Structured Programming." <a href="#dijkstra-notes">[Dij70]</a></p>
      <p><a id="footnotemain1-16"></a>[16] The major deviation from Java concerns the syntax for type annotations: it's "<span class="code">variable:</span>&nbsp;<span class="code">Type</span>" instead of "<span class="code">Type</span>&nbsp;<span class="code">variable</span>" in Java. Scala's postfix type syntax resembles Pascal, Modula-2, or Eiffel.<a id="i-357661779-1"></a> The main reason for this deviation has to do with type inference, which often lets you omit the type of a variable or the return type of a method. Using the "<span class="code">variable:</span>&nbsp;<span class="code">Type</span>" syntax is easy—just leave out the colon and the type. But in C-style "<span class="code">Type</span>&nbsp;<span class="code">variable</span>" syntax you cannot simply leave off the type; there would be no marker to start the definition anymore. You'd need some alternative keyword to be a placeholder for a missing type (C# 3.0, which does some type inference, uses <span class="code">var</span> for this purpose). Such an alternative keyword feels more ad-hoc and less regular than Scala's approach.</p>
      <p><a id="footnotemain1-17"></a>[17] Landin, "The Next 700 Programming Languages." <a href="#landin-next">[Lan66]</a></p>
      <p><a id="footnotemain1-18"></a>[18] For more information, see <a href="#odersky-et-al-ecoop03">[Ode03]</a>, <a href="#odersky-sca">[Ode05]</a>, and <a href="#scala-ecoop07">[Emi07]</a> in the bibliography.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-first-steps-in-scala">Chapter 2</a></h2>
      <h1>First Steps in Scala</h1>
      <p>It's time to write some Scala code. Before we start on the in-depth Scala tutorial, we put in two chapters that will give you the big picture of Scala, and most importantly, get you writing code. We encourage you to actually try out all the code examples presented in this chapter and the next as you go. The best way to start learning Scala is to program in it.</p>
      <p>To run the examples in this chapter, you should have a standard Scala installation. To get one, go to <a href="http://www.scala-lang.org/downloads">http://www.scala-lang.org/downloads</a> and follow the directions for your platform.<a id="i314057734-1"></a><a id="i840520690-1"></a> You can also use a Scala plug-in for Eclipse<a id="i-1327804143-1"></a>, IntelliJ<a id="i933444833-1"></a>, or NetBeans<a id="i-899073402-1"></a><a id="i-1715822447-1"></a>. For the steps in this chapter, we'll assume you're using the Scala distribution from <a href="http://www.scala-lang.org">scala-lang.org</a>.<a href="#footnotemain2-1">[1]</a></p>
      <p>If you are a veteran programmer new to Scala, the next two chapters should give you enough understanding to enable you to start writing useful programs in Scala. If you are less experienced, some of the material may seem a bit mysterious to you. But don't worry. To get you up to speed quickly, we had to leave out some details. Everything will be explained in a less "fire hose" fashion in later chapters. In addition, we inserted quite a few footnotes in these next two chapters to point you to later sections of the book where you'll find more detailed explanations.</p>
      <h3><a id="step1">Step 1. Learn to use the Scala interpreter</a></h3>
      <p>The easiest way to get started with Scala is by using the Scala<a id="i-2008009094-1"></a><a id="i-162949284-1"></a><a id="i-2032368478-1"></a> interpreter, an interactive "shell" for writing Scala expressions and programs. The interpreter, which is called<a id="i1638768746-1"></a> <span class="code">scala</span>, will evaluate expressions you type and print the resulting value. You use it by typing <span class="code">scala</span> at a command prompt:<a href="#footnotemain2-2">[2]</a></p> <pre>  $&nbsp;scala
  <code class="output">Welcome&nbsp;to&nbsp;Scala&nbsp;version&nbsp;2.11.7</code>
  <code class="output">Type&nbsp;in&nbsp;expressions&nbsp;to&nbsp;have&nbsp;them&nbsp;evaluated.</code>
  <code class="output">Type&nbsp;:help&nbsp;for&nbsp;more&nbsp;information.</code>
  <br>  scala&gt;&nbsp;
</pre>
      <p>After you type an expression, such as <span class="code">1</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span>, and hit enter:</p> <pre>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;<code class="literal">2</code>
</pre>
      <p>The interpreter will print:</p> <pre>  <code class="output">res0:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <p>This line includes:</p>
      <ul>
        <li>an automatically generated or user-defined name to refer to the computed value (<span class="code">res0</span>, which means result 0), </li>
        <li>a colon (<span class="code">:</span>), followed by the type of the expression (<span class="code">Int</span>), </li>
        <li>an equals sign (<span class="code">=</span>), </li>
        <li>the value resulting from evaluating the expression (<span class="code">3</span>). </li>
      </ul>
      <p>The type <span class="code">Int</span> names the class <span class="code">Int</span> in the package <span class="code">scala</span>. Packages in Scala are similar to packages in Java: They partition the global namespace<a id="i374717171-1"></a> and provide a mechanism for information hiding.<a href="#footnotemain2-3">[3]</a> Values of class <span class="code">Int</span> correspond to Java's <span class="code">int</span> values. More generally, all of Java's primitive types have corresponding classes in the <span class="code">scala</span> package. For example, <span class="code">scala.Boolean</span> corresponds to Java's <span class="code">boolean</span>. <span class="code">scala.Float</span> corresponds to Java's <span class="code">float</span>. And when you compile your Scala code to Java bytecodes, the Scala compiler will use Java's primitive types where possible to give you the performance benefits<a id="i884498802-1"></a> of the primitive types.</p>
      <p>The <span class="code">resX</span> identifier may be used in later lines. For instance, since <span class="code">res0</span> was set to 3 previously, <span class="code">res0</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">3</span> will be <span class="code">9</span>:</p> <pre>  scala&gt;&nbsp;res0&nbsp;*&nbsp;<code class="literal">3</code>
  <code class="output">res1:&nbsp;Int&nbsp;=&nbsp;9</code>
</pre>
      <p>To print the necessary, but not sufficient, <span class="code">Hello,</span>&nbsp;<span class="code">world!</span> greeting, type:</p> <pre>  scala&gt;&nbsp;println(<code class="quotedstring">"Hello,&nbsp;world!"</code>)
  <code class="output">Hello,&nbsp;world!</code>
</pre>
      <p>The <span class="code">println</span> function prints the passed string to the standard output, similar to <span class="code">System.out.println</span> in Java.</p>
      <h3><a id="step2">Step 2. Define some variables</a></h3>
      <p>Scala has two kinds of variables, <span class="code">val</span>s and <span class="code">var</span>s.<a id="i-717204901-1"></a><a id="i646151360-1"></a><a id="i-1545622202-1"></a> A <span class="code">val</span> is similar to a final variable in Java. Once initialized, a <span class="code">val</span> can never be reassigned. A <span class="code">var</span>, by contrast, is similar to a non-final variable in Java. A <span class="code">var</span> can be reassigned throughout its lifetime. Here's a <span class="code">val</span> definition:<a id="i61-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;msg&nbsp;=&nbsp;<code class="quotedstring">"Hello,&nbsp;world!"</code>
  <code class="output">msg:&nbsp;String&nbsp;=&nbsp;Hello,&nbsp;world!</code>
</pre>
      <p>This statement introduces <span class="code">msg</span> as a name for the string <span class="code">"Hello,</span>&nbsp;<span class="code">world!"</span>. The type of <span class="code">msg</span> is <span class="code">java.lang.String</span>, because Scala strings are implemented by Java's <span class="code">String</span> class.</p>
      <p>If you're used to declaring variables in Java, you'll notice one striking difference here: neither <span class="code">java.lang.String</span> nor <span class="code">String</span> appear anywhere in the <span class="code">val</span> definition. This example illustrates <em>type inference</em>, Scala's ability to figure out types you leave off. In this case, because you initialized <span class="code">msg</span> with a string literal, Scala inferred the type of <span class="code">msg</span> to be <span class="code">String</span>. When the Scala interpreter (or compiler) can infer types, it is often best to let it do so rather than fill the code with unnecessary, explicit type annotations.<a id="i-2107785776-3"></a><a id="i1449766718-3"></a> You can, however, specify a type explicitly if you wish, and sometimes you probably should. An explicit type annotation can both ensure the Scala compiler infers the type you intend, as well as serve as useful documentation for future readers of the code. In contrast to Java, where you specify a variable's type before its name, in Scala you specify a variable's type after its name, separated by a colon.<a id="i-1836523111-1"></a> For example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;msg2:&nbsp;<code class="typename">java.lang.String</code>&nbsp;=&nbsp;<code class="quotedstring">"Hello&nbsp;again,&nbsp;world!"</code>
  <code class="output">msg2:&nbsp;String&nbsp;=&nbsp;Hello&nbsp;again,&nbsp;world!</code>
</pre>
      <p>Or, since <span class="code">java.lang</span> types are visible with their simple names<a href="#footnotemain2-4">[4]</a> in Scala programs, simply:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;msg3:&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;<code class="quotedstring">"Hello&nbsp;yet&nbsp;again,&nbsp;world!"</code>
  <code class="output">msg3:&nbsp;String&nbsp;=&nbsp;Hello&nbsp;yet&nbsp;again,&nbsp;world!</code>
</pre>
      <p>Going back to the original <span class="code">msg</span>, now that it is defined, you can use it as you'd expect, for example:</p> <pre>  scala&gt;&nbsp;println(msg)
  <code class="output">Hello,&nbsp;world!</code>
</pre>
      <p>What you can't do with <span class="code">msg</span>, given that it is a <span class="code">val</span>, not a <span class="code">var</span>, is reassign it.<a href="#footnotemain2-5">[5]</a> For example, see how the interpreter complains when you attempt the following:<a id="i1301665902-1"></a></p> <pre>  scala&gt;&nbsp;msg&nbsp;=&nbsp;<code class="quotedstring">"Goodbye&nbsp;cruel&nbsp;world!"</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;reassignment&nbsp;to&nbsp;val</code>
  <code class="output"></code>
</pre>
      <p>If reassignment is what you want, you'll need to use a <span class="code">var</span>, as in:</p> <pre>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;greeting&nbsp;=&nbsp;<code class="quotedstring">"Hello,&nbsp;world!"</code>
  <code class="output">greeting:&nbsp;String&nbsp;=&nbsp;Hello,&nbsp;world!</code>
</pre>
      <p>Since <span class="code">greeting</span> is a <span class="code">var</span> not a <span class="code">val</span>, you can reassign it later. If you are feeling grouchy later, for example, you could change your <span class="code">greeting</span> to:</p> <pre>  scala&gt;&nbsp;greeting&nbsp;=&nbsp;<code class="quotedstring">"Leave&nbsp;me&nbsp;alone,&nbsp;world!"</code>
  <code class="output">mutated&nbsp;greeting</code>
</pre>
      <p>To enter something into the interpreter that spans multiple lines, just keep typing after the first line. If the code you typed so far is not complete, the interpreter will respond with a vertical bar on the next line.</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;multiLine&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<code class="quotedstring">"This&nbsp;is&nbsp;the&nbsp;next&nbsp;line."</code>
  <code class="output">multiLine:&nbsp;String&nbsp;=&nbsp;This&nbsp;is&nbsp;the&nbsp;next&nbsp;line.</code>
</pre>
      <p>If you realize you have typed something wrong, but the interpreter is still waiting for more input, you can escape by pressing enter twice:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;oops&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;
  <code class="output">You&nbsp;typed&nbsp;two&nbsp;blank&nbsp;lines.&nbsp;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;command.</code>
  <br>  scala&gt;
</pre>
      <p>In the rest of the book, we'll leave out the vertical bars to make the code easier to read (and easier to copy and paste from the PDF eBook into the interpreter).</p>
      <h3><a id="step3">Step 3. Define some functions</a></h3>
      <p><a id="sec-define-some-functions"></a></p>
      <p>Now that you've worked with Scala variables, you'll probably want to write some functions. Here's how you do that in Scala:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;max(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;&gt;&nbsp;y)&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;y
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">max:&nbsp;(x:&nbsp;Int,&nbsp;y:&nbsp;Int)Int</code>
</pre>
      <p>Function definitions start with <span class="code">def</span>.<a id="i1764649166-1"></a> The function's name, in this case <span class="code">max</span>, is followed by a comma-separated list of parameters in parentheses. A type annotation must follow every function parameter, preceded by a colon, because the Scala compiler (and interpreter, but from now on we'll just say compiler) does not infer function parameter types. In this example, the function named <span class="code">max</span> takes two parameters, <span class="code">x</span> and <span class="code">y</span>, both of type <span class="code">Int</span>. After the close parenthesis of <span class="code">max</span>'s parameter list you'll find another "<span class="code">:</span>&nbsp;<span class="code">Int</span>" type annotation. This one defines the <a href="#g-595246755"><em>result type</em></a> of<a id="i-595246755-1"></a><a id="i-1437134274-1"></a> the <span class="code">max</span> function itself.<a href="#footnotemain2-6">[6]</a> Following the function's result type is an equals sign and pair of curly braces that contain the body of the function. In this case, the body contains a single <span class="code">if</span> expression,<a id="i-1395149224-1"></a> which selects either <span class="code">x</span> or <span class="code">y</span>, whichever is greater, as the result of the <span class="code">max</span> function. As demonstrated here, Scala's <span class="code">if</span> expression can result in a value, similar to Java's ternary operator. For example, the Scala expression "<span class="code">if</span>&nbsp;<span class="code">(x</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">y)</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">else</span>&nbsp;<span class="code">y</span>" behaves similarly to "<span class="code">(x</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">y)</span>&nbsp;<span class="code">?</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">:</span>&nbsp;<span class="code">y</span>" in Java. The equals sign that precedes the body of a function hints that in the functional world view, a function defines an expression that results in a value. The basic structure of a function is illustrated in <a href="#fig-method-form">Figure 2.1</a>.</p>
      <div class="figure">
        <a id="fig-method-form"></a>
        <p><img src="methodForm144.png" alt="images/methodForm144.png"></p>
      </div>
      <h5> Figure 2.1 - The basic form of a function definition in Scala.<a id="i-1058128094-1"></a></h5>
      <p>Sometimes the Scala compiler will require you to specify the result type of a function. If the function is <a href="#g1165780018"><em>recursive</em></a>,<a href="#footnotemain2-7">[7]</a> for example, you must explicitly specify the function's result type. In the case of <span class="code">max</span>, however, you may leave the result type off and the compiler will infer it.<a href="#footnotemain2-8">[8]</a> Also, if a function consists of just one statement, you can optionally leave off the curly braces. Thus, you could alternatively write the <span class="code">max</span> function like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;max(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;&gt;&nbsp;y)&nbsp;x&nbsp;<code class="vem">else</code>&nbsp;y
  <code class="output">max:&nbsp;(x:&nbsp;Int,&nbsp;y:&nbsp;Int)Int</code>
</pre>
      <p>Once you have defined a function, you can call it by name, as in:</p> <pre>  scala&gt;&nbsp;max(<code class="literal">3</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">res4:&nbsp;Int&nbsp;=&nbsp;5</code>
</pre>
      <p>Here's the definition of a function that takes no parameters and returns no interesting result:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;greet()&nbsp;=&nbsp;println(<code class="quotedstring">"Hello,&nbsp;world!"</code>)
  <code class="output">greet:&nbsp;()Unit</code>
</pre>
      <p>When you define the <span class="code">greet()</span> function, the interpreter will respond with <span class="code">greet:</span>&nbsp;<span class="code">()Unit</span>. "<span class="code">greet</span>" is, of course, the name of the function. The empty parentheses indicate the function takes no parameters. And <span class="code">Unit</span> is <span class="code">greet</span>'s result type. A result type of <span class="code">Unit</span> indicates the function returns no interesting value. Scala's <span class="code">Unit</span> type is similar to Java's <span class="code">void</span> type; in fact, every <span class="code">void</span>-returning method in Java is mapped to a <span class="code">Unit</span>-returning method in Scala. Methods with the result type of <span class="code">Unit</span>, therefore, are only executed for their side effects. In the case of <span class="code">greet()</span>, the side effect is a friendly greeting printed to the standard output.</p>
      <p>In the next step, you'll place Scala code in a file and run it as a script. If you wish to exit the interpreter, you can do so by entering <span class="code">:quit</span> or <span class="code">:q</span>.</p> <pre>  scala&gt;&nbsp;:quit
  $
</pre>
      <h3><a id="step4">Step 4. Write some Scala scripts</a></h3>
      <p>Although Scala is designed to help programmers build very large-scale systems, it also scales<a id="i1047419434-1"></a> down nicely to scripting. A script is just a sequence of statements in a file that will be executed sequentially. Put this into a file named <span class="code">hello.scala</span>:</p> <pre>  println(<code class="quotedstring">"Hello,&nbsp;world,&nbsp;from&nbsp;a&nbsp;script!"</code>)
</pre>
      <p>then run:<a href="#footnotemain2-9">[9]</a></p> <pre>  $&nbsp;scala&nbsp;hello.scala
</pre>
      <p>And you should get yet another greeting:</p> <pre>  <code class="output">Hello,&nbsp;world,&nbsp;from&nbsp;a&nbsp;script!</code>
</pre>
      <p>Command line arguments<a id="i337914190-1"></a> to a Scala script are available via a Scala array named <span class="code">args</span>.<a id="i515731402-1"></a> In Scala, arrays are zero based, and you access an element by specifying an index in parentheses. So the first element in a Scala array named <span class="code">steps</span> is <span class="code">steps(0)</span>, not <span class="code">steps[0]</span>, as in Java. To try this out, type the following into a new file named <span class="code">helloarg.scala</span>:</p> <pre>  <code class="comment">//&nbsp;Say&nbsp;hello&nbsp;to&nbsp;the&nbsp;first&nbsp;argument</code>
  println(<code class="quotedstring">"Hello,&nbsp;"</code>&nbsp;+&nbsp;args(<code class="literal">0</code>)&nbsp;+&nbsp;<code class="quotedstring">"!"</code>)
</pre>
      <p>then run:<a id="i1342830375-1"></a></p> <pre>  $&nbsp;scala&nbsp;helloarg.scala&nbsp;planet
</pre>
      <p>In this command, <span class="code">"planet"</span> is passed as a command line argument, which is accessed in the script as <span class="code">args(0)</span>. Thus, you should see:</p> <pre>  <code class="output">Hello,&nbsp;planet!</code>
</pre>
      <p>Note that this script included a comment. The Scala compiler will ignore characters between <span class="code">//</span> and the next end of line and any characters between <span class="code">/*</span> and <span class="code">*/</span>. This example also shows <span class="code">String</span>s being concatenated with the <span class="code">+</span> operator. This works as you'd expect. The expression <span class="code">"Hello,</span>&nbsp;<span class="code">"</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">"world!"</span> will result in the string <span class="code">"Hello,</span>&nbsp;<span class="code">world!"</span>.</p>
      <h3><a id="step5">Step 5. Loop with <span class="code">while</span>; decide with <span class="code">if</span></a></h3>
      <p>To try out a <span class="code">while</span>, type the following<a id="i852231328-1"></a> into a file named <span class="code">printargs.scala</span>:</p> <pre>  <code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="vem">while</code>&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;println(args(i))
  &nbsp;&nbsp;i&nbsp;+=&nbsp;<code class="literal">1</code>
  }
</pre>
      <div class="note">
        <h4>Note</h4>
        <p>Although the examples in this section help explain <span class="code">while</span> loops, they do not demonstrate the best Scala style. In the next section, you'll see better approaches that avoid iterating through arrays with indexes.</p>
      </div>
      <p>This script starts with a variable definition, <span class="code">var</span>&nbsp;<span class="code">i</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">0</span>. Type inference gives <span class="code">i</span> the type <span class="code">scala.Int</span>, because that is the type of its initial value, <span class="code">0</span>. The <span class="code">while</span> construct on the next line causes the <a href="#g93832333"><em>block</em></a> (the code between the curly braces) to be repeatedly executed until the boolean expression <span class="code">i</span>&nbsp;<span class="code">&lt;</span>&nbsp;<span class="code">args.length</span> is false. <span class="code">args.length</span> gives the length of the <span class="code">args</span> array. The block contains two statements, each indented two spaces, the recommended indentation style for Scala. The first statement, <span class="code">println(args(i))</span>, prints out the <span class="code">i</span>th command line argument. The second statement, <span class="code">i</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">1</span>, increments <span class="code">i</span> by one. Note that Java's <span class="code">++i</span> and <span class="code">i++</span> don't work in Scala. To increment in Scala, you need to say either <span class="code">i</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">i</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span> or <span class="code">i</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">1</span>.<a id="i-1984818667-1"></a> Run this script with the following command:</p> <pre>  $&nbsp;scala&nbsp;printargs.scala&nbsp;Scala&nbsp;is&nbsp;fun
</pre>
      <p>And you should see:<span style="color: white"></span></p> <pre>  <code class="output">Scala</code>
  <code class="output">is</code>
  <code class="output">fun</code>
</pre>
      <p>For even more fun, type the following code into a new file with the name <span class="code">echoargs.scala</span>:</p> <pre>  <code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="vem">while</code>&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(i&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">"&nbsp;"</code>)
  &nbsp;&nbsp;print(args(i))
  &nbsp;&nbsp;i&nbsp;+=&nbsp;<code class="literal">1</code>
  }
  println()
</pre>
      <p>In this version, you've replaced the <span class="code">println</span> call with a <span class="code">print</span> call, so that all the arguments will be printed out on the same line. To make this readable, you've inserted a single space before each argument except the first via the <span class="code">if</span>&nbsp;<span class="code">(i</span>&nbsp;<span class="code">!=</span>&nbsp;<span class="code">0)</span> construct. Since <span class="code">i</span>&nbsp;<span class="code">!=</span>&nbsp;<span class="code">0</span> will be <span class="code">false</span> the first time through the <span class="code">while</span> loop, no space will get printed before the initial argument. Lastly, you've added one more <span class="code">println</span> to the end, to get a line return after printing out all the arguments. Your output will be very pretty indeed. If you run this script with the following command:</p> <pre>  $&nbsp;scala&nbsp;echoargs.scala&nbsp;Scala&nbsp;is&nbsp;even&nbsp;more&nbsp;fun
</pre>
      <p>You'll get:</p> <pre>  <code class="output">Scala&nbsp;is&nbsp;even&nbsp;more&nbsp;fun</code>
</pre>
      <p>Note that in Scala, as in Java, you must put the boolean expression for a <span class="code">while</span> or an <span class="code">if</span> in parentheses. (In other words, you can't say in Scala things like <span class="code">if</span>&nbsp;<span class="code">i</span>&nbsp;<span class="code">&lt;</span>&nbsp;<span class="code">10</span> as you can in a language such as Ruby.<a id="i-1395149224-2"></a> You must say <span class="code">if</span>&nbsp;<span class="code">(i</span>&nbsp;<span class="code">&lt;</span>&nbsp;<span class="code">10)</span> in Scala.) Another similarity to Java is that if a block has only one statement, you can optionally leave off the curly braces, as demonstrated by the <span class="code">if</span> statement in <span class="code">echoargs.scala</span>. And although you haven't seen any of them, Scala does use semicolons to separate statements as in Java, except that in Scala the semicolons are very often optional, giving some welcome relief to your right little finger. If you had been in a more verbose mood, therefore, you could have written the <span class="code">echoargs.scala</span> script as follows:</p> <pre>  <code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">0</code>;
  <code class="vem">while</code>&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(i&nbsp;!=&nbsp;<code class="literal">0</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">"&nbsp;"</code>);
  &nbsp;&nbsp;}
  &nbsp;&nbsp;print(args(i));
  &nbsp;&nbsp;i&nbsp;+=&nbsp;<code class="literal">1</code>;
  }
  println();
</pre>
      <h3><a id="step6">Step 6. Iterate with <span class="code">foreach</span> and <span class="code">for</span></a></h3>
      <p>Although you may not have realized it, when you wrote the <span class="code">while</span> loops in the previous step, you were programming in an <em>imperative</em> style. In the imperative style, which is the style you normally use with languages like Java, C++, and C, you give one imperative command at a time, iterate with loops, and often mutate state shared between different functions. Scala enables you to program imperatively, but as you get to know Scala better, you'll likely often find yourself programming in a more <em>functional</em> style. In fact, one of the main aims of this book is to help you become as comfortable with the functional style as you are with imperative style.</p>
      <p>One of the main characteristics of a functional language is that functions are first class constructs, and that's very true in Scala. For example, another (far more concise) way to print each command line argument is:<a id="i1367928747-1"></a><a id="i443322727-1"></a></p> <pre>  args.foreach(arg&nbsp;=&gt;&nbsp;println(arg))
</pre>
      <p>In this code, you call the <span class="code">foreach</span> method on <span class="code">args</span> and pass in a function. In this case, you're passing in a <a href="#g1911543911"><em>function literal</em></a> that takes one parameter named <span class="code">arg</span>. The body of the function is <span class="code">println(arg)</span>. If you type the above code into a new file named <span class="code">pa.scala</span> and execute with the command:</p> <pre>  $&nbsp;scala&nbsp;pa.scala&nbsp;Concise&nbsp;is&nbsp;nice
</pre>
      <p>You should see:</p> <pre>  <code class="output">Concise</code>
  <code class="output">is</code>
  <code class="output">nice</code>
</pre>
      <p>In the previous example, the Scala interpreter infers the type of <span class="code">arg</span> to be <span class="code">String</span>, since <span class="code">String</span> is the element type of the array on which you're calling <span class="code">foreach</span>. If you'd prefer to be more explicit, you can mention the type name. But when you do, you'll need to wrap the argument portion in parentheses (which is the normal form of the syntax anyway):</p> <pre>  args.foreach((arg:&nbsp;<code class="typename">String</code>)&nbsp;=&gt;&nbsp;println(arg))
</pre>
      <p>Running this script has the same behavior as the previous one.</p>
      <p>If you're in the mood for more conciseness instead of more explicitness, you can take advantage of a special shorthand in Scala. If a function literal consists of one statement that takes a single argument, you need not explicitly name and specify the argument.<a href="#footnotemain2-10">[10]</a> Thus, the following code also works:</p> <pre>  args.foreach(println)
</pre>
      <p>To summarize, the syntax for a function literal is a list of named parameters, in parentheses, a right arrow, and then the body of the function. This syntax is illustrated in <a href="#fig-function-literal">Figure 2.2</a>.</p>
      <div class="figure">
        <a id="fig-function-literal"></a>
        <p><img src="functionLiteral96.png" alt="images/functionLiteral96.png"></p>
      </div>
      <h5> Figure 2.2 - The syntax of a function literal in Scala.<a id="i-995341786-1"></a></h5>
      <p>Now, by this point you may be wondering what happened to those trusty <span class="code">for</span> loops you have been accustomed to using in imperative languages, such as Java or C. In an effort to guide you in a functional direction, only a functional relative of the imperative <span class="code">for</span> (called a <em><span class="code">for</span> expression</em>) is available in Scala.<a id="i-207940604-1"></a> While you won't see their full power and expressiveness until you reach (or peek ahead to) <a href="#sec-for-expressions">Section 7.3</a>, we'll give you a glimpse here. In a new file named <span class="code">forargs.scala</span>, type the following:</p> <pre>  <code class="vem">for</code>&nbsp;(arg&nbsp;&lt;-&nbsp;args)
  &nbsp;&nbsp;println(arg)
</pre>
      <p>The parentheses after the "<span class="code">for</span>" contain <span class="code">arg</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">args</span>.<a href="#footnotemain2-11">[11]</a> To the right of the <span class="code">&lt;-</span> symbol is the familiar <span class="code">args</span> array.<a id="i-1528740659-1"></a> To the left of <span class="code">&lt;-</span> is "<span class="code">arg</span>", the name of a <span class="code">val</span>, not a <span class="code">var</span>. (Because it is always a <span class="code">val</span>, you just write "<span class="code">arg</span>" by itself, not "<span class="code">val</span>&nbsp;<span class="code">arg</span>".) Although <span class="code">arg</span> may seem to be a <span class="code">var</span>, because it will get a new value on each iteration, it really is a <span class="code">val</span>: <span class="code">arg</span> can't be reassigned inside the body of the <span class="code">for</span> expression. Instead, for each element of the <span class="code">args</span> array, a <em>new</em> <span class="code">arg</span> <span class="code">val</span> will be created and initialized to the element value, and the body of the <span class="code">for</span> will be executed.</p>
      <p>If you run the <span class="code">forargs.scala</span> script with the command:</p> <pre>  $&nbsp;scala&nbsp;forargs.scala&nbsp;for&nbsp;arg&nbsp;in&nbsp;args
</pre>
      <p>You'll see:</p> <pre>  <code class="output">for</code>
  <code class="output">arg</code>
  <code class="output">in</code>
  <code class="output">args</code>
</pre>
      <p>Scala's <span class="code">for</span> expression can do much more than this, but this example is enough to get you started. We'll show you more about <span class="code">for</span> in <a href="#sec-for-expressions">Section 7.3</a> and <a href="#chap-for-expressions-revisited.html">Chapter 23</a>.</p>
      <h3>Conclusion</h3>
      <p>In this chapter, you learned some Scala basics and, hopefully, took advantage of the opportunity to write a bit of Scala code. In the next chapter, we'll continue this introductory overview and get into more advanced topics.</p>
      <hr>
      <h4>Footnotes for Chapter 2:</h4>
      <p><a id="footnotemain2-1"></a>[1] We tested the examples in this book with Scala version 2.13.1.</p>
      <p><a id="footnotemain2-2"></a>[2] If you're using Windows, you'll need to type the <span class="code">scala</span> command into the "Command Prompt" DOS box.</p>
      <p><a id="footnotemain2-3"></a>[3] If you're not familiar with Java packages, you can think of them as providing a full name for classes. Because <span class="code">Int</span> is a member of package <span class="code">scala</span>, "<span class="code">Int</span>" is the class's simple name, and "<span class="code">scala.Int</span>" is its full name. The details of packages are explained in <a href="#chap-packages-and-imports">Chapter 13</a>.</p>
      <p><a id="footnotemain2-4"></a>[4] The simple name of <span class="code">java.lang.String</span> is <span class="code">String</span>.</p>
      <p><a id="footnotemain2-5"></a>[5] In the interpreter, however, you can <em>define</em> a new <span class="code">val</span> with a name that was already used before. This mechanism is explained in <a href="#sec-variable-scope">Section 7.7</a>.</p>
      <p><a id="footnotemain2-6"></a>[6] In Java, the type of the value returned from a method is its return type<a id="i-1544421334-1"></a><a id="i-1437104303-1"></a>. In Scala, that same concept is called <em>result type</em>.</p>
      <p><a id="footnotemain2-7"></a>[7] A function is recursive if it calls itself.</p>
      <p><a id="footnotemain2-8"></a>[8] Nevertheless, it is often a good idea to indicate function result types explicitly, even when the compiler doesn't require it. Such type annotations can make the code easier to read, because the reader need not study the function body to figure out the inferred result type.</p>
      <p><a id="footnotemain2-9"></a>[9] You can run scripts without typing "<span class="code">scala</span>" on Unix and Windows using a "pound-bang" syntax, which is shown in <a href="scala-scripts-on-unix-and-windows.html">Appendix A</a>.</p>
      <p><a id="footnotemain2-10"></a>[10] This shorthand, called a <em>partially applied function</em>, is described in <a href="#sec-partially-applied-functions">Section 8.6</a>.</p>
      <p><a id="footnotemain2-11"></a>[11] You can say "in" for the <span class="code">&lt;-</span> symbol. You'd read <span class="code">for</span>&nbsp;<span class="code">(arg</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">args)</span>, therefore, as "for arg in args."</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-next-steps-in-scala">Chapter 3</a></h2>
      <h1>Next Steps in Scala</h1>
      <p>This chapter continues the previous chapter's introduction to Scala. In this chapter, we'll introduce some more advanced features. When you complete this chapter, you should have enough knowledge to enable you to start writing useful scripts in Scala. As with the previous chapter, we recommend you try out these examples as you go. The best way to get a feel for Scala is to start writing Scala code.</p>
      <h3><a id="step7">Step 7. Parameterize arrays with types</a></h3>
      <p>In Scala, you can instantiate objects, or class instances, using <span class="code">new</span>. When you instantiate an object in Scala, you can <em>parameterize</em><a id="i1621984850-1"></a><a id="i-676617420-1"></a><a id="i534686151-1"></a><a id="i-780439702-1"></a><a id="i1292813002-1"></a> it with values and types. Parameterization means "configuring" an instance when you create it. You parameterize an instance with values by passing objects to a constructor<a id="i-1995954247-1"></a> in parentheses. For example, the following Scala code instantiates a new <span class="code">java.math.BigInteger</span> and parameterizes it with the value <span class="code">"12345"</span>:</p> <pre>  <code class="vem">val</code>&nbsp;big&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">java.math.BigInteger</code>(<code class="quotedstring">"12345"</code>)
</pre>
      <p>You parameterize an instance with types by specifying one or more types in square brackets. An example is shown in <a href="#lst-param-array">Listing 3.1</a>. In this example, <span class="code">greetStrings</span> is a value of type <span class="code">Array[String]</span> (an "array of string") that is initialized to length 3 by parameterizing it with the value <span class="code">3</span> in the first line of code. If you run the code in <a href="#lst-param-array">Listing 3.1</a> as a script, you'll see yet another <span class="code">Hello,</span>&nbsp;<span class="code">world!</span> greeting. Note that when you parameterize an instance with both a type and a value, the type comes first in its square brackets, followed by the value in parentheses.</p>
      <p><a id="lst-param-array"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;greetStrings&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[String]</code>(<code class="literal">3</code>)
  <br>  &nbsp;&nbsp;greetStrings(<code class="literal">0</code>)&nbsp;=&nbsp;<code class="quotedstring">"Hello"</code>
  &nbsp;&nbsp;greetStrings(<code class="literal">1</code>)&nbsp;=&nbsp;<code class="quotedstring">",&nbsp;"</code>
  &nbsp;&nbsp;greetStrings(<code class="literal">2</code>)&nbsp;=&nbsp;<code class="quotedstring">"world!\n"</code>
  <br>  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;to&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;print(greetStrings(i))
</pre>
      <h5>Listing 3.1 - Parameterizing an array with a type.</h5>
      <div class="note">
        <h4>Note</h4>
        <p>Although the code in <a href="#lst-param-array">Listing 3.1</a> demonstrates important concepts, it does not show the recommended way to create and initialize an array in Scala. You'll see a better way in <a href="#lst-init-array">Listing 3.2</a> <a href="#lst-init-array">here</a>.</p>
      </div>
      <p>Had you been in a more explicit mood, you could have specified the type of <span class="code">greetStrings</span> explicitly like this:</p> <pre>  <code class="vem">val</code>&nbsp;greetStrings:&nbsp;<code class="typename">Array[String]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[String]</code>(<code class="literal">3</code>)
</pre>
      <p>Given Scala's type inference, this line of code is semantically equivalent to the actual first line of <a href="#lst-param-array">Listing 3.1</a>. But this form demonstrates that while the type parameterization portion (the type names in square brackets) forms part of the type of the instance, the value parameterization part (the values in parentheses) does not. The type of <span class="code">greetStrings</span> is <span class="code">Array[String]</span>, not <span class="code">Array[String](3)</span>.</p>
      <p>The next three lines of code in <a href="#lst-param-array">Listing 3.1</a> initialize each element of the <span class="code">greetStrings</span> array:</p> <pre>  greetStrings(<code class="literal">0</code>)&nbsp;=&nbsp;<code class="quotedstring">"Hello"</code>
  greetStrings(<code class="literal">1</code>)&nbsp;=&nbsp;<code class="quotedstring">",&nbsp;"</code>
  greetStrings(<code class="literal">2</code>)&nbsp;=&nbsp;<code class="quotedstring">"world!\n"</code>
</pre>
      <p>As mentioned previously, arrays<a id="i1726482861-1"></a> in Scala are accessed by placing the index inside parentheses, not square brackets as in Java. Thus the zeroth element of the array is <span class="code">greetStrings(0)</span>, not <span class="code">greetStrings[0]</span>.</p>
      <p>These three lines of code illustrate an important concept to understand about Scala concerning the meaning of <span class="code">val</span><a id="i-1513931462-1"></a>. When you define a variable with <span class="code">val</span>, the variable can't be reassigned, but the object to which it refers could potentially still be changed. So in this case, you couldn't reassign <span class="code">greetStrings</span> to a different array; <span class="code">greetStrings</span> will always point to the same <span class="code">Array[String]</span> instance with which it was initialized. But you <em>can</em> change the elements of that <span class="code">Array[String]</span> over time, so the array itself is mutable.</p>
      <p>The final two lines in <a href="#lst-param-array">Listing 3.1</a> contain a <span class="code">for</span> expression that prints out each <span class="code">greetStrings</span> array element in turn:</p> <pre>  <code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;to&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;print(greetStrings(i))
</pre>
      <p>The first line of code in this <span class="code">for</span> expression illustrates another general rule of Scala: if a method takes only one parameter, you can<a id="i574171488-1"></a> call it without a dot or parentheses.<a id="i-614149608-1"></a> The <span class="code">to</span> in this example is actually a method that takes one <span class="code">Int</span> argument. The code <span class="code">0</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">2</span> is transformed into the method call <span class="code">(0).to(2)</span>.<a href="#footnotemain3-1">[1]</a> Note that this syntax only works if you explicitly specify the receiver of the method call. You cannot write "<span class="code">println</span>&nbsp;<span class="code">10</span>", but you can write "<span class="code">Console</span>&nbsp;<span class="code">println</span>&nbsp;<span class="code">10</span>".</p>
      <p>Scala doesn't technically have operator overloading,<a id="i-189261806-1"></a><a id="i2049320438-1"></a> because it doesn't actually have operators in the traditional sense. Instead, characters such as <span class="code">+</span>, <span class="code">-</span>, <span class="code">*</span>, and <span class="code">/</span> can be used in method names. Thus, when you typed <span class="code">1</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span> into the Scala interpreter in Step 1, you were actually invoking a method named <span class="code">+</span> on the <span class="code">Int</span> object <span class="code">1</span>, passing in <span class="code">2</span> as a parameter. As illustrated in <a href="#fig-operator-notation">Figure 3.1</a>, you could alternatively have written <span class="code">1</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span> using traditional method invocation syntax, <span class="code">(1).+(2)</span>.</p>
      <div class="figure">
        <a id="fig-operator-notation"></a>
        <p><img src="operatorNotation80.png" alt="images/operatorNotation80.png"></p>
      </div>
      <h5> Figure 3.1 - All operations are method calls in Scala.</h5>
      <p>Another important idea illustrated by this example will give you insight into why arrays are accessed with parentheses<a id="i580437291-1"></a> in Scala. Scala has fewer special cases than Java. Arrays are simply instances of classes like any other class in Scala. When you apply parentheses surrounding one or more values to a variable, Scala will transform the code into an invocation of a method named <span class="code">apply</span><a id="i1032551708-1"></a><a id="i-760757566-1"></a> on that variable. So <span class="code">greetStrings(i)</span> gets transformed into <span class="code">greetStrings.apply(i)</span>. Thus accessing an element of an array in Scala is simply a method call like any other.<a id="i-1841919811-1"></a> This principle is not restricted to arrays: any application of an object to some arguments in parentheses will be transformed to an <span class="code">apply</span> method call. Of course this will compile only if that type of object actually defines an <span class="code">apply</span> method. So it's not a special case; it's a general rule.</p>
      <p>Similarly, when an assignment is made to a variable to which parentheses and one or more arguments have been applied, the compiler will transform that into an invocation of an <span class="code">update</span> method that takes the arguments in parentheses as well as the object to the right of the equals sign.<a id="i1392004210-1"></a> For example:</p> <pre>  greetStrings(<code class="literal">0</code>)&nbsp;=&nbsp;<code class="quotedstring">"Hello"</code>&nbsp;
</pre>
      <p>will be transformed into:</p> <pre>  greetStrings.update(<code class="literal">0</code>,&nbsp;<code class="quotedstring">"Hello"</code>)
</pre>
      <p>Thus, the following is semantically equivalent to the code in <a href="#lst-param-array">Listing 3.1</a>:</p> <pre>  <code class="vem">val</code>&nbsp;greetStrings&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[String]</code>(<code class="literal">3</code>)
  <br>  greetStrings.update(<code class="literal">0</code>,&nbsp;<code class="quotedstring">"Hello"</code>)
  greetStrings.update(<code class="literal">1</code>,&nbsp;<code class="quotedstring">",&nbsp;"</code>)
  greetStrings.update(<code class="literal">2</code>,&nbsp;<code class="quotedstring">"world!\n"</code>)
  <br>  <code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0.</code>to(<code class="literal">2</code>))
  &nbsp;&nbsp;print(greetStrings.apply(i))
</pre>
      <p>Scala achieves a conceptual simplicity by treating everything, from arrays to expressions, as objects with methods. You don't have to remember special cases, such as the differences in Java between primitive and their corresponding wrapper types, or between arrays and regular objects. Moreover, this uniformity does not incur a significant performance cost. The Scala compiler uses Java arrays, primitive types<a id="i-1876955136-1"></a><a id="i-1448312026-1"></a>, and native arithmetic where possible in the compiled code.<a id="i884498802-2"></a><a id="i341425106-1"></a></p>
      <p>Although the examples you've seen so far in this step compile and run just fine, Scala provides a more concise way to create and initialize arrays that you would normally use (see <a href="#lst-init-array">Listing 3.2</a>). This code creates a new array of length three, initialized to the passed strings, <span class="code">"zero"</span>, <span class="code">"one"</span>, and <span class="code">"two"</span>. The compiler infers the type of the array to be <span class="code">Array[String]</span>, because you passed strings to it.</p>
      <p><a id="lst-init-array"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;numNames&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="quotedstring">"zero"</code>,&nbsp;<code class="quotedstring">"one"</code>,&nbsp;<code class="quotedstring">"two"</code>)
</pre>
      <h5>Listing 3.2 - Creating and initializing an array.</h5>
      <p>What<a id="i-1162394563-1"></a><a id="i1766069577-1"></a><a id="i1302049027-1"></a> you're actually doing in <a href="#lst-init-array">Listing 3.2</a> is calling a factory<a id="i-640194953-1"></a><a id="i1891034327-1"></a> method,<a id="i-1125093732-1"></a> named <span class="code">apply</span>, which creates and returns the new array.<a id="i-930370406-1"></a><a id="i-1249757433-1"></a> This <span class="code">apply</span> method takes a variable number of arguments<a href="#footnotemain3-2">[2]</a><a id="i-1544402352-1"></a><a id="i-580179190-1"></a> and is defined on the <span class="code">Array</span> <em>companion object</em>.<a id="i228947968-1"></a> You'll learn more about companion objects in <a href="#sec-singleton-objects">Section 4.3</a>. If you're a Java programmer, you can think of this as calling a static method named <span class="code">apply</span> on class <span class="code">Array</span>. A more verbose way to call the same <span class="code">apply</span> method is:</p> <pre>  <code class="vem">val</code>&nbsp;numNames2&nbsp;=&nbsp;Array.apply(<code class="quotedstring">"zero"</code>,&nbsp;<code class="quotedstring">"one"</code>,&nbsp;<code class="quotedstring">"two"</code>)
</pre>
      <h3><a id="step8">Step 8. Use lists</a></h3>
      <p>One of the big ideas of the functional style of programming is that methods should<a id="i102982549-1"></a> not have side effects.<a id="i18918201-2"></a><a id="i-86904923-1"></a> A method's only act should be to compute and return a value. Some benefits gained when you take this approach are that methods become less entangled, and therefore more reliable and reusable. Another benefit (in a statically typed language) is that everything that goes into and out of a method is checked by a type checker, so logic errors are more likely to manifest themselves as type errors. Applying this functional philosophy to the world of objects means making objects immutable.<a id="i2043021322-1"></a><a id="i-124569956-1"></a></p>
      <p>As you've seen, a Scala array is a mutable sequence of objects that all share the same type. An <span class="code">Array[String]</span> contains only strings, for example. Although you can't change the length of an array after it is instantiated, you can change its element values. Thus, arrays are mutable objects.</p>
      <p>For an immutable sequence of objects that share the same type you can use Scala's <span class="code">List</span><a id="i882498454-1"></a> class. As with arrays, a <span class="code">List[String]</span> contains only strings. Scala's <span class="code">List</span>, <span class="code">scala.List</span>, differs from Java's <span class="code">java.util.List</span> type in that Scala <span class="code">List</span>s are always immutable (whereas Java <span class="code">List</span>s can be mutable). More generally, Scala's <span class="code">List</span> is designed to enable a functional style of programming. Creating a list is easy, and <a href="#lst-init-list">Listing 3.3</a> shows how:</p>
      <p><a id="lst-init-list"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;oneTwoThree&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
</pre>
      <h5>Listing 3.3 - Creating and initializing a list.</h5>
      <p>The<a id="i-797883688-1"></a><a id="i-625874522-1"></a><a id="i457962676-1"></a> code in <a href="#lst-init-list">Listing 3.3</a><a id="i486535256-1"></a> establishes a new <span class="code">val</span> named <span class="code">oneTwoThree</span>, initialized with a new <span class="code">List[Int]</span> with the integer elements 1, 2, and 3.<a href="#footnotemain3-3">[3]</a><a id="i19484993-1"></a><a id="i1305057997-1"></a> Because <span class="code">List</span>s are immutable,<a id="i124289382-1"></a> they behave a bit like Java strings: when you call a method on a list that might seem by its name to imply the list will mutate, it instead creates and returns a new list with the new value. For example, <span class="code">List</span> has a method named `<span class="code">:::</span>'<a id="i55390901-1"></a><a id="i-1839436249-1"></a> for list concatenation. Here's how you use it:</p> <pre>  <code class="vem">val</code>&nbsp;oneTwo&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="vem">val</code>&nbsp;threeFour&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">3</code>,&nbsp;<code class="literal">4</code>)
  <code class="vem">val</code>&nbsp;oneTwoThreeFour&nbsp;=&nbsp;oneTwo&nbsp;:::&nbsp;threeFour
  println(oneTwo&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;and&nbsp;"</code>&nbsp;+&nbsp;threeFour&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;were&nbsp;not&nbsp;mutated."</code>)
  println(<code class="quotedstring">"Thus,&nbsp;"</code>&nbsp;+&nbsp;oneTwoThreeFour&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;is&nbsp;a&nbsp;new&nbsp;list."</code>)
</pre>
      <p>If you run this script, you'll see:</p> <pre>  <code class="output">List(1,&nbsp;2)&nbsp;and&nbsp;List(3,&nbsp;4)&nbsp;were&nbsp;not&nbsp;mutated.</code>
  <code class="output">Thus,&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4)&nbsp;is&nbsp;a&nbsp;new&nbsp;list.</code>
</pre>
      <p>Perhaps the most common operator you'll use with lists is `<span class="code">::</span>',<a id="i1674095775-1"></a><a id="i620923488-1"></a> which is pronounced "cons."<a id="i1411857630-1"></a> Cons prepends a new element to the beginning of an existing list and returns the resulting list. For example, if you run this script:</p> <pre>  <code class="vem">val</code>&nbsp;twoThree&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="vem">val</code>&nbsp;oneTwoThree&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;::&nbsp;twoThree
  println(oneTwoThree)
</pre>
      <p>You'll see:</p> <pre>  <code class="output">List(1,&nbsp;2,&nbsp;3)</code>
</pre>
      <div class="note">
        <h4>Note</h4> In the expression "<span class="code">1</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">twoThree</span>", <span class="code">::</span> is a method of its <span style="font-style:italic"> right</span> operand, the list, <span class="code">twoThree</span>. You might suspect there's something amiss with the associativity<a id="i-1085593547-1"></a> of the <span class="code">::</span> method, but it is actually a simple rule to remember: If a method is used in operator notation, such as <span class="code">a</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">b</span>, the method is invoked on the left operand, as in <span class="code">a.*(b)</span>—unless the method name ends in a colon. If the method name ends in a colon, the method is invoked on the <em>right</em> operand. Therefore, in <span class="code">1</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">twoThree</span>, the <span class="code">::</span> method is invoked on <span class="code">twoThree</span>, passing in <span class="code">1</span>, like this: <span class="code">twoThree.::(1)</span>. Operator associativity will be described in more detail in <a href="#sec-precedence">Section 5.9</a>.<a id="note-colonmethod"></a><a id="i192988404-1"></a><a id="i-1491182453-1"></a>
      </div>
      <p>Given that a shorthand way to specify an empty list is <span class="code">Nil</span>,<a id="i1899558990-1"></a> one way to initialize new lists is to string together elements with the cons operator, with <span class="code">Nil</span> as the last element.<a href="#footnotemain3-4">[4]</a> For example, the following script will produce the same output as the previous one, "<span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>":</p> <pre>  <code class="vem">val</code>&nbsp;oneTwoThree&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;::&nbsp;<code class="literal">2</code>&nbsp;::&nbsp;<code class="literal">3</code>&nbsp;::&nbsp;<code class="typename">Nil</code>
  println(oneTwoThree)
</pre>
      <p>Scala's <span class="code">List</span> is packed with useful methods, many of which are shown in <a href="#tab-listmethods">Table 3.1</a>. The full power of lists will be revealed in <a href="#chap-working-with-lists">Chapter 16</a><a id="i51698754-1"></a><a id="i-1815843466-1"></a>.</p>
      <div class="aside">
        <h3>Why not append to lists?</h3>
        <p>Class <span class="code">List</span> does offer an "append" operation—it's written <span class="code">:+</span> and is explained in <a href="#chap-collections-in-depth">Chapter 24</a>—but this operation is rarely used, because the time it takes to append to a list grows linearly with the size of the list, whereas prepending with <span class="code">::</span> takes constant time. If you want to build a list efficiently by appending elements, you can prepend them and when you're done call <span class="code">reverse</span>. Or you can use a <span class="code">ListBuffer</span>, a mutable list that does offer an append operation, and when you're done call <span class="code">toList</span>. <span class="code">ListBuffer</span> will be described in <a href="#sec-the-listbuffer-class">Section 22.2</a>.</p>
      </div>
      <p><a id="tab-listmethods"></a></p>
      <h5>Some <span class="code">List</span> methods and usages<a id="i-262118592-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span class="code">List()</span> or <span class="code">Nil</span> </td>
            <td> The empty <span class="code">List</span> </td>
          </tr>
          <tr>
            <td> <span class="code">List("Cool",</span>&nbsp;<span class="code">"tools",</span>&nbsp;<span class="code">"rule")</span> </td>
            <td> Creates a new <span class="code">List[String]</span> with the three values <span class="code">"Cool"</span>, <span class="code">"tools"</span>, and <span class="code">"rule"</span> </td>
          </tr>
          <tr>
            <td> <span class="code">val</span>&nbsp;<span class="code">thrill</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">"Will"</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">"fill"</span>&nbsp;<span class="code">::</span><br> <span class="code">"until"</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">Nil</span> </td>
            <td> Creates a new <span class="code">List[String]</span> with the three values <span class="code">"Will"</span>, <span class="code">"fill"</span>, and <span class="code">"until"</span> </td>
          </tr>
          <tr>
            <td> <span class="code">List("a",</span>&nbsp;<span class="code">"b")</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">List("c",</span>&nbsp;<span class="code">"d")</span> </td>
            <td> Concatenates two lists (returns a new <span class="code">List[String]</span> with values <span class="code">"a"</span>, <span class="code">"b"</span>, <span class="code">"c"</span>, and <span class="code">"d"</span>) </td>
          </tr>
          <tr>
            <td> <span class="code">thrill(2)</span> </td>
            <td> Returns the element at index 2 (zero based) of the <span class="code">thrill</span> list (returns <span class="code">"until"</span>) </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.count(s</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">s.length</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">4)</span> </td>
            <td> Counts the number of string elements in <span class="code">thrill</span> that have length 4 (returns 2)<a id="i607267229-1"></a><a id="i-1852559773-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.drop(2)</span> </td>
            <td> Returns the <span class="code">thrill</span> list without its first 2 elements (returns <span class="code">List("until")</span>)<a id="i-673511213-1"></a><a id="i1464293147-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.dropRight(2)</span> </td>
            <td> Returns the <span class="code">thrill</span> list without its rightmost 2 elements (returns <span class="code">List("Will")</span>)<a id="i915202043-1"></a><a id="i-981552191-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.exists(s</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">s</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">"until")</span> </td>
            <td> Determines whether a string element exists in <span class="code">thrill</span> that has the value <span class="code">"until"</span> (returns <span class="code">true</span>)<a id="i339085162-1"></a><a id="i-1529560696-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.filter(s</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">s.length</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">4)</span> </td>
            <td> Returns a list of all elements, in order, of the <span class="code">thrill</span> list that have length 4 (returns <span class="code">List("Will",</span>&nbsp;<span class="code">"fill")</span>)<a id="i1807572102-1"></a><a id="i-1514694492-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.forall(s</span>&nbsp;<span class="code">=&gt;</span><br> <span class="code">s.endsWith("l"))</span> </td>
            <td> Indicates whether all elements in the <span class="code">thrill</span> list end with the letter <span class="code">"l"</span> (returns <span class="code">true</span>)<a id="i260029766-1"></a><a id="i-1508992668-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.foreach(s</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">print(s))</span> </td>
            <td> Executes the <span class="code">print</span> statement on each of the strings in the <span class="code">thrill</span> list (prints <span class="code">"Willfilluntil"</span>)<a id="i331113560-1"></a><a id="i465975966-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.foreach(print)</span> </td>
            <td> Same as the previous, but more concise (also prints <span class="code">"Willfilluntil"</span>) </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.head</span> </td>
            <td> Returns the first element in the <span class="code">thrill</span> list (returns <span class="code">"Will"</span>)<a id="i-735890706-1"></a><a id="i1464399372-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.init</span> </td>
            <td> Returns a list of all but the last element in the <span class="code">thrill</span> list (returns <span class="code">List("Will",</span>&nbsp;<span class="code">"fill")</span>)<a id="i-1293540834-1"></a><a id="i1464438076-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.isEmpty</span> </td>
            <td> Indicates whether the <span class="code">thrill</span> list is empty (returns <span class="code">false</span>)<a id="i1657074897-1"></a><a id="i-1093268841-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.last</span> </td>
            <td> Returns the last element in the <span class="code">thrill</span> list (returns <span class="code">"until"</span>)<a id="i1113811620-1"></a><a id="i1464515266-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.length</span> </td>
            <td> Returns the number of elements in the <span class="code">thrill</span> list (returns 3)<a id="i1353349876-1"></a><a id="i-1346566126-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.map(s</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">s</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">"y")</span> </td>
            <td> Returns a list resulting from adding a <span class="code">"y"</span> to each string element in the <span class="code">thrill</span> list (returns <span class="code">List("Willy",</span>&nbsp;<span class="code">"filly",</span>&nbsp;<span class="code">"untily")</span>)<a id="i395196522-1"></a><a id="i1986906032-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.mkString(",</span>&nbsp;<span class="code">")</span> </td>
            <td> Makes a string with the elements of the list (returns <span class="code">"Will,</span>&nbsp;<span class="code">fill,</span>&nbsp;<span class="code">until"</span>)<a id="i1357784029-1"></a><a id="i746937723-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.filterNot(s</span>&nbsp;<span class="code">=&gt;</span><br> <span class="code">s.length</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">4)</span> </td>
            <td> Returns a list of all elements, in order, of the <span class="code">thrill</span> list <em>except those</em> that have length 4 (returns <span class="code">List("until")</span>)<a id="i1676197778-1"></a><a id="i-1174813264-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.reverse</span> </td>
            <td> Returns a list containing all elements of the <span class="code">thrill</span> list in reverse order (returns <span class="code">List("until",</span>&nbsp;<span class="code">"fill",</span>&nbsp;<span class="code">"Will")</span>)<a id="i1817641200-1"></a><a id="i-2051462346-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">thrill.sortWith((s,</span>&nbsp;<span class="code">t)</span>&nbsp;<span class="code">=&gt;</span><br> <span class="code">s.charAt(0).toLower</span>&nbsp;<span class="code">&lt;</span><br> <span class="code">t.charAt(0).toLower)</span> </td>
            <td> Returns a list containing all elements of the <span class="code">thrill</span> list in alphabetical order of the first character lowercased (returns <span class="code">List("fill",</span>&nbsp;<span class="code">"until",</span>&nbsp;<span class="code">"Will")</span>)<a id="i532902316-1"></a><a id="i1464737226-1"></a> </td>
          </tr>
          <tr class="bottomline">
            <td> <span class="code">thrill.tail</span> </td>
            <td> Returns the <span class="code">thrill</span> list minus its first element (returns <span class="code">List("fill",</span>&nbsp;<span class="code">"until")</span>)<a id="i849842526-1"></a><a id="i1464753276-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <h3><a id="step9">Step 9. Use tuples</a></h3>
      <p>Another useful container object is the <em>tuple</em>. Like lists, tuples are<a id="i-2050968957-1"></a><a id="i-1857258168-1"></a> immutable, but unlike lists, tuples can contain different types of elements. Whereas a list might be a <span class="code">List[Int]</span> or a <span class="code">List[String]</span>, a tuple could contain both an integer and a string at the same time. Tuples are very useful, for example, if you need to return multiple objects from a method. Whereas in Java<a id="i651595778-1"></a> you would often create a JavaBean-like<a id="i1133571489-1"></a> class to hold the multiple return values,<a id="i2120520132-1"></a> in Scala you can simply return a tuple. And it is simple: To instantiate a new tuple that holds some objects, just place the objects in parentheses, separated by commas. Once you have a tuple instantiated, you can access its elements individually with a dot, underscore, and the one-based index of the element. An example is shown in <a href="#lst-init-tuple">Listing 3.4</a>:</p>
      <p><a id="lst-init-tuple"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;pair&nbsp;=&nbsp;(<code class="literal">99</code>,&nbsp;<code class="quotedstring">"Luftballons"</code>)
  &nbsp;&nbsp;println(pair._1)
  &nbsp;&nbsp;println(pair._2)
</pre>
      <h5>Listing 3.4 - Creating and using a tuple.</h5>
      <p>In the first line of <a href="#lst-init-tuple">Listing 3.4</a>, you create a new tuple that contains the integer 99, as its first element, and the string, <span class="code">"Luftballons"</span>, as its second element. Scala infers the type of the tuple to be <span class="code">Tuple2[Int,</span>&nbsp;<span class="code">String]</span>, and gives that type to the variable <span class="code">pair</span> as well. In the second line, you access the <span class="code">_1</span> field, which will produce the first element, 99. The "<span class="code">.</span>" in the second line is the same dot you'd use to access a field or invoke a method. In this case you are accessing a field named <span class="code">_1</span>.<a id="i-837880330-1"></a> If you run this script, you'll see:</p> <pre>  <code class="output">99</code>
  <code class="output">Luftballons</code>
</pre>
      <p>The actual type of a tuple depends on the number of elements it contains and the types of those elements. Thus, the type of <span class="code">(99,</span>&nbsp;<span class="code">"Luftballons")</span> is <span class="code">Tuple2[Int,</span>&nbsp;<span class="code">String]</span>. The type of <span class="code">('u',</span>&nbsp;<span class="code">'r',</span>&nbsp;<span class="code">"the",</span>&nbsp;<span class="code">1,</span>&nbsp;<span class="code">4,</span>&nbsp;<span class="code">"me")</span> is <span class="code">Tuple6[Char,</span>&nbsp;<span class="code">Char,</span>&nbsp;<span class="code">String,</span>&nbsp;<span class="code">Int,</span>&nbsp;<span class="code">Int,</span>&nbsp;<span class="code">String]</span>.<a href="#footnotemain3-5">[5]</a></p>
      <div class="aside">
        <h3>Accessing the elements of a tuple</h3>
        <p>You may be wondering why you can't access the elements of a tuple like the elements of a list, for example, with "<span class="code">pair(0)</span>". The reason is that a list's <span class="code">apply</span> method always returns the same type, but each element of a tuple may be a different type: <span class="code">_1</span> can have one result type, <span class="code">_2</span> another, and so on. These <span class="code">_N</span> numbers are one-based, instead of zero-based, because starting with <span class="code">1</span> is a tradition set by other languages with statically typed tuples,<a id="i-188293365-1"></a> such as Haskell and ML.</p>
      </div>
      <h3><a id="step10">Step 10. Use sets and maps</a></h3>
      <p><a id="sec-updateops"></a></p>
      <p>Because Scala aims to help you take advantage of both functional<a id="i1434668372-1"></a><a id="i-1837133869-1"></a> and imperative styles,<a id="i148663933-1"></a><a id="i341176230-1"></a> its collections libraries make a point to differentiate between mutable and immutable collections. For example, arrays are always mutable; lists are always immutable. Scala also provides mutable and immutable alternatives for sets and maps, but uses the same simple names for both versions. For sets<a id="i-472072085-1"></a> and maps,<a id="i-1702928719-1"></a> Scala models mutability in the class hierarchy.</p>
      <p>For example, the Scala API contains a base <em>trait</em> for sets,<a id="i3526737-1"></a> where a trait is similar to a Java interface. (You'll find out more about traits in <a href="#chap-traits">Chapter 12</a>.) Scala then provides two subtraits, one for mutable sets and another for immutable sets.</p>
      <p>As you can see in <a href="#fig-set-hierarchy">Figure 3.2</a>, these three traits all share the same simple name, <span class="code">Set</span>. Their fully qualified names differ, however, because each resides in a different package. Concrete set classes in the Scala API, such as the <span class="code">HashSet</span><a id="i1649804972-1"></a> classes shown in <a href="#fig-set-hierarchy">Figure 3.2</a>, extend either the mutable or immutable <span class="code">Set</span> trait. (Although in Java you "implement" interfaces, in Scala you "extend" or "mix in" traits.<a id="i-1672969622-1"></a>) Thus, if you want to use a <span class="code">HashSet</span>, you can choose between mutable and immutable varieties depending upon your needs. The default way to create a set is shown in <a href="#lst-init-immutable-set">Listing 3.5</a>:<a id="i1277661430-1"></a><a id="i1124278062-1"></a><a id="i-1634739460-1"></a><a id="i1868251958-1"></a> <a id="lst-init-immutable-set"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;jetSet&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"Boeing"</code>,&nbsp;<code class="quotedstring">"Airbus"</code>)
  &nbsp;&nbsp;jetSet&nbsp;+=&nbsp;<code class="quotedstring">"Lear"</code>
  &nbsp;&nbsp;println(jetSet.contains(<code class="quotedstring">"Cessna"</code>))
</pre>
      <h5>Listing 3.5 - Creating, initializing, and using an immutable set.<a id="i1504035872-1"></a></h5>
      <div class="figure">
        <a id="fig-set-hierarchy"></a>
        <p><img src="sets85.png" alt="images/sets85.png"></p>
      </div>
      <h5> Figure 3.2 - Class hierarchy for Scala sets.<a id="i-1161517801-1"></a><a id="i894901459-1"></a><a id="i-702923198-1"></a></h5>
      <p>In the first line of code in <a href="#lst-init-immutable-set">Listing 3.5</a>, you define a new <span class="code">var</span> named <span class="code">jetSet</span> and initialize it with an immutable set containing the two strings, <span class="code">"Boeing"</span> and <span class="code">"Airbus"</span>. As this example shows, you can create sets in Scala similarly to how you create lists and arrays: by invoking a factory method named <span class="code">apply</span> on a <span class="code">Set</span> companion object. In <a href="#lst-init-immutable-set">Listing 3.5</a>, you invoke <span class="code">apply</span> on the companion object for <span class="code">scala.collection.immutable.Set</span>, which returns an instance of a default, immutable <span class="code">Set</span>. The Scala compiler infers <span class="code">jetSet</span>'s type to be the immutable <span class="code">Set[String]</span>.</p>
      <p>To add a new element to an immutable set, you call <span class="code">+</span> on the set<a id="i58065198-1"></a>, passing in the new element. The <span class="code">+</span> method will create and return a new immutable set with the element added. Although mutable sets offer an actual <span class="code">+=</span> method, immutable sets do not<a id="i518995282-1"></a>.</p>
      <p>In this case, the second line of code, "<span class="code">jetSet</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">"Lear"</span>", is essentially a shorthand for:</p> <pre>  jetSet&nbsp;=&nbsp;jetSet&nbsp;+&nbsp;<code class="quotedstring">"Lear"</code>
</pre>
      <p>Thus, in the second line of <a href="#lst-init-immutable-set">Listing 3.5</a>, you reassign the <span class="code">jetSet</span> <span class="code">var</span> with a new set containing <span class="code">"Boeing"</span>, <span class="code">"Airbus"</span>, and <span class="code">"Lear"</span>. Finally, the last line of <a href="#lst-init-immutable-set">Listing 3.5</a> prints out whether or not the set contains the string <span class="code">"Cessna"</span>. (As you'd expect, it prints <span class="code">false</span>.)</p>
      <p>If you want a mutable set, you'll need to use an <em>import</em>, as shown in <a href="#lst-init-mutable-set">Listing 3.6</a>:<a id="i1926037870-1"></a></p>
      <p><a id="lst-init-mutable-set"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;movieSet&nbsp;=&nbsp;<code class="typename">mutable.Set</code>(<code class="quotedstring">"Hitch"</code>,&nbsp;<code class="quotedstring">"Poltergeist"</code>)
  &nbsp;&nbsp;movieSet&nbsp;+=&nbsp;<code class="quotedstring">"Shrek"</code>
  &nbsp;&nbsp;println(movieSet)&nbsp;
</pre>
      <h5>Listing 3.6 - Creating, initializing, and using a mutable set.<a id="i1504035872-2"></a></h5>
      <p>The<a id="i-875218022-1"></a> first line of <a href="#lst-init-mutable-set">Listing 3.6</a> imports <span class="code">scala.collection.mutable</span>. An import statement allows you to use a simple name instead of the longer, fully qualified name.<a id="i-2107109778-1"></a> As a result, when you say <span class="code">mutable.Set</span> on the third line, the compiler knows you mean <span class="code">scala.collection.mutable.Set</span>. On that line, you initialize <span class="code">movieSet</span> with a new mutable set that contains the strings <span class="code">"Hitch"</span> and <span class="code">"Poltergeist"</span>. The subsequent line adds <span class="code">"Shrek"</span> to the mutable set by calling the <span class="code">+=</span> method on the set, passing in the string <span class="code">"Shrek"</span>. As mentioned previously, <span class="code">+=</span> is an actual method defined on mutable sets. Had you wanted to, instead of writing <span class="code">movieSet</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">"Shrek"</span>, you could have written <span class="code">movieSet.+=("Shrek")</span>.<a href="#footnotemain3-6">[6]</a></p>
      <p>Although the default set implementations produced by the mutable and immutable <span class="code">Set</span> factory methods shown thus far will likely be sufficient for most situations, occasionally you may want an explicit set class. Fortunately, the syntax is similar. Simply import that class you need, and use the factory method on its companion object. For example, if you need an immutable <span class="code">HashSet</span>, you could do this:</p> <pre>  <code class="vem">import</code>&nbsp;scala.collection.immutable.HashSet
  <br>  <code class="vem">val</code>&nbsp;hashSet&nbsp;=&nbsp;<code class="typename">HashSet</code>(<code class="quotedstring">"Tomatoes"</code>,&nbsp;<code class="quotedstring">"Chilies"</code>)
  println(hashSet&nbsp;+&nbsp;<code class="quotedstring">"Coriander"</code>)
</pre>
      <p>Another<a id="i3344023-1"></a> useful collection trait in Scala is <span class="code">Map</span>. As with sets, Scala provides mutable and<a id="i-2121468463-1"></a> immutable versions of <span class="code">Map</span>, using a class hierarchy. As you can see in <a href="#fig-map-hierarchy">Figure 3.3</a>, the class hierarchy for maps looks a lot like the one for sets. There's a base <span class="code">Map</span> trait in package <span class="code">scala.collection</span>, and two subtrait <span class="code">Map</span>s: a mutable <span class="code">Map</span> in <span class="code">scala.collection.mutable</span> and an immutable one in <span class="code">scala.collection.immutable</span>.</p>
      <div class="figure">
        <a id="fig-map-hierarchy"></a>
        <p><img src="maps85.png" alt="images/maps85.png"></p>
      </div>
      <h5> Figure 3.3 - Class hierarchy for Scala maps.<a id="i691333469-1"></a><a id="i-335955175-1"></a><a id="i-703105912-1"></a></h5>
      <p>Implementations of <span class="code">Map</span>, such as the <span class="code">HashMap</span>s shown in the class hierarchy in <a href="#fig-map-hierarchy">Figure 3.3</a>, extend either the mutable or immutable trait. You can create and initialize maps using factory methods similar to those used for arrays, lists, and sets.</p>
      <p><a id="lst-init-mutable-map"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;treasureMap&nbsp;=&nbsp;<code class="typename">mutable.Map[Int,&nbsp;String]</code>()
  &nbsp;&nbsp;treasureMap&nbsp;+=&nbsp;(<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Go&nbsp;to&nbsp;island."</code>)
  &nbsp;&nbsp;treasureMap&nbsp;+=&nbsp;(<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Find&nbsp;big&nbsp;X&nbsp;on&nbsp;ground."</code>)
  &nbsp;&nbsp;treasureMap&nbsp;+=&nbsp;(<code class="literal">3</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Dig."</code>)
  &nbsp;&nbsp;println(treasureMap(<code class="literal">2</code>))
</pre>
      <h5>Listing 3.7 - Creating, initializing, and using a mutable map.<a id="i1682530400-1"></a></h5>
      <p>For example, <a href="#lst-init-mutable-map">Listing 3.7</a> shows a mutable map in action. On the first line of <a href="#lst-init-mutable-map">Listing 3.7</a>, you import the mutable <span class="code">Map</span>. You then define a <span class="code">val</span> named <span class="code">treasureMap</span>, and initialize it with an empty mutable <span class="code">Map</span> that has integer keys and string values. The map is empty because you pass nothing to the factory method (the parentheses in "<span class="code">Map[Int,</span>&nbsp;<span class="code">String]()</span>" are empty).<a href="#footnotemain3-7">[7]</a> On the next three lines you add key/value pairs to the map using the <span class="code">-&gt;</span> and <span class="code">+=</span> methods.<a id="i42793141-1"></a> As illustrated previously, the Scala compiler transforms a binary operation expression like <span class="code">1</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">"Go</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">island."</span> into <span class="code">(1).-&gt;("Go</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">island.")</span>. Thus, when you say <span class="code">1</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">"Go</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">island."</span>, you are actually calling a method named <span class="code">-&gt;</span> on an integer with the value 1, passing in a string with the value <span class="code">"Go</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">island."</span> This <span class="code">-&gt;</span> method, which you can invoke on any object in a Scala program, returns a two-element tuple<a id="i-316383483-1"></a> containing the key and value.<a href="#footnotemain3-8">[8]</a> You then pass this tuple to the <span class="code">+=</span> method of the map object to which <span class="code">treasureMap</span> refers. Finally, the last line prints the value that corresponds to the key <span class="code">2</span> in the <span class="code">treasureMap</span>.</p>
      <p>If you run this code, it will print:</p> <pre>  Find&nbsp;big&nbsp;X&nbsp;on&nbsp;ground.
</pre>
      <p>If you prefer an immutable map, no import is necessary, as immutable is the default map. An example is shown in <a href="#lst-init-immutable-map">Listing 3.8</a>:<a id="i1124095348-1"></a><a id="i-1948600164-1"></a><a id="i-809004496-1"></a></p>
      <p><a id="lst-init-immutable-map"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;romanNumeral&nbsp;=&nbsp;<code class="typename">Map</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"I"</code>,&nbsp;<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"II"</code>,&nbsp;<code class="literal">3</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"III"</code>,&nbsp;<code class="literal">4</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"IV"</code>,&nbsp;<code class="literal">5</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"V"</code>
  &nbsp;&nbsp;)
  &nbsp;&nbsp;println(romanNumeral(<code class="literal">4</code>))
</pre>
      <h5>Listing 3.8 - Creating, initializing, and using an immutable map.<a id="i1503853158-1"></a><a id="i-1742365636-1"></a></h5>
      <p>Given there are no imports, when you say <span class="code">Map</span> in the first line of <a href="#lst-init-immutable-map">Listing 3.8</a>, you'll get the default: a <span class="code">scala.collection.immutable.Map</span>. You pass five key/value tuples to the map's factory method, which returns an immutable <span class="code">Map</span> containing the passed key/value pairs. If you run the code in <a href="#lst-init-immutable-map">Listing 3.8</a> it will print "<span class="code">IV</span>".</p>
      <h3><a id="step11">Step 11. Learn to recognize the functional style</a></h3>
      <p><a id="sec-importance-of-vals"></a></p>
      <p>As mentioned in <a href="#chap-a-scalable-language">Chapter 1</a>, Scala allows you to program in an imperative style,<a id="i975391822-1"></a> but encourages you to adopt a more functional style.<a id="i-1384669019-1"></a> If you are coming to Scala from an imperative background—for example, if you are a Java programmer—one of the main challenges you may face when learning Scala is figuring out how to program in the functional style. We realize this style might be unfamiliar at first, and in this book we try hard to guide you through the transition. It will require some work on your part, and we encourage you to make the effort. If you come from an imperative background, we believe that learning to program in a functional style will not only make you a better Scala programmer, it will expand your horizons and make you a better programmer in general.</p>
      <p>The first step is to recognize the difference between the two styles in code. One telltale sign is that if code contains any <span class="code">var</span>s, it is probably in an imperative style. If the code contains no <span class="code">var</span>s at all—<i>i.e.</i>, it contains <em>only</em> <span class="code">val</span>s—it is probably in a functional style. One way to move towards a functional style, therefore, is to try to program without <span class="code">var</span>s<a id="i-96078285-1"></a>.</p>
      <p>If you're coming from an imperative background, such as Java, C++, or C#, you may think of <span class="code">var</span> as a regular variable and <span class="code">val</span> as a special kind of variable.<a id="i-687482648-1"></a> On the other hand, if you're coming from a functional background, such as Haskell, OCaml, or Erlang<a id="i2012001632-2"></a><a id="i916374005-2"></a><a id="i337211374-1"></a><a id="i-140820978-1"></a><a id="i-1496851060-3"></a><a id="i-1028679267-3"></a>, you might think of <span class="code">val</span> as a regular variable and <span class="code">var</span> as akin to blasphemy. The Scala perspective, however, is that <span class="code">val</span> and <span class="code">var</span> are just two different tools in your toolbox, both useful, neither inherently evil. Scala encourages you to lean towards <span class="code">val</span>s, but ultimately reach for the best tool given the job at hand. Even if you agree with this balanced philosophy, however, you may still find it challenging at first to figure out how to get rid of <span class="code">var</span>s in your code.</p>
      <p>Consider the following <span class="code">while</span> loop example, adapted from <a href="#chap-first-steps-in-scala">Chapter 2</a>, which uses a <span class="code">var</span> and is therefore in the imperative style:<a id="i-334114095-1"></a></p> <pre>  <code class="vem">def</code>&nbsp;printArgs(args:&nbsp;<code class="typename">Array[String]</code>):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(args(i))
  &nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;}
  }
</pre>
      <p>You can transform this bit of code into a more functional style by getting rid of the <span class="code">var</span>, for example, like this:</p> <pre>  <code class="vem">def</code>&nbsp;printArgs(args:&nbsp;<code class="typename">Array[String]</code>):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(arg&nbsp;&lt;-&nbsp;args)
  &nbsp;&nbsp;&nbsp;&nbsp;println(arg)
  }
</pre>
      <p>or this:</p> <pre>  <code class="vem">def</code>&nbsp;printArgs(args:&nbsp;<code class="typename">Array[String]</code>):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;args.foreach(println)
  }
</pre>
      <p>This example illustrates one benefit of programming with fewer <span class="code">var</span>s. The refactored (more functional) code is clearer, more concise, and less error-prone than the original (more imperative) code. The reason Scala encourages a functional style is that it can help you write more understandable, less error-prone code<a id="i-1761697159-1"></a>.</p>
      <p>But you can go even further. The refactored <span class="code">printArgs</span> method is not <em>purely</em> functional because it has side effects—in this case, its side effect<a id="i18918201-3"></a> is printing to the standard output stream. The telltale sign of a function with side effects is that its result type is <span class="code">Unit</span>. If a function isn't returning any interesting value, which is what a result type of <span class="code">Unit</span> means,<a id="i-1581694980-1"></a> the only way that function can make a difference in the world is through some kind of side effect. A more functional approach would be to define a method that formats the passed <span class="code">args</span> for printing, but just returns the formatted string, as shown in <a href="#lst-format-args">Listing 3.9</a>:</p>
      <p><a id="lst-format-args"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;formatArgs(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;args.mkString(<code class="quotedstring">"\n"</code>)
</pre>
      <h5>Listing 3.9 - A function without side effects or <span class="code">var</span>s.</h5>
      <p>Now you're really functional: no side effects or <span class="code">var</span>s in sight. The <span class="code">mkString</span> method<a id="i1043598554-1"></a>, which you can call on any iterable collection (including arrays, lists, sets, and maps), returns a string consisting of the result of calling <span class="code">toString</span> on each element, separated by the passed string. Thus if <span class="code">args</span> contains three elements <span class="code">"zero"</span>, <span class="code">"one"</span>, and <span class="code">"two"</span>, <span class="code">formatArgs</span> will return <span class="code">"zero\none\ntwo"</span>. Of course, this function doesn't actually print anything out like the <span class="code">printArgs</span> methods did, but you can easily pass its result to <span class="code">println</span> to accomplish that:</p> <pre>  println(formatArgs(args))
</pre>
      <p>Every useful program is likely to have side effects of some form; otherwise, it wouldn't be able to provide value to the outside world. Preferring methods without side effects<a id="i255589052-1"></a> encourages you to design programs where side-effecting code is minimized. One benefit of this approach is that it can help make your programs easier to test<a id="i-1422446064-1"></a>.</p>
      <p>For example, to test any of the three <span class="code">printArgs</span> methods shown earlier in this section, you'd need to redefine <span class="code">println</span>, capture the output passed to it, and make sure it is what you expect. By contrast, you could test the <span class="code">formatArgs</span> function simply by checking its result<a id="i-2030836876-1"></a>:</p> <pre>  <code class="vem">val</code>&nbsp;res&nbsp;=&nbsp;formatArgs(<code class="typename">Array</code>(<code class="quotedstring">"zero"</code>,&nbsp;<code class="quotedstring">"one"</code>,&nbsp;<code class="quotedstring">"two"</code>))
  assert(res&nbsp;==&nbsp;<code class="quotedstring">"zero\none\ntwo"</code>)
</pre>
      <p>Scala's <span class="code">assert</span> method checks the passed <span class="code">Boolean</span> and if it is false, throws <span class="code">AssertionError</span>.<a id="i1445339835-1"></a><a id="i-176392533-1"></a> If the passed <span class="code">Boolean</span> is true, <span class="code">assert</span> just returns quietly. You'll learn more about assertions and tests in <a href="#chap-assertions-and-tests">Chapter 14</a>.</p>
      <p>That said, bear in mind that neither <span class="code">var</span>s nor side effects are inherently evil. Scala is not a pure functional language that forces you to program everything in the functional style. Scala is a hybrid imperative/functional language. You may find that in some situations an imperative style is a better fit for the problem at hand, and in such cases you should not hesitate to use it. To help you learn how to program without <span class="code">var</span>s, however, we'll show you many specific examples of code with <span class="code">var</span>s and how to transform those <span class="code">var</span>s to <span class="code">val</span>s in <a href="#chap-built-in-control-structures">Chapter 7</a>.</p>
      <div class="aside">
        <h3>A balanced attitude for Scala programmers</h3>
        <p>Prefer <span class="code">val</span>s, immutable objects, and methods without side effects. Reach for them first. Use <span class="code">var</span>s, mutable objects, and methods with side effects when you have a specific need and justification for them.<a id="i1618156815-1"></a></p>
      </div>
      <h3><a id="step12">Step 12. Read lines from a file</a></h3>
      <p>Scripts that perform small, everyday tasks often need to process lines in files. In this section, you'll build a script that reads lines from a file and prints them out prepended with the number of characters in each line. The first version is shown in <a href="#lst-from-file-first">Listing 3.10</a>:<a id="i539380770-1"></a><a id="i972936021-1"></a><a id="i855616002-1"></a></p>
      <p><a id="lst-from-file-first"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.io.Source
  <br>  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(args.length&nbsp;&gt;&nbsp;<code class="literal">0</code>)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;Source.fromFile(args(<code class="literal">0</code>)).getLines())
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(line.length.toString&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;line)
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;Console.err.println(<code class="quotedstring">"Please&nbsp;enter&nbsp;filename"</code>)
</pre>
      <h5>Listing 3.10 - Reading lines from a file.<a id="i-1925017016-1"></a></h5>
      <p>This script starts with an import of a class named <span class="code">Source</span> from package <span class="code">scala.io</span>.<a id="i835817156-1"></a> It then checks to see if at least one argument was specified on the command line. If so, the first argument is interpreted as a filename to open and process. The expression <span class="code">Source.fromFile(args(0))</span> attempts to open the specified file and returns a <span class="code">Source</span> object, on which you call <span class="code">getLines</span>. The <span class="code">getLines</span> method<a id="i1243928720-1"></a> returns an <span class="code">Iterator[String]</span>, which provides one line on each iteration, excluding the end-of-line character. The <span class="code">for</span> expression iterates through these lines and prints for each the length of the line, a space, and the line itself. If there were no arguments supplied on the command line, the final else clause will print a message to the standard error stream. If you place this code in a file named <span class="code">countchars1.scala</span>, and run it on itself with<a id="i517167387-1"></a>:</p> <pre>  $&nbsp;scala&nbsp;countchars1.scala&nbsp;countchars1.scala
</pre>
      <p>You should see:</p> <pre>  22&nbsp;import&nbsp;scala.io.Source
  0&nbsp;
  22&nbsp;if&nbsp;(args.length&nbsp;&gt;&nbsp;0)&nbsp;{
  0&nbsp;
  51&nbsp;&nbsp;&nbsp;for&nbsp;(line&nbsp;&lt;-&nbsp;Source.fromFile(args(0)).getLines())
  37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(line.length&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;line)
  1&nbsp;}
  4&nbsp;else
  46&nbsp;&nbsp;&nbsp;Console.err.println("Please&nbsp;enter&nbsp;filename")
</pre>
      <p>Although the script in its current form prints out the needed information, you may wish to line up the numbers, right adjusted, and add a pipe character, so that the output looks instead like:</p> <pre>  22&nbsp;|&nbsp;import&nbsp;scala.io.Source
  &nbsp;0&nbsp;|&nbsp;
  22&nbsp;|&nbsp;if&nbsp;(args.length&nbsp;&gt;&nbsp;0)&nbsp;{
  &nbsp;0&nbsp;|&nbsp;
  51&nbsp;|&nbsp;&nbsp;&nbsp;for&nbsp;(line&nbsp;&lt;-&nbsp;Source.fromFile(args(0)).getLines())
  37&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(line.length&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;line)
  &nbsp;1&nbsp;|&nbsp;}
  &nbsp;4&nbsp;|&nbsp;else
  46&nbsp;|&nbsp;&nbsp;&nbsp;Console.err.println("Please&nbsp;enter&nbsp;filename")
</pre>
      <p>To accomplish this, you can iterate through the lines twice. The first time through you'll determine the maximum width required by any line's character count. The second time through you'll print the output, using the maximum width calculated previously. Because you'll be iterating through the lines twice, you may as well assign them to a variable:</p> <pre>  <code class="vem">val</code>&nbsp;lines&nbsp;=&nbsp;Source.fromFile(args(<code class="literal">0</code>)).getLines().toList
</pre>
      <p>The final <span class="code">toList</span> is required because the <span class="code">getLines</span> method returns an iterator. Once you've iterated through an iterator, it is spent. By transforming it into a list via the <span class="code">toList</span> call, you gain the ability to iterate as many times as you wish, at the cost of storing all lines from the file in memory at once. The <span class="code">lines</span> variable, therefore, references a list of strings that contains the contents of the file specified on the command line. Next, because you'll be calculating the width of each line's character count twice, once per iteration, you might factor that expression out into a small function, which calculates the character width of the passed string's length:</p> <pre>  <code class="vem">def</code>&nbsp;widthOfLength(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;s.length.toString.length
</pre>
      <p>With this function, you could calculate the maximum width like this:</p> <pre>  <code class="vem">var</code>&nbsp;maxWidth&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;lines)
  &nbsp;&nbsp;maxWidth&nbsp;=&nbsp;maxWidth.max(widthOfLength(line))
</pre>
      <p>Here you iterate through each line with a <span class="code">for</span> expression, calculate the character width of that line's length, and, if it is larger than the current maximum, assign it to <span class="code">maxWidth</span>, a <span class="code">var</span> that was initialized to 0. (The <span class="code">max</span> method,<a id="i-256644535-1"></a> which you can invoke on any <span class="code">Int</span>, returns the greater of the value on which it was invoked and the value passed to it.) Alternatively, if you prefer to find the maximum without <span class="code">var</span>s, you could first find the longest line like this:</p> <pre>  <code class="vem">val</code>&nbsp;longestLine&nbsp;=&nbsp;lines.reduceLeft(
  &nbsp;&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;<code class="vem">if</code>&nbsp;(a.length&nbsp;&gt;&nbsp;b.length)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;b&nbsp;
  )&nbsp;
</pre>
      <p>The <span class="code">reduceLeft</span> method<a id="i2086106882-1"></a><a id="i1836203449-1"></a> applies the passed function to the first two elements in <span class="code">lines</span>, then applies it to the result of the first application and the next element in <span class="code">lines</span>, and so on, all the way through the list. On each such application, the result will be the longest line encountered so far because the passed function, <span class="code">(a,</span>&nbsp;<span class="code">b)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">if</span>&nbsp;<span class="code">(a.length</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">b.length)</span>&nbsp;<span class="code">a</span>&nbsp;<span class="code">else</span>&nbsp;<span class="code">b</span>, returns the longest of the two passed strings. "<span class="code">reduceLeft</span>" will return the result of the last application of the function, which in this case will be the longest string element contained in <span class="code">lines</span>.</p>
      <p>Given this result, you can calculate the maximum width by passing the longest line to <span class="code">widthOfLength</span>:</p> <pre>  <code class="vem">val</code>&nbsp;maxWidth&nbsp;=&nbsp;widthOfLength(longestLine)
</pre>
      <p>All that remains is to print out the lines with proper formatting. You can do that like this<a id="i-880685326-1"></a>:</p> <pre>  <code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;lines)&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;numSpaces&nbsp;=&nbsp;maxWidth&nbsp;-&nbsp;widthOfLength(line)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;padding&nbsp;=&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;*&nbsp;numSpaces
  &nbsp;&nbsp;println(padding&nbsp;+&nbsp;line.length&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;|&nbsp;"</code>&nbsp;+&nbsp;line)
  }
</pre>
      <p>In this <span class="code">for</span> expression, you once again iterate through the lines. For each line, you first calculate the number of spaces required before the line length and assign it to <span class="code">numSpaces</span>. Then you create a string containing <span class="code">numSpaces</span> spaces with the expression <span class="code">"</span>&nbsp;<span class="code">"</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">numSpaces</span>. Finally, you print out the information with the desired formatting. The entire script looks as shown in <a href="#lst-from-file-last">Listing 3.11</a>:</p>
      <p><a id="lst-from-file-last"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.io.Source
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;widthOfLength(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;s.length.toString.length
  <br>  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(args.length&nbsp;&gt;&nbsp;<code class="literal">0</code>)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;lines&nbsp;=&nbsp;Source.fromFile(args(<code class="literal">0</code>)).getLines().toList
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;longestLine&nbsp;=&nbsp;lines.reduceLeft(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;<code class="vem">if</code>&nbsp;(a.length&nbsp;&gt;&nbsp;b.length)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;b&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxWidth&nbsp;=&nbsp;widthOfLength(longestLine)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;lines)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numSpaces&nbsp;=&nbsp;maxWidth&nbsp;-&nbsp;widthOfLength(line)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;padding&nbsp;=&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;*&nbsp;numSpaces
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(padding&nbsp;+&nbsp;line.length&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;|&nbsp;"</code>&nbsp;+&nbsp;line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;Console.err.println(<code class="quotedstring">"Please&nbsp;enter&nbsp;filename"</code>)
</pre>
      <h5>Listing 3.11 - Printing formatted character counts for the lines of a file.</h5>
      <h3>Conclusion</h3>
      <p>With the knowledge you've gained in this chapter, you should be able to start using Scala for small tasks, especially scripts. In later chapters, we will dive further into these topics and introduce other topics that weren't even hinted at here.</p>
      <hr>
      <h4>Footnotes for Chapter 3:</h4>
      <p><a id="footnotemain3-1"></a>[1] This <span class="code">to</span> method actually returns not an array but a different kind of sequence, containing the values 0, 1, and 2, which the <span class="code">for</span> expression iterates over. Sequences and other collections will be described in <a href="#chap-working-with-other-collections">Chapter 17</a>.</p>
      <p><a id="footnotemain3-2"></a>[2] Variable-length argument lists, or <em>repeated parameters</em>, are described in <a href="#sec-fancy-parameters">Section 8.8</a>.</p>
      <p><a id="footnotemain3-3"></a>[3] You don't need to say <span class="code">new</span>&nbsp;<span class="code">List</span> because "<span class="code">List.apply()</span>" is defined as a factory method on the <span class="code">scala.List</span> <em>companion object</em>. You'll read more on companion objects in <a href="#sec-singleton-objects">Section 4.3</a>.</p>
      <p><a id="footnotemain3-4"></a>[4] The reason you need <span class="code">Nil</span> at the end is that <span class="code">::</span> is defined on class <span class="code">List</span>. If you try to just say <span class="code">1</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">3</span>, it won't compile because <span class="code">3</span> is an <span class="code">Int</span>, which doesn't have a <span class="code">::</span> method.</p>
      <p><a id="footnotemain3-5"></a>[5] Although conceptually you could create tuples of any length, currently the Scala library only defines them up to <span class="code">Tuple22</span>.</p>
      <p><a id="footnotemain3-6"></a>[6] Because the set in <a href="#lst-init-mutable-set">Listing 3.6</a> is mutable, there is no need to reassign <span class="code">movieSet</span>, which is why it can be a <span class="code">val</span>. By contrast, using <span class="code">+=</span> with the immutable set in <a href="#lst-init-immutable-set">Listing 3.5</a> required reassigning <span class="code">jetSet</span>, which is why it must be a <span class="code">var</span>.<a id="i877592417-1"></a></p>
      <p><a id="footnotemain3-7"></a>[7] The explicit type parameterization,<a id="i-219390285-2"></a><a id="i-24732165-2"></a> "<span class="code">[Int,</span>&nbsp;<span class="code">String]</span>", is required in <a href="#lst-init-mutable-map">Listing 3.7</a> because without any values passed to the factory method, the compiler is unable to infer the map's type parameters. By contrast, the compiler can infer the type parameters from the values passed to the map factory shown in <a href="#lst-init-immutable-map">Listing 3.8</a>, thus no explicit type parameters are needed.</p>
      <p><a id="footnotemain3-8"></a>[8] The Scala mechanism that allows you to invoke <span class="code">-&gt;</span> on any object, <em>implicit conversion</em>, will be covered in <a href="#chap-implicit-conversions-and-parameters">Chapter 21</a>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-classes-and-objects">Chapter 4</a></h2>
      <h1>Classes and Objects</h1>
      <p>You've now seen the basics of classes and objects in Scala from the previous two chapters. In this chapter, we'll take you a bit deeper. You'll learn more about classes, fields, and methods, and get an overview of semicolon inference. We'll discuss singleton objects, including how to use them to write and run a Scala application. If you are familiar with Java, you'll find that the concepts in Scala are similar, but not exactly the same. So even if you're a Java guru, it will pay to read on.</p>
      <h3 id="sec-classes-fields-methods">4.1 Classes, fields, and methods</h3>
      <p>A class is a blueprint for objects<a id="i853620774-1"></a>. Once you define a class, you can create objects from the class blueprint with the keyword <span class="code">new</span>.<a id="i313049961-1"></a><a id="i-1663070161-1"></a> For example, given the class definition:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ChecksumAccumulator</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;class&nbsp;definition&nbsp;goes&nbsp;here</code>
  }
</pre>
      <p>You can create <span class="code">ChecksumAccumulator</span> objects with:</p> <pre>  <code class="vem">new</code>&nbsp;<code class="typename">ChecksumAccumulator</code>
</pre>
      <p>Inside a class definition, you place fields and methods, which are collectively called <em>members</em>.<a id="i1842841433-1"></a><a id="i1490663010-1"></a><a id="i-1274708295-1"></a><a id="i1074702876-1"></a><a id="i955534258-1"></a> Fields, which you define with either <span class="code">val</span> or <span class="code">var</span>, are variables that refer to objects<a id="i521418335-1"></a><a id="i1295914649-1"></a>. Methods, which you define with <span class="code">def</span>, contain executable code.<a id="i1764649166-2"></a> The fields hold the state, or data, of an object, whereas the methods use that data to do the computational work of the object. When you instantiate a class, the runtime sets aside some memory to hold the image of that object's state (<i>i.e.</i>, the content of its variables). For example, if you defined a <span class="code">ChecksumAccumulator</span> class and gave it a <span class="code">var</span> field named <span class="code">sum</span>:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ChecksumAccumulator</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  }
</pre>
      <p>and you instantiated it twice with:</p> <pre>  <code class="vem">val</code>&nbsp;acc&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ChecksumAccumulator</code>
  <code class="vem">val</code>&nbsp;csa&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ChecksumAccumulator</code>
</pre>
      <p>The image of the objects in memory might look like this:</p>
      <div style="text-align: center">
        <img src="cc0dd0160.png" alt="images/cc0dd0160.png">
      </div>
      <p>Since <span class="code">sum</span>, a field declared inside class <span class="code">ChecksumAccumulator</span>, is a <span class="code">var</span>, not a <span class="code">val</span>, you can later reassign to <span class="code">sum</span> a different <span class="code">Int</span> value, like this:</p> <pre>  acc.sum&nbsp;=&nbsp;<code class="literal">3</code>
</pre>
      <p>Now the picture would look like this:</p>
      <div style="text-align: center">
        <img src="cc3dd0160.png" alt="images/cc3dd0160.png">
      </div>
      <p>One thing to notice about this picture is that there are two <span class="code">sum</span> variables, one in the object referenced by <span class="code">acc</span> and the other in the object referenced by <span class="code">csa</span>. Fields are also known as <em>instance variables</em>,<a id="i-1571995732-1"></a><a id="i-813534408-1"></a> because every instance gets its own set of the variables. Collectively, an object's instance variables make up the memory image of the object. You see this illustrated here not only in that you see two <span class="code">sum</span> variables, but also that when you changed one, the other was unaffected.</p>
      <p>Another thing to note in this example is that you were able to mutate the object <span class="code">acc</span> referred to, even though <span class="code">acc</span> is a <span class="code">val</span>. What you can't do with <span class="code">acc</span> (or <span class="code">csa</span>), given that they are <span class="code">val</span>s, not <span class="code">var</span>s, is reassign a different object to them. For example, the following attempt would fail:</p> <pre>  <code class="comment">//&nbsp;Won't&nbsp;compile,&nbsp;because&nbsp;acc&nbsp;is&nbsp;a&nbsp;val</code>
  acc&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ChecksumAccumulator</code>
</pre>
      <p>What you can count on, therefore, is that <span class="code">acc</span> will always refer to the same <span class="code">ChecksumAccumulator</span> object with which you initialize it, but the fields contained inside that object might change over time.</p>
      <p>One important way to pursue robustness of an object is to ensure that the object's state—the values of its instance variables—remains valid during its entire lifetime. The first step is to prevent outsiders from accessing the fields directly by making the fields <em>private</em>.<a id="i694224322-1"></a><a id="i1692219636-1"></a> Because private fields can only be accessed by methods defined in the same class, all the code that can update the state will be localized to the class. To declare a field private, you place a <span class="code">private</span> access modifier in front of the field, like this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ChecksumAccumulator</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  }
</pre>
      <p>Given this definition of <span class="code">ChecksumAccumulator</span>, any attempt to access <span class="code">sum</span> from the outside of the class would fail:</p> <pre>  <code class="vem">val</code>&nbsp;acc&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ChecksumAccumulator</code>
  acc.sum&nbsp;=&nbsp;<code class="literal">5</code>&nbsp;<code class="comment">//&nbsp;Won't&nbsp;compile,&nbsp;because&nbsp;sum&nbsp;is&nbsp;private</code>
</pre>
      <div class="note">
        <h4>Note</h4>
        <p>The way you make members public in Scala is by not explicitly specifying any access modifier<a id="i807441147-1"></a>. Put another way, where you'd say "public" in Java, you simply say nothing in Scala. Public is Scala's default access level.</p>
      </div>
      <p>Now that <span class="code">sum</span> is private, the only code that can access <span class="code">sum</span> is code defined inside the body of the class itself. Thus, <span class="code">ChecksumAccumulator</span> won't be of much use to anyone unless we define some methods in it:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ChecksumAccumulator</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(b:&nbsp;<code class="typename">Byte</code>):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;b
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;checksum():&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">return</code>&nbsp;<code style="font-size:large">~</code>(sum&nbsp;&amp;&nbsp;<code class="literal">0xFF</code>)&nbsp;+&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;}
  }
</pre>
      <p>The <span class="code">ChecksumAccumulator</span> now has two methods, <span class="code">add</span> and <span class="code">checksum</span>, both of which exhibit the basic form of a function definition, shown in <a href="#fig-method-form">Figure 2.1</a> <a href="#fig-method-form">here</a>.</p>
      <p>Any parameters to a method can be used inside the method. One important characteristic of method parameters in Scala is that they are <span class="code">val</span>s, not <span class="code">var</span>s.<a href="#footnotemain4-1">[1]</a><a id="i1448353285-1"></a> If you attempt to reassign a parameter inside a method in Scala, therefore, it won't compile:</p> <pre>  <code class="vem">def</code>&nbsp;add(b:&nbsp;<code class="typename">Byte</code>):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;b&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;This&nbsp;won't&nbsp;compile,&nbsp;because&nbsp;b&nbsp;is&nbsp;a&nbsp;val</code>
  &nbsp;&nbsp;sum&nbsp;+=&nbsp;b
  }
</pre>
      <p>Although <span class="code">add</span> and <span class="code">checksum</span> in this version of <span class="code">ChecksumAccumulator</span> correctly implement the desired functionality, you can express them using a more concise style. First, the <span class="code">return</span> at the end of the <span class="code">checksum</span> method is superfluous and can be dropped. In the absence of any explicit return statement, a Scala method returns the last value computed by the method.<a id="i-2127509767-1"></a><a id="i119623890-1"></a></p>
      <p>The recommended style for methods is in fact to avoid having explicit, and especially multiple, return statements. Instead, think of each method as an expression that yields one value, which is returned. This philosophy will encourage you to make methods quite small, to factor larger methods into multiple smaller ones. On the other hand, design choices depend on the design context, and Scala makes it easy to write methods that have multiple, explicit <span class="code">return</span>s if that's what you desire.</p>
      <p>Because all <span class="code">checksum</span> does is calculate a value, it does not need an explicit <span class="code">return</span>. Another shorthand for methods is that you can leave off the curly braces if a method computes only a single result expression. If the result expression is short, it can even be placed on the same line as the <span class="code">def</span> itself. For the utmost in conciseness, you can leave off the result type and Scala will infer it. With these changes, class <span class="code">ChecksumAccumulator</span> looks like this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ChecksumAccumulator</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(b:&nbsp;<code class="typename">Byte</code>)&nbsp;=&nbsp;sum&nbsp;+=&nbsp;b
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;checksum()&nbsp;=&nbsp;<code style="font-size:large">~</code>(sum&nbsp;&amp;&nbsp;<code class="literal">0xFF</code>)&nbsp;+&nbsp;<code class="literal">1</code>
  }
</pre>
      <p>Although the Scala compiler will correctly infer the result types of the <span class="code">add</span> and <span class="code">checksum</span> methods shown in the previous example, readers of the code will also need to <span class="textit">mentally infer</span> the result types by studying the bodies of the methods. As a result it is often better to explicitly provide the result types of public methods declared in a class even when the compiler would infer it for you. <a href="#lst-checksum-class">Listing 4.1</a> shows this style.</p>
      <p><a id="lst-checksum-class"></a></p> <pre>  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;ChecksumAccumulator.scala</code>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ChecksumAccumulator</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(b:&nbsp;<code class="typename">Byte</code>):&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{&nbsp;sum&nbsp;+=&nbsp;b&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;checksum():&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code style="font-size:large">~</code>(sum&nbsp;&amp;&nbsp;<code class="literal">0xFF</code>)&nbsp;+&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 4.1 - Final version of class <span class="code">ChecksumAccumulator</span>.</h5>
      <p>Methods with a result type of <span class="code">Unit</span>, such as <span class="code">ChecksumAccumulator</span>'s <span class="code">add</span> method, are executed for their side effects. A side effect is generally defined as mutating state somewhere external to the method or performing an I/O action. In <span class="code">add</span>'s case, the side effect is that <span class="code">sum</span> is reassigned. A method that is executed only for its side effects is known as a <em>procedure</em>.<a id="i-163214618-1"></a><a id="i408410112-1"></a><a id="i-1220669121-1"></a></p>
      <h3 id="sec-semicolon-inf">4.2 Semicolon inference</h3>
      <p>In a Scala program, a semicolon<a id="i1984943760-1"></a><a id="i794983274-1"></a> at the end of a statement is usually optional<a id="i-491339878-1"></a>. You can type one if you want but you don't have to if the statement appears by itself on a single line. On the other hand, a semicolon is required if you write multiple statements on a single line:</p> <pre>  <code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;<code class="quotedstring">"hello"</code>;&nbsp;println(s)
</pre>
      <p>If you want to enter a statement that spans multiple lines, most of the time you can simply enter it and Scala will separate the statements in the correct place. For example, the following is treated as one four-line statement:</p> <pre>  <code class="vem">if</code>&nbsp;(x&nbsp;&lt;&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;println(<code class="quotedstring">"too&nbsp;small"</code>)
  <code class="vem">else</code>
  &nbsp;&nbsp;println(<code class="quotedstring">"ok"</code>)
</pre>
      <p>Occasionally, however, Scala will split a statement into two parts against your wishes:</p> <pre>  x
  +&nbsp;y
</pre>
      <p>This parses as two statements <span class="code">x</span> and <span class="code">+y</span>. If you intend it to parse as one statement <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span>, you can always wrap it in parentheses:</p> <pre>  (x
  +&nbsp;y)
</pre>
      <p>Alternatively, you can put the <span class="code">+</span> at the end of a line.<a id="i-1344376109-1"></a><a id="i1115343227-1"></a> For just this reason, whenever you are chaining an infix operation such as <span class="code">+</span>, it is a common Scala style to put the operators at the end of the line instead of the beginning:</p> <pre>  x&nbsp;+
  y&nbsp;+
  z
</pre>
      <div class="aside">
        <h3>The rules of semicolon inference</h3>
        <p>The precise rules for statement separation<a id="i1984943760-2"></a> are surprisingly simple for how well they work. In short, a line ending is treated as a semicolon unless one of the following conditions is true:</p>
        <ol>
          <li>The line in question ends in a word that would not be legal as the end of a statement, such as a period or an infix operator. </li>
          <li>The next line begins with a word that cannot start a statement. </li>
          <li>The line ends while inside parentheses <span class="code">(...)</span> or brackets <span class="code">[...]</span>, because these cannot contain multiple statements anyway. </li>
        </ol>
      </div>
      <h3 id="sec-singleton-objects">4.3 Singleton objects</h3>
      <p>As mentioned in <a href="#chap-a-scalable-language">Chapter 1</a>, one way in which Scala is more object-oriented than Java is that classes in Scala cannot have static members.<a id="i-100664180-1"></a><a id="i-1455692441-1"></a> Instead, Scala has <a href="#g775061748"><em>singleton objects</em></a>.<a id="i-1742889473-1"></a><a id="i-1642091000-1"></a> A singleton object definition looks like a class definition, except instead of the keyword <span class="code">class</span> you use the keyword <span class="code">object</span>. <a href="#lst-checksum-obj">Listing 4.2</a> shows an example.</p>
      <p>The singleton object in this figure is named <span class="code">ChecksumAccumulator</span>, the same name as the class in the previous example. When a singleton object shares the same name with a class, it is called that class's <a href="#g423027411"><em>companion object</em></a>.<a id="i541826262-1"></a> You must define both the class and its companion object in the same source file. The class is called the <a href="#g-828430492"><em>companion class</em></a> of the singleton object. A class and its companion object can access each other's private members.<a id="i-1552749806-1"></a><a id="i-216316744-1"></a></p>
      <p><a id="lst-checksum-obj"></a></p> <pre>  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;ChecksumAccumulator.scala</code>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">ChecksumAccumulator</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;cache&nbsp;=&nbsp;mutable.Map.empty[<code class="typename">String</code>,&nbsp;<code class="typename">Int</code>]
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;calculate(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(cache.contains(s))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache(s)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;acc&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ChecksumAccumulator</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(c&nbsp;&lt;-&nbsp;s)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc.add(c.toByte)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;cs&nbsp;=&nbsp;acc.checksum()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache&nbsp;+=&nbsp;(s&nbsp;-&gt;&nbsp;cs)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 4.2 - Companion object for class <span class="code">ChecksumAccumulator</span>.</h5>
      <p>The <span class="code">ChecksumAccumulator</span> singleton object has one method, named <span class="code">calculate</span>, which takes a <span class="code">String</span> and calculates a checksum for the characters in the <span class="code">String</span>. It also has one private field, <span class="code">cache</span>, a mutable map in which previously calculated checksums are cached.<a href="#footnotemain4-2">[2]</a> The first line of the method, "<span class="code">if</span>&nbsp;<span class="code">(cache.contains(s))</span>", checks the cache to see if the passed string is already contained as a key in the map. If so, it just returns the mapped value, <span class="code">cache(s)</span>. Otherwise, it executes the else clause, which calculates the checksum. The first line of the else clause defines a <span class="code">val</span> named <span class="code">acc</span> and initializes it with a new <span class="code">ChecksumAccumulator</span> instance.<a href="#footnotemain4-3">[3]</a> The next line is a <span class="code">for</span> expression, which cycles through each character in the passed string, converts the character to a <span class="code">Byte</span> by invoking <span class="code">toByte</span> on it, and passes that to the <span class="code">add</span> method of the <span class="code">ChecksumAccumulator</span> instance to which <span class="code">acc</span> refers. After the <span class="code">for</span> expression completes, the next line of the method invokes <span class="code">checksum</span> on <span class="code">acc</span>, which gets the checksum for the passed <span class="code">String</span>, and stores it into a <span class="code">val</span> named <span class="code">cs</span>. In the next line, <span class="code">cache</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(s</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">cs)</span>, the passed string key is mapped to the integer checksum value, and this key-value pair is added to the cache map. The last expression of the method, <span class="code">cs</span>, ensures the checksum is the result of the method.</p>
      <p>If you are a Java programmer, one way to think of singleton objects is as the home for any static methods you might have written in Java. You can invoke methods on singleton objects using a similar syntax: the name of the singleton object, a dot, and the name of the method. For example, you can invoke the <span class="code">calculate</span> method of singleton object <span class="code">ChecksumAccumulator</span> like this:</p> <pre>  ChecksumAccumulator.calculate(<code class="quotedstring">"Every&nbsp;value&nbsp;is&nbsp;an&nbsp;object."</code>)
</pre>
      <p>A singleton object is more than a holder of static methods, however. It is a first-class object. You can think of a singleton object's name, therefore, as a "name tag" attached to the object:</p>
      <div style="text-align: center">
        <img src="csaObject160.png" alt="images/csaObject160.png">
      </div>
      <p>Defining a singleton object doesn't define a type (at the Scala level of abstraction). Given just a definition of object <span class="code">ChecksumAccumulator</span>, you can't make a variable of type <span class="code">ChecksumAccumulator</span>. Rather, the type named <span class="code">ChecksumAccumulator</span> is defined by the singleton object's companion class. However, singleton objects extend a superclass and can mix in traits. Given each singleton object is an instance of its superclasses and mixed-in traits, you can invoke its methods via these types, refer to it from variables of these types, and pass it to methods expecting these types. We'll show some examples of singleton objects inheriting from classes and traits in <a href="#chap-packages-and-imports">Chapter 13</a>.</p>
      <p>One difference between classes and singleton objects is that singleton<a id="i-614433232-1"></a> objects cannot take parameters, whereas classes can. Because you can't instantiate a singleton object with the <span class="code">new</span> keyword, you have no way to pass parameters to it. Each singleton object is implemented as<a id="i-1705632190-1"></a><a id="i1357897992-1"></a> an instance of a <a href="#g1908038877"><em>synthetic class</em></a> referenced from a static variable, so they have the same initialization semantics as Java statics.<a href="#footnotemain4-4">[4]</a> In particular, a singleton object is initialized the first time some code accesses it.</p>
      <p>A singleton object that does not share the same name with a companion class is called a <a href="#g1856979834"><em>standalone object</em></a>.<a id="i1181640299-1"></a><a id="i1731800121-1"></a> You can use standalone objects for many purposes, including collecting related utility methods together or defining an entry point to a Scala application. This use case is shown in the next section.</p>
      <h3 id="sec-a-scala-application">4.4 A Scala application</h3>
      <p>To run a Scala program, you must supply the name of a standalone singleton object with a <span class="code">main</span> method that takes one parameter, an <span class="code">Array[String]</span>, and has a result type of <span class="code">Unit</span>.<a id="i40729076-1"></a> Any standalone object with a <span class="code">main</span> method of the proper signature can be used as the entry point into an application. An example is shown in <a href="#lst-summer-app">Listing 4.3</a>:<a id="i558250415-1"></a></p>
      <p><a id="lst-summer-app"></a></p> <pre>  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;Summer.scala</code>
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;ChecksumAccumulator.calculate
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Summer</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(arg&nbsp;&lt;-&nbsp;args)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(arg&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;calculate(arg))
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 4.3 - The <span class="code">Summer</span> application.</h5>
      <p>The name of the singleton object in <a href="#lst-summer-app">Listing 4.3</a> is <span class="code">Summer</span>. Its <span class="code">main</span> method has the proper signature, so you can use it as an application. The first statement in the file is an import of the <span class="code">calculate</span> method defined in the <span class="code">ChecksumAccumulator</span> object in the previous example. This import statement allows you to use the method's simple name in the rest of the file.<a href="#footnotemain4-5">[5]</a> The body of the <span class="code">main</span> method simply prints out each argument and the checksum for the argument, separated by a colon.</p>
      <div class="note">
        <h4>Note</h4>
        <p>Scala implicitly imports members of packages <span class="code">java.lang</span> and <span class="code">scala</span>, as well as the members of a singleton object named <span class="code">Predef</span>, into every Scala source file. <span class="code">Predef</span>, which resides in package <span class="code">scala</span>, contains many useful methods. For example, when you say <span class="code">println</span> in a Scala source file, you're actually invoking <span class="code">println</span> on <span class="code">Predef</span>. (<span class="code">Predef.println</span> turns around and invokes <span class="code">Console.println</span>, which does the real work.) When you say <span class="code">assert</span>, you're invoking <span class="code">Predef.assert</span>.<a id="i-783142358-1"></a><a id="i586706545-1"></a></p>
      </div>
      <p>To run the <span class="code">Summer</span> application, place the code from <a href="#lst-summer-app">Listing 4.3</a> into a file named <span class="code">Summer.scala</span>. Because <span class="code">Summer</span> uses <span class="code">ChecksumAccumulator</span>, place the code for <span class="code">ChecksumAccumulator</span>, both the class shown in <a href="#lst-checksum-class">Listing 4.1</a> and its companion object shown in <a href="#lst-checksum-obj">Listing 4.2</a>, into a file named <span class="code">ChecksumAccumulator.scala</span>.</p>
      <p>One difference between Scala and Java is that whereas Java requires you to put a public class in a file named after the class—for example, you'd put class <span class="code">SpeedRacer</span> in file <span class="code">SpeedRacer.java</span>—in Scala, you can name <span class="code">.scala</span> files anything you want, no matter what Scala classes or code you put in them.<a id="i-1061147639-1"></a><a id="i982997419-1"></a> In general in the case of non-scripts, however, it is recommended style to name files after the classes they contain as is done in Java, so that programmers can more easily locate classes by looking at file names. This is the approach we've taken with the two files in this example, <span class="code">Summer.scala</span> and <span class="code">ChecksumAccumulator.scala</span>.</p>
      <p>Neither <span class="code">ChecksumAccumulator.scala</span> nor <span class="code">Summer.scala</span> are scripts, because they end in a definition. A script, by contrast, must end in a result expression.<a id="i1047419434-2"></a> Thus if you try to run <span class="code">Summer.scala</span> as a script, the Scala interpreter will complain that <span class="code">Summer.scala</span> does not end in a result expression (assuming of course you didn't add any expression of your own after the <span class="code">Summer</span> object definition). Instead, you'll need to actually compile these files with the Scala compiler, then run the resulting class files. One way to do this is to use <span class="code">scalac</span>, which is the basic Scala compiler, like this:<a id="i-674656853-1"></a><a id="i-2092005582-1"></a><a id="i-1405503952-1"></a></p> <pre>  $&nbsp;scalac&nbsp;ChecksumAccumulator.scala&nbsp;Summer.scala
</pre>
      <p>This compiles your source files, but there may be a perceptible delay before the compilation finishes. The reason is that every time the compiler starts up, it spends time scanning the contents of <span class="code">jar</span> files and doing other initial work before it even looks at the fresh source files you submit to it. For this reason, the Scala distribution also includes a Scala compiler <em>daemon</em> called <span class="code">fsc</span> (for fast Scala compiler).<a id="i1477728746-1"></a> You use it like this:</p> <pre>  $&nbsp;fsc&nbsp;ChecksumAccumulator.scala&nbsp;Summer.scala
</pre>
      <p>The first time you run <span class="code">fsc</span>, it will create a local server daemon attached to a port on your computer. It will then send the list of files to compile to the daemon via the port, and the daemon will compile the files. The next time you run <span class="code">fsc</span>, the daemon will already be running, so <span class="code">fsc</span> will simply send the file list to the daemon, which will immediately compile the files. Using <span class="code">fsc</span>, you only need to wait for the Java runtime to startup the first time. If you ever want to stop the <span class="code">fsc</span> daemon, you can do so with <span class="code">fsc</span>&nbsp;<span class="code">-shutdown</span>.</p>
      <p>Running either of these <span class="code">scalac</span> or <span class="code">fsc</span> commands will produce Java class files that you can then run via the <span class="code">scala</span> command, the same command you used to invoke the interpreter in previous examples.<a id="i1944711780-1"></a> However, instead of giving it a filename with a <span class="code">.scala</span> extension containing Scala code to interpret as you did in every previous example,<a href="#footnotemain4-6">[6]</a> in this case you'll give it the name of a standalone object containing a <span class="code">main</span> method of the proper signature. You can run the <span class="code">Summer</span> application, therefore, by typing:</p> <pre>  $&nbsp;scala&nbsp;Summer&nbsp;of&nbsp;love
</pre>
      <p>You will see checksums printed for the two command line arguments:</p> <pre>  <code class="output">of:&nbsp;-213</code>
  <code class="output">love:&nbsp;-182</code>
</pre>
      <h3 id="sec-app-trait">4.5 The <span class="code">App</span> trait</h3>
      <p>Scala provides a trait, <span class="code">scala.App</span>, that can save you some finger typing.<a id="i2043724591-1"></a> Although we haven't yet covered everything you'll need to understand exactly how this trait works, we figured you'd want to know about it now anyway. <a href="#lst-season-app">Listing 4.4</a> shows an example:</p>
      <p><a id="lst-season-app"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;ChecksumAccumulator.calculate
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">FallWinterSpringSummer</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">App</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(season&nbsp;&lt;-&nbsp;<code class="typename">List</code>(<code class="quotedstring">"fall"</code>,&nbsp;<code class="quotedstring">"winter"</code>,&nbsp;<code class="quotedstring">"spring"</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(season&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;calculate(season))
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 4.4 - Using the <span class="code">App</span> trait.</h5>
      <p>To use the trait, you first write "<span class="code">extends</span>&nbsp;<span class="code">App</span>" after the name of your singleton object. Then instead of writing a <span class="code">main</span> method, you place the code you would have put in the <span class="code">main</span> method directly between the curly braces of the singleton object. You can access command-line arguments via an array of strings named <span class="code">args</span>. That's it. You can compile and run this application just like any other.</p>
      <h3>4.6 Conclusion</h3>
      <p>This chapter has given you the basics of classes and objects in Scala, and shown you how to compile and run applications. In the next chapter, you'll learn about Scala's basic types and how to use them.</p>
      <hr>
      <h4>Footnotes for Chapter 4:</h4>
      <p><a id="footnotemain4-1"></a>[1] The reason parameters are <span class="code">val</span>s is that <span class="code">val</span>s are easier to reason about. You needn't look further to determine if a <span class="code">val</span> is reassigned, as you must do with a <span class="code">var</span>.</p>
      <p><a id="footnotemain4-2"></a>[2] We used a cache here to show a singleton object with a field. A cache such as this is a performance optimization that trades off memory for computation time. In general, you would likely use such a cache only if you encountered a performance problem that the cache solves, and might use a weak map, such as <span class="code">WeakHashMap</span> in <span class="code">scala.collection.mutable</span>, so that entries in the cache could be garbage collected if memory becomes scarce.</p>
      <p><a id="footnotemain4-3"></a>[3] Because the keyword <span class="code">new</span> is only used to instantiate classes, the new object created here is an instance of the <span class="code">ChecksumAccumulator</span> class, not the singleton object of the same name.</p>
      <p><a id="footnotemain4-4"></a>[4] The name of the synthetic class is the object name plus a dollar sign. Thus the synthetic class for the singleton object named <span class="code">ChecksumAccumulator</span> is <span class="code">ChecksumAccumulator$</span>.</p>
      <p><a id="footnotemain4-5"></a>[5] If you're a Java programmer, you can think of this import as similar to the static import feature introduced in Java 5. One difference in Scala, however, is that you can import members from any object, not just singleton objects.</p>
      <p><a id="footnotemain4-6"></a>[6] The actual mechanism that the scala program uses to "interpret" a Scala source file is that it compiles the Scala source code to Java bytecodes, loads them immediately via a class loader, and executes them.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-basic-types-and-operations">Chapter 5</a></h2>
      <h1>Basic Types and Operations</h1>
      <p>Now that you've seen classes and objects in action, it's a good time to look at Scala's basic types and operations in more depth. If you're familiar with Java, you'll be glad to find that Java's basic types and operators have the same meaning in Scala. However, there are some interesting differences that will make this chapter worth reading even if you're an experienced Java developer. Because some aspects of Scala covered in this chapter are essentially the same as in Java, we've inserted notes indicating what sections Java developers can safely skip.</p>
      <p>In this chapter, you'll get an overview of Scala's basic types, including <span class="code">String</span>s and the value types <span class="code">Int</span>, <span class="code">Long</span>, <span class="code">Short</span>, <span class="code">Byte</span>, <span class="code">Float</span>, <span class="code">Double</span>, <span class="code">Char</span>, and <span class="code">Boolean</span>. You'll learn the operations you can perform on these types, including how operator precedence works in Scala expressions. You'll also learn how implicit conversions can "enrich" variants of these basic types, giving you additional operations beyond those supported by Java.</p>
      <h3>5.1 Some basic types</h3>
      <p>Several fundamental types of Scala, along with the ranges of values instances of these types may have, are shown in <a href="#tab-valtypes">Table 5.1</a>. Collectively, types <span class="code">Byte</span>,<a id="i1013322880-1"></a> <span class="code">Short</span>,<a id="i1149344948-1"></a> <span class="code">Int</span>,<a id="i517506535-1"></a> <span class="code">Long</span>,<a id="i-149056780-1"></a> and <span class="code">Char</span><a id="i1377752142-1"></a> are called <em>integral types</em>.<a id="i-1495655539-1"></a> The integral types plus <span class="code">Float</span><a id="i-1609149804-1"></a> and <span class="code">Double</span><a id="i-265180023-1"></a> are called <em>numeric types</em>.<a id="i-404482804-1"></a></p>
      <p><a id="tab-valtypes"></a></p>
      <h5>Table 5.1 - Some basic types<a id="i608338568-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline ">
            <td> <span style="font-size:medium"><span style="font-weight:bold">Basic type</span></span> </td>
            <td>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">Range</span></span>
              </div> </td>
          </tr>
          <tr class="topline ">
            <td> <span class="code"><span class="typename">Byte</span></span> </td>
            <td> <span style="font-size:small">8-bit signed two's complement integer (-2<sup>7</sup> to 2<sup>7</sup> - 1, inclusive)</span> </td>
          </tr>
          <tr>
            <td> <span class="code"><span class="typename">Short</span></span> </td>
            <td> <span style="font-size:small">16-bit signed two's complement integer (-2<sup>15</sup> to 2<sup>15</sup> - 1, inclusive)</span> </td>
          </tr>
          <tr>
            <td> <span class="code"><span class="typename">Int</span></span> </td>
            <td> <span style="font-size:small">32-bit signed two's complement integer (-2<sup>31</sup> to 2<sup>31</sup> - 1, inclusive)</span> </td>
          </tr>
          <tr>
            <td> <span class="code"><span class="typename">Long</span></span> </td>
            <td> <span style="font-size:small">64-bit signed two's complement integer (-2<sup>63</sup> to 2<sup>63</sup> - 1, inclusive)</span> </td>
          </tr>
          <tr>
            <td> <span class="code"><span class="typename">Char</span></span> </td>
            <td> <span style="font-size:small">16-bit unsigned Unicode character (0 to 2<sup>16</sup> - 1, inclusive)</span> </td>
          </tr>
          <tr>
            <td> <span class="code"><span class="typename">String</span></span> </td>
            <td> <span style="font-size:small">a sequence of <span class="code">Char</span>s</span> </td>
          </tr>
          <tr>
            <td> <span class="code"><span class="typename">Float</span></span> </td>
            <td> <span style="font-size:small">32-bit IEEE 754 single-precision float</span> </td>
          </tr>
          <tr>
            <td> <span class="code"><span class="typename">Double</span></span> </td>
            <td> <span style="font-size:small">64-bit IEEE 754 double-precision float</span> </td>
          </tr>
          <tr class="bottomline">
            <td> <span class="code"><span class="typename">Boolean</span></span> </td>
            <td> <span style="font-size:small"><span class="code">true</span> or <span class="code">false</span></span> </td>
          </tr>
        </tbody>
      </table>
      <p>Other than <span class="code">String</span>, which resides in package <span class="code">java.lang</span>, all of the types shown in <a href="#tab-valtypes">Table 5.1</a> are members of package <span class="code">scala</span>.<a href="#footnotemain5-1">[1]</a> For example, the full name of <span class="code">Int</span> is <span class="code">scala.Int</span>. However, given that all the members of package <span class="code">scala</span> and <span class="code">java.lang</span> are automatically imported into every Scala source file, you can just use the simple names (<i>i.e.</i>, names like <span class="code">Boolean</span>,<a id="i1148427104-1"></a> <span class="code">Char</span>, or <span class="code">String</span><a id="i-1230806839-1"></a>) everywhere.</p>
      <p>Savvy Java developers will note that Scala's basic types have the exact same ranges as the corresponding types in Java. This enables the Scala compiler to transform instances of Scala <a href="#g1985162377"><em>value types</em></a>, such as <span class="code">Int</span> or <span class="code">Double</span>, down to Java primitive types in the bytecodes it produces.</p>
      <h3 id="sec-literals">5.2 Literals</h3>
      <p>All of the basic types listed in <a href="#tab-valtypes">Table 5.1</a> can be written with <a href="#g182460591"><em>literals</em></a>. A literal is a way to write a constant value directly in code.<a id="i1361311140-1"></a></p>
      <div class="pointofinterest">
        <h3>Fast track for Java programmers</h3>
        <p>The syntax of most literals shown in this section are exactly the same as in Java, so if you're a Java master, you can safely skip much of this section. Some differences you should read about are Scala's literals for raw strings and symbols, described starting <a href="#sec-string-literals">here</a>, and string interpolation, described starting <a href="#sec-string-interpolation">here</a>. Also, Scala does not support octal literals; integer literals that start with a 0, such as 031, do not compile.</p>
      </div>
      <h4>Integer literals</h4>
      <p>Integer literals for the types <span class="code">Int</span>, <span class="code">Long</span>, <span class="code">Short</span>, and <span class="code">Byte</span> come in two forms: decimal and hexadecimal. The way an integer literal begins indicates the base of the number. If the number begins with a <span class="code">0x</span> or <span class="code">0X</span>, it is hexadecimal (base 16), and may contain <span class="code">0</span> through <span class="code">9</span> as well as upper or lowercase digits <span class="code">A</span> through <span class="code">F</span>. Some examples are:<a id="i-168837784-1"></a><a id="i208067142-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;hex&nbsp;=&nbsp;<code class="literal">0x5</code>
  <code class="output">hex:&nbsp;Int&nbsp;=&nbsp;5</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;hex2&nbsp;=&nbsp;<code class="literal">0x00FF</code>
  <code class="output">hex2:&nbsp;Int&nbsp;=&nbsp;255</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;magic&nbsp;=&nbsp;<code class="literal">0xcafebabe</code>
  <code class="output">magic:&nbsp;Int&nbsp;=&nbsp;-889275714</code>
</pre>
      <p>Note that the Scala shell always prints integer values in base 10, no matter what literal form you may have used to initialize it. Thus the interpreter displays the value of the <span class="code">hex2</span> variable you initialized with literal <span class="code">0x00FF</span> as decimal 255. (Of course, you don't need to take our word for it. A good way to start getting a feel for the language is to try these statements out in the interpreter as you read this chapter.) If the number begins with a non-zero digit, and is otherwise undecorated, it is decimal (base 10). For example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;dec1&nbsp;=&nbsp;<code class="literal">31</code>
  <code class="output">dec1:&nbsp;Int&nbsp;=&nbsp;31</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;dec2&nbsp;=&nbsp;<code class="literal">255</code>
  <code class="output">dec2:&nbsp;Int&nbsp;=&nbsp;255</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;dec3&nbsp;=&nbsp;<code class="literal">20</code>
  <code class="output">dec3:&nbsp;Int&nbsp;=&nbsp;20</code>
</pre>
      <p>If an integer literal ends in an <span class="code">L</span> or <span class="code">l</span>, it is a <span class="code">Long</span>; otherwise it is an <span class="code">Int</span>. Some examples of <span class="code">Long</span> integer literals are:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;prog&nbsp;=&nbsp;<code class="literal">0XCAFEBABEL</code>
  <code class="output">prog:&nbsp;Long&nbsp;=&nbsp;3405691582</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;tower&nbsp;=&nbsp;<code class="literal">35L</code>
  <code class="output">tower:&nbsp;Long&nbsp;=&nbsp;35</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;of&nbsp;=&nbsp;<code class="literal">31l</code>
  <code class="output">of:&nbsp;Long&nbsp;=&nbsp;31</code>
</pre>
      <p>If an <span class="code">Int</span> literal is assigned to a variable of type <span class="code">Short</span> or <span class="code">Byte</span>, the literal is treated as if it were a <span class="code">Short</span> or <span class="code">Byte</span> type so long as the literal value is within the valid range for that type. For example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;little:&nbsp;<code class="typename">Short</code>&nbsp;=&nbsp;<code class="literal">367</code>
  <code class="output">little:&nbsp;Short&nbsp;=&nbsp;367</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;littler:&nbsp;<code class="typename">Byte</code>&nbsp;=&nbsp;<code class="literal">38</code>
  <code class="output">littler:&nbsp;Byte&nbsp;=&nbsp;38</code>
</pre>
      <h4>Floating point literals</h4>
      <p>Floating point literals are made up of decimal digits, optionally containing a decimal point, and optionally followed by an <span class="code">E</span> or <span class="code">e</span> and an exponent. Some examples of floating-point literals are:<a id="i1661236620-1"></a><a id="i2064554715-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;big&nbsp;=&nbsp;<code class="literal">1.2345</code>
  <code class="output">big:&nbsp;Double&nbsp;=&nbsp;1.2345</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bigger&nbsp;=&nbsp;<code class="literal">1.2345e1</code>
  <code class="output">bigger:&nbsp;Double&nbsp;=&nbsp;12.345</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;biggerStill&nbsp;=&nbsp;<code class="literal">123E45</code>
  <code class="output">biggerStill:&nbsp;Double&nbsp;=&nbsp;1.23E47</code>
</pre>
      <p>Note that the exponent portion means the power of 10 by which the other portion is multiplied. Thus, 1.2345e1 is 1.2345 <i>times</i> 10<sup>1</sup>, which is 12.345. If a floating-point literal ends in an <span class="code">F</span> or <span class="code">f</span>, it is a <span class="code">Float</span>; otherwise it is a <span class="code">Double</span>. Optionally, a <span class="code">Double</span> floating-point literal can end in <span class="code">D</span> or <span class="code">d</span>. Some examples of <span class="code">Float</span> literals are:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;little&nbsp;=&nbsp;<code class="literal">1.2345F</code>
  <code class="output">little:&nbsp;Float&nbsp;=&nbsp;1.2345</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;littleBigger&nbsp;=&nbsp;<code class="literal">3e5f</code>
  <code class="output">littleBigger:&nbsp;Float&nbsp;=&nbsp;300000.0</code>
</pre>
      <p>That last value expressed as a <span class="code">Double</span> could take these (and other) forms:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;anotherDouble&nbsp;=&nbsp;<code class="literal">3e5</code>
  <code class="output">anotherDouble:&nbsp;Double&nbsp;=&nbsp;300000.0</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;yetAnother&nbsp;=&nbsp;<code class="literal">3e5D</code>
  <code class="output">yetAnother:&nbsp;Double&nbsp;=&nbsp;300000.0</code>
</pre>
      <h4>Character literals</h4>
      <p>Character literals are composed of any Unicode character between single quotes, such as:<a id="i1377637053-1"></a><a id="i2027394259-1"></a><a id="i-197420869-1"></a><a id="i-2096980664-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="quotedstring">'A'</code>
  <code class="output">a:&nbsp;Char&nbsp;=&nbsp;A</code>
</pre>
      <p>In addition to providing an explicit character between the single quotes, you can identify a character using its Unicode code point. To do so, write <span class="code">\u</span> followed by four hex digits with the code point, like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;d&nbsp;=&nbsp;<code class="quotedstring">'\u0041'</code>
  <code class="output">d:&nbsp;Char&nbsp;=&nbsp;A</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;<code class="quotedstring">'\u0044'</code>
  <code class="output">f:&nbsp;Char&nbsp;=&nbsp;D</code>
</pre>
      <p>In fact, such Unicode characters can appear anywhere in a Scala program. For instance you could also write an identifier like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;B\u0041\u0044&nbsp;=&nbsp;<code class="literal">1</code>
  <code class="output">BAD:&nbsp;Int&nbsp;=&nbsp;1</code>
</pre>
      <p>This identifier is treated as identical to <span class="code">BAD</span>, the result of expanding the two Unicode characters in the code above. In general, it is a bad idea to name identifiers like this because it is hard to read. Rather, this syntax is intended to allow Scala source files that include non-ASCII Unicode characters to be represented in ASCII.</p>
      <p>Finally, there are also a few character literals represented by special escape sequences, shown in <a href="#tab-specchar">Table 5.2</a>. For example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;backslash&nbsp;=&nbsp;<code class="quotedstring">'\\'</code>
  <code class="output">backslash:&nbsp;Char&nbsp;=&nbsp;\</code>
</pre>
      <p><a id="tab-specchar"></a></p>
      <h5>Table 5.2 - Special character literal escape sequences<a id="i-1682237230-1"></a><a id="i576133849-1"></a></h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> <span style="font-size:medium"><span style="font-weight:bold">Literal</span></span> </td>
              <td> <span style="font-size:medium"><span style="font-weight:bold">Meaning</span></span> </td>
            </tr>
            <tr class="topline ">
              <td> <span class="code">\n</span> </td>
              <td> line feed (<span class="code">\u000A</span>) </td>
            </tr>
            <tr>
              <td> <span class="code">\b</span> </td>
              <td> backspace (<span class="code">\u0008</span>) </td>
            </tr>
            <tr>
              <td> <span class="code">\t</span> </td>
              <td> tab (<span class="code">\u0009</span>) </td>
            </tr>
            <tr>
              <td> <span class="code">\f</span> </td>
              <td> form feed (<span class="code">\u000C</span>) </td>
            </tr>
            <tr>
              <td> <span class="code">\r</span> </td>
              <td> carriage return (<span class="code">\u000D</span>) </td>
            </tr>
            <tr>
              <td> <span class="code">\"</span> </td>
              <td> double quote (<span class="code">\u0022</span>) </td>
            </tr>
            <tr>
              <td> <span class="code">\'</span> </td>
              <td> single quote (<span class="code">\u0027</span>) </td>
            </tr>
            <tr class="bottomline">
              <td> <span class="code">\\</span> </td>
              <td> backslash (<span class="code">\u005C</span>) </td>
            </tr>
          </tbody>
        </table>
      </div>
      <h4>String literals</h4>
      <p><a id="sec-string-literals"></a></p>
      <p>A string literal is composed of characters surrounded by double quotes:<a id="i-2068973913-1"></a><a id="i1483927337-1"></a><a id="i1349528476-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;hello&nbsp;=&nbsp;<code class="quotedstring">"hello"</code>
  <code class="output">hello:&nbsp;String&nbsp;=&nbsp;hello</code>
</pre>
      <p>The syntax of the characters within the quotes is the same as with character literals. For example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;escapes&nbsp;=&nbsp;<code class="quotedstring">"\\\"\'"</code>
  <code class="output">escapes:&nbsp;String&nbsp;=&nbsp;\"'</code>
</pre>
      <p>Because this syntax is awkward for strings that contain a lot of escape sequences or strings that span multiple lines, Scala includes a special syntax for <span style="font-style:italic">raw strings</span>.<a id="i-1493588176-1"></a><a id="i1433882250-1"></a><a id="i943241332-1"></a> You start and end a raw string with three double quotation marks in a row (<span class="code">"""</span>). The interior of a raw string may contain any characters whatsoever, including newlines, quotation marks, and special characters, except of course three quotes in a row. For example, the following program prints out a message using a raw string:<a id="i-1356616527-1"></a></p> <pre>  println(<code class="quotedstring">"""Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">Type&nbsp;"HELP"&nbsp;for&nbsp;help."""</code>)
</pre>
      <p>However, running this code does not produce quite what is desired:</p> <pre>  <code class="output">Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;"HELP"&nbsp;for&nbsp;help.</code>
</pre>
      <p>The issue is that the leading spaces before the second line are included in the string! To help with this common situation, you can call <span class="code">stripMargin</span> on strings.<a id="i1176903119-1"></a> To use this method, put a pipe character (<span class="code">|</span>) at the front of each line, and then call <span class="code">stripMargin</span> on the whole string:</p> <pre>  println(<code class="quotedstring">"""|Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">|Type&nbsp;"HELP"&nbsp;for&nbsp;help."""</code>.stripMargin)
</pre>
      <p>Now the code behaves as desired:</p> <pre>  <code class="output">Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</code>
  <code class="output">Type&nbsp;"HELP"&nbsp;for&nbsp;help.</code>
</pre>
      <h4>Symbol literals</h4>
      <p>A symbol literal is written <span class="code">'</span><em>ident</em>, where <em>ident</em> can be any alphanumeric identifier. Such literals are mapped to instances of the predefined class <span class="code">scala.Symbol</span>. Specifically, the literal <span class="code">'cymbal</span> will be expanded by the compiler to a factory method invocation: <span class="code">Symbol("cymbal")</span>. Symbol literals are typically used in situations where you would use just an identifier in a dynamically<a id="i2012339474-3"></a><a id="i716433724-3"></a> typed language.<a id="i-2064511954-1"></a><a id="i386345772-1"></a> For instance, you might want to define a method that updates a record in a database:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;updateRecordByName(r:&nbsp;<code class="typename">Symbol</code>,&nbsp;value:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;code&nbsp;goes&nbsp;here</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">updateRecordByName:&nbsp;(Symbol,Any)Unit</code>
</pre>
      <p>The method takes as parameters a symbol indicating the name of a record field and a value with which the field should be updated in the record. In a dynamically typed language, you could invoke this operation passing an undeclared field identifier to the method, but in Scala this would not compile:<a id="i138103638-1"></a></p> <pre>  scala&gt;&nbsp;updateRecordByName(favoriteAlbum,&nbsp;<code class="quotedstring">"OK&nbsp;Computer"</code>)
  <code class="output">&lt;console&gt;:6:&nbsp;error:&nbsp;not&nbsp;found:&nbsp;value&nbsp;favoriteAlbum</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateRecordByName(favoriteAlbum,&nbsp;"OK&nbsp;Computer")</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^&nbsp;&nbsp;</code>
</pre>
      <p>Instead, and almost as concisely, you can pass a symbol literal:</p> <pre>  scala&gt;&nbsp;updateRecordByName(<code class="quotedstring">'favoriteAlbum</code>,&nbsp;<code class="quotedstring">"OK&nbsp;Computer"</code>)
</pre>
      <p>There is not much you can do with a symbol, except find out its name:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;<code class="quotedstring">'aSymbol</code>
  <code class="output">s:&nbsp;Symbol&nbsp;=&nbsp;'aSymbol</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;nm&nbsp;=&nbsp;s.name
  <code class="output">nm:&nbsp;String&nbsp;=&nbsp;aSymbol</code>
</pre>
      <p>Another thing that's noteworthy is that symbols are <span style="font-style:italic">interned</span>. If you write the same symbol literal twice, both expressions will refer to the exact same <span class="code">Symbol</span> object.</p>
      <h4>Boolean literals</h4>
      <p>The <span class="code">Boolean</span> type has two literals, <span class="code">true</span> and <span class="code">false</span>:<a id="i-2062178222-1"></a><a id="i594122396-1"></a><a id="i907417652-1"></a><a id="i1304901727-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bool&nbsp;=&nbsp;<code class="vem">true</code>&nbsp;
  <code class="output">bool:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fool&nbsp;=&nbsp;<code class="vem">false</code>
  <code class="output">fool:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>That's all there is to it. You are now literally<a href="#footnotemain5-2">[2]</a> an expert in Scala.</p>
      <h3 id="sec-string-interpolation">5.3 String interpolation</h3>
      <p>Scala includes a flexible mechanism for string interpolation, which allows you to embed expressions within string literals. Its most common use case is to provide a concise and readable alternative to string concatenation. Here's an example:</p> <pre>  <code class="vem">val</code>&nbsp;name&nbsp;=&nbsp;<code class="quotedstring">"reader"</code>
  println(s<code class="quotedstring">"Hello,&nbsp;$name!"</code>)
</pre>
      <p>The expression, <span class="code">s"Hello,</span>&nbsp;<span class="code">$name!"</span> is a <span class="textit">processed</span> string literal.<a id="i479175681-1"></a><a id="i-1017781128-1"></a><a id="i-2068973913-2"></a><a id="i1349528476-2"></a><a id="i-1883760226-1"></a><a id="i544577078-1"></a> Because the letter <span class="code">s</span> immediately precedes the open quote, Scala will use the <span class="textit"><span class="code">s</span> string interpolator</span> to process the literal. The <span class="code">s</span> interpolator will<a id="i1290088777-1"></a> evaluate each embedded expression, invoke <span class="code">toString</span> on each result, and replace the embedded expressions in the literal with those results. Thus <span class="code">s"Hello,</span>&nbsp;<span class="code">$name!"</span> yields <span class="code">"Hello,</span>&nbsp;<span class="code">reader!"</span>, the same result as <span class="code">"Hello,</span>&nbsp;<span class="code">"</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">name</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">"!"</span>.</p>
      <p>You can place any expression after a dollar sign (<span class="code">$</span>) in a processed string literal. For single-variable expressions, you can often just place the variable name after the dollar sign. Scala will interpret all characters up to the first non-identifier character as the expression. If the expression includes non-identifier characters, you must place it in curly braces, with the open curly brace immediately following the dollar sign. Here's an example:</p> <pre>  scala&gt;&nbsp;s<code class="quotedstring">"The&nbsp;answer&nbsp;is&nbsp;${6&nbsp;*&nbsp;7}."</code>
  <code class="output">res0:&nbsp;String&nbsp;=&nbsp;The&nbsp;answer&nbsp;is&nbsp;42.</code>
</pre>
      <p>Scala provides two other string interpolators by default: <span class="code">raw</span><a id="i-2113209218-1"></a> and <span class="code">f</span><a id="i-1457473092-1"></a>. The <span class="code">raw</span> string interpolator behaves like <span class="code">s</span>, except it does not recognize character literal escape sequences (such as those shown in <a href="#tab-specchar">Table 5.2</a>). For example, the following statement prints four backslashes, not two:</p> <pre>  println(raw<code class="quotedstring">"No\\\\escape!"</code>)&nbsp;<code class="comment">//&nbsp;prints:&nbsp;No\\\\escape!</code>
</pre>
      <p>The <span class="code">f</span> string interpolator allows you to attach <span class="code">printf</span>-style formatting instructions to embedded expressions. You place the instructions after the expression, starting with a percent sign (<span class="texttt">%</span>), using the syntax specified by <span class="code">java.util.Formatter</span>. For example, here's how you might format pi:</p> <pre>  scala&gt;&nbsp;f<code class="quotedstring">"${math.Pi}<code class="texttt">%</code>.5f"</code>
  <code class="output">res1:&nbsp;String&nbsp;=&nbsp;3.14159</code>
</pre>
      <p>If you provide no formatting instructions for an embedded expression, the <span class="code">f</span> string interpolator will default to <span class="texttt">%</span><span class="code">s</span>, which means the <span class="code">toString</span> value will be substituted, just like the <span class="code">s</span> string interpolator. For example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;pi&nbsp;=&nbsp;<code class="quotedstring">"Pi"</code>
  <code class="output">pi:&nbsp;String&nbsp;=&nbsp;Pi</code>
  <br>  scala&gt;&nbsp;f<code class="quotedstring">"$pi&nbsp;is&nbsp;approximately&nbsp;${math.Pi}<code class="texttt">%</code>.8f."</code>
  <code class="output">res2:&nbsp;String&nbsp;=&nbsp;Pi&nbsp;is&nbsp;approximately&nbsp;3.14159265.</code>
</pre>
      <p>In Scala, string interpolation is implemented by rewriting code at compile time. The compiler will treat any expression consisting of an identifier followed immediately by the open double quote of a string literal as a string interpolator expression. The <span class="code">s</span>, <span class="code">f</span>, and <span class="code">raw</span> string interpolators are implemented via this general mechanism. Libraries and users can define other string interpolators for other purposes.</p>
      <h3 id="sec-operators">5.4 Operators are methods</h3>
      <p>Scala provides a rich set of operators for its basic types. As mentioned in previous chapters, these operators are actually just a nice syntax for ordinary method calls. For example, <span class="code">1</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span> really means the same thing as <span class="code">1.+(2)</span>.<a id="i-614149608-2"></a> In other words, class <span class="code">Int</span> contains a method named <span class="code">+</span> that takes an <span class="code">Int</span> and returns an <span class="code">Int</span> result. This <span class="code">+</span> method is invoked when you add two <span class="code">Int</span>s:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;1.+(2)</code>
  <code class="output">sum:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <p>To prove this to yourself, you can write the expression explicitly as a method invocation:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sumMore&nbsp;=&nbsp;<code class="literal">1.</code>+(<code class="literal">2</code>)&nbsp;
  <code class="output">sumMore:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <p>In fact, <span class="code">Int</span> contains several <em>overloaded</em> <span class="code">+</span> methods that take different parameter types.<a href="#footnotemain5-3">[3]</a> For example, <span class="code">Int</span> has another method, also named <span class="code">+</span>, that takes and returns a <span class="code">Long</span>. If you add a <span class="code">Long</span> to an <span class="code">Int</span>, this alternate <span class="code">+</span> method will be invoked, as in:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;longSum&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;<code class="literal">2L</code>&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;1.+(2L)</code>
  <code class="output">longSum:&nbsp;Long&nbsp;=&nbsp;3</code>
</pre>
      <p>The <span class="code">+</span> symbol is an operator—an infix operator to be specific.<a id="i145517742-1"></a><a id="i-74898194-1"></a> Operator notation is not limited to methods like <span class="code">+</span> that look like operators in other languages. You can use <em>any</em> method in operator notation.<a id="i-1126677335-1"></a> For example, class <span class="code">String</span> has a method, <span class="code">indexOf</span>, that takes one <span class="code">Char</span> parameter. The <span class="code">indexOf</span> method searches the string for the first occurrence of the specified character and returns its index or <span class="code">-1</span> if it doesn't find the character. You can use <span class="code">indexOf</span> as an operator, like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;<code class="quotedstring">"Hello,&nbsp;world!"</code>&nbsp;
  <code class="output">s:&nbsp;String&nbsp;=&nbsp;Hello,&nbsp;world!</code>
  <br>  scala&gt;&nbsp;s&nbsp;indexOf&nbsp;<code class="quotedstring">'o'</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;s.indexOf('o')</code>
  <code class="output">res0:&nbsp;Int&nbsp;=&nbsp;4</code>
</pre>
      <p>In addition, <span class="code">String</span> offers an overloaded <span class="code">indexOf</span> method that takes two parameters, the character for which to search and an index at which to start. (The other <span class="code">indexOf</span> method, shown previously, starts at index zero, the beginning of the <span class="code">String</span>.) Even though this <span class="code">indexOf</span> method takes two arguments, you can use it in operator notation. But whenever you call a method that takes multiple arguments using operator notation, you have to place those arguments in parentheses. For example, here's how you use this other <span class="code">indexOf</span> form as an operator (continuing from the previous example):</p> <pre>  scala&gt;&nbsp;s&nbsp;indexOf&nbsp;(<code class="quotedstring">'o'</code>,&nbsp;<code class="literal">5</code>)&nbsp;<code class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;s.indexOf('o',&nbsp;5)</code>
  <code class="output">res1:&nbsp;Int&nbsp;=&nbsp;8</code>
</pre>
      <div class="aside">
        <h3>Any method can be an operator</h3>
        <p>In Scala operators are not special language syntax; any method can be an operator. What makes a method an operator is how you <em>use</em> it. When you write "<span class="code">s.indexOf('o')</span>", <span class="code">indexOf</span> is not an operator. But when you write "<span class="code">s</span>&nbsp;<span class="code">indexOf</span>&nbsp;<span class="code">'o'</span>", <span class="code">indexOf</span> <em>is</em> an operator, because you're using it in operator notation.</p>
      </div>
      <p>So far, you've seen examples of <em>infix</em> operator notation, which means the method to invoke sits between the object and the parameter (or parameters) you wish to pass to the method, as in "<span class="code">7</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span>". Scala also has two other operator notations: prefix and postfix. In prefix notation, you put the method name before the object on which you are invoking the method (for example, the `<span class="code">-</span>' in <span class="code">-7</span>). In postfix notation, you put the method after the object (for example, the "<span class="code">toLong</span>" in "<span class="code">7</span>&nbsp;<span class="code">toLong</span>").</p>
      <p>In contrast to the infix operator notation—in which operators take two operands, one to the left and the other to the right—prefix and postfix operators are <em>unary</em>: they take just one operand.<a id="i-1088310403-1"></a> In prefix notation, the operand is to the right of the operator.<a id="i711311856-1"></a><a id="i-2117778892-1"></a> Some examples of prefix operators are <span class="code">-2.0</span>, <span class="code">!found</span>, and <span class="code"><span style="font-size:large">~</span>0xFF</span>. As with the infix operators, these prefix operators are a shorthand way of invoking methods. In this case, however, the name of the method has "<span class="code">unary_</span>" prepended to the operator character. For instance, Scala will transform the expression <span class="code">-2.0</span> into the method invocation "<span class="code">(2.0).unary_-</span>". You can demonstrate this to yourself by typing the method call both via operator notation and explicitly:</p> <pre>  scala&gt;&nbsp;-<code class="literal">2.0</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;(2.0).unary_-</code>
  <code class="output">res2:&nbsp;Double&nbsp;=&nbsp;-2.0</code>
  <br>  scala&gt;&nbsp;(<code class="literal">2.0</code>).unary_-
  <code class="output">res3:&nbsp;Double&nbsp;=&nbsp;-2.0</code>
</pre>
      <p>The only identifiers that can be used as prefix operators are <span class="code">+</span>, <span class="code">-</span>, <span class="code">!</span>, and <span class="code"><span style="font-size:large">~</span></span>. Thus, if you define a method named <span class="code">unary_!</span>, you could invoke that method on a value or variable of the appropriate type using prefix operator notation, such as <span class="code">!p</span>. But if you define a method named <span class="code">unary_*</span>, you wouldn't be able to use prefix operator notation because <span class="code">*</span> isn't one of the four identifiers that can be used as prefix operators. You could invoke the method normally, as in <span class="code">p.unary_*</span>, but if you attempted to invoke it via <span class="code">*p</span>, Scala will parse it as if you'd written <span class="code">*.p</span>, which is probably not what you had in mind!<a href="#footnotemain5-4">[4]</a></p>
      <p>Postfix operators are methods that take no arguments, when they are invoked without a dot or parentheses. In Scala, you can leave off empty parentheses on method calls.<a id="i-1718164274-1"></a><a id="i1976561855-1"></a> The convention is that you include parentheses if the method has side effects, such as <span class="code">println()</span>, but you can leave them off if the method has no side effects, such as <span class="code">toLowerCase</span> invoked on a <span class="code">String</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;<code class="quotedstring">"Hello,&nbsp;world!"</code>
  <code class="output">s:&nbsp;String&nbsp;=&nbsp;Hello,&nbsp;world!</code>
  <br>  scala&gt;&nbsp;s.toLowerCase&nbsp;
  <code class="output">res4:&nbsp;String&nbsp;=&nbsp;hello,&nbsp;world!</code>
</pre>
      <p>In this latter case of a method that requires no arguments, you can alternatively leave off the dot and use postfix operator notation:<a id="i797797395-1"></a><a id="i-1299180525-1"></a></p> <pre>  scala&gt;&nbsp;s&nbsp;toLowerCase
  <code class="output">res5:&nbsp;String&nbsp;=&nbsp;hello,&nbsp;world!</code>
</pre>
      <p>In this case, <span class="code">toLowerCase</span> is used as a postfix operator on the operand <span class="code">s</span>.</p>
      <p>Therefore, to see what operators you can use with Scala's basic types, all you really need to do is look at the methods declared in the type's classes in the Scala API documentation. Given that this is a Scala tutorial, however, we'll give you a quick tour of most of these methods in the next few sections.</p>
      <div class="pointofinterest">
        <h3>Fast track for Java programmers</h3>
        <p>Many aspects of Scala described in the remainder of this chapter are the same as in Java. If you're a Java guru in a rush, you can safely skip to <a href="#sec-equality">Section 5.8</a> <a href="#sec-equality">here</a>, which describes how Scala differs from Java in the area of object equality.</p>
      </div>
      <h3>5.5 Arithmetic operations</h3>
      <p>You can invoke arithmetic methods via infix operator notation for<a id="i63774984-1"></a> addition (<span class="code">+</span>),<a id="i983413923-1"></a> subtraction (<span class="code">-</span>)<a id="i716347441-1"></a>, multiplication (<span class="code">*</span>)<a id="i-1513393110-1"></a>, division (<span class="code">/</span>)<a id="i1085968089-1"></a>, and remainder (<span class="code"><span class="texttt">%</span></span>)<a id="i277713802-1"></a> on any numeric type. Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="literal">1.2</code>&nbsp;+&nbsp;<code class="literal">2.3</code>
  <code class="output">res6:&nbsp;Double&nbsp;=&nbsp;3.5</code>
  <br>  scala&gt;&nbsp;<code class="literal">3</code>&nbsp;-&nbsp;<code class="literal">1</code>
  <code class="output">res7:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;<code class="quotedstring">'b'</code>&nbsp;-&nbsp;<code class="quotedstring">'a'</code>
  <code class="output">res8:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;<code class="literal">2L</code>&nbsp;*&nbsp;<code class="literal">3L</code>&nbsp;&nbsp;
  <code class="output">res9:&nbsp;Long&nbsp;=&nbsp;6</code>
  <br>  scala&gt;&nbsp;<code class="literal">11</code>&nbsp;/&nbsp;<code class="literal">4</code>&nbsp;&nbsp;&nbsp;
  <code class="output">res10:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;<code class="literal">11</code>&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">4</code>&nbsp;&nbsp;&nbsp;
  <code class="output">res11:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br>  scala&gt;&nbsp;<code class="literal">11.0f</code>&nbsp;/&nbsp;<code class="literal">4.0f</code>
  <code class="output">res12:&nbsp;Float&nbsp;=&nbsp;2.75</code>
  <br>  scala&gt;&nbsp;<code class="literal">11.0</code>&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">4.0</code>&nbsp;&nbsp;
  <code class="output">res13:&nbsp;Double&nbsp;=&nbsp;3.0</code>
</pre>
      <p>When both the left and right operands are integral types (<span class="code">Int</span>, <span class="code">Long</span>, <span class="code">Byte</span>, <span class="code">Short</span>, or <span class="code">Char</span>), the <span class="code">/</span> operator will tell you the whole number portion of the quotient, excluding any remainder. The <span class="code"><span class="texttt">%</span></span> operator indicates the remainder of an implied integer division.</p>
      <p>The floating-point remainder you get with <span class="code"><span class="texttt">%</span></span> is not the one defined by the IEEE 754 standard. The IEEE 754 remainder uses rounding division, not truncating division, in calculating the remainder, so it is quite different from the integer remainder operation. If you really want an IEEE 754 remainder, you can call <span class="code">IEEEremainder</span> on <span class="code">scala.math</span>, as in:</p> <pre>  scala&gt;&nbsp;<code class="typename">math.IEEEremainder</code>(<code class="literal">11.0</code>,&nbsp;<code class="literal">4.0</code>)
  <code class="output">res14:&nbsp;Double&nbsp;=&nbsp;-1.0</code>
</pre>
      <p>The numeric types also offer unary prefix operators <span class="code">+</span> (method <span class="code">unary_+</span>) and <span class="code">-</span> (method <span class="code">unary_-</span>), which allow you to indicate whether a literal number is positive or negative, as in <span class="code">-3</span> or <span class="code">+4.0</span>. If you don't specify a unary <span class="code">+</span> or <span class="code">-</span>, a literal number is interpreted as positive. Unary <span class="code">+</span> exists solely for symmetry with unary <span class="code">-</span>, but has no effect. The unary <span class="code">-</span> can also be used to negate a variable. Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;neg&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;-<code class="literal">3</code>
  <code class="output">neg:&nbsp;Int&nbsp;=&nbsp;-2</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;+<code class="literal">3</code>
  <code class="output">y:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br>  scala&gt;&nbsp;-neg
  <code class="output">res15:&nbsp;Int&nbsp;=&nbsp;2</code>
</pre>
      <h3>5.6 Relational and logical operations</h3>
      <p>You can compare numeric types with relational methods greater than<a id="i-1517365894-1"></a> (<span class="code">&gt;</span>)<a id="i990790573-1"></a>, less than (<span class="code">&lt;</span>)<a id="i220203625-1"></a>, greater than or equal to (<span class="code">&gt;=</span>)<a id="i-248849346-1"></a>, and less than or equal to (<span class="code">&lt;=</span>)<a id="i529909354-1"></a>, which yield a <span class="code">Boolean</span> result. In addition, you can use the unary `<span class="code">!</span>' operator (the <span class="code">unary_!</span> method) to invert a <span class="code">Boolean</span> value.<a id="i1211007643-1"></a><a id="i1148427104-2"></a> Here are a few examples:</p> <pre>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;&gt;&nbsp;<code class="literal">2</code>&nbsp;
  <code class="output">res16:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;&lt;&nbsp;<code class="literal">2</code>&nbsp;
  <code class="output">res17:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="literal">1.0</code>&nbsp;&lt;=&nbsp;<code class="literal">1.0</code>&nbsp;&nbsp;
  <code class="output">res18:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="literal">3.5f</code>&nbsp;&gt;=&nbsp;<code class="literal">3.6f</code>&nbsp;&nbsp;
  <code class="output">res19:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;<code class="quotedstring">'a'</code>&nbsp;&gt;=&nbsp;<code class="quotedstring">'A'</code>&nbsp;
  <code class="output">res20:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;untrue&nbsp;=&nbsp;!<code class="vem">true</code>&nbsp;
  <code class="output">untrue:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>Logical methods, logical-and (<span class="code">&amp;&amp;</span> and <span class="code">&amp;</span>) and logical-or (<span class="code">||</span> and <span class="code">|</span>), take <span class="code">Boolean</span> operands in infix notation<a id="i-206208280-1"></a> and yield a <span class="code">Boolean</span> result. For example:<a id="i-991245277-1"></a><a id="i-821581301-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;toBe&nbsp;=&nbsp;<code class="vem">true</code>
  <code class="output">toBe:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;question&nbsp;=&nbsp;toBe&nbsp;||&nbsp;!toBe
  <code class="output">question:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;paradox&nbsp;=&nbsp;toBe&nbsp;&amp;&amp;&nbsp;!toBe
  <code class="output">paradox:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>The <span class="code">&amp;&amp;</span> and <span class="code">||</span> operations <em>short-circuit</em> as in Java: expressions<a id="i682407483-1"></a> built from these operators are only evaluated as far as needed to determine the result. In other words, the right-hand side of <span class="code">&amp;&amp;</span> and <span class="code">||</span> expressions won't be evaluated if the left-hand side determines the result. For example, if the left-hand side of a <span class="code">&amp;&amp;</span> expression evaluates to <span class="code">false</span>, the result of the expression will definitely be <span class="code">false</span>, so the right-hand side is not evaluated. Likewise, if the left-hand side of a <span class="code">||</span> expression evaluates to <span class="code">true</span>, the result of the expression will definitely be <span class="code">true</span>, so the right-hand side is not evaluated.</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;salt()&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"salt"</code>);&nbsp;<code class="vem">false</code>&nbsp;}
  <code class="output">salt:&nbsp;()Boolean</code>
  <br>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;pepper()&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"pepper"</code>);&nbsp;<code class="vem">true</code>&nbsp;}
  <code class="output">pepper:&nbsp;()Boolean</code>
  <br>  scala&gt;&nbsp;pepper()&nbsp;&amp;&amp;&nbsp;salt()&nbsp;
  <code class="output">pepper</code>
  <code class="output">salt</code>
  <code class="output">res21:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;salt()&nbsp;&amp;&amp;&nbsp;pepper()&nbsp;
  <code class="output">salt</code>
  <code class="output">res22:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>In the first expression, <span class="code">pepper</span> and <span class="code">salt</span> are invoked, but in the second, only <span class="code">salt</span> is invoked. Given <span class="code">salt</span> returns <span class="code">false</span>, there's no need to call <span class="code">pepper</span>.</p>
      <p>If you want to evaluate the right hand side no matter what, use <span class="code">&amp;</span> and <span class="code">|</span> instead. The <span class="code">&amp;</span> method performs a logical-and operation, and <span class="code">|</span> a logical-or, but don't short-ciruit like <span class="code">&amp;&amp;</span> and <span class="code">||</span>. Here's an example:</p> <pre>  scala&gt;&nbsp;salt()&nbsp;&amp;&nbsp;pepper()&nbsp;
  <code class="output">salt</code>
  <code class="output">pepper</code>
  <code class="output">res23:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <div class="note">
        <h4>Note</h4>
        <p>You may be wondering how short-circuiting can work given operators are just methods. Normally, all arguments are evaluated before entering a method, so how can a method avoid evaluating its second argument? The answer is that all Scala methods have a facility for delaying the evaluation of their arguments, or even declining to evaluate them at all. The facility is called <a href="#g-1173919606"><em>by-name parameters</em></a> and is discussed in <a href="#sec-by-name-parameters">Section 9.5</a>.</p>
      </div>
      <h3>5.7 Bitwise operations</h3>
      <p>Scala enables you to perform operations on individual bits of integer types with several bitwise methods.<a id="i1795120479-1"></a><a id="i824307652-1"></a><a id="i608439332-1"></a><a id="i-788169784-1"></a><a id="i-354658411-1"></a> The bitwise methods are: bitwise-and (<span class="code">&amp;</span>), bitwise-or (<span class="code">|</span>), and bitwise-xor (<span class="code">^</span>).<a href="#footnotemain5-5">[5]</a> The unary bitwise complement operator (<span class="code"><span style="font-size:large">~</span></span>, the method <span class="code">unary_<span style="font-size:large">~</span></span>) inverts each bit in its operand. For example:</p> <pre>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;&amp;&nbsp;<code class="literal">2</code>&nbsp;&nbsp;
  <code class="output">res24:&nbsp;Int&nbsp;=&nbsp;0</code>
  <br>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;|&nbsp;<code class="literal">2</code>&nbsp;&nbsp;
  <code class="output">res25:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;^&nbsp;<code class="literal">3</code>&nbsp;&nbsp;
  <code class="output">res26:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;<code style="font-size:large">~</code><code class="literal">1</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res27:&nbsp;Int&nbsp;=&nbsp;-2</code>
</pre>
      <p>The first expression, <span class="code">1</span>&nbsp;<span class="code">&amp;</span>&nbsp;<span class="code">2</span>, bitwise-ands each bit in 1 (0001) and 2 (0010), which yields 0 (0000). The second expression, <span class="code">1</span>&nbsp;<span class="code">|</span>&nbsp;<span class="code">2</span>, bitwise-ors each bit in the same operands, yielding 3 (0011). The third expression, <span class="code">1</span>&nbsp;<span class="code">^</span>&nbsp;<span class="code">3</span>, bitwise-xors each bit in 1 (0001) and 3 (0011), yielding 2 (0010). The final expression, <span class="code"><span style="font-size:large">~</span>1</span>, inverts each bit in 1 (0001), yielding -2, which in binary looks like 11111111111111111111111111111110.</p>
      <p>Scala integer types also offer three shift methods: shift left (<span class="code">&lt;&lt;</span>), shift right (<span class="code">&gt;&gt;</span>), and<a id="i1503282158-1"></a><a id="i683040431-1"></a><a id="i1817662978-1"></a><a id="i-1799112486-1"></a> unsigned shift right (<span class="code">&gt;&gt;&gt;</span>). The shift methods, when used in infix operator notation, shift the integer value on the left of the operator by the amount specified by the integer value on the right. Shift left and unsigned shift right fill with zeroes as they shift. Shift right fills with the highest bit (the sign bit) of the left-hand value as it shifts. Here are some examples:<a id="i1037331510-1"></a></p> <pre>  scala&gt;&nbsp;-<code class="literal">1</code>&nbsp;&gt;&gt;&nbsp;<code class="literal">31</code>&nbsp;
  <code class="output">res28:&nbsp;Int&nbsp;=&nbsp;-1</code>
  <br>  scala&gt;&nbsp;-<code class="literal">1</code>&nbsp;&gt;&gt;&gt;&nbsp;<code class="literal">31</code>
  <code class="output">res29:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;&lt;&lt;&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;
  <code class="output">res30:&nbsp;Int&nbsp;=&nbsp;4</code>
</pre>
      <p>-1 in binary is 11111111111111111111111111111111. In the first example, <span class="code">-1</span>&nbsp;<span class="code">&gt;&gt;</span>&nbsp;<span class="code">31</span>, -1 is shifted to the right 31 bit positions. Since an <span class="code">Int</span> consists of 32 bits, this operation effectively moves the leftmost bit over until it becomes the rightmost bit.<a href="#footnotemain5-6">[6]</a> Since the <span class="code">&gt;&gt;</span> method fills with ones as it shifts right, because the leftmost bit of -1 is 1, the result is identical to the original left operand, 32 one bits, or -1. In the second example, <span class="code">-1</span>&nbsp;<span class="code">&gt;&gt;&gt;</span>&nbsp;<span class="code">31</span>, the leftmost bit is again shifted right until it is in the rightmost position, but this time filling with zeroes along the way. Thus the result this time is binary 00000000000000000000000000000001, or 1. In the final example, <span class="code">1</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">2</span>, the left operand, 1, is shifted left two positions (filling in with zeroes), resulting in binary 00000000000000000000000000000100, or 4.</p>
      <h3 id="sec-equality">5.8 Object equality</h3>
      <p>If you want to compare two objects for equality, you can use either <span class="code">==</span> or its inverse <span class="code">!=</span>.<a id="i46092869-1"></a><a id="i307189229-1"></a> Here are a few simple examples:<a id="i-1583721442-1"></a><a id="i1095465388-1"></a><a id="i15383763-1"></a><a id="i-1108611945-1"></a></p> <pre>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;==&nbsp;<code class="literal">2</code>&nbsp;
  <code class="output">res31:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;!=&nbsp;<code class="literal">2</code>&nbsp;
  <code class="output">res32:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">2</code>&nbsp;
  <code class="output">res33:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>These operations actually apply to all objects, not just basic types. For example, you can use <span class="code">==</span> to compare lists:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;==&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res34:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;==&nbsp;<code class="typename">List</code>(<code class="literal">4</code>,&nbsp;<code class="literal">5</code>,&nbsp;<code class="literal">6</code>)
  <code class="output">res35:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>Going further, you can compare two objects that have different types:</p> <pre>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;==&nbsp;<code class="literal">1.0</code>
  <code class="output">res36:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;==&nbsp;<code class="quotedstring">"hello"</code>
  <code class="output">res37:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>You can even compare against <span class="code">null</span>, or against things that might be <span class="code">null</span>. No exception will be thrown:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;==&nbsp;<code class="vem">null</code>
  <code class="output">res38:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;<code class="vem">null</code>&nbsp;==&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res39:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>As you see, <span class="code">==</span> has been carefully crafted so that you get just the equality comparison you want in most cases. This is accomplished with a very simple rule: First check the left side for <span class="code">null</span>. If it is not <span class="code">null</span>, call the <span class="code">equals</span> method.<a id="i-342464093-1"></a> Since <span class="code">equals</span> is a method, the precise comparison you get depends on the type of the left-hand argument. Since there is an automatic null check, you do not have to do the check yourself.<a href="#footnotemain5-7">[7]</a></p>
      <p>This kind of comparison will yield <span class="code">true</span> on different objects, so long as their contents are the same and their <span class="code">equals</span> method is written to be based on contents. For example, here is a comparison between two strings that happen to have the same five letters in them:<a id="i307189229-2"></a></p> <pre>  scala&gt;&nbsp;(<code class="quotedstring">"he"</code>&nbsp;+&nbsp;<code class="quotedstring">"llo"</code>)&nbsp;==&nbsp;<code class="quotedstring">"hello"</code>
  <code class="output">res40:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <div class="aside">
        <h3>How Scala's <span class="code">==</span> differs from Java's</h3>
        <p>In Java, you can use <span class="code">==</span> to compare both primitive<a id="i-383144457-1"></a><a id="i1422354335-1"></a> and reference types. On primitive types, Java's <span class="code">==</span> compares value equality,<a id="i1877185224-1"></a> as in Scala. On reference types, however, Java's <span class="code">==</span> compares <a href="#g1293228591"><em>reference equality</em></a>, which means the two variables point to the same object on the JVM's heap. Scala provides a facility for comparing reference equality, as well, under the name <span class="code">eq</span>. However, <span class="code">eq</span> and its opposite, <span class="code">ne</span>, only apply to objects that directly map to Java objects. The full details about <span class="code">eq</span> and <span class="code">ne</span> are given in <a href="#sec-scalas-class-hierarchy">Sections 11.1</a> and<a href="#sec-impl-primitives"> 11.2</a>. Also, see <a href="#chap-object-equality">Chapter 30</a> on how to write a good <span class="code">equals</span> method.<a id="i-795280463-1"></a><a id="i2030434891-1"></a><a id="i-1620977796-1"></a><a id="i1319501024-1"></a><a id="i1544052809-1"></a></p>
      </div>
      <h3 id="sec-precedence">5.9 Operator precedence and associativity</h3>
      <p>Operator precedence determines which parts of an expression are evaluated before the other parts. For example, the expression<a id="i1955596960-1"></a><a id="i2084616098-1"></a> <span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">7</span> evaluates to 16, not 28, because the * operator has a higher precedence than the + operator. Thus the multiplication part of the expression is evaluated before the addition part. You can of course use parentheses in expressions to clarify evaluation order or to override precedence. For example, if you really wanted the result of the expression above to be 28, you could write the expression like this:</p> <pre>  (<code class="literal">2</code>&nbsp;+&nbsp;<code class="literal">2</code>)&nbsp;*&nbsp;<code class="literal">7</code>
</pre>
      <p>Given that Scala doesn't have operators, per se, just a way to use methods in operator notation, you may be wondering how operator precedence works. Scala decides precedence based on the first character of the methods used in operator notation (there's one exception to this rule, which will be discussed in the following pages). If the method name starts with a <span class="code">*</span>, for example, it will have a higher precedence than a method that starts with a <span class="code">+</span>. Thus <span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">7</span> will be evaluated as <span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">7)</span>. Similarly, <span class="code">a</span>&nbsp;<span class="code">+++</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">***</span>&nbsp;<span class="code">c</span> (in which <span class="code">a</span>, <span class="code">b</span>, and <span class="code">c</span> are variables, and <span class="code">+++</span> and <span class="code">***</span> are methods) will be evaluated <span class="code">a</span>&nbsp;<span class="code">+++</span>&nbsp;<span class="code">(b</span>&nbsp;<span class="code">***</span>&nbsp;<span class="code">c)</span>, because the <span class="code">***</span> method has a higher precedence than the <span class="code">+++</span> method.</p>
      <p><a id="tab-opprec"></a></p>
      <h5>Table 5.3 - Operator precedence<a id="i-1002965951-1"></a><a id="i-1679614205-1"></a></h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> (all other special characters) </td>
            </tr>
            <tr>
              <td> <span class="code">*</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code"><span class="texttt">%</span></span> </td>
            </tr>
            <tr>
              <td> <span class="code">+</span>&nbsp;<span class="code">-</span> </td>
            </tr>
            <tr>
              <td> <span class="code">:</span> </td>
            </tr>
            <tr>
              <td> <span class="code">=</span>&nbsp;<span class="code">!</span> </td>
            </tr>
            <tr>
              <td> <span class="code">&lt;</span>&nbsp;<span class="code">&gt;</span> </td>
            </tr>
            <tr>
              <td> <span class="code">&amp;</span> </td>
            </tr>
            <tr>
              <td> <span class="code">^</span> </td>
            </tr>
            <tr>
              <td> <span class="code">|</span> </td>
            </tr>
            <tr>
              <td> (all letters) </td>
            </tr>
            <tr class="bottomline">
              <td> (all assignment operators) </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p><a href="#tab-opprec">Table 5.3</a> shows the precedence given to the first character of a method in decreasing order of precedence, with characters on the same line having the same precedence. The higher a character is in this table, the higher the precedence of methods that start with that character. Here's an example that illustrates the influence of precedence:</p> <pre>  scala&gt;&nbsp;<code class="literal">2</code>&nbsp;&lt;&lt;&nbsp;<code class="literal">2</code>&nbsp;+&nbsp;<code class="literal">2</code>
  <code class="output">res41:&nbsp;Int&nbsp;=&nbsp;32</code>
</pre>
      <p>The <span class="code">&lt;&lt;</span> method starts with the character <span class="code">&lt;</span>, which appears lower in <a href="#tab-opprec">Table 5.3</a> than the character <span class="code">+</span>, which is the first and only character of the <span class="code">+</span> method. Thus <span class="code">&lt;&lt;</span> will have lower precedence than <span class="code">+</span>, and the expression will be evaluated by first invoking the <span class="code">+</span> method, then the <span class="code">&lt;&lt;</span> method, as in <span class="code">2</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">(2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2)</span>. <span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span> is <span class="code">4</span>, by our math, and <span class="code">2</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">4</span> yields <span class="code">32</span>. If you swap the operators, you'll get a different result:</p> <pre>  scala&gt;&nbsp;<code class="literal">2</code>&nbsp;+&nbsp;<code class="literal">2</code>&nbsp;&lt;&lt;&nbsp;<code class="literal">2</code>
  <code class="output">res42:&nbsp;Int&nbsp;=&nbsp;16</code>
</pre>
      <p>Since the first characters are the same as in the previous example, the methods will be invoked in the same order. First the <span class="code">+</span> method will be invoked, then the <span class="code">&lt;&lt;</span> method. So <span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span> will again yield <span class="code">4</span>, and <span class="code">4</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">2</span> is 16.</p>
      <p>The one exception to the precedence rule, alluded to earlier, concerns <span style="font-style:italic">assignment operators</span>, which end in an equals character. If an operator ends in an equals character <span class="code">(=)</span>, and the operator is not one of the comparison operators <span class="code">&lt;=</span>, <span class="code">&gt;=</span>, <span class="code">==</span>, or <span class="code">!=</span>, then the precedence of the operator is the same as that of simple assignment <span class="code">(=)</span>. That is, it is lower than the precedence of any other operator. For instance:</p> <pre>  x&nbsp;*=&nbsp;y&nbsp;+&nbsp;<code class="literal">1</code>
</pre>
      <p>means the same as:</p> <pre>  x&nbsp;*=&nbsp;(y&nbsp;+&nbsp;<code class="literal">1</code>)
</pre>
      <p>because <span class="code">*=</span> is classified as an assignment operator whose precedence is lower than <span class="code">+</span>, even though the operator's first character is <span class="code">*</span>, which would suggest a precedence higher than <span class="code">+</span>.</p>
      <p>When multiple operators of the same precedence appear side by side in an expression, the <em>associativity</em> of the operators<a id="i1109054020-1"></a><a id="i1812392602-1"></a> determines the way operators are grouped. The associativity of an operator in Scala is determined by its <em>last</em> character. As mentioned <a href="#note-colonmethod">here</a> of <a href="#chap-next-steps-in-scala">Chapter 3</a>, any method that ends in a `<span class="code">:</span>' character is invoked on its right operand, passing in the left operand. Methods that end in any other character are the other way around: They are invoked on their left operand, passing in the right operand. So <span class="code">a</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">b</span> yields <span class="code">a.*(b)</span>, but <span class="code">a</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">b</span> yields <span class="code">b.:::(a)</span>.<a id="i-1085593547-2"></a></p>
      <p>No matter what associativity an operator has, however, its operands are always evaluated left to right. So if <span class="code">a</span> is an expression that is not just a simple reference to an immutable value, then <span class="code">a</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">b</span> is more precisely treated as the following block:</p> <pre>  {&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;a;&nbsp;b.:::(x)&nbsp;}
</pre>
      <p>In this block <span class="code">a</span> is still evaluated before <span class="code">b</span>, and then the result of this evaluation is passed as an operand to <span class="code">b</span>'s <span class="code">:::</span> method.</p>
      <p>This associativity rule also plays a role when multiple operators of the same precedence appear side by side. If the methods end in `<span class="code">:</span>', they are grouped right to left; otherwise, they are grouped left to right. For example, <span class="code">a</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">c</span> is treated as <span class="code">a</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">(b</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">c)</span>. But <span class="code">a</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">c</span>, by contrast, is treated as <span class="code">(a</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">b)</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">c</span>.</p>
      <p>Operator precedence is part of the Scala language. You needn't be afraid to use it. Nevertheless, it is good style to use parentheses to clarify what operators are operating upon what expressions. Perhaps the only precedence you can truly count on other programmers knowing without looking up is that multiplicative operators, <span class="code">*</span>, <span class="code">/</span>, and <span class="code"><span class="texttt">%</span></span>, have a higher precedence than the additive ones <span class="code">+</span> and <span class="code">-</span>. Thus even if <span class="code">a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">c</span> yields the result you want without parentheses, the extra clarity you get by writing <span class="code">(a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b)</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">c</span> may reduce the frequency with which your peers utter your name in operator notation, for example, by shouting in disgust, "<span class="code">bills</span> <span class="code">!*&amp;^<span class="texttt">%</span><span style="font-size:large">~</span></span> <span class="code">code!</span>".<a href="#footnotemain5-8">[8]</a></p>
      <h3 id="sec-rich-wrappers">5.10 Rich wrappers</h3>
      <p>You can invoke many more methods on Scala's basic types than were described in the previous sections. A few examples are shown in <a href="#tab-richops">Table 5.4</a>. These methods are available via <em>implicit conversions</em>, a technique that will be described in detail in <a href="#chap-implicit-conversions-and-parameters">Chapter 21</a>.<a id="i-108634082-1"></a><a id="i681737575-1"></a><a id="i807731316-1"></a> All you need to know for now is that for each basic type described in this chapter, there is also a "rich wrapper" that provides several additional methods. To see all the available methods on the basic types, therefore, you should look at the API documentation on the rich wrapper for each basic type. Those classes are listed in <a href="#tab-richclasses">Table 5.5</a>.</p>
      <p><a id="tab-richops"></a></p>
      <h5>Table 5.4 - Some rich operations<a id="i-256644535-2"></a><a id="i-2103371977-1"></a><a id="i574171488-2"></a><a id="i-995240575-1"></a><a id="i1813550033-1"></a></h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> <span style="font-size:medium"><span style="font-weight:bold">Code</span></span> </td>
              <td> <span style="font-size:medium"><span style="font-weight:bold">Result</span></span> </td>
            </tr>
            <tr class="topline ">
              <td> <span class="code"><span class="literal">0</span></span>&nbsp;<span class="code">max</span>&nbsp;<span class="code"><span class="literal">5</span></span> </td>
              <td> <span class="code">5</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="literal">0</span></span>&nbsp;<span class="code">min</span>&nbsp;<span class="code"><span class="literal">5</span></span> </td>
              <td> <span class="code">0</span> </td>
            </tr>
            <tr>
              <td> <span class="code">-<span class="literal">2.7</span></span>&nbsp;<span class="code">abs</span> </td>
              <td> <span class="code">2.7</span> </td>
            </tr>
            <tr>
              <td> <span class="code">-<span class="literal">2.7</span></span>&nbsp;<span class="code">round</span> </td>
              <td> <span class="code">-3L</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="literal">1.5</span></span>&nbsp;<span class="code">isInfinity</span> </td>
              <td> <span class="code">false</span> </td>
            </tr>
            <tr>
              <td> <span class="code">(<span class="literal">1.0</span></span>&nbsp;<span class="code">/</span>&nbsp;<span class="code"><span class="literal">0</span>)</span>&nbsp;<span class="code">isInfinity</span> </td>
              <td> <span class="code">true</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="literal">4</span></span>&nbsp;<span class="code">to</span>&nbsp;<span class="code"><span class="literal">6</span></span> </td>
              <td> <span class="code">Range(4,</span>&nbsp;<span class="code">5,</span>&nbsp;<span class="code">6)</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="quotedstring">"bob"</span></span>&nbsp;<span class="code">capitalize</span> </td>
              <td> <span class="code">"Bob"</span> </td>
            </tr>
            <tr class="bottomline">
              <td> <span class="code"><span class="quotedstring">"robert"</span></span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code"><span class="literal">2</span></span> </td>
              <td> <span class="code">"bert"</span> </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p><a id="tab-richclasses"></a></p>
      <h5>Table 5.5 - Rich wrapper classes</h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> <span style="font-size:medium"><span style="font-weight:bold">Basic type</span></span> </td>
              <td> <span style="font-size:medium"><span style="font-weight:bold">Rich wrapper</span></span> </td>
            </tr>
            <tr class="topline ">
              <td> <span class="code"><span class="typename">Byte</span></span> </td>
              <td> <span class="code">scala.runtime.RichByte</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="typename">Short</span></span> </td>
              <td> <span class="code">scala.runtime.RichShort</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="typename">Int</span></span> </td>
              <td> <span class="code">scala.runtime.RichInt</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="typename">Long</span></span> </td>
              <td> <span class="code">scala.runtime.RichLong</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="typename">Char</span></span> </td>
              <td> <span class="code">scala.runtime.RichChar</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="typename">Float</span></span> </td>
              <td> <span class="code">scala.runtime.RichFloat</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="typename">Double</span></span> </td>
              <td> <span class="code">scala.runtime.RichDouble</span> </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="typename">Boolean</span></span> </td>
              <td> <span class="code">scala.runtime.RichBoolean</span> </td>
            </tr>
            <tr class="bottomline">
              <td> <span class="code"><span class="typename">String</span></span> </td>
              <td> <span class="code">scala.collection.immutable.StringOps</span> </td>
            </tr>
          </tbody>
        </table>
      </div>
      <h3>5.11 Conclusion</h3>
      <p>The main take-aways from this chapter are that operators in Scala are method calls, and that implicit conversions to rich variants exist for Scala's basic types that add even more useful methods. In the next chapter, we'll show you what it means to design objects in a functional style that gives new implementations of some of the operators that you have seen in this chapter.</p>
      <hr>
      <h4>Footnotes for Chapter 5:</h4>
      <p><a id="footnotemain5-1"></a>[1] Packages, which were briefly described in <a href="#step1">Step 1</a> in <a href="#chap-first-steps-in-scala">Chapter 2</a>, will be covered in depth in <a href="#chap-packages-and-imports">Chapter 13</a>.</p>
      <p><a id="footnotemain5-2"></a>[2] figuratively speaking</p>
      <p><a id="footnotemain5-3"></a>[3] <em>Overloaded</em> methods have the same name but different argument types. More on method overloading in <a href="#sec-method-overloading">Section 6.11</a>.</p>
      <p><a id="footnotemain5-4"></a>[4] All is not necessarily lost, however. There is an extremely slight chance your program with the <span class="code">*p</span> might compile as C++.</p>
      <p><a id="footnotemain5-5"></a>[5] The bitwise-xor method performs an <em>exclusive or</em> on its operands. Identical bits yield a 0. Different bits yield a 1. Thus <span class="code">0011</span>&nbsp;<span class="code">^</span>&nbsp;<span class="code">0101</span> yields <span class="code">0110</span>.</p>
      <p><a id="footnotemain5-6"></a>[6] The leftmost bit in an integer type is the sign bit. If the leftmost bit is 1, the number is negative. If 0, the number is positive.</p>
      <p><a id="footnotemain5-7"></a>[7] The automatic check does not look at the right-hand side, but any reasonable <span class="code">equals</span> method should return <span class="code">false</span> if its argument is <span class="code">null</span>.</p>
      <p><a id="footnotemain5-8"></a>[8] By now you should be able to figure out that given this code, the Scala compiler would invoke <span class="code">(bills.!*&amp;^<span class="texttt">%</span><span style="font-size:large">~</span>(code)).!()</span>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-functional-objects">Chapter 6</a></h2>
      <h1>Functional Objects</h1>
      <p>With the understanding of Scala basics you've gained from previous chapters, you're ready to design more full-featured classes in Scala. In this chapter, the emphasis is on classes that define functional objects, or objects that do not have any mutable state.<a id="i47852440-1"></a> As a running example, we'll create several variants of a class that models rational numbers as immutable objects. Along the way, we'll show you more aspects of object-oriented programming in Scala: class parameters and constructors, methods and operators, private members, overriding, checking preconditions, overloading, and self references<a id="i1689782844-2"></a><a id="i-2121954815-1"></a>.</p>
      <h3 id="sec-class-for-rational-numbers">6.1 A specification for class <span class="code">Rational</span></h3>
      <p>A <em>rational number</em> is a number that can be expressed as a ratio <sup>n</sup>/<sub>d</sub>, where <i>n</i> and <i>d</i> are integers, except that <i>d</i> cannot be zero. <i>n</i> is called the <span style="font-style:italic">numerator</span> and <i>d</i> the <span style="font-style:italic">denominator</span>. Examples of rational numbers are <sup>1</sup>/<sub>2</sub>, <sup>2</sup>/<sub>3</sub>, <sup>112</sup>/<sub>239</sub>, and <sup>2</sup>/<sub>1</sub>. Compared to floating-point numbers, rational numbers have the advantage that fractions are represented exactly, without rounding or approximation.</p>
      <p>The class we'll design in this chapter must model the behavior of rational numbers, including allowing them to be added, subtracted, multiplied, and divided. To add two rationals, you must first obtain a common denominator, then add the two numerators. For example, to add <sup>1</sup>/<sub>2</sub> + <sup>2</sup>/<sub>3</sub>, you multiply both parts of the left operand by 3 and both parts of the right operand by 2, which gives you <sup>3</sup>/<sub>6</sub> + <sup>4</sup>/<sub>6</sub>. Adding the two numerators yields the result, <sup>7</sup>/<sub>6</sub>. To multiply two rational numbers, you can simply multiply their numerators and multiply their denominators. Thus, <sup>1</sup>/<sub>2</sub> * <sup>2</sup>/<sub>5</sub> gives <sup>2</sup>/<sub>10</sub>, which can be represented more compactly in its "normalized" form as <sup>1</sup>/<sub>5</sub>. You divide by swapping the numerator and denominator of the right operand and then multiplying. For instance <sup>1</sup>/<sub>2</sub> / <sup>3</sup>/<sub>5</sub> is the same as <sup>1</sup>/<sub>2</sub> * <sup>5</sup>/<sub>3</sub>, or <sup>5</sup>/<sub>6</sub>.</p>
      <p>One, maybe rather trivial, observation is that in mathematics, rational numbers do not have mutable state. You can add one rational number to another, but the result will be a new rational number. The original numbers will not have "changed." The immutable <span class="code">Rational</span> class we'll design in this chapter will have the same property. Each rational number will be represented by one <span class="code">Rational</span> object. When you add two <span class="code">Rational</span> objects, you'll create a new <span class="code">Rational</span> object to hold the sum.</p>
      <p>This chapter will give you a glimpse of some of the ways Scala enables you to write libraries that feel like native language support. For example, at the end of this chapter you'll be able to do this with class <span class="code">Rational</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;oneHalf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">oneHalf:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;twoThirds&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">twoThirds:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br>  scala&gt;&nbsp;(oneHalf&nbsp;/&nbsp;<code class="literal">7</code>)&nbsp;+&nbsp;(<code class="literal">1</code>&nbsp;-&nbsp;twoThirds)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res0:&nbsp;Rational&nbsp;=&nbsp;17/42</code>
</pre>
      <h3>6.2 Constructing a <span class="code">Rational</span></h3>
      <p>A good place to start designing class <span class="code">Rational</span> is to consider how client programmers will create a new <span class="code">Rational</span> object. Given we've decided to make <span class="code">Rational</span> objects immutable, we'll require that clients provide all data needed by an instance (in this case, a numerator and a denominator) when they construct the instance. Thus, we will start the design with this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)
</pre>
      <p>One of the first things to note about this line of code is that if a class doesn't have a body, you don't need to specify empty curly braces (though you could, of course, if you wanted to).<a id="i-1274918996-1"></a><a id="i-1738295964-1"></a> The identifiers <span class="code">n</span> and <span class="code">d</span> in the parentheses after the class name, <span class="code">Rational</span>, are called <em>class parameters</em><a id="i177886610-1"></a>. The Scala compiler will gather up these two class parameters and create a <em>primary constructor</em> that takes the same two parameters.<a id="i2081307927-1"></a><a id="i161912641-1"></a></p>
      <div class="aside">
        <h3>Immutable object trade-offs</h3>
        <p>Immutable objects offer several advantages over mutable objects, and one potential disadvantage.<a id="i1835948581-1"></a> First, immutable objects are often easier to reason about than mutable ones, because they do not have complex state spaces that change over time. Second, you can pass immutable objects around quite freely, whereas you may need to make defensive copies<a id="i-1422525536-1"></a> of mutable objects before passing them to other code. Third, there is no way for two threads concurrently accessing an immutable to corrupt its state once it has been properly constructed, because no thread can change the state of an immutable. Fourth, immutable objects make safe hash table keys. If a mutable object is mutated after it is placed into a <span class="code">HashSet</span>, for example, that object may not be found the next time you look into the <span class="code">HashSet</span>.</p>
        <p>The main disadvantage of immutable objects is that they sometimes require that a large object graph be copied, whereas an update could be done in its place. In some cases this can be awkward to express and might also cause a performance bottleneck. As a result, it is<a id="i-222173474-1"></a> not uncommon for libraries to provide mutable alternatives to immutable classes. For example, class <span class="code">StringBuilder</span> is a mutable alternative to the immutable <span class="code">String</span>. We'll give you more information on designing mutable objects in Scala in <a href="#chap-mutable-objects">Chapter 18</a>.</p>
      </div>
      <div class="note">
        <h4>Note</h4>
        <p>This initial <span class="code">Rational</span> example highlights a difference between Java and Scala.<a id="i263298648-1"></a> In Java, classes have constructors, which can take parameters; whereas in Scala, classes can take parameters directly. The Scala notation is more concise—class parameters can be used directly in the body of the class; there's no need to define fields and write assignments that copy constructor parameters into fields. This can yield substantial savings in boilerplate code, especially for small classes.</p>
      </div>
      <p>The Scala compiler will compile any code you place in the class body, which isn't part of a field or a method definition, into the primary constructor. For example, you could print a debug message like this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;println(<code class="quotedstring">"Created&nbsp;"</code>&nbsp;+&nbsp;n&nbsp;+&nbsp;<code class="quotedstring">"/"</code>&nbsp;+&nbsp;d)
  }
</pre>
      <p>Given this code, the Scala compiler would place the call to <span class="code">println</span> into <span class="code">Rational</span>'s primary constructor. The <span class="code">println</span> call will, therefore, print its debug message whenever you create a new <span class="code">Rational</span> instance:</p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">Created&nbsp;1/2</code>
  <code class="output">res0:&nbsp;Rational&nbsp;=&nbsp;Rational@6121a7dd</code>
</pre>
      <h3 id="sec-reimp-tostring">6.3 Reimplementing the <span class="code">toString</span> method</h3>
      <p>When we created an instance of <span class="code">Rational</span> in the previous example, the interpreter printed "Rational@2591e0c9". The interpreter obtained this somewhat funny looking string by calling <span class="code">toString</span> on the <span class="code">Rational</span> object. By default, class <span class="code">Rational</span> inherits the implementation of <span class="code">toString</span> defined in class <span class="code">java.lang.Object</span>, which just prints the class name, an @ sign, and a hexadecimal number. The result of <span class="code">toString</span> is primarily intended to help programmers by providing information that can be used in debug print statements, log messages, test failure reports, and interpreter and debugger output. The result currently provided by <span class="code">toString</span> is not especially helpful because it doesn't give any clue about the rational number's value. A more useful implementation of <span class="code">toString</span> would print out the values of the <span class="code">Rational</span>'s numerator and denominator. You can <em>override</em> the default implementation by adding a method <span class="code">toString</span> to class <span class="code">Rational</span>, like this:<a id="i-189935346-1"></a><a id="i-720005867-1"></a></p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$n/$d"</code>
  }
</pre>
      <p>The <span class="code">override</span> modifier in front of a method definition signals that a previous method definition is overridden (more on this in <a href="#chap-composition-and-inheritance">Chapter 10</a>). Since <span class="code">Rational</span> numbers will display nicely now, we removed the debug <span class="code">println</span> statement we put into the body of previous version of class <span class="code">Rational</span>.<a id="i1201360043-1"></a> You can test the new behavior of <span class="code">Rational</span> in the interpreter:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">x:&nbsp;Rational&nbsp;=&nbsp;1/3</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">5</code>,&nbsp;<code class="literal">7</code>)
  <code class="output">y:&nbsp;Rational&nbsp;=&nbsp;5/7</code>
</pre>
      <h3 id="sec-checking-preconditions">6.4 Checking preconditions</h3>
      <p>As a next step, we will turn our attention to a problem with the<a id="i1294809499-1"></a> current behavior of the primary constructor. As mentioned at the beginning of this chapter, rational numbers may not have a zero in the denominator. Currently, however, the primary constructor accepts a zero passed as <span class="code">d</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">5</code>,&nbsp;<code class="literal">0</code>)
  <code class="output">res1:&nbsp;Rational&nbsp;=&nbsp;5/0</code>
</pre>
      <p>One of the benefits of object-oriented programming is that it allows you to encapsulate data inside objects so that you can ensure the data is valid throughout its lifetime. In the case of an immutable object such as <span class="code">Rational</span>, this means that you should ensure the data is valid when the object is constructed. Given that a zero denominator is an invalid state for a <span class="code">Rational</span> number, you should not let a <span class="code">Rational</span> be constructed if a zero is passed in the <span class="code">d</span> parameter.</p>
      <p>The best way to approach this problem is to define as a <em>precondition</em> of the primary constructor that <span class="code">d</span> must be non-zero. A precondition is a constraint on values passed into a method or constructor, a requirement which callers must fulfill. One way to do that is to use <span class="code">require</span>,<a href="#footnotemain6-1">[1]</a> like this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$n/$d"</code>
  }
</pre>
      <p>The <span class="code">require</span> method takes one boolean parameter. If the passed value is true, <span class="code">require</span> will return normally<a id="i-2113140869-1"></a>. Otherwise, <span class="code">require</span> will prevent the object from being constructed by throwing an <span class="code">IllegalArgumentException</span>.</p>
      <h3 id="sec-adding-fields">6.5 Adding fields</h3>
      <p>Now that the primary constructor is properly enforcing its precondition, we will turn our attention to supporting addition. To do so, we'll define a public <span class="code">add</span> method on class <span class="code">Rational</span> that takes another <span class="code">Rational</span> as a parameter. To keep <span class="code">Rational</span> immutable, the <span class="code">add</span> method must not add the passed rational number to itself. Rather, it must create and return a new <span class="code">Rational</span> that holds the sum. You might think you could write <span class="code">add</span> this way:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;This&nbsp;won't&nbsp;compile</code>
  &nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$n/$d"</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(n&nbsp;*&nbsp;that.d&nbsp;+&nbsp;that.n&nbsp;*&nbsp;d,&nbsp;d&nbsp;*&nbsp;that.d)
  }
</pre>
      <p>However, given this code the compiler will complain:<a id="i988779894-1"></a></p> <pre>  &lt;console&gt;:11:&nbsp;error:&nbsp;value&nbsp;d&nbsp;is&nbsp;not&nbsp;a&nbsp;member&nbsp;of&nbsp;Rational
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Rational(n&nbsp;*&nbsp;that.d&nbsp;+&nbsp;that.n&nbsp;*&nbsp;d,&nbsp;d&nbsp;*&nbsp;that.d)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
  &lt;console&gt;:11:&nbsp;error:&nbsp;value&nbsp;d&nbsp;is&nbsp;not&nbsp;a&nbsp;member&nbsp;of&nbsp;Rational
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Rational(n&nbsp;*&nbsp;that.d&nbsp;+&nbsp;that.n&nbsp;*&nbsp;d,&nbsp;d&nbsp;*&nbsp;that.d)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre>
      <p>Although class parameters <span class="code">n</span> and <span class="code">d</span> are in scope in the code of your <span class="code">add</span> method, you can only access their value on the object on which <span class="code">add</span> was invoked. Thus, when you say <span class="code">n</span> or <span class="code">d</span> in <span class="code">add</span>'s implementation, the compiler is happy to provide you with the values for these class parameters. But it won't let you say <span class="code">that.n</span> or <span class="code">that.d</span> because <span class="code">that</span> does not refer to the <span class="code">Rational</span> object on which <span class="code">add</span> was invoked.<a href="#footnotemain6-2">[2]</a> To access the numerator and denominator on <span class="code">that</span>, you'll need to make them into fields. <a href="#lst-rational-fields">Listing 6.1</a> shows how you could add these fields to class <span class="code">Rational</span>.<a href="#footnotemain6-3">[3]</a><a id="i2138903369-1"></a><a id="i-590826255-1"></a></p>
      <p><a id="lst-rational-fields"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;d
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$numer/$denom"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 6.1 - <span class="code">Rational</span> with fields.</h5>
      <p>In the version of <span class="code">Rational</span> shown in <a href="#lst-rational-fields">Listing 6.1</a>, we added two fields named <span class="code">numer</span> and <span class="code">denom</span>, and initialized them with the values of class parameters <span class="code">n</span> and <span class="code">d</span>.<a href="#footnotemain6-4">[4]</a> We also changed the implementation of <span class="code">toString</span> and <span class="code">add</span> so that they use the fields, not the class parameters. This version of class <span class="code">Rational</span> compiles. You can test it by adding some rational numbers:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;oneHalf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">oneHalf:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;twoThirds&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">twoThirds:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br>  scala&gt;&nbsp;oneHalf&nbsp;add&nbsp;twoThirds
  <code class="output">res2:&nbsp;Rational&nbsp;=&nbsp;7/6</code>
</pre>
      <p>One other thing you can do now that you couldn't do before is access the numerator and denominator values from outside the object. Simply access the public <span class="code">numer</span> and <span class="code">denom</span> fields, like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;r&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">r:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br>  scala&gt;&nbsp;r.numer
  <code class="output">res3:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;r.denom
  <code class="output">res4:&nbsp;Int&nbsp;=&nbsp;2</code>
</pre>
      <h3 id="sec-self-references">6.6 Self references</h3>
      <p>The keyword <span class="code">this</span> refers to the<a id="i3559070-1"></a><a id="i423816156-1"></a> object instance on which the currently executing method was invoked, or if used in a constructor, the object instance being constructed. As an example, consider adding a method, <span class="code">lessThan</span>, which tests whether the given <span class="code">Rational</span> is smaller than a parameter:</p> <pre>  <code class="vem">def</code>&nbsp;lessThan(that:&nbsp;<code class="typename">Rational</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">this</code>.numer&nbsp;*&nbsp;that.denom&nbsp;&lt;&nbsp;that.numer&nbsp;*&nbsp;<code class="vem">this</code>.denom
</pre>
      <p>Here, <span class="code">this.numer</span> refers to the numerator of the object on which <span class="code">lessThan</span> was invoked. You can also leave off the <span class="code">this</span> prefix and write just <span class="code">numer</span>; the two notations are equivalent.</p>
      <p>As an example of where you can't do without <span class="code">this</span>, consider adding a <span class="code">max</span> method to class <span class="code">Rational</span> that returns the greater of the given rational number and an argument:</p> <pre>  <code class="vem">def</code>&nbsp;max(that:&nbsp;<code class="typename">Rational</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(<code class="vem">this</code>.lessThan(that))&nbsp;that&nbsp;<code class="vem">else</code>&nbsp;<code class="vem">this</code>
</pre>
      <p>Here, the first <span class="code">this</span> is redundant. You could have left it off and written: <span class="code">lessThan(that)</span>. But the second <span class="code">this</span> represents the result of the method in the case where the test returns false; were you to omit it, there would be nothing left to return!</p>
      <h3 id="sec-multicons">6.7 Auxiliary constructors</h3>
      <p>Sometimes you need multiple constructors in a class. In Scala, constructors other than the primary constructor are called <a href="#g729406368"><em>auxiliary constructors</em></a>.<a id="i-717257147-1"></a><a id="i1136761043-1"></a><a id="i-1656673269-1"></a> For example, a rational number with a denominator of 1 can be written more succinctly as simply the numerator. Instead of <sup>5</sup>/<sub>1</sub>, for example, you can just write 5. It might be nice, therefore, if instead of writing <span class="code">new</span>&nbsp;<span class="code">Rational(5,</span>&nbsp;<span class="code">1)</span>, client programmers could simply write <span class="code">new</span>&nbsp;<span class="code">Rational(5)</span>. This would require adding an auxiliary constructor to <span class="code">Rational</span> that takes only one argument, the numerator, with the denominator predefined to be 1. <a href="#lst-aux-constructor">Listing 6.2</a> shows what that would look like.</p>
      <p><a id="lst-aux-constructor"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;d
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(n:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(n,&nbsp;<code class="literal">1</code>)&nbsp;<code class="comment">//&nbsp;auxiliary&nbsp;constructor</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$numer/$denom"</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 6.2 - <span class="code">Rational</span> with an auxiliary constructor.</h5>
      <p>Auxiliary constructors in Scala start with <span class="code">def</span>&nbsp;<span class="code">this(...)</span>. The body of <span class="code">Rational</span>'s auxiliary constructor merely invokes the primary constructor, passing along its lone argument, <span class="code">n</span>, as the numerator and <span class="code">1</span> as the denominator. You can see the auxiliary constructor in action by typing the following into the interpreter:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">3</code>)
  <code class="output">y:&nbsp;Rational&nbsp;=&nbsp;3/1</code>
</pre>
      <p>In Scala, every auxiliary constructor must invoke another constructor of the same class as its first action. In other words, the first statement in every auxiliary constructor in every Scala class will have the form "<span class="code">this(</span>...<span class="code">)</span>". The invoked constructor is either the primary constructor (as in the <span class="code">Rational</span> example), or another auxiliary constructor that comes textually before the calling constructor. The net effect of this rule is that every constructor invocation in Scala will end up eventually calling the primary constructor of the class. The primary constructor is thus the single point of entry of a class.</p>
      <div class="note">
        <h4>Note</h4>
        <p>If you're familiar with Java, you may wonder why Scala's rules for constructors are a bit more restrictive than Java's. In Java, a constructor must either invoke another constructor of the same class, or directly invoke a constructor of the superclass, as its first action. In a Scala class, only the primary constructor can invoke a superclass constructor. The increased restriction in Scala is really a design trade-off that needed to be paid in exchange for the greater conciseness and simplicity of Scala's constructors compared to Java's. Superclasses and the details of how constructor invocation and inheritance interact will be explained in <a href="#chap-composition-and-inheritance">Chapter 10</a>.</p>
      </div>
      <h3>6.8 Private fields and methods</h3>
      <p>In the previous version of <span class="code">Rational</span>, we simply initialized <span class="code">numer</span> with <span class="code">n</span> and <span class="code">denom</span> with <span class="code">d</span>. As a result, the numerator and denominator of a <span class="code">Rational</span> can be larger than needed. For example, the fraction <sup>66</sup>/<sub>42</sub> could be normalized to an equivalent reduced form, <sup>11</sup>/<sub>7</sub>, but <span class="code">Rational</span>'s primary constructor doesn't currently do this:</p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">66</code>,&nbsp;<code class="literal">42</code>)
  <code class="output">res5:&nbsp;Rational&nbsp;=&nbsp;66/42</code>
</pre>
      <p>To normalize in this way, you need to divide the numerator and denominator by their <em>greatest common divisor</em>. For example, the greatest common divisor of 66 and 42 is 6. (In other words, 6 is the largest integer that divides evenly into both 66 and 42.) Dividing both the numerator and denominator of <sup>66</sup>/<sub>42</sub> by 6 yields its reduced form, <sup>11</sup>/<sub>7</sub>. <a href="#lst-private-members">Listing 6.3</a> shows one way to do this:</p>
      <p><a id="lst-private-members"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;n&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;d&nbsp;/&nbsp;g
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(n:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(n,&nbsp;<code class="literal">1</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;add(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$numer/$denom"</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 6.3 - <span class="code">Rational</span> with a private field and method.<a id="i694224322-2"></a><a id="i1692219636-2"></a><a id="i-1558980393-1"></a><a id="i-1621898821-1"></a></h5>
      <p>In this version of <span class="code">Rational</span>, we added a private field, <span class="code">g</span>, and modified the initializers for <span class="code">numer</span> and <span class="code">denom</span>. (An <em>initializer</em> is the code that initializes a variable; for example, the "<span class="code">n</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">g</span>" that initializes <span class="code">numer</span>.) Because <span class="code">g</span> is private, it can be accessed inside the body of the class, but not outside<a id="i1857067865-1"></a>. We also added a private method, <span class="code">gcd</span>, which calculates the greatest common divisor of two passed <span class="code">Int</span>s. For example, <span class="code">gcd(12,</span>&nbsp;<span class="code">8)</span> is <span class="code">4</span>. As you saw in <a href="#sec-classes-fields-methods">Section 4.1</a>, to make a field or method private you simply place the <span class="code">private</span> keyword in front of its definition. The purpose of the private "helper method" <span class="code">gcd</span> is to factor out code needed by some other part of the class, in this case, the primary constructor. To ensure <span class="code">g</span> is always positive, we pass the absolute value of <span class="code">n</span> and <span class="code">d</span>, which we obtain by invoking <span class="code">abs</span> on them, a method you can invoke on any <span class="code">Int</span> to get its absolute value.<a id="i-1171773097-1"></a></p>
      <p>The Scala compiler will place the code for the initializers of <span class="code">Rational</span>'s three fields into the primary constructor in the order in which they appear in the source code.<a id="i-400083503-1"></a> Thus, <span class="code">g</span>'s initializer, <span class="code">gcd(n.abs,</span>&nbsp;<span class="code">d.abs)</span>, will execute before the other two, because it appears first in the source. Field <span class="code">g</span> will be initialized with the result, the greatest common divisor of the absolute value of the class parameters, <span class="code">n</span> and <span class="code">d</span>. Field <span class="code">g</span> is then used in the initializers of <span class="code">numer</span> and <span class="code">denom</span>. By dividing <span class="code">n</span> and <span class="code">d</span> by their greatest common divisor, <span class="code">g</span>, every <span class="code">Rational</span> will be constructed in its normalized form:</p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">66</code>,&nbsp;<code class="literal">42</code>)
  <code class="output">res6:&nbsp;Rational&nbsp;=&nbsp;11/7</code>
</pre>
      <h3>6.9 Defining operators</h3>
      <p>The current implementation of <span class="code">Rational</span> addition is OK, but could be made more convenient to use. You might ask yourself why you can write:</p> <pre>  x&nbsp;+&nbsp;y
</pre>
      <p>if <span class="code">x</span> and <span class="code">y</span> are integers or floating-point numbers, but you have to write:</p> <pre>  x.add(y)
</pre>
      <p>or at least:<span style="color:#fff"></span></p> <pre>  x&nbsp;add&nbsp;y
</pre>
      <p>if they are rational numbers. There's no convincing reason why this should be so. Rational numbers are numbers just like other numbers. In a mathematical sense they are even more natural than, say, floating-point numbers.</p>
      <p>Why should you not use the natural arithmetic operators on them? In Scala you can do this. In the rest of this chapter, we'll show you how.</p>
      <p>The first step is to replace <span class="code">add</span> by the usual mathematical symbol. This is straightforward, as <span class="code">+</span> is a legal identifier in Scala. We can simply define a method with <span class="code">+</span> as its name. While we're at it, we may as well implement a method named <span class="code">*</span> that performs multiplication. The result is shown in <a href="#lst-operator-methods">Listing 6.4</a>:</p>
      <p><a id="lst-operator-methods"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;n&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;d&nbsp;/&nbsp;g
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(n:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(n,&nbsp;<code class="literal">1</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;*&nbsp;that.numer,&nbsp;denom&nbsp;*&nbsp;that.denom)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$numer/$denom"</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 6.4 - <span class="code">Rational</span> with operator methods.</h5>
      <p>With class <span class="code">Rational</span> defined in this manner, you can now write:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">x:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">y:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br>  scala&gt;&nbsp;x&nbsp;+&nbsp;y
  <code class="output">res7:&nbsp;Rational&nbsp;=&nbsp;7/6</code>
</pre>
      <p>As always, the operator syntax on the last input line is equivalent to a method call.<a id="i-614149608-3"></a> You could also write:</p> <pre>  scala&gt;&nbsp;x.+(y)
  <code class="output">res8:&nbsp;Rational&nbsp;=&nbsp;7/6</code>
</pre>
      <p>but this is not as readable.</p>
      <p>Another thing to note is that given Scala's rules for operator precedence, which were described in <a href="#sec-precedence">Section 5.9</a>, the <span class="code">*</span> method will bind more tightly than the <span class="code">+</span> method for <span class="code">Rational</span>s. In other words, expressions involving <span class="code">+</span> and <span class="code">*</span> operations on <span class="code">Rational</span>s will behave as expected.<a id="i1955596960-2"></a><a id="i2084616098-2"></a> For example, <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">y</span> will execute as <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(x</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">y)</span>, not <span class="code">(x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">x)</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">y</span>:</p> <pre>  scala&gt;&nbsp;x&nbsp;+&nbsp;x&nbsp;*&nbsp;y
  <code class="output">res9:&nbsp;Rational&nbsp;=&nbsp;5/6</code>
  <br>  scala&gt;&nbsp;(x&nbsp;+&nbsp;x)&nbsp;*&nbsp;y
  <code class="output">res10:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br>  scala&gt;&nbsp;x&nbsp;+&nbsp;(x&nbsp;*&nbsp;y)
  <code class="output">res11:&nbsp;Rational&nbsp;=&nbsp;5/6</code>
</pre>
      <h3>6.10 Identifiers in Scala</h3>
      <p>You have now seen the two most important ways to form an identifier in Scala: alphanumeric and operator. Scala has very flexible rules for forming identifiers. Besides the two forms you have seen there are also two others. All four forms of identifier formation are described in this section.<a id="i1368189162-1"></a></p>
      <p>An <span style="font-style:italic">alphanumeric identifier</span> starts with a letter or underscore, which can be followed by further letters, digits, or underscores. The `$' character also counts as a letter; however, it is reserved for identifiers generated by the Scala compiler. Identifiers in user programs should not contain `$' characters, even though it will compile; if they do, this might lead to name clashes with identifiers generated by the Scala compiler.<a id="i-890920833-1"></a></p>
      <p>Scala follows Java's convention of using camel-case<a href="#footnotemain6-5">[5]</a> identifiers,<a id="i81954455-1"></a> such as <span class="code">toString</span> and <span class="code">HashSet</span>.<a id="i857734909-1"></a><a id="i-917788527-1"></a><a id="i350029111-1"></a><a id="i-1611050102-1"></a> Although underscores are legal in identifiers, they are not used that often in Scala programs, in part to be consistent with Java, but also because underscores have many other non-identifier uses in Scala code<a id="i1978221382-1"></a>. As a result, it is best to avoid identifiers like <span class="code">to_string</span>, <span class="code">__init__</span>, or <span class="code">name_</span>. Camel-case names of fields, method parameters, local variables, and functions should start with a lower case letter, for example: <span class="code">length</span>, <span class="code">flatMap</span>, and <span class="code">s</span>. Camel-case names of classes and traits should start with an upper case letter, for example: <span class="code">BigInt</span>, <span class="code">List</span>, and <span class="code">UnbalancedTreeMap</span>.<a href="#footnotemain6-6">[6]</a></p>
      <div class="note">
        <h4>Note</h4>
        <p>One consequence of using a trailing underscore in an identifier is that if you attempt, for example, to write a declaration like this, "<span class="code">val</span>&nbsp;<span class="code">name_:</span>&nbsp;<span class="code">Int</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">1</span>", you'll get a compiler error. The compiler will think you are trying to declare a <span class="code">val</span> named "<span class="code">name_:</span>". To get this to compile, you would need to insert an extra space before the colon, as in: "<span class="code">val</span>&nbsp;<span class="code">name_</span>&nbsp;<span class="code">:</span>&nbsp;<span class="code">Int</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">1</span>".</p>
      </div>
      <p>One way in which Scala's conventions depart from Java's involves constant names.<a id="i-422276785-1"></a> In Scala, the word <em>constant</em> does not just mean <span class="code">val</span>. Even though a <span class="code">val</span> does remain constant after it is initialized, it is still a variable. For example, method parameters are <span class="code">val</span>s, but each time the method is called those <span class="code">val</span>s can hold different values. A constant is more permanent. For example, <span class="code">scala.math.Pi</span> is defined to be the double value closest to the real value of π, the ratio of a circle's circumference to its diameter. This value is unlikely to change ever; thus, <span class="code">Pi</span> is clearly a constant. You can also use constants to give names to values that would otherwise be <em>magic numbers</em> in your code:<a id="i1838929623-1"></a> literal values with no explanation, which in the worst case appear in multiple places. You may also want to define constants for use in pattern matching, a use case that will be described in <a href="#subsec-kinds-of-patterns-variables">Section 15.2</a>. In Java, the convention is to give constants names that are all upper case, with underscores separating the words, such as <span class="code">MAX_VALUE</span> or <span class="code">PI</span>. In Scala, the convention is merely that the first character should be upper case. Thus, constants named in the Java style, such as <span class="code">X_OFFSET</span>, will work as Scala constants, but the Scala convention is to use camel case for constants, such as <span class="code">XOffset</span>.</p>
      <p>An <span style="font-style:italic">operator identifier</span> consists of one or more operator characters.<a id="i1206563604-1"></a><a id="i-12268236-1"></a> Operator characters are printable ASCII characters such as <span class="code">+</span>, <span class="code">:</span>, <span class="code">?</span>, <span class="code"><span style="font-size:large">~</span></span> or <span class="code">#</span>.<a href="#footnotemain6-7">[7]</a> Here are some examples of operator identifiers:</p>
      <div style="text-align: center">
        <p><span class="code">+</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">++</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">&lt;?&gt;</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">:-&gt;</span></p>
      </div>
      <p>The Scala compiler will internally "mangle" operator identifiers to turn them into legal Java identifiers with embedded <span class="code">$</span> characters. For instance, the identifier <span class="code">:-&gt;</span> would be represented internally as <span class="code">$colon$minus$greater</span>. If you ever wanted to access this identifier from Java code, you'd need to use this internal representation.</p>
      <p>Because operator identifiers in Scala can become arbitrarily long, there is a small difference between Java and Scala. In Java, the input <span class="code">x&lt;-y</span> would be parsed as four lexical symbols, so it would be equivalent to <span class="code">x</span>&nbsp;<span class="code">&lt;</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">y</span>. In Scala, <span class="code">&lt;-</span> would be parsed as a single identifier, giving <span class="code">x</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">y</span>. If you want the first interpretation, you need to separate the <span class="code">&lt;</span> and the <span class="code">-</span> characters by a space. This is unlikely to be a problem in practice, as very few people would write <span class="code">x&lt;-y</span> in Java without inserting spaces or parentheses between the operators.</p>
      <p>A <span style="font-style:italic">mixed identifier</span> consists of an alphanumeric identifier, which is followed by an underscore and an operator identifier.<a id="i-1955463099-1"></a><a id="i1641787755-1"></a> For example, <span class="code">unary_+</span><a id="i-1088310403-2"></a> used as a method name defines a unary <span class="code">+</span> operator. Or, <span class="code">myvar_=</span> used as method name defines an assignment operator. In addition, the mixed identifier form <span class="code">myvar_=</span> is generated by the Scala compiler to support <span style="font-style:italic">properties</span> (more on that in <a href="#chap-mutable-objects">Chapter 18</a><a id="i-926053069-1"></a>).</p>
      <p><a id="sec-literal-identifier"></a> A <span style="font-style:italic">literal identifier</span> is an arbitrary string enclosed in back ticks (<span class="code">`</span> ...<span class="code">`</span>).<a id="i-144177089-1"></a><a id="i-1241489226-1"></a><a id="i1204364761-1"></a> Some examples of literal identifiers are:</p>
      <div style="text-align: center">
        <p><span class="code">`x`</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">`&lt;clinit&gt;`</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">`yield`</span></p>
      </div>
      <p>The idea is that you can put any string that's accepted by the runtime as an identifier between back ticks. The result is always a Scala identifier. This works even if the name contained in the back ticks would be a Scala reserved word<a id="i1517246665-1"></a>. A typical use case is accessing the static <span class="code">yield</span> method in Java's <span class="code">Thread</span> class. You cannot write <span class="code">Thread.yield()</span> because <span class="code">yield</span> is a reserved word in Scala. However, you can still name the method in back ticks, <i>e.g.</i>, <span class="code">Thread.`yield`()</span>.</p>
      <h3 id="sec-method-overloading">6.11 Method overloading</h3>
      <p>Back to class <span class="code">Rational</span>. With the latest changes, you can now do<a id="i-1178969056-1"></a><a id="i1636832800-1"></a> addition and multiplication operations in a natural style on rational numbers. But one thing still missing is mixed arithmetic. For instance, you cannot multiply a rational number by an integer because the operands of <span class="code">*</span> always have to be <span class="code">Rational</span>s. So for a rational number <span class="code">r</span> you can't write <span class="code">r</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2</span>. You must write <span class="code">r</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">new</span>&nbsp;<span class="code">Rational(2)</span>, which is not as nice.</p>
      <p>To make <span class="code">Rational</span> even more convenient, we'll add new methods to the class that perform mixed addition and multiplication on rational numbers and integers. While we're at it, we'll add methods for subtraction and division too. The result is shown in <a href="#lst-overloaded-methods">Listing 6.5</a>.</p>
      <p><a id="lst-overloaded-methods"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;n&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;d&nbsp;/&nbsp;g
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(n:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(n,&nbsp;<code class="literal">1</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;+&nbsp;i&nbsp;*&nbsp;denom,&nbsp;denom)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;-&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;-&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;-&nbsp;(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;-&nbsp;i&nbsp;*&nbsp;denom,&nbsp;denom)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;*&nbsp;that.numer,&nbsp;denom&nbsp;*&nbsp;that.denom)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;*&nbsp;i,&nbsp;denom)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;/&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer&nbsp;*&nbsp;that.denom,&nbsp;denom&nbsp;*&nbsp;that.numer)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;/&nbsp;(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(numer,&nbsp;denom&nbsp;*&nbsp;i)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$numer/$denom"</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 6.5 - <span class="code">Rational</span> with overloaded methods.<a id="i-1789856-1"></a></h5>
      <p>There are now two versions each of the arithmetic methods: one that takes a rational as its argument and another that takes an integer. In other words, each of these method names is <em>overloaded</em> because each name is now being used by multiple methods. For example, the name <span class="code">+</span> is used by one method that takes a <span class="code">Rational</span> and another that takes an <span class="code">Int</span>. In a method call, the compiler picks the version of an overloaded method that correctly matches the types of the arguments. For instance, if the argument <span class="code">y</span> in <span class="code">x.+(y)</span> is a <span class="code">Rational</span>, the compiler will pick the method <span class="code">+</span> that takes a <span class="code">Rational</span> parameter. But if the argument is an integer, the compiler will pick the method <span class="code">+</span> that takes an <span class="code">Int</span> parameter instead. If you try this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">x:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br>  scala&gt;&nbsp;x&nbsp;*&nbsp;x
  <code class="output">res12:&nbsp;Rational&nbsp;=&nbsp;4/9</code>
  <br>  scala&gt;&nbsp;x&nbsp;*&nbsp;<code class="literal">2</code>
  <code class="output">res13:&nbsp;Rational&nbsp;=&nbsp;4/3</code>
</pre>
      <p>You'll see that the <span class="code">*</span> method invoked is determined in each case by the type of the right operand.</p>
      <div class="note">
        <h4>Note</h4>
        <p>Scala's process of overloaded method resolution is very similar to Java's. In every case, the chosen overloaded version is the one that best matches the static types of the arguments. Sometimes there is no unique best matching version; in that case the compiler will give you an "ambiguous reference" error.</p>
      </div>
      <h3>6.12 Implicit conversions</h3>
      <p>Now that you can write <span class="code">r</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2</span>, you might also want to swap the operands, as in <span class="code">2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">r</span>. Unfortunately this does not work yet:<a id="i869323971-1"></a></p> <pre>  scala&gt;&nbsp;<code class="literal">2</code>&nbsp;*&nbsp;r
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;overloaded&nbsp;method&nbsp;value&nbsp;*&nbsp;with&nbsp;alternatives:</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x:&nbsp;Double)Double&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x:&nbsp;Float)Float&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x:&nbsp;Long)Long&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x:&nbsp;Int)Int&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x:&nbsp;Char)Int&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x:&nbsp;Short)Int&nbsp;&lt;and&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x:&nbsp;Byte)Int</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cannot&nbsp;be&nbsp;applied&nbsp;to&nbsp;(Rational)</code>
  <code class="output"></code>
</pre>
      <p>The problem here is that <span class="code">2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">r</span> is equivalent to <span class="code">2.*(r)</span>, so it is a method call on the number <span class="code">2</span>, which is an integer. But the <span class="code">Int</span> class contains no multiplication method that takes a <span class="code">Rational</span> argument—it couldn't because class <span class="code">Rational</span> is not a standard class in the Scala library.</p>
      <p>However, there is another way to solve this problem in Scala: You can create an implicit conversion that automatically converts integers to rational numbers when needed.<a id="i-2127602858-1"></a> Try adding this line in the interpreter:</p> <pre>  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToRational(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(x)
</pre>
      <p>This defines a conversion method from <span class="code">Int</span> to <span class="code">Rational</span>. The <span class="code">implicit</span> modifier in front of the method tells the compiler to apply it automatically in a number of situations<a id="i-425423387-1"></a>. With the conversion defined, you can now retry the example that failed before:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;r&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">2</code>,<code class="literal">3</code>)
  <code class="output">r:&nbsp;Rational&nbsp;=&nbsp;2/3</code>
  <br>  scala&gt;&nbsp;<code class="literal">2</code>&nbsp;*&nbsp;r
  <code class="output">res15:&nbsp;Rational&nbsp;=&nbsp;4/3</code>
</pre>
      <p>For an implicit conversion to work, it needs to be in scope. If you place the implicit method definition inside class <span class="code">Rational</span>, it won't be in scope in the interpreter. For now, you'll need to define it directly in the interpreter.</p>
      <p>As you can glimpse from this example, implicit conversions are a very powerful technique for making libraries more flexible and more convenient to use. Because they are so powerful, they can also be easily misused. You'll find out more on implicit conversions, including ways to bring them into scope where they are needed, in <a href="#chap-implicit-conversions-and-parameters">Chapter 21</a>.</p>
      <h3>6.13 A word of caution</h3>
      <p>As this chapter has demonstrated, creating methods with operator names<a id="i771080752-1"></a> and defining implicit conversions can help you design libraries for which client code is concise and easy to understand. Scala gives you a great deal of power to design such easy-to-use libraries. But please bear in mind that with power comes responsibility.</p>
      <p>If used unartfully, both operator methods and implicit conversions can give rise to client code that is hard to read and understand. Because implicit conversions are applied implicitly by the compiler, not explicitly written down in the source code, it can be non-obvious to client programmers what implicit conversions are being applied. And although operator methods will usually make client code more concise, they will only make it more readable to the extent client programmers will be able to recognize and remember the meaning of each operator.</p>
      <p>The goal you should keep in mind as you design libraries is not merely<a id="i-506868082-1"></a> enabling concise client code, but readable, understandable client code. Conciseness will often be a big part of that readability, but you can take conciseness too far. By designing libraries that enable tastefully concise and at the same time understandable client code, you can help those client programmers work productively.</p>
      <h3>6.14 Conclusion</h3>
      <p>In this chapter, you saw more aspects of classes in Scala. You saw how to add parameters to a class, define several constructors, define operators as methods, and customize classes so that they are natural to use. Maybe most importantly, you saw that defining and using immutable objects is a quite natural way to code in Scala.</p>
      <p>Although the final version of <span class="code">Rational</span> shown in this chapter fulfills the requirements set forth at the beginning of the chapter, it could still be improved. We will in fact return to this example later in the book. For example, in <a href="#chap-object-equality">Chapter 30</a>, you'll learn how to override <span class="code">equals</span> and <span class="code">hashcode</span> to allow <span class="code">Rational</span>s to behave better when compared with <span class="code">==</span> or placed into hash tables. In <a href="#chap-implicit-conversions-and-parameters">Chapter 21</a>, you'll learn how to place implicit method definitions in a companion object for <span class="code">Rational</span>, so they can be more easily placed into scope when client programmers are working with <span class="code">Rational</span>s.</p>
      <hr>
      <h4>Footnotes for Chapter 6:</h4>
      <p><a id="footnotemain6-1"></a>[1] The <span class="code">require</span> method is defined in standalone object, <span class="code">Predef</span>. As mentioned in <a href="#sec-a-scala-application">Section 4.4</a>, <span class="code">Predef</span>'s members are imported automatically into every Scala source file.</p>
      <p><a id="footnotemain6-2"></a>[2] Actually, you could add a <span class="code">Rational</span> to itself, in which case <span class="code">that</span> would refer to the object on which <span class="code">add</span> was invoked. But because you can pass any <span class="code">Rational</span> object to <span class="code">add</span>, the compiler still won't let you say <span class="code">that.n</span>.</p>
      <p><a id="footnotemain6-3"></a>[3] In <a href="#sec-parametric-fields">Section 10.6</a> you'll find out about <em>parametric fields</em>, which provide a shorthand for writing the same code.</p>
      <p><a id="footnotemain6-4"></a>[4] Even though <span class="code">n</span> and <span class="code">d</span> are used in the body of the class, given they are only used inside constructors, the Scala compiler will not emit fields for them. Thus, given this code the Scala compiler will generate a class with two <span class="code">Int</span> fields, one for <span class="code">numer</span> and one for <span class="code">denom</span>.</p>
      <p><a id="footnotemain6-5"></a>[5] This style of naming identifiers is called <em>camel case</em> because the identifiersHaveHumps consisting of the embedded capital letters.</p>
      <p><a id="footnotemain6-6"></a>[6] In <a href="#sec-list-patterns">Section 16.5</a>, you'll see that sometimes you may want to give a special kind of class known as a <em>case class</em> a name consisting solely of operator characters. For example, the Scala API contains a class named <span class="code">::</span>, which facilitates pattern matching on <span class="code">List</span>s.</p>
      <p><a id="footnotemain6-7"></a>[7] More precisely, an operator character belongs to the Unicode set of mathematical symbols(Sm) or other symbols(So), or to the 7-bit ASCII characters that are not letters, digits, parentheses, square brackets, curly braces, single or double quote, or an underscore, period, semi-colon, comma, or back tick character.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-built-in-control-structures">Chapter 7</a></h2>
      <h1>Built-in Control Structures</h1>
      <p>Scala has only a handful of built-in control structures. The only control structures are <span class="code">if</span>, <span class="code">while</span>, <span class="code">for</span>, <span class="code">try</span>, <span class="code">match</span>, and function calls. The reason Scala has so few is that it has included function literals since its inception. Instead of accumulating one higher-level control structure after another in the base syntax, Scala accumulates them in libraries. (<a href="#chap-control-abstraction">Chapter 9</a> will show precisely how that is done.) This chapter will show those few control structures that are built in.</p>
      <p>One thing you will notice is that almost all of Scala's control structures result in some value. This is the approach taken by functional languages, where programs are viewed as computing a value, thus the components of a program should also compute values. You can also view this approach as the logical conclusion of a trend already present in imperative languages. In imperative languages, function calls can return a value, even though having the called function update an output variable passed as an argument would work just as well. In addition, imperative languages often have a ternary operator (such as the <span class="code">?:</span> operator of C, C++, and Java), which behaves exactly like <span class="code">if</span>, but results in a value. Scala adopts this ternary operator model, but calls it <span class="code">if</span>. In other words, Scala's <span class="code">if</span> can result in a value. Scala then continues this trend by having <span class="code">for</span>, <span class="code">try</span>, and <span class="code">match</span> also result in values.</p>
      <p>Programmers can use these result values to simplify their code, just as they use return values of functions. Without this facility, the programmer must create temporary variables just to hold results that are calculated inside a control structure. Removing these temporary variables makes the code a little simpler, and it also prevents many bugs where you set the variable in one branch but forget to set it in another.</p>
      <p>Overall, Scala's basic control structures, minimal as they are, provide all of the essentials from imperative languages. Further, they allow you to shorten your code by consistently having result values. To show you how this works, we'll take a closer look at each of Scala's basic control structures.</p>
      <h3 id="sec-if-expressions">7.1 If expressions</h3>
      <p>Scala's <span class="code">if</span> works just like in many other languages.<a id="i-1395149224-3"></a> It tests a condition and then executes one of two code branches depending on whether the condition holds true. Here is a common example, written in an imperative style:</p> <pre>  <code class="vem">var</code>&nbsp;filename&nbsp;=&nbsp;<code class="quotedstring">"default.txt"</code>
  <code class="vem">if</code>&nbsp;(!args.isEmpty)
  &nbsp;&nbsp;filename&nbsp;=&nbsp;args(<code class="literal">0</code>)
</pre>
      <p>This code declares a variable, <span class="code">filename</span>, and initializes it to a default value. It then uses an <span class="code">if</span> expression to check whether any arguments were supplied to the program. If so, it changes the variable to hold the value specified in the argument list. If no arguments were supplied, it leaves the variable set to the default value.</p>
      <p>This code can be written more nicely because, as mentioned in <a href="#step3">Step 3</a> in <a href="#chap-first-steps-in-scala">Chapter 2</a>, Scala's <span class="code">if</span> is an expression that results in a value. <a href="#lst-if-else-init">Listing 7.1</a> shows how you can accomplish the same effect as the previous example, without using any <span class="code">var</span>s:<a id="i1218979943-1"></a></p>
      <p><a id="lst-if-else-init"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;filename&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(!args.isEmpty)&nbsp;args(<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="quotedstring">"default.txt"</code>
</pre>
      <h5>Listing 7.1 - Scala's idiom for conditional initialization.</h5>
      <p>This time, the <span class="code">if</span> has two branches. If <span class="code">args</span> is not empty, the initial element, <span class="code">args(0)</span>, is chosen; otherwise, the default value is chosen.<a id="i1150746877-1"></a> The <span class="code">if</span> expression results in the chosen value, and the <span class="code">filename</span> variable is initialized with that value. This code is slightly shorter, but its real advantage is that it uses a <span class="code">val</span> instead of a <span class="code">var</span>. Using a <span class="code">val</span> is the functional style, and it helps you in much the same way as a <span class="code">final</span> variable in Java<a id="i-168967627-1"></a>. It tells readers of the code that the variable will never change, saving them from scanning all code in the variable's scope to see if it ever changes.</p>
      <p>A second advantage to using a <span class="code">val</span> instead of a <span class="code">var</span> is that it better supports <em>equational reasoning</em>. The introduced variable is <em>equal</em> to the expression that computes it, assuming that expression has no side effects. Thus, any time you are about to write the variable name, you could instead write the expression. Instead of <span class="code">println(filename)</span>, for example, you could just write this:</p> <pre>  println(<code class="vem">if</code>&nbsp;(!args.isEmpty)&nbsp;args(<code class="literal">0</code>)&nbsp;<code class="vem">else</code>&nbsp;<code class="quotedstring">"default.txt"</code>)
</pre>
      <p>The choice is yours. You can write it either way. Using <span class="code">val</span>s helps you safely make this kind of refactoring as your code evolves<a id="i204271861-1"></a> over time.</p>
      <div class="callout">
        <p><br> Look for opportunities to use <span class="code">val</span>s. They can make your code both easier to read and easier to refactor. <br></p>
      </div>
      <h3 id="sec-while-loops">7.2 While loops</h3>
      <p>Scala's <span class="code">while</span> loop behaves as in other languages.<a id="i852231328-2"></a> It has a condition and a body, and the body is executed over and over as long as the condition holds true. <a href="#lst-gcdloop">Listing 7.2</a> shows an example:</p>
      <p><a id="lst-gcdloop"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;gcdLoop(x:&nbsp;<code class="typename">Long</code>,&nbsp;y:&nbsp;<code class="typename">Long</code>):&nbsp;<code class="typename">Long</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;a&nbsp;=&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;b&nbsp;=&nbsp;y
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(a&nbsp;!=&nbsp;<code class="literal">0</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;temp&nbsp;=&nbsp;a
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;b&nbsp;<code class="texttt">%</code>&nbsp;a
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;temp
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;b
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 7.2 - Calculating greatest common divisor with a <span class="code">while</span> loop.</h5>
      <p>Scala also has a <span class="code">do</span>-<span class="code">while</span> loop. This works like the <span class="code">while</span> loop except that it tests the condition after the loop body instead of before.<a id="i846768734-1"></a> <a href="#lst-do-while">Listing 7.3</a> shows a Scala script that uses a <span class="code">do-while</span> to echo lines read from the standard input, until an empty line is entered: <a id="lst-do-while"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;line&nbsp;=&nbsp;<code class="quotedstring">""</code>
  &nbsp;&nbsp;<code class="vem">do</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;=&nbsp;readLine()
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Read:&nbsp;"</code>&nbsp;+&nbsp;line)
  &nbsp;&nbsp;}&nbsp;<code class="vem">while</code>&nbsp;(line&nbsp;!=&nbsp;<code class="quotedstring">""</code>)
</pre>
      <h5>Listing 7.3 - Reading from the standard input with <span class="code">do-while</span>.<a id="i-504023058-1"></a><a id="i-379989681-1"></a></h5>
      <p>The <span class="code">while</span> and <span class="code">do-while</span> constructs are called "loops," not expressions, because they don't result in an interesting value. The type of the result is <span class="code">Unit</span>. It turns out that a value (and in fact, only one value) exists whose type is <span class="code">Unit</span>. It is called the <em>unit value</em> and is written <span class="code">()</span>.<a id="i737037269-1"></a><a id="i-1932805493-1"></a> The existence of <span class="code">()</span> is how Scala's <span class="code">Unit</span> differs from Java's <span class="code">void</span>. Try this in the interpreter:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;greet()&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"hi"</code>)&nbsp;}
  <code class="output">greet:&nbsp;()Unit</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;whatAmI&nbsp;=&nbsp;greet()
  <code class="output">hi</code>
  <code class="output">whatAmI:&nbsp;Unit&nbsp;=&nbsp;()</code>
</pre>
      <p>Because the type of the <span class="code">println("hi")</span> expression is <span class="code">Unit</span>, <span class="code">greet</span> is defined to be a procedure with a result type of <span class="code">Unit</span>. Therefore, <span class="code">greet</span> returns the unit value, <span class="code">()</span>. This is confirmed in the next line: the <span class="code">whatAmI</span> variable has type <span class="code">Unit</span> and captures to <span class="code">greet</span>'s unit value result, <span class="code">()</span>.</p>
      <p>One other construct that results in the unit value, which is relevant here, is reassignment to <span class="code">var</span>s. For example, were you to attempt to read lines in Scala using the following <span class="code">while</span> loop idiom from Java (and C and C++), you'll run into trouble:</p> <pre>  <code class="vem">var</code>&nbsp;line&nbsp;=&nbsp;<code class="quotedstring">""</code>
  <code class="vem">while</code>&nbsp;((line&nbsp;=&nbsp;readLine())&nbsp;!=&nbsp;<code class="quotedstring">""</code>)&nbsp;<code class="comment">//&nbsp;This&nbsp;doesn't&nbsp;work!</code>
  &nbsp;&nbsp;println(<code class="quotedstring">"Read:&nbsp;"</code>&nbsp;+&nbsp;line)
</pre>
      <p>When you compile this code, Scala will give you a warning that comparing values of type <span class="code">Unit</span> and <span class="code">String</span> using <span class="code">!=</span> will always yield true. Whereas in Java, assignment results in the value assigned (in this case a line from the standard input), in Scala assignment<a id="i1918232661-1"></a> always results in the unit value, <span class="code">()</span>. Thus, the value of the assignment "<span class="code">line</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">readLine()</span>" will always be <span class="code">()</span> and never be <span class="code">""</span>. As a result, this <span class="code">while</span> loop's condition will never be false, and the loop will, therefore, never terminate.</p>
      <p>Because the <span class="code">while</span> loop results in no value, it is often left out of pure functional languages. Such languages have expressions, not loops. Scala includes the <span class="code">while</span> loop nonetheless because sometimes an imperative solution can be more readable, especially to programmers with a predominantly imperative background. For example, if you want to code an algorithm that repeats a process until some condition changes, a <span class="code">while</span> loop can express it directly while the functional alternative, which likely uses recursion, may be less obvious to some readers of the code.</p>
      <p>For example, <a href="#lst-gcd-recursive">Listing 7.4</a> shows an alternate way to determine a greatest common divisor of two numbers.<a href="#footnotemain7-1">[1]</a> Given the same two values for <span class="code">x</span> and <span class="code">y</span>, the <span class="code">gcd</span> function shown in <a href="#lst-gcd-recursive">Listing 7.4</a> will return the same result as the <span class="code">gcdLoop</span> function, shown in <a href="#lst-gcdloop">Listing 7.2</a>. The difference between these two approaches is that <span class="code">gcdLoop</span> is written in an imperative style, using <span class="code">var</span>s and and a <span class="code">while</span> loop, whereas <span class="code">gcd</span> is written in a more functional style that involves recursion (<span class="code">gcd</span> calls itself) and requires no <span class="code">var</span>s.</p>
      <p><a id="lst-gcd-recursive"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;gcd(x:&nbsp;<code class="typename">Long</code>,&nbsp;y:&nbsp;<code class="typename">Long</code>):&nbsp;<code class="typename">Long</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(y&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;x&nbsp;<code class="vem">else</code>&nbsp;gcd(y,&nbsp;x&nbsp;<code class="texttt">%</code>&nbsp;y)&nbsp;
</pre>
      <h5>Listing 7.4 - Calculating greatest common divisor with recursion.</h5>
      <p>In general, we recommend you challenge <span class="code">while</span> loops in your code in the same way you challenge <span class="code">var</span>s. In fact, <span class="code">while</span> loops and <span class="code">var</span>s often go hand in hand. Because <span class="code">while</span> loops don't result in a value, to make any kind of difference to your program, a <span class="code">while</span> loop will usually either need to update <span class="code">var</span>s or perform I/O. You can see this in action in the <span class="code">gcdLoop</span> example shown previously. As that <span class="code">while</span> loop does its business, it updates <span class="code">var</span>s <span class="code">a</span> and <span class="code">b</span>. Thus, we suggest you be a bit suspicious of <span class="code">while</span> loops in your code. If there isn't a good justification for a particular <span class="code">while</span> or <span class="code">do-while</span> loop, try to find a way to do the same thing without it.</p>
      <h3 id="sec-for-expressions">7.3 For expressions</h3>
      <p>Scala's <span class="code">for</span> expression is a Swiss army knife of iteration<a id="i-207940604-2"></a>. It lets you combine a few simple ingredients in different ways to express a wide variety of iterations. Simple uses enable common tasks such as iterating through a sequence of integers. More advanced expressions can iterate over multiple collections of different kinds, filter out elements based on arbitrary conditions, and produce new collections.</p>
      <h4>Iteration through collections</h4>
      <p>The simplest thing you can do with <span class="code">for</span> is to iterate through all the elements of a collection. For example, <a href="#lst-listing-file-names">Listing 7.5</a> shows some code that prints out all files in the current directory. The I/O is performed using the Java API. First, we create a <span class="code">java.io.File</span> on the current directory, <span class="code">"."</span>, and call its <span class="code">listFiles</span> method. This method returns an array of <span class="code">File</span> objects, one per directory and file contained in the current directory. We store the resulting array in the <span class="code">filesHere</span> variable.</p>
      <p><a id="lst-listing-file-names"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;filesHere&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">java.io.File</code>(<code class="quotedstring">"."</code>)).listFiles
  <br>  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere)
  &nbsp;&nbsp;&nbsp;&nbsp;println(file)
</pre>
      <h5>Listing 7.5 - Listing files in a directory with a <span class="code">for</span> expression.</h5>
      <p>With the "<span class="code">file</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">filesHere</span>" syntax, which is called a <a href="#g286956243"><em>generator</em></a>, we iterate through the elements of <span class="code">filesHere</span>. In each iteration, a new <span class="code">val</span> named <span class="code">file</span> is initialized with an element value. The compiler infers the type of <span class="code">file</span> to be <span class="code">File</span>, because <span class="code">filesHere</span> is an <span class="code">Array[File]</span>. For each iteration, the body of the <span class="code">for</span> expression, <span class="code">println(file)</span>, will be executed. Because <span class="code">File</span>'s <span class="code">toString</span> method yields the name of the file or directory, the names of all the files and directories in the current directory will be printed.</p>
      <p>The <span class="code">for</span> expression syntax works for any kind of collection, not just arrays.<a href="#footnotemain7-2">[2]</a> One convenient special case is the <span class="code">Range</span> type, which you briefly saw in <a href="#tab-richops">Table 5.4</a> <a href="#tab-richops">here</a>. You can create <span class="code">Range</span>s using syntax like "<span class="code">1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">5</span>" and can iterate through them with a <span class="code">for</span>. Here is a simple example:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">4</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Iteration&nbsp;"</code>&nbsp;+&nbsp;i)
  <code class="output">Iteration&nbsp;1</code>
  <code class="output">Iteration&nbsp;2</code>
  <code class="output">Iteration&nbsp;3</code>
  <code class="output">Iteration&nbsp;4</code>
</pre>
      <p>If you don't want to include the upper bound of the range in the values that are iterated over, use <span class="code">until</span> instead of <span class="code">to</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;until&nbsp;<code class="literal">4</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Iteration&nbsp;"</code>&nbsp;+&nbsp;i)
  <code class="output">Iteration&nbsp;1</code>
  <code class="output">Iteration&nbsp;2</code>
  <code class="output">Iteration&nbsp;3</code>
</pre>
      <p>Iterating through integers like this is common in Scala, but not nearly as much as in other languages. In other languages, you might use this facility to iterate through an array, like this:</p> <pre>  <code class="comment">//&nbsp;Not&nbsp;common&nbsp;in&nbsp;Scala...</code>
  <code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;to&nbsp;filesHere.length&nbsp;-&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;println(filesHere(i))
</pre>
      <p>This <span class="code">for</span> expression introduces a variable <span class="code">i</span>, sets it in turn to each integer between <span class="code">0</span> and <span class="code">filesHere.length</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1</span>, and executes the body of the <span class="code">for</span> expression for each setting of <span class="code">i</span>. For each setting of <span class="code">i</span>, the <span class="code">i</span>'th element of <span class="code">filesHere</span> is extracted and processed.</p>
      <p>The reason this kind of iteration is less common in Scala is that you can just iterate over the collection directly. When you do, your code becomes shorter and you sidestep many of the off-by-one errors that can arise when iterating through arrays. Should you start at 0 or 1? Should you add -1, +1, or nothing to the final index? Such questions are easily answered, but also easily answered wrong. It is safer to avoid such questions entirely.</p>
      <h4>Filtering</h4>
      <p>Sometimes you don't want to iterate through a collection in its entirety;<a id="i1946581356-1"></a> you want to filter it down to some subset. You can do this with a <span class="code">for</span> expression by adding a <a href="#g-1274492040"><em>filter</em></a>, an <span class="code">if</span> clause inside the <span class="code">for</span>'s parentheses. For example, the code shown in <a href="#lst-list-scala-files">Listing 7.6</a> lists only those files in the current directory whose names end with "<span class="texttt">.scala</span>":</p>
      <p><a id="lst-list-scala-files"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;filesHere&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">java.io.File</code>(<code class="quotedstring">"."</code>)).listFiles
  <br>  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(file)
</pre>
      <h5>Listing 7.6 - Finding <span class="code">.scala</span> files using a <span class="code">for</span> with a filter.</h5>
      <p>You could alternatively accomplish the same goal with this code:</p> <pre>  <code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere)
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(file.getName.endsWith(<code class="quotedstring">".scala"</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(file)
</pre>
      <p>This code yields the same output as the previous code, and likely looks more familiar to programmers with an imperative background. The imperative form, however, is only an option because this particular <span class="code">for</span> expression is executed for its printing side-effects and results in the unit value <span class="code">()</span>. As demonstrated later in this section, the <span class="code">for</span> expression is called an "expression" because it can result in an interesting value, a collection whose type is determined by the <span class="code">for</span> expression's <span class="code">&lt;-</span> clauses.</p>
      <p>You can include more filters if you want. Just keep adding <span class="code">if</span> clauses. For example, to be extra defensive, the code in <a href="#lst-list-only-files">Listing 7.7</a> prints only files and not directories. It does so by adding a filter that checks the <span class="code">file</span>'s <span class="code">isFile</span> method.</p>
      <p><a id="lst-list-only-files"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.isFile
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>)
  &nbsp;&nbsp;)&nbsp;println(file)
</pre>
      <h5>Listing 7.7 - Using multiple filters in a <span class="code">for</span> expression.</h5>
      <h4>Nested iteration</h4>
      <p>If you add multiple <span class="code">&lt;-</span> clauses, you will get nested "loops." For example, the <span class="code">for</span> expression shown in <a href="#lst-nested-iteration">Listing 7.8</a> has two nested loops. The outer loop iterates through <span class="code">filesHere</span>, and the inner loop iterates through <span class="code">fileLines(file)</span> for any <span class="code">file</span> that ends with <span class="texttt">.scala</span>.</p>
      <p><a id="lst-nested-iteration"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;fileLines(file:&nbsp;<code class="typename">java.io.File</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;scala.io.Source.fromFile(file).getLines().toArray
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;grep(pattern:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>);
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;&lt;-&nbsp;fileLines(file)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;line.trim.matches(pattern)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;println(s<code class="quotedstring">"$file:&nbsp;${line.trim}"</code>)
  <br>  &nbsp;&nbsp;grep(<code class="quotedstring">".*gcd.*"</code>)
</pre>
      <h5>Listing 7.8 - Using multiple generators in a <span class="code">for</span> expression.</h5>
      <p><a id="exa-for-semicolon-explanation"></a> If you prefer, you can use curly braces instead of parentheses to surround the generators and filters. One advantage to using curly braces is that you can leave off some of the semicolons that are needed when you use parentheses because, as explained in <a href="#sec-semicolon-inf">Section 4.2</a>, the Scala compiler will not infer semicolons while inside parentheses.<a id="i-597205837-1"></a><a id="i-1905470655-1"></a></p>
      <h4>Mid-stream variable bindings</h4>
      <p>Note that the previous code repeats the expression <span class="code">line.trim</span>. This is a non-trivial computation, so you might want to only compute it once. You can do this by binding the result to a new variable using an equals sign (<span class="code">=</span>). The bound variable is introduced and used just like a <span class="code">val</span>, only with the <span class="code">val</span> keyword left out.<a id="i1392088405-1"></a><a id="i31167931-1"></a> <a href="#lst-mid-stream-assignment">Listing 7.9</a> shows an example.</p>
      <p><a id="lst-mid-stream-assignment"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;grep(pattern:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;&lt;-&nbsp;fileLines(file)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trimmed&nbsp;=&nbsp;line.trim
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;trimmed.matches(pattern)&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;println(s<code class="quotedstring">"$file:&nbsp;$trimmed"</code>)
  <br>  &nbsp;&nbsp;grep(<code class="quotedstring">".*gcd.*"</code>)
</pre>
      <h5>Listing 7.9 - Mid-stream assignment in a <span class="code">for</span> expression.</h5>
      <p>In <a href="#lst-mid-stream-assignment">Listing 7.9</a>, a variable named <span class="code">trimmed</span> is introduced halfway through the <span class="code">for</span> expression. That variable is initialized to the result of <span class="code">line.trim</span>. The rest of the <span class="code">for</span> expression then uses the new variable in two places, once in an <span class="code">if</span> and once in <span class="code">println</span>.</p>
      <h4>Producing a new collection</h4>
      <p>While all of the examples so far have operated on the iterated values and then forgotten them, you can also generate a value to remember for each iteration. To do so, you prefix the body of the <span class="code">for</span> expression by the keyword <span class="code">yield</span>.<a id="i1145887345-1"></a> For example, here is a function that identifies the <span class="code">.scala</span> files and stores them in an array:</p> <pre>  <code class="vem">def</code>&nbsp;scalaFiles&nbsp;=
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>)
  &nbsp;&nbsp;}&nbsp;<code class="vem">yield</code>&nbsp;file
</pre>
      <p>Each time the body of the <span class="code">for</span> expression executes, it produces one value, in this case simply <span class="code">file</span>. When the <span class="code">for</span> expression completes, the result will include all of the yielded values contained in a single collection. The type of the resulting collection is based on the kind of collections processed in the iteration clauses. In this case the result is an <span class="code">Array[File]</span>, because <span class="code">filesHere</span> is an array and the type of the yielded expression is <span class="code">File</span>.</p>
      <p>Be careful, by the way, where you place the <span class="code">yield</span> keyword. The syntax of a <span class="code">for</span>-<span class="code">yield</span> expression is like this:</p> <pre>  <code class="vem">for</code>&nbsp;<i>clauses</i>&nbsp;<code class="vem">yield</code>&nbsp;<i>body</i>
</pre>
      <p>The <span class="code">yield</span> goes before the entire body. Even if the body is a block surrounded by curly braces, put the <span class="code">yield</span> before the first curly brace, not before the last expression of the block. Avoid the temptation to write things like this:</p> <pre>  <code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>))&nbsp;{
  &nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file&nbsp;&nbsp;<code class="comment">//&nbsp;Syntax&nbsp;error!</code>
  }
</pre>
      <p>For example, the <span class="code">for</span> expression shown in <a href="#lst-transforming-an-array">Listing 7.10</a> first transforms the <span class="code">Array[File]</span> named <span class="code">filesHere</span>, which contains all files in the current directory, to one that contains only <span class="code">.scala</span> files. For each of these it generates an <span class="code">Array[String]</span>, the result of the <span class="code">fileLines</span> method, whose definition is shown in <a href="#lst-nested-iteration">Listing 7.8</a>. Each element of this <span class="code">Array[String]</span> contains one line from the current file bring processed. This Array[String] containing lines is transformed into another <span class="code">Array[String]</span> containing only trimmed lines that include the substring <span class="code">"for"</span>. Finally, for each of these, an integer length is yielded. The result of this <span class="code">for</span> expression is an <span class="code">Array[Int]</span> containing those lengths.</p>
      <p><a id="lst-transforming-an-array"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;forLineLengths&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;&lt;-&nbsp;filesHere
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(<code class="quotedstring">".scala"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;&lt;-&nbsp;fileLines(file)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trimmed&nbsp;=&nbsp;line.trim
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;trimmed.matches(<code class="quotedstring">".*for.*"</code>)&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">yield</code>&nbsp;trimmed.length
</pre>
      <h5>Listing 7.10 - Transforming an <span class="code">Array[File]</span> to <span class="code">Array[Int]</span> with a <span class="code">for</span>.</h5>
      <p>At this point, you have seen all the major features of Scala's <span class="code">for</span> expression, but we went through them rather quickly. A more thorough coverage of <span class="code">for</span> expressions is given in <a href="#chap-for-expressions-revisited.html">Chapter 23</a>.</p>
      <h3 id="sec-try-expressions">7.4 Exception handling with <span class="code">try</span> expressions</h3>
      <p>Scala's exceptions behave just like in many other languages.<a id="i668047766-1"></a><a id="i-60007022-1"></a> Instead<a id="i147418614-1"></a> of returning a value in the normal way, a method can terminate by throwing an exception. The method's caller can either catch and handle that exception, or it can itself simply terminate, in which case the exception propagates to the caller's caller. The exception propagates in this way, unwinding the call stack, until a method<a id="i2050330638-1"></a> handles it or there are no more methods left.</p>
      <h4>Throwing exceptions</h4>
      <p>Throwing an exception in Scala looks the same as in Java. You create an exception object and then throw it with the <span class="code">throw</span> keyword:</p> <pre>  <code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>
</pre>
      <p>Although it may seem somewhat paradoxical, in Scala, <span class="code">throw</span> is an expression that has a result type.<a id="i44952225-1"></a><a id="i958036312-1"></a> Here's an example where result type matters:</p> <pre>  <code class="vem">val</code>&nbsp;half&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;/&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">RuntimeException</code>(<code class="quotedstring">"n&nbsp;must&nbsp;be&nbsp;even"</code>)
</pre>
      <p>What happens here is that if <span class="code">n</span> is even, <span class="code">half</span> will be initialized to half of <span class="code">n</span>. If <span class="code">n</span> is not even, an exception will be thrown before <span class="code">half</span> can be initialized to anything at all. Because of this, it is safe to treat a thrown exception as any kind of value whatsoever. Any context that tries to use the return from a <span class="code">throw</span> will never get to do so, and thus no harm will come.</p>
      <p>Technically, an exception throw has type <span class="code">Nothing</span>. You can use a <span class="code">throw</span> as an expression even though it will never actually evaluate to anything. This little bit of technical gymnastics might sound weird, but is frequently useful in cases like the previous example. One branch of an <span class="code">if</span> computes a value, while the other throws an exception and computes <span class="code">Nothing</span>. The type of the whole <span class="code">if</span> expression is then the type of that branch which does compute something. Type <span class="code">Nothing</span> is discussed further in <a href="#sec-bottom-types">Section 11.3</a>.</p>
      <h4>Catching exceptions</h4>
      <p>You catch exceptions using the syntax shown in <a href="#lst-try-catch-syntax">Listing 7.11</a> The syntax for <span class="code">catch</span> clauses was chosen for its consistency with an important part of Scala: <em>pattern matching</em>.<a id="i-2116566913-1"></a> Pattern matching, a powerful feature, is described briefly in this chapter and in more detail in <a href="#chap-case-classes-and-pattern-matching">Chapter 15</a><a id="i692796846-1"></a>.</p>
      <p><a id="lst-try-catch-syntax"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.io.FileReader
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.io.FileNotFoundException
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.io.IOException
  <br>  &nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">FileReader</code>(<code class="quotedstring">"input.txt"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Use&nbsp;and&nbsp;close&nbsp;file</code>
  &nbsp;&nbsp;}&nbsp;<code class="vem">catch</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">FileNotFoundException</code>&nbsp;=&gt;&nbsp;<code class="comment">//&nbsp;Handle&nbsp;missing&nbsp;file</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">IOException</code>&nbsp;=&gt;&nbsp;<code class="comment">//&nbsp;Handle&nbsp;other&nbsp;I/O&nbsp;error</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 7.11 - A <span class="code">try-catch</span> clause in Scala.</h5>
      <p>The behavior of this <span class="code">try</span>-<span class="code">catch</span> expression is the same as in other<a id="i-1329663144-1"></a> languages with exceptions. The body is executed, and if it throws an exception, each <span class="code">catch</span> clause is tried in turn. In this example, if the exception is of type <span class="code">FileNotFoundException</span>, the first clause will execute. If it is of type <span class="code">IOException</span>, the second clause will execute. If the exception is of neither type, the <span class="code">try</span>-<span class="code">catch</span> will terminate and the exception will propagate further.</p>
      <div class="note">
        <h4>Note</h4> One difference you'll quickly notice in Scala is that, unlike Java, Scala does not require you to catch checked exceptions or declare them in a throws clause. You can declare a throws clause if you wish with the <span class="code">@</span><span class="code">throws</span> annotation, but it is not required. See<a id="i1490895901-1"></a> <a href="#sec-annotations">Section 31.2</a> for more information on <span class="code">@</span><span class="code">throws</span>.
      </div>
      <h4>The <span class="code">finally</span> clause</h4>
      <p>You can wrap an expression with a <span class="code">finally</span> clause if you want to cause some code to execute no matter how the expression terminates.<a id="i-86518969-1"></a> For example, you might want to be sure an open file gets closed even if a method exits by throwing an exception. <a href="#lst-try-finally-syntax">Listing 7.12</a> shows an example.<a href="#footnotemain7-3">[3]</a></p>
      <p><a id="lst-try-finally-syntax"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.io.FileReader
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;file&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">FileReader</code>(<code class="quotedstring">"input.txt"</code>)
  &nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Use&nbsp;the&nbsp;file</code>
  &nbsp;&nbsp;}&nbsp;<code class="vem">finally</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;file.close()&nbsp;&nbsp;<code class="comment">//&nbsp;Be&nbsp;sure&nbsp;to&nbsp;close&nbsp;the&nbsp;file</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 7.12 - A <span class="code">try-finally</span> clause in Scala.</h5>
      <div class="note">
        <h4>Note</h4>
        <p><a href="#lst-try-finally-syntax">Listing 7.12</a> shows the idiomatic way to ensure a non-memory resource, such as a file, socket, or database connection, is closed. First you acquire the resource. Then you start a <span class="code">try</span> block in which you use the resource. Lastly, you close the resource in a <span class="code">finally</span> block. This idiom is the same in Scala as in Java; alternatively, in Scala you can employ a technique called the <em>loan pattern</em><a id="i-531276704-1"></a><a id="i850457101-1"></a> to achieve the same goal more concisely. The loan pattern will be described in <a href="#sec-control-structures">Section 9.4</a>.<a id="i-1122723055-1"></a><a id="i-330150415-1"></a><a id="i193663324-1"></a></p>
      </div>
      <h4>Yielding a value</h4>
      <p>As with most other Scala control structures, <span class="code">try</span>-<span class="code">catch</span>-<span class="code">finally</span> results in a value. For example, <a href="#lst-catch-yielding-value">Listing 7.13</a> shows how you can try to parse a URL but use a default value if the URL is badly formed. The result is that of the <span class="code">try</span> clause if no exception is thrown, or the relevant <span class="code">catch</span> clause if an exception is thrown and caught. If an exception is thrown but not caught, the expression has no result at all. The value computed in the <span class="code">finally</span> clause, if there is one, is dropped. Usually <span class="code">finally</span> clauses do some kind of clean up, such as closing a file. Normally, they should not change the value computed in the main body or a <span class="code">catch</span> clause of the <span class="code">try</span>.</p>
      <p><a id="lst-catch-yielding-value"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.net.URL
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.net.MalformedURLException
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;urlFor(path:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;URL(path)
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">catch</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;e:&nbsp;<code class="typename">MalformedURLException</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;URL(<code class="quotedstring">"http://www.scala-lang.org"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>
      <h5>Listing 7.13 - A <span class="code">catch</span> clause that yields a value.</h5>
      <p>If you're familiar with Java, it's worth noting that Scala's behavior differs from Java only because Java's <span class="code">try-finally</span> does not result in a value. As in Java, if a <span class="code">finally</span> clause includes an explicit return statement, or throws an exception, that return value or exception will "overrule" any previous one that originated in the <span class="code">try</span> block or one of its <span class="code">catch</span> clauses. For example, given this, rather contrived, function definition:</p> <pre>  <code class="vem">def</code>&nbsp;f():&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="vem">try</code>&nbsp;<code class="vem">return</code>&nbsp;<code class="literal">1</code>&nbsp;<code class="vem">finally</code>&nbsp;<code class="vem">return</code>&nbsp;<code class="literal">2</code>
</pre>
      <p>calling <span class="code">f()</span> results in 2. By contrast, given:</p> <pre>  <code class="vem">def</code>&nbsp;g():&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="vem">try</code>&nbsp;<code class="literal">1</code>&nbsp;<code class="vem">finally</code>&nbsp;<code class="literal">2</code>
</pre>
      <p>calling <span class="code">g()</span> results in 1. Both of these functions exhibit behavior that could surprise most programmers, so it's usually best to avoid returning values from <span class="code">finally</span> clauses. The best way to think of <span class="code">finally</span> clauses is as a way to ensure some side effect happens, such as closing an open file.</p>
      <h3 id="sec-match-expressions">7.5 Match expressions</h3>
      <p>Scala's <span class="code">match</span> expression lets you select from a number of <a href="#g-196794451"><em>alternatives</em></a>,<a id="i1524854239-1"></a> just like <span class="code">switch</span> statements<a id="i-1502876100-1"></a> in other languages. In general a <span class="code">match</span> expression lets you select using arbitrary <em>patterns</em>, which will be described in <a href="#chap-case-classes-and-pattern-matching">Chapter 15</a>. The general form can wait. For now, just consider using <span class="code">match</span> to select among a number of alternatives.<a id="i-440612313-1"></a><a id="i-1073471110-1"></a></p>
      <p>As an example, the script in <a href="#lst-match-with-side-effects">Listing 7.14</a> reads a food name from the argument list and prints a companion to that food. This <span class="code">match</span> expression examines <span class="code">firstArg</span>, which has been set to the first argument out of the argument list. If it is the string <span class="code">"salt"</span>, it prints <span class="code">"pepper"</span>, while if it is the string <span class="code">"chips"</span>, it prints <span class="code">"salsa"</span>, and so on. The default case is specified with an underscore (<span class="code">_</span>), a wildcard symbol frequently used in Scala as a placeholder for a completely unknown value<a id="i2028498488-1"></a>.</p>
      <p><a id="lst-match-with-side-effects"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;firstArg&nbsp;=&nbsp;<code class="vem">if</code>&nbsp;(args.length&nbsp;&gt;&nbsp;<code class="literal">0</code>)&nbsp;args(<code class="literal">0</code>)&nbsp;<code class="vem">else</code>&nbsp;<code class="quotedstring">""</code>
  <br>  &nbsp;&nbsp;firstArg&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"salt"</code>&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"pepper"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"chips"</code>&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"salsa"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"eggs"</code>&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"bacon"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"huh?"</code>)
  &nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</pre>
      <h5>Listing 7.14 - A <span class="code">match</span> expression with side effects.</h5>
      <p>There are a few important differences from Java's <span class="code">switch</span> statement. One is that any kind of constant, as well as other things, can be used in cases in Scala, not just the integer-type, enum, and string constants of Java's case statements. In <a href="#lst-match-with-side-effects">Listing 7.14</a>, the alternatives are strings. Another difference is that there are no <span class="code">break</span>s<a id="i544483331-1"></a> at the end of each alternative. Instead the <span class="code">break</span> is implicit, and there is no fall through from one alternative to the next. The common case—not falling through—becomes shorter, and a source of errors is avoided because programmers can no longer fall through by accident.<a id="i1689875656-1"></a></p>
      <p>The most significant difference from Java's <span class="code">switch</span>, however, may be that <span class="code">match</span> expressions result in a value. In the previous example, each alternative in the <span class="code">match</span> expression prints out a value. It would work just as well to yield the value rather than print it, as shown in <a href="#lst-match-expression">Listing 7.15</a>. The value that results from this <span class="code">match</span> expression is stored in the <span class="code">friend</span> variable. Aside from the code getting shorter (in number of tokens anyway), the code now disentangles two separate concerns: first it chooses a food and then prints it.</p>
      <p><a id="lst-match-expression"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;firstArg&nbsp;=&nbsp;<code class="vem">if</code>&nbsp;(!args.isEmpty)&nbsp;args(<code class="literal">0</code>)&nbsp;<code class="vem">else</code>&nbsp;<code class="quotedstring">""</code>
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;friend&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;firstArg&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"salt"</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"pepper"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"chips"</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"salsa"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"eggs"</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"bacon"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="quotedstring">"huh?"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <br>  &nbsp;&nbsp;println(friend)
</pre>
      <h5>Listing 7.15 - A <span class="code">match</span> expression that yields a value.</h5>
      <h3>7.6 Living without <span class="code">break</span> and <span class="code">continue</span><a id="i656795516-1"></a><a id="i1665067476-1"></a></h3>
      <p>You may have noticed that there has been no mention of <span class="code">break</span> or <span class="code">continue</span>. Scala leaves out these commands because they do not mesh well with function literals, a feature described in the next chapter. It is clear what <span class="code">continue</span> means inside a <span class="code">while</span> loop, but what would it mean inside a function literal? While Scala supports both imperative and functional styles of programming, in this case it leans slightly towards functional programming in exchange for simplifying the language. Do not worry, though. There are many ways to program without <span class="code">break</span> and <span class="code">continue</span>, and if you take advantage of function literals, those alternatives can often be shorter than the original code.</p>
      <p>The simplest approach is to replace every <span class="code">continue</span> by an <span class="code">if</span> and every <span class="code">break</span> by a boolean variable. The boolean variable indicates whether the enclosing <span class="code">while</span> loop should continue. For example, suppose you are searching through an argument list for a string that ends with "<span class="code">.scala</span>" but does not start with a hyphen. In Java you could—if you were quite fond of <span class="code">while</span> loops, <span class="code">break</span>, and <span class="code">continue</span>—write the following:</p> <pre>  int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;This&nbsp;is&nbsp;Java
  boolean&nbsp;foundIt&nbsp;=&nbsp;false;
  while&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;if&nbsp;(args[i].startsWith("-"))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1;
  &nbsp;&nbsp;&nbsp;&nbsp;continue;
  &nbsp;&nbsp;}
  &nbsp;&nbsp;if&nbsp;(args[i].endsWith(".scala"))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;foundIt&nbsp;=&nbsp;true;
  &nbsp;&nbsp;&nbsp;&nbsp;break;
  &nbsp;&nbsp;}
  &nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1;
  }
</pre>
      <p>To transliterate this Java code directly to Scala, instead of doing an <span class="code">if</span> and then a <span class="code">continue</span>, you could write an <span class="code">if</span> that surrounds the entire remainder of the <span class="code">while</span> loop. To get rid of the <span class="code">break</span>, you would normally add a boolean variable indicating whether to keep going, but in this case you can reuse <span class="code">foundIt</span>. Using both of these tricks, the code ends up looking as shown in <a href="#lst-looping-without">Listing 7.16</a>.</p>
      <p><a id="lst-looping-without"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;foundIt&nbsp;=&nbsp;<code class="vem">false</code>
  <br>  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(i&nbsp;&lt;&nbsp;args.length&nbsp;&amp;&amp;&nbsp;!foundIt)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(!args(i).startsWith(<code class="quotedstring">"-"</code>))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(args(i).endsWith(<code class="quotedstring">".scala"</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foundIt&nbsp;=&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 7.16 - Looping without <span class="code">break</span> or <span class="code">continue</span>.</h5>
      <p>This Scala code in <a href="#lst-looping-without">Listing 7.16</a> is quite similar to the original Java code. All the basic pieces are still there and in the same order. There are two reassignable variables and a <span class="code">while</span> loop. Inside the loop, there is a test that <span class="code">i</span> is less than <span class="code">args.length</span>, a check for <span class="code">"-"</span>, and a check for <span class="code">".scala"</span>.</p>
      <p>If you wanted to get rid of the <span class="code">var</span>s in <a href="#lst-looping-without">Listing 7.16</a>, one approach you could try is to rewrite the loop as a recursive function. You could, for example, define a <span class="code">searchFrom</span> function that takes an integer as an input, searches forward from there, and then returns the index of the desired argument. Using this technique the code would look as shown in <a href="#lst-recursive-approach">Listing 7.17</a>:</p>
      <p><a id="lst-recursive-approach"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;searchFrom(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(i&nbsp;&gt;=&nbsp;args.length)&nbsp;-<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="vem">if</code>&nbsp;(args(i).startsWith(<code class="quotedstring">"-"</code>))&nbsp;searchFrom(i&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="vem">if</code>&nbsp;(args(i).endsWith(<code class="quotedstring">".scala"</code>))&nbsp;i
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;searchFrom(i&nbsp;+&nbsp;<code class="literal">1</code>)
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;i&nbsp;=&nbsp;searchFrom(<code class="literal">0</code>)
</pre>
      <h5>Listing 7.17 - A recursive alternative to looping with <span class="code">var</span>s.</h5>
      <p>The version in <a href="#lst-recursive-approach">Listing 7.17</a> gives a human-meaningful name to what the function does, and it uses recursion to substitute for looping. Each <span class="code">continue</span> is replaced by a recursive call with <span class="code">i</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span> as the argument, effectively skipping to the next integer. Many people find this style of programming easier to understand, once they get used to the recursion.</p>
      <div class="note">
        <h4>Note</h4>
        <p>The Scala compiler will not actually emit a recursive function for the code shown in <a href="#lst-recursive-approach">Listing 7.17</a>. Because all of the recursive calls are in <em>tail-call</em> position, the compiler will generate code similar to a <span class="code">while</span> loop. Each recursive call will be implemented as a jump back to the beginning of the function. Tail-call optimization is discussed in <a href="#sec-tail-recursion">Section 8.9</a>.</p>
      </div>
      <p>If after all this discussion you still feel the need to use <span class="code">break</span>, there's help in Scala's standard library. Class <span class="code">Breaks</span><a id="i1129777612-1"></a> in package <span class="code">scala.util.control</span> offers a <span class="code">break</span> method,<a id="i1125528421-1"></a> which can be used to exit an enclosing block that's marked with <span class="code">breakable</span>.<a id="i168968267-1"></a> Here is an example how this library-supplied <span class="code">break</span> method could be applied:</p> <pre>  <code class="vem">import</code>&nbsp;scala.util.control.Breaks._
  <code class="vem">import</code>&nbsp;java.io._
  <br>  <code class="vem">val</code>&nbsp;in&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BufferedReader</code>(<code class="vem">new</code>&nbsp;<code class="typename">InputStreamReader</code>(System.in))
  <br>  breakable&nbsp;{
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(<code class="vem">true</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"?&nbsp;"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(in.readLine()&nbsp;==&nbsp;<code class="quotedstring">""</code>)&nbsp;break
  &nbsp;&nbsp;}
  }
</pre>
      <p>This will repeatedly read non-empty lines from the standard input. Once the user enters an empty line, control flow exits from the enclosing <span class="code">breakable</span>, and with it the while loop.</p>
      <p>The <span class="code">Breaks</span> class implements <span class="code">break</span> by throwing an exception that is caught by an enclosing application of the <span class="code">breakable</span> method. Therefore, the call to <span class="code">break</span> does not need to be in the same method as the call to <span class="code">breakable</span>.</p>
      <h3 id="sec-variable-scope">7.7 Variable scope</h3>
      <p>Now that you've seen Scala's built-in<a id="i46504593-1"></a><a id="i-250564140-1"></a> control structures, we'll use them in this section to explain how scoping works in Scala.</p>
      <div class="pointofinterest">
        <h3>Fast track for Java programmers</h3>
        <p>If you're a Java programmer, you'll find that Scala's scoping rules are almost identical to Java's. One difference between Java and Scala is that Scala allows you to define variables of the same name in nested scopes. So if you're a Java programmer, you may wish to at least skim this section.</p>
      </div>
      <p>Variable declarations in Scala programs have a <em>scope</em> that defines where you can use the name. The most common example of scoping is that curly braces generally introduce a new<a id="i-1385018222-1"></a><a id="i32772000-1"></a> scope, so anything defined inside curly braces leaves scope after the final closing brace.<a href="#footnotemain7-4">[4]</a> As an illustration, consider the function shown in <a href="#lst-first-multi-table">Listing 7.18</a>.</p>
      <p><a id="lst-first-multi-table"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;printMultiTable()&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;only&nbsp;i&nbsp;in&nbsp;scope&nbsp;here</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(i&nbsp;&lt;=&nbsp;<code class="literal">10</code>)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;j&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;both&nbsp;i&nbsp;and&nbsp;j&nbsp;in&nbsp;scope&nbsp;here</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(j&nbsp;&lt;=&nbsp;<code class="literal">10</code>)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;prod&nbsp;=&nbsp;(i&nbsp;*&nbsp;j).toString
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;i,&nbsp;j,&nbsp;and&nbsp;prod&nbsp;in&nbsp;scope&nbsp;here</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;k&nbsp;=&nbsp;prod.length
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;i,&nbsp;j,&nbsp;prod,&nbsp;and&nbsp;k&nbsp;in&nbsp;scope&nbsp;here</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(k&nbsp;&lt;&nbsp;<code class="literal">4</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">"&nbsp;"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(prod)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;i&nbsp;and&nbsp;j&nbsp;still&nbsp;in&nbsp;scope;&nbsp;prod&nbsp;and&nbsp;k&nbsp;out&nbsp;of&nbsp;scope</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;i&nbsp;still&nbsp;in&nbsp;scope;&nbsp;j,&nbsp;prod,&nbsp;and&nbsp;k&nbsp;out&nbsp;of&nbsp;scope</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 7.18 - Variable scoping when printing a multiplication table.</h5>
      <p>The <span class="code">printMultiTable</span> function shown in <a href="#lst-first-multi-table">Listing 7.18</a> prints out a multiplication table.<a href="#footnotemain7-5">[5]</a> The first statement of this function introduces a variable named <span class="code">i</span> and initializes it to the integer 1. You can then use the name <span class="code">i</span> for the remainder of the function.</p>
      <p>The next statement in <span class="code">printMultiTable</span> is a <span class="code">while</span> loop:</p> <pre>  <code class="vem">while</code>&nbsp;(i&nbsp;&lt;=&nbsp;<code class="literal">10</code>)&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;j&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;...
  }
</pre>
      <p>You can use <span class="code">i</span> here because it is still in scope. In the first statement inside that <span class="code">while</span> loop, you introduce another variable, this time named <span class="code">j</span>, and again initialize it to 1. Because the variable <span class="code">j</span> was defined inside the open curly brace of the <span class="code">while</span> loop, it can be used only within that <span class="code">while</span> loop. If you were to attempt to do something with <span class="code">j</span> after the closing curly brace of this <span class="code">while</span> loop, after the comment that says <span class="code">j</span>, <span class="code">prod</span>, and <span class="code">k</span> are out of scope, your program would not compile.</p>
      <p>All variables defined in this example—<span class="code">i</span>, <span class="code">j</span>, <span class="code">prod</span>, and <span class="code">k</span>—are <em>local variables</em>.<a id="i1400207106-1"></a><a id="i40385448-1"></a> Such variables are "local" to the function in which they are defined. Each time a function is invoked, a new set of its local variables is used.</p>
      <p>Once a variable is defined, you can't define a new variable with the same name in the same scope. For example, the following script with two variables named <span class="code">a</span> in the same scope would not compile:</p> <pre>  <code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">1</code>
  <code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;<code class="comment">//&nbsp;Does&nbsp;not&nbsp;compile</code>
  println(a)
</pre>
      <p>You can, on the other hand, define a variable in an inner scope that has the same name as a variable in an outer scope. The following script would compile and run:</p> <pre>  <code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">1</code>;
  {
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;<code class="comment">//&nbsp;Compiles&nbsp;just&nbsp;fine</code>
  &nbsp;&nbsp;println(a)
  }
  println(a)
</pre>
      <p>When executed, the script shown previously would print 2 then 1, because the <span class="code">a</span> defined inside the curly braces is a different variable, which is in scope only until the closing curly brace.<a href="#footnotemain7-6">[6]</a> One difference to note between Scala and Java is that Java will not let you create a variable in an inner scope that has the same name as a variable in an outer scope. In a Scala program, an inner variable is said to <em>shadow</em> a like-named outer variable, because the outer variable becomes invisible in the inner scope.<a id="i1857790361-1"></a><a id="i-1451425665-1"></a><a id="i-141883422-1"></a></p>
      <p>You might have already noticed something that looks like shadowing in the interpreter:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">1</code>
  <code class="output">a:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">2</code>
  <code class="output">a:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;println(a)
  <code class="output">2</code>
</pre>
      <p>In the interpreter, you can reuse variable names to your heart's content. Among other things, this allows you to change your mind if you made a mistake when you defined a variable the first time in the interpreter. You can do this because conceptually the interpreter creates a new nested scope for each new statement you type in. Thus, you could visualize the previous interpreted code like this:</p> <pre>  <code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">1</code>;
  {
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="literal">2</code>;
  &nbsp;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(a)
  &nbsp;&nbsp;}
  }
</pre>
      <p>This code will compile and run as a Scala script, and like the code typed into the interpreter, will print 2. Keep in mind that such code can be very confusing to readers, because variable names adopt new meanings in nested scopes. It is usually better to choose a new, meaningful variable name rather than to shadow an outer variable.</p>
      <h3 id="sec-refactoring-imperative-code">7.8 Refactoring imperative-style code</h3>
      <p>To help you gain insight into the functional style, in this section we'll refactor the imperative approach to printing a multiplication table shown in<a id="i892284799-1"></a> <a href="#lst-first-multi-table">Listing 7.18</a>.<a id="i-2064017764-1"></a><a id="i-496550431-1"></a> Our functional alternative is shown in <a href="#lst-second-multi-table">Listing 7.19</a>.</p>
      <p><a id="lst-second-multi-table"></a></p> <pre>  &nbsp;&nbsp;<code class="comment">//&nbsp;Returns&nbsp;a&nbsp;row&nbsp;as&nbsp;a&nbsp;sequence</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;makeRowSeq(row:&nbsp;<code class="typename">Int</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(col&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)&nbsp;<code class="vem">yield</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;prod&nbsp;=&nbsp;(row&nbsp;*&nbsp;col).toString
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;padding&nbsp;=&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;*&nbsp;(<code class="literal">4</code>&nbsp;-&nbsp;prod.length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding&nbsp;+&nbsp;prod
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;Returns&nbsp;a&nbsp;row&nbsp;as&nbsp;a&nbsp;string</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;makeRow(row:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;makeRowSeq(row).mkString
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;Returns&nbsp;table&nbsp;as&nbsp;a&nbsp;string&nbsp;with&nbsp;one&nbsp;row&nbsp;per&nbsp;line</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;multiTable()&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;tableSeq&nbsp;=&nbsp;<code class="comment">//&nbsp;a&nbsp;sequence&nbsp;of&nbsp;row&nbsp;strings</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;makeRow(row)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;tableSeq.mkString(<code class="quotedstring">"\n"</code>)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 7.19 - A functional way to create a multiplication table.</h5>
      <p>The imperative style reveals itself in <a href="#lst-first-multi-table">Listing 7.18</a> in two ways. First, invoking <span class="code">printMultiTable</span> has a side effect: printing a multiplication table to the standard output. In <a href="#lst-second-multi-table">Listing 7.19</a>, we refactored the function so that it returns the multiplication table as a string. Since the function no longer prints, we renamed it <span class="code">multiTable</span>. As mentioned previously, one advantage of side-effect-free functions is they are easier to unit test.<a id="i-2030836876-2"></a><a id="i808305838-1"></a> To test <span class="code">printMultiTable</span>, you would need to somehow redefine <span class="code">print</span> and <span class="code">println</span> so you could check the output for correctness. You could test <span class="code">multiTable</span> more easily by checking its string result.</p>
      <p>The other telltale sign of the imperative style in <span class="code">printMultiTable</span> is its <span class="code">while</span> loop and <span class="code">var</span>s. By contrast, the <span class="code">multiTable</span> function uses <span class="code">val</span>s, <span class="code">for</span> expressions, <a href="#g-59832310"><em>helper functions</em></a>, and calls to <span class="code">mkString</span>.</p>
      <p>We factored out the two helper functions, <span class="code">makeRow</span> and <span class="code">makeRowSeq</span>, to make the code easier to read. Function <span class="code">makeRowSeq</span> uses a <span class="code">for</span> expression whose generator iterates through column numbers 1 through 10. The body of this <span class="code">for</span> calculates the product of row and column, determines the padding needed for the product, and yields the result of concatenating the padding and product strings. The result of the <span class="code">for</span> expression will be a sequence (some subclass of <span class="code">scala.Seq</span>) containing these yielded strings as elements. The other helper function, <span class="code">makeRow</span>, simply invokes <span class="code">mkString</span> on the result returned by <span class="code">makeRowSeq</span>. <span class="code">mkString</span> will concatenate the strings in the sequence and return them as one string.</p>
      <p>The <span class="code">multiTable</span> method first initializes <span class="code">tableSeq</span> with the result of a <span class="code">for</span> expression whose generator iterates through row numbers 1 to 10, and for each calls <span class="code">makeRow</span> to get the string for that row. This string is yielded; thus the result of this <span class="code">for</span> expression will be a sequence of row strings. The only remaining task is to convert the sequence of strings into a single string. The call to <span class="code">mkString</span> accomplishes this, and because we pass <span class="code">"\n"</span>, we get an end of line character inserted between each string. If you pass the string returned by <span class="code">multiTable</span> to <span class="code">println</span>, you'll see the same output that's produced by calling <span class="code">printMultiTable</span>.</p>
      <div style="text-align: center">
        <p><span class="code">&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10</span><br> <span class="code">&nbsp;2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;10&nbsp;&nbsp;12&nbsp;&nbsp;14&nbsp;&nbsp;16&nbsp;&nbsp;18&nbsp;&nbsp;20</span><br> <span class="code">&nbsp;3&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;12&nbsp;&nbsp;15&nbsp;&nbsp;18&nbsp;&nbsp;21&nbsp;&nbsp;24&nbsp;&nbsp;27&nbsp;&nbsp;30</span><br> <span class="code">&nbsp;4&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;12&nbsp;&nbsp;16&nbsp;&nbsp;20&nbsp;&nbsp;24&nbsp;&nbsp;28&nbsp;&nbsp;32&nbsp;&nbsp;36&nbsp;&nbsp;40</span><br> <span class="code">&nbsp;5&nbsp;&nbsp;10&nbsp;&nbsp;15&nbsp;&nbsp;20&nbsp;&nbsp;25&nbsp;&nbsp;30&nbsp;&nbsp;35&nbsp;&nbsp;40&nbsp;&nbsp;45&nbsp;&nbsp;50</span><br> <span class="code">&nbsp;6&nbsp;&nbsp;12&nbsp;&nbsp;18&nbsp;&nbsp;24&nbsp;&nbsp;30&nbsp;&nbsp;36&nbsp;&nbsp;42&nbsp;&nbsp;48&nbsp;&nbsp;54&nbsp;&nbsp;60</span><br> <span class="code">&nbsp;7&nbsp;&nbsp;14&nbsp;&nbsp;21&nbsp;&nbsp;28&nbsp;&nbsp;35&nbsp;&nbsp;42&nbsp;&nbsp;49&nbsp;&nbsp;56&nbsp;&nbsp;63&nbsp;&nbsp;70</span><br> <span class="code">&nbsp;8&nbsp;&nbsp;16&nbsp;&nbsp;24&nbsp;&nbsp;32&nbsp;&nbsp;40&nbsp;&nbsp;48&nbsp;&nbsp;56&nbsp;&nbsp;64&nbsp;&nbsp;72&nbsp;&nbsp;80</span><br> <span class="code">&nbsp;9&nbsp;&nbsp;18&nbsp;&nbsp;27&nbsp;&nbsp;36&nbsp;&nbsp;45&nbsp;&nbsp;54&nbsp;&nbsp;63&nbsp;&nbsp;72&nbsp;&nbsp;81&nbsp;&nbsp;90</span><br> <span class="code">10&nbsp;&nbsp;20&nbsp;&nbsp;30&nbsp;&nbsp;40&nbsp;&nbsp;50&nbsp;&nbsp;60&nbsp;&nbsp;70&nbsp;&nbsp;80&nbsp;&nbsp;90&nbsp;100</span><br></p>
      </div>
      <h3>7.9 Conclusion</h3>
      <p>Scala's built-in control structures are minimal, but they do the job. They act much like their imperative equivalents, but because they tend to result in a value, they support a functional style, too. Just as important, they are careful in what they omit, thus leaving room for one of Scala's most powerful features, the function literal, which will be described in the next chapter.</p>
      <hr>
      <h4>Footnotes for Chapter 7:</h4>
      <p><a id="footnotemain7-1"></a>[1] The <span class="code">gcd</span> function shown in <a href="#lst-gcd-recursive">Listing 7.4</a> uses the same approach used by the like-named function, first shown in <a href="#lst-private-members">Listing 6.3</a>, to calculate greatest common divisors for class <span class="code">Rational</span>. The main difference is that instead of <span class="code">Int</span>s the <span class="code">gcd</span> of <a href="#lst-gcd-recursive">Listing 7.4</a> works with <span class="code">Long</span>s.</p>
      <p><a id="footnotemain7-2"></a>[2] To be precise, the expression to the right of the <span class="code">&lt;-</span> symbol in a <span class="code">for</span> expression can be any type that has certain methods (in this case <span class="code">foreach</span>) with appropriate signatures. Details on how the Scala compiler processes <span class="code">for</span> expressions are described in <a href="#chap-for-expressions-revisited.html">Chapter 23</a>.</p>
      <p><a id="footnotemain7-3"></a>[3] Although you must always surround the <span class="code">case</span> statements of a <span class="code">catch</span> clause in curly braces, <span class="code">try</span> and <span class="code">finally</span> do not require curly braces if they contain only one expression. For example, you could write: <span class="code">try</span>&nbsp;<span class="code">t()</span>&nbsp;<span class="code">catch</span>&nbsp;<span class="code">{</span>&nbsp;<span class="code">case</span>&nbsp;<span class="code">e:</span>&nbsp;<span class="code">Exception</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">...</span>&nbsp;<span class="code">}</span>&nbsp;<span class="code">finally</span>&nbsp;<span class="code">f()</span>.</p>
      <p><a id="footnotemain7-4"></a>[4] There are a few exceptions to this rule because in Scala you can sometimes use curly braces in place of parentheses. One example of this kind of curly-brace use is the alternative <span class="code">for</span> expression syntax described in <a href="#sec-for-expressions">Section 7.3</a>.</p>
      <p><a id="footnotemain7-5"></a>[5] The <span class="code">printMultiTable</span> function shown in <a href="#lst-first-multi-table">Listing 7.18</a> is written in an imperative style. We'll refactor it into a functional style in the next section.</p>
      <p><a id="footnotemain7-6"></a>[6] By the way, the semicolon is required in this case after the first definition of <span class="code">a</span> because Scala's semicolon inference mechanism will not place one there.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-functions-and-closures">Chapter 8</a></h2>
      <h1>Functions and Closures</h1>
      <p>When programs get larger, you need some way to divide them into smaller, more manageable pieces. For dividing up control flow, Scala offers an approach familiar to all experienced programmers: divide the code into functions. In fact, Scala offers several ways to define functions that are not present in Java. Besides methods, which are functions that are members of some object, there are also functions nested within functions, function literals, and function values. This chapter takes you on a tour through all of these flavors of functions in Scala.</p>
      <h3>8.1 Methods</h3>
      <p>The most common way to define a function is as a member of some object; such a function is called a <span style="font-style:italic">method</span><a id="i955534258-2"></a>. As an example, <a href="#lst-longlines-methods">Listing 8.1</a> shows two methods that together read a file with a given name and print out all lines whose length exceeds a given width. Every printed line is prefixed with the name of the file it appears in.</p>
      <p><a id="lst-longlines-methods"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.io.Source
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">LongLines</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;processFile(filename:&nbsp;<code class="typename">String</code>,&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;source&nbsp;=&nbsp;Source.fromFile(filename)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;source.getLines())&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processLine(filename,&nbsp;width,&nbsp;line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;processLine(filename:&nbsp;<code class="typename">String</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;<code class="typename">Int</code>,&nbsp;line:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(line.length&nbsp;&gt;&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(filename&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;line.trim)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 8.1 - <span class="code">LongLines</span> with a private <span class="code">processLine</span> method.</h5>
      <p>The <span class="code">processFile</span> method takes a <span class="code">filename</span> and <span class="code">width</span> as parameters. It creates a <span class="code">Source</span> object from the file name and, in the generator of the <span class="code">for</span> expression, calls <span class="code">getLines</span> on the source. As mentioned in <a href="#step12">Step 12</a> of <a href="#chap-next-steps-in-scala">Chapter 3</a>, <span class="code">getLines</span> returns an iterator that provides one line from the file on each iteration, excluding the end-of-line character. The <span class="code">for</span> expression processes each of these lines by calling the helper method, <span class="code">processLine</span>. The <span class="code">processLine</span> method takes three parameters: a <span class="code">filename</span>, a <span class="code">width</span>, and a <span class="code">line</span>. It tests whether the length of the line is greater than the given width, and, if so, it prints the filename, a colon, and the line.</p>
      <p>To use <span class="code">LongLines</span> from the command line, we'll create an application that expects the line width as the first command-line argument, and interprets subsequent arguments as filenames:<a href="#footnotemain8-1">[1]</a></p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">FindLongLines</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;width&nbsp;=&nbsp;args(<code class="literal">0</code>).toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(arg&nbsp;&lt;-&nbsp;args.drop(<code class="literal">1</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LongLines.processFile(arg,&nbsp;width)
  &nbsp;&nbsp;}&nbsp;
  }&nbsp;
</pre>
      <p>Here's how you'd use this application to find the lines in <span class="code">LongLines.scala</span> that are over 45 characters in length (there's just one):</p> <pre>  $&nbsp;scala&nbsp;FindLongLines&nbsp;45&nbsp;LongLines.scala
  <code class="output">LongLines.scala:&nbsp;def&nbsp;processFile(filename:&nbsp;String,&nbsp;width:&nbsp;Int)&nbsp;=&nbsp;{</code>
</pre>
      <p>So far, this is very similar to what you would do in any object-oriented language. However, the concept of a function in Scala is more general than a method. Scala's other ways to express functions will be explained in the following sections.</p>
      <h3>8.2 Local functions</h3>
      <p>The construction of the <span class="code">processFile</span> method in the previous section demonstrated an important design principle of the functional programming style: programs should be decomposed into many small functions that each do a well-defined task. Individual functions are often quite small. The advantage of this style is that it gives a programmer many building blocks that can be flexibly composed to do more difficult things. Each building block should be simple enough to be understood individually.</p>
      <p>One problem with this approach is that all the helper function names can pollute the program namespace. In the interpreter this is not so much of a problem, but once functions are packaged in reusable classes and objects, it's desirable to hide the helper functions from clients of a class. They often do not make sense individually, and you often want to keep enough flexibility to delete the helper functions if you later rewrite the class in a different way.</p>
      <p>In Java, your main tool for this purpose is the private method. This private-method approach works in Scala as well, as demonstrated in <a href="#lst-longlines-methods">Listing 8.1</a>, but Scala offers an additional approach: you can define functions inside other functions. Just like local variables, such <a href="#g43293933"><em>local function</em>s</a> are visible only in their enclosing block.<a id="i1082301132-1"></a><a id="i1342112038-1"></a> Here's an example:<a id="i-1153551486-1"></a></p> <pre>  <code class="vem">def</code>&nbsp;processFile(filename:&nbsp;<code class="typename">String</code>,&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;processLine(filename:&nbsp;<code class="typename">String</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;<code class="typename">Int</code>,&nbsp;line:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(line.length&nbsp;&gt;&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(filename&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;line.trim)
  &nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;source&nbsp;=&nbsp;Source.fromFile(filename)
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;source.getLines())&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;processLine(filename,&nbsp;width,&nbsp;line)
  &nbsp;&nbsp;}
  }
</pre>
      <p>In this example, we refactored the original <span class="code">LongLines</span> version, shown in <a href="#lst-longlines-methods">Listing 8.1</a>, by transforming private method, <span class="code">processLine</span>, into a local function of <span class="code">processFile</span>. To do so we removed the <span class="code">private</span> modifier, which can only be applied (and is only needed) for members, and placed the definition of <span class="code">processLine</span> inside the definition of <span class="code">processFile</span>. As a local function, <span class="code">processLine</span> is in scope inside <span class="code">processFile</span>, but inaccessible outside.</p>
      <p>Now that <span class="code">processLine</span> is defined inside <span class="code">processFile</span>, however, another improvement becomes possible. Notice how <span class="code">filename</span> and <span class="code">width</span> are passed unchanged into the helper function? This is not necessary because local functions can access the parameters of their enclosing function. You can just use the parameters of the outer <span class="code">processFile</span> function, as shown in <a href="#lst-longlines-function">Listing 8.2</a>.</p>
      <p><a id="lst-longlines-function"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.io.Source
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">LongLines</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;processFile(filename:&nbsp;<code class="typename">String</code>,&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;processLine(line:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(line.length&nbsp;&gt;&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(filename&nbsp;+&nbsp;<code class="quotedstring">":&nbsp;"</code>&nbsp;+&nbsp;line.trim)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;source&nbsp;=&nbsp;Source.fromFile(filename)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(line&nbsp;&lt;-&nbsp;source.getLines())
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processLine(line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 8.2 - <span class="code">LongLines</span> with a local <span class="code">processLine</span> function.</h5>
      <p>Simpler, isn't it? This use of an enclosing function's parameters is a common and useful example of the general nesting Scala provides. The nesting and scoping described in <a href="#sec-variable-scope">Section 7.7</a> applies to all Scala constructs, including functions. It's a simple principle, but very powerful, especially in a language with first-class functions.</p>
      <h3>8.3 First-class functions</h3>
      <p>Scala has <a href="#g1589563862"><em>first-class functions</em></a>.<a id="i-1098728772-2"></a> Not only can you define functions and call them, but you can write down functions as unnamed <em>literals</em> and then pass them around as <em>values</em>. We introduced function literals in <a href="#chap-first-steps-in-scala">Chapter 2</a> and showed the basic syntax in <a href="#fig-function-literal">Figure 2.2</a> <a href="#fig-function-literal">here</a>.</p>
      <p>A function literal<a id="i-132187383-1"></a> is compiled into a class that<a id="i-1850091418-1"></a><a id="i2141458026-1"></a> when instantiated at runtime is a <a href="#g1731647273"><em>function value</em></a>.<a href="#footnotemain8-2">[2]</a> Thus the distinction between function literals and values is that function literals exist in the source code, whereas function values exist as objects at runtime. The distinction is much like that between classes (source code) and objects (runtime).</p>
      <p>Here is a simple example of a function literal that adds one to a number:</p> <pre>  (x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<code class="literal">1</code>
</pre>
      <p>The <span class="code">=&gt;</span> designates that this function converts the thing on the left (any integer <span class="code">x</span>) to the thing on the right (<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span>). So, this is a function mapping any integer <span class="code">x</span> to <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span>.</p>
      <p>Function values are objects, so you can store them in variables if you like. They are functions, too, so you can invoke them using the usual parentheses function-call notation. Here is an example of both activities:</p> <pre>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;increase&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<code class="literal">1</code>
  <code class="output">increase:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$988/1232424564@cf01c2e</code>
  <br>  scala&gt;&nbsp;increase(<code class="literal">10</code>)
  <code class="output">res0:&nbsp;Int&nbsp;=&nbsp;11</code>
</pre>
      <p>Because <span class="code">increase</span>, in this example, is a <span class="code">var</span>, you can assign a different function value to it later on.</p> <pre>  scala&gt;&nbsp;increase&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<code class="literal">9999</code>
  <code class="output">mutated&nbsp;increase</code>
  <br>  scala&gt;&nbsp;increase(<code class="literal">10</code>)
  <code class="output">res1:&nbsp;Int&nbsp;=&nbsp;10009</code>
</pre>
      <p>If you want to have more than one statement in the function literal, surround its body by curly braces and put one statement per line, thus forming a <a href="#g93832333">block</a>. Just like a method, when the function value is invoked, all of the statements will be executed, and the value returned from the function is whatever results from evaluating the last expression.</p> <pre>  scala&gt;&nbsp;increase&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"We"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"are"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"here!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;+&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">mutated&nbsp;increase</code>
  <br>  scala&gt;&nbsp;increase(<code class="literal">10</code>)
  <code class="output">We</code>
  <code class="output">are</code>
  <code class="output">here!</code>
  <code class="output">res2:&nbsp;Int&nbsp;=&nbsp;11</code>
</pre>
      <p>So now you have seen the nuts and bolts of function literals and function values. Many Scala libraries give you opportunities to use them. For example, a <span class="code">foreach</span> method is available for all collections.<a href="#footnotemain8-3">[3]</a> It takes a function as an argument and invokes that function on each of its elements. Here is how it can be used to print out all of the elements of a list: <a id="exa-someNumbers-def"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;someNumbers&nbsp;=&nbsp;<code class="typename">List</code>(-<code class="literal">11</code>,&nbsp;-<code class="literal">10</code>,&nbsp;-<code class="literal">5</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">5</code>,&nbsp;<code class="literal">10</code>)
  <code class="output">someNumbers:&nbsp;List[Int]&nbsp;=&nbsp;List(-11,&nbsp;-10,&nbsp;-5,&nbsp;0,&nbsp;5,&nbsp;10)</code>
  <br>  scala&gt;&nbsp;someNumbers.foreach((x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;println(x))
  <code class="output">-11</code>
  <code class="output">-10</code>
  <code class="output">-5</code>
  <code class="output">0</code>
  <code class="output">5</code>
  <code class="output">10</code>
</pre>
      <p>As another example, collection types also have a <span class="code">filter</span> method. This method selects those elements of a collection that pass a test the user supplies. That test is supplied using a function. For example, the function <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span> could be used for filtering. This function maps positive integers to true and all others to false. Here is how to use it with <span class="code">filter</span>:</p> <pre>  scala&gt;&nbsp;someNumbers.filter((x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res4:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>
      <p>Methods like <span class="code">foreach</span> and <span class="code">filter</span> are described further later in the book. <a href="#chap-working-with-lists">Chapter 16</a> talks about their use in class <span class="code">List</span>. <a href="#chap-working-with-other-collections">Chapter 17</a> discusses their use with other collection types.</p>
      <h3>8.4 Short forms of function literals</h3>
      <p>Scala provides a number of ways to leave out redundant information and write function literals more briefly. Keep your eyes open for these opportunities, because they allow you to remove clutter from your code.</p>
      <p>One way to make a function literal more brief is to leave off the parameter types. Thus, the previous example with filter could be written like this:</p> <pre>  scala&gt;&nbsp;someNumbers.filter((x)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res5:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>
      <p>The Scala compiler knows that <span class="code">x</span> must be an integer, because it sees that you are immediately using the function to filter a list of integers (referred to by <span class="code">someNumbers</span>). This is called <a href="#g-1884158234"><em>target typing</em></a> because the targeted usage of an expression (in this case, an argument to <span class="code">someNumbers.filter()</span>) is allowed to influence the typing of that expression (in this case to determine the type of the <span class="code">x</span> parameter).<a id="i-1884158234-1"></a><a id="i1428968692-1"></a> The precise details of target typing are not important. You can simply start by writing a function literal without the argument type, and if the compiler gets confused, add in the type. Over time you'll get a feel for which situations the compiler can and cannot puzzle out.</p>
      <p>A second way to remove useless characters is to leave out parentheses around a parameter whose type is inferred. In the previous example, the parentheses around <span class="code">x</span> are unnecessary:</p> <pre>  scala&gt;&nbsp;someNumbers.filter(x&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res6:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>
      <h3 id="sec-placeholder-syntax">8.5 Placeholder syntax</h3>
      <p>To make a function literal even more concise, you can use underscores as<a id="i603770043-1"></a><a id="i-383997826-1"></a><a id="i-372979206-1"></a> placeholders for one or more parameters, so long as each parameter appears only one time within the function literal<a id="i788093512-1"></a>. For example, <span class="code">_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span> is very short notation for a function that checks whether a value is greater than zero:</p> <pre>  scala&gt;&nbsp;someNumbers.filter(_&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res7:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>
      <p>You can think of the underscore as a "blank" in the expression that needs to be "filled in." This blank will be filled in with an argument to the function each time the function is invoked. For example, given that <span class="code">someNumbers</span> was initialized <a href="#exa-someNumbers-def">here</a> to the value <span class="code">List(-11,</span>&nbsp;<span class="code">-10,</span>&nbsp;<span class="code">-5,</span>&nbsp;<span class="code">0,</span>&nbsp;<span class="code">5,</span>&nbsp;<span class="code">10)</span>, the <span class="code">filter</span> method will replace the blank in <span class="code">_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span> first with <span class="code">-11</span>, as in <span class="code">-11</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span>, then with <span class="code">-10</span>, as in <span class="code">-10</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span>, then with <span class="code">-5</span>, as in <span class="code">-5</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span>, and so on to the end of the <span class="code">List</span>. The function literal <span class="code">_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span>, therefore, is equivalent to the slightly more verbose <span class="code">x</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span>, as demonstrated here:</p> <pre>  scala&gt;&nbsp;someNumbers.filter(x&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res8:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</code>
</pre>
      <p>Sometimes when you use underscores as placeholders for parameters, the compiler might not have enough information to infer missing parameter types. For example, suppose you write <span class="code">_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">_</span> by itself:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;_&nbsp;+&nbsp;_
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;missing&nbsp;parameter&nbsp;type&nbsp;for&nbsp;expanded&nbsp;function&nbsp;</code>
  <code class="output">((x$1:&nbsp;&lt;error&gt;,&nbsp;x$2)&nbsp;=&gt;&nbsp;x$1.$plus(x$2))</code>
</pre>
      <p>In such cases, you can specify the types using a colon, like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;(_:&nbsp;<code class="typename">Int</code>)&nbsp;+&nbsp;(_:&nbsp;<code class="typename">Int</code>)
  <code class="output">f:&nbsp;(Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1075/1481958694@289fff3c</code>
  <br>  scala&gt;&nbsp;f(<code class="literal">5</code>,&nbsp;<code class="literal">10</code>)
  <code class="output">res9:&nbsp;Int&nbsp;=&nbsp;15</code>
</pre>
      <p>Note that <span class="code">_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">_</span> expands into a literal for a function that takes two parameters. This is why you can use this short form only if each parameter appears in the function literal exactly once. Multiple underscores mean multiple parameters, not reuse of a single parameter repeatedly. The first underscore represents the first parameter, the second underscore the second parameter, the third underscore the third parameter, and so on.</p>
      <h3 id="sec-partially-applied-functions">8.6 Partially applied functions</h3>
      <p>Although the previous examples substitute underscores in place of individual parameters, you can also replace an entire parameter list with an underscore.<a id="i1834060518-1"></a><a id="i1842232449-1"></a><a id="i1128745740-1"></a> For example, rather than writing <span class="code">println(_)</span>, you could write <span class="code">println _</span>. Here's an example:</p> <pre>  someNumbers.foreach(println&nbsp;_)
</pre>
      <p>Scala treats this short form exactly as if you had written the following:</p> <pre>  someNumbers.foreach(x&nbsp;=&gt;&nbsp;println(x))
</pre>
      <p>Thus, the underscore in this case is not a placeholder for a single parameter. It is a placeholder for an entire parameter list. Remember that you need to leave a space between the function name and the underscore; otherwise, the compiler will think you are referring to a different symbol, such as, for example, a method named <span class="code">println_</span>, which likely does not exist.</p>
      <p>When you use an underscore in this way, you are writing a <a href="#g-1880499411"><em>partially applied function</em></a>. In Scala, when you invoke a function, passing in any needed arguments, you <em>apply</em> that function <em>to</em> the arguments.<a id="i1914165903-1"></a> For example, given the following function:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;sum(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>,&nbsp;c:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c
  <code class="output">sum:&nbsp;(a:&nbsp;Int,&nbsp;b:&nbsp;Int,&nbsp;c:&nbsp;Int)Int</code>
</pre>
      <p>You could apply the function <span class="code">sum</span> to the arguments <span class="code">1</span>, <span class="code">2</span>, and <span class="code">3</span> like this:</p> <pre>  scala&gt;&nbsp;sum(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res10:&nbsp;Int&nbsp;=&nbsp;6</code>
</pre>
      <p>A partially applied function is an expression in which you don't supply all of the arguments needed by the function. Instead, you supply some, or none, of the needed arguments. For example, to create a partially applied function expression involving <span class="code">sum</span>, in which you supply none of the three required arguments, you just place an underscore after "<span class="code">sum</span>". The resulting function can then be stored in a variable. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;sum&nbsp;_
  <code class="output">a:&nbsp;(Int,&nbsp;Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1091/1149618736@6415112c</code>
</pre>
      <p>Given this code, the Scala compiler instantiates a function value that takes the three integer parameters missing from the partially applied function expression, <span class="code">sum _</span>, and assigns a reference to that new function value to the variable <span class="code">a</span>. When you apply three arguments to this new function value, it will turn around and invoke <span class="code">sum</span>, passing in those same three arguments:</p> <pre>  scala&gt;&nbsp;a(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res11:&nbsp;Int&nbsp;=&nbsp;6</code>
</pre>
      <p>Here's what just happened: The variable named <span class="code">a</span> refers to a function value object. This function value is an instance of a class generated automatically by the Scala compiler from <span class="code">sum _</span>, the partially applied function expression. The class generated by the compiler has an <span class="code">apply</span> method that takes three arguments.<a href="#footnotemain8-4">[4]</a> The generated class's <span class="code">apply</span> method takes three arguments because three is the number of arguments missing in the <span class="code">sum _</span> expression. The Scala compiler translates the expression <span class="code">a(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> into an invocation of the function value's <span class="code">apply</span> method, passing in the three arguments <span class="code">1</span>, <span class="code">2</span>, and <span class="code">3</span>. Thus, <span class="code">a(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> is a short form for:</p> <pre>  scala&gt;&nbsp;a.apply(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res12:&nbsp;Int&nbsp;=&nbsp;6</code>
</pre>
      <p>This <span class="code">apply</span> method, defined in the class generated automatically by the Scala compiler from the expression <span class="code">sum _</span>, simply forwards those three missing parameters to <span class="code">sum</span>, and returns the result. In this case <span class="code">apply</span> invokes <span class="code">sum(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>, and returns what <span class="code">sum</span> returns, which is <span class="code">6</span>.</p>
      <p>Another way to think about this kind of expression, in which an underscore is used to represent an entire parameter list, is as a way to transform a <span class="code">def</span> into a function value. For example, if you have a local function, such as <span class="code">sum(a:</span>&nbsp;<span class="code">Int,</span>&nbsp;<span class="code">b:</span>&nbsp;<span class="code">Int,</span>&nbsp;<span class="code">c:</span>&nbsp;<span class="code">Int):</span>&nbsp;<span class="code">Int</span>, you can "wrap" it in a function value whose <span class="code">apply</span> method has the same parameter list and result types. When you apply this function value to some arguments, it in turn applies <span class="code">sum</span> to those same arguments and returns the result. Although you can't assign a method or nested function to a variable, or pass it as an argument to another function, you can do these things if you wrap the method or nested function in a function value by placing an underscore after its name.</p>
      <p>Now, although <span class="code">sum _</span> is indeed a partially applied function, it may not be obvious to you why it is called this. It has this name because you are not applying that function to all of its arguments. In the case of <span class="code">sum _</span>, you are applying it to <em>none</em> of its arguments. But you can also express a partially applied function by supplying only <em>some</em> of the required arguments. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;b&nbsp;=&nbsp;sum(<code class="literal">1</code>,&nbsp;_:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">b:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1092/457198113@280aa1bd</code>
</pre>
      <p>In this case, you've supplied the first and last argument to <span class="code">sum</span>, but not the middle argument. Since only one argument is missing, the Scala compiler generates a new function class whose <span class="code">apply</span> method takes one argument. When invoked with that one argument, this generated function's <span class="code">apply</span> method invokes <span class="code">sum</span>, passing in <span class="code">1</span>, the argument passed to the function, and <span class="code">3</span>. Here are some examples:</p> <pre>  scala&gt;&nbsp;b(<code class="literal">2</code>)
  <code class="output">res13:&nbsp;Int&nbsp;=&nbsp;6</code>
</pre>
      <p>In this case, <span class="code">b.apply</span> invoked <span class="code">sum(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>.</p> <pre>  scala&gt;&nbsp;b(<code class="literal">5</code>)
  <code class="output">res14:&nbsp;Int&nbsp;=&nbsp;9</code>
</pre>
      <p>And in this case, <span class="code">b.apply</span> invoked <span class="code">sum(1,</span>&nbsp;<span class="code">5,</span>&nbsp;<span class="code">3)</span>.</p>
      <p>If you are writing a partially applied function expression in which you leave off all parameters, such as <span class="code">println _</span> or <span class="code">sum _</span>, you can express it more concisely by leaving off the underscore if a function is required at that point in the code. For example, instead of printing out each of the numbers in <span class="code">someNumbers</span> (defined <a href="#exa-someNumbers-def">here</a>) like this:</p> <pre>  someNumbers.foreach(println&nbsp;_)
</pre>
      <p>You could just write:</p> <pre>  someNumbers.foreach(println)
</pre>
      <p>This last form is allowed only in places where a function is required, such as the invocation of <span class="code">foreach</span> in this example. The compiler knows a function is required in this case, because <span class="code">foreach</span> requires that a function be passed as an argument. In situations where a function is not required, attempting to use this form will cause a compilation error. Here's an example:<a id="i732535273-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;c&nbsp;=&nbsp;sum
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;missing&nbsp;argument&nbsp;list&nbsp;for&nbsp;method&nbsp;sum</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unapplied&nbsp;methods&nbsp;are&nbsp;only&nbsp;converted&nbsp;to&nbsp;functions&nbsp;when</code>
  <code class="output">&nbsp;a&nbsp;function&nbsp;type&nbsp;is&nbsp;expected.</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You&nbsp;can&nbsp;make&nbsp;this&nbsp;conversion&nbsp;explicit&nbsp;by&nbsp;writing&nbsp;`sum&nbsp;</code>
  <code class="output">_`&nbsp;or&nbsp;`sum(_,_,_)`&nbsp;instead&nbsp;of&nbsp;`sum`.</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;d&nbsp;=&nbsp;sum&nbsp;_
  <code class="output">d:&nbsp;(Int,&nbsp;Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1095/598308875@12223aed</code>
  <br>  scala&gt;&nbsp;d(<code class="literal">10</code>,&nbsp;<code class="literal">20</code>,&nbsp;<code class="literal">30</code>)
  <code class="output">res14:&nbsp;Int&nbsp;=&nbsp;60</code>
</pre>
      <h3>8.7 Closures</h3>
      <p>So far in this chapter, all the examples of function literals have referred only to passed parameters.<a id="i1093320088-1"></a> For example, in <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span>, the only variable used in the function body, <span class="code">x</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0</span>, is <span class="code">x</span>, which is defined as a parameter to the function. You can, however, refer to variables defined elsewhere:</p> <pre>  (x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more&nbsp;&nbsp;<code class="comment">//&nbsp;how&nbsp;much&nbsp;more?</code>
</pre>
      <p>This function adds "<span class="code">more</span>" to its argument, but what is <span class="code">more</span>? From the point of view of this function, <span class="code">more</span> is a <a href="#g-761850448"><em>free variable</em></a> because<a id="i-2142527293-1"></a><a id="i-968704369-1"></a> the function literal does not itself give a meaning to it. The <span class="code">x</span> variable, by contrast, is a <a href="#g183453406"><em>bound variable</em></a> because<a id="i31167931-2"></a><a id="i1392088405-2"></a> it does have a meaning in the context of the function: it is defined as the function's lone parameter, an <span class="code">Int</span>. If you try using this function literal by itself, without any <span class="code">more</span> defined in its scope, the compiler will complain:<a id="i138103638-2"></a></p> <pre>  scala&gt;&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;not&nbsp;found:&nbsp;value&nbsp;more</code>
</pre>
      <div class="aside">
        <h3>Why the trailing underscore?</h3>
        <p>Scala's syntax for partially applied functions highlights a difference in the design trade-offs of Scala and classical functional languages, such as Haskell or ML. In these languages, partially applied functions are considered the normal case. Furthermore, these languages have a fairly strict static type system that will usually highlight every error with partial applications that you can make. Scala bears a much closer relation to imperative languages, such as Java, where a method that's not applied to all its arguments is considered an error. Furthermore, the object-oriented tradition of subtyping and a universal root type accepts some programs that would be considered erroneous in classical functional languages.</p>
        <p>For instance, say you mistook the <span class="code">drop(n:</span>&nbsp;<span class="code">Int)</span> method of <span class="code">List</span> for <span class="code">tail</span>, and therefore forgot you need to pass a number to <span class="code">drop</span>. You might write, "<span class="code">println(xs.drop)</span>". Had Scala adopted the classical functional tradition that partially applied functions are OK everywhere, this code would type check. However, you might be surprised to find out that the output printed by this <span class="code">println</span> statement would always be <span class="code">&lt;function&gt;</span>! What would have happened is that the expression <span class="code">drop</span> would have been treated as a function object. Because <span class="code">println</span> takes objects of any type, this would have compiled OK, but it would have given an unexpected result.</p>
        <p>To avoid situations like this, Scala normally requires you to specify function arguments that are left out explicitly, even if the indication is as simple as a `<span class="code">_</span>'. Scala allows you to leave off even the <span class="code">_</span> only when a function type is expected.</p>
      </div>
      <p>On the other hand, the same function literal will work fine so long as there is something available named <span class="code">more</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;more&nbsp;=&nbsp;<code class="literal">1</code>
  <code class="output">more:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;addMore&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more
  <code class="output">addMore:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1103/2125513028@11cb348c</code>
  <br>  scala&gt;&nbsp;addMore(<code class="literal">10</code>)
  <code class="output">res16:&nbsp;Int&nbsp;=&nbsp;11</code>
</pre>
      <p>The function value (the object) that's created at runtime from this function literal is called a <a href="#g866552379"><em>closure</em></a>.<a id="i-940840561-1"></a><a id="i-698028847-1"></a> The name arises from the act of "closing" the function literal by "capturing" the bindings of its free variables. A function literal with no free variables, such as <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span>, is called a <em>closed term</em>, where a <em>term</em> is a bit of source code<a id="i1045501329-1"></a>. Thus a function value created at runtime from this function literal is not a closure in the strictest sense, because <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span> is already closed as written. But any function literal with free variables, such as <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">more</span>, is an <em>open term</em>. Therefore, any function value created at runtime from <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">more</span> will, by definition, require that a binding for its free variable, <span class="code">more</span>, be captured. The resulting function value, which will contain a reference to the captured <span class="code">more</span> variable, is called a closure because the function value is the end product of the act of closing the open term, <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">more</span>.</p>
      <p>This example brings up a question: What happens if <span class="code">more</span> changes after the closure is created? In Scala, the answer is that the closure sees the change. For example:</p> <pre>  scala&gt;&nbsp;more&nbsp;=&nbsp;<code class="literal">9999</code>
  <code class="output">mutated&nbsp;more</code>
  <br>  scala&gt;&nbsp;addMore(<code class="literal">10</code>)
  <code class="output">res17:&nbsp;Int&nbsp;=&nbsp;10009</code>
</pre>
      <p>Intuitively, Scala's closures capture variables themselves, not the value to which variables refer.<a href="#footnotemain8-5">[5]</a> As the previous example shows, the closure created for <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">more</span> sees the change to <span class="code">more</span> made outside the closure. The same is true in the opposite direction. Changes made by a closure to a captured variable are visible outside the closure. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;someNumbers&nbsp;=&nbsp;<code class="typename">List</code>(-<code class="literal">11</code>,&nbsp;-<code class="literal">10</code>,&nbsp;-<code class="literal">5</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">5</code>,&nbsp;<code class="literal">10</code>)
  <code class="output">someNumbers:&nbsp;List[Int]&nbsp;=&nbsp;List(-11,&nbsp;-10,&nbsp;-5,&nbsp;0,&nbsp;5,&nbsp;10)</code>
  <br>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="output">sum:&nbsp;Int&nbsp;=&nbsp;0</code>
  <br>  scala&gt;&nbsp;someNumbers.foreach(sum&nbsp;+=&nbsp;&nbsp;_)
</pre> <pre>  scala&gt;&nbsp;sum
  <code class="output">res19:&nbsp;Int&nbsp;=&nbsp;-11</code>
</pre>
      <p>This example uses a roundabout way to sum the numbers in a <span class="code">List</span>. Variable <span class="code">sum</span> is in a surrounding scope from the function literal <span class="code">sum</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">_</span>, which adds numbers to <span class="code">sum</span>. Even though it is the closure modifying <span class="code">sum</span> at runtime, the resulting total, <span class="code">-11</span>, is still visible outside the closure.</p>
      <p>What if a closure accesses some variable that has several different copies as the program runs? For example, what if a closure uses a local variable of some function, and the function is invoked many times? Which instance of that variable gets used at each access?</p>
      <p>Only one answer is consistent with the rest of the language: the instance used is the one that was active at the time the closure was created. For example, here is a function that creates and returns "increase" closures:</p> <pre>  <code class="vem">def</code>&nbsp;makeIncreaser(more:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more
</pre>
      <p>Each time this function is called it will create a new closure. Each closure will access the <span class="code">more</span> variable that was active when the closure was created.</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;inc1&nbsp;=&nbsp;makeIncreaser(<code class="literal">1</code>)
  <code class="output">inc1:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1126/1042315811@4262a8d2</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;inc9999&nbsp;=&nbsp;makeIncreaser(<code class="literal">9999</code>)
  <code class="output">inc9999:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1126/1042315811@4c8bbc5e</code>
</pre>
      <p>When you call <span class="code">makeIncreaser(1)</span>, a closure is created and returned that captures the value <span class="code">1</span> as the binding for <span class="code">more</span>. Similarly, when you call <span class="code">makeIncreaser(9999)</span>, a closure that captures the value <span class="code">9999</span> for <span class="code">more</span> is returned. When you apply these closures to arguments (in this case, there's just one argument, <span class="code">x</span>, which must be passed in), the result that comes back depends on how <span class="code">more</span> was defined when the closure was created:</p> <pre>  scala&gt;&nbsp;inc1(<code class="literal">10</code>)
  <code class="output">res20:&nbsp;Int&nbsp;=&nbsp;11</code>
  <br>  scala&gt;&nbsp;inc9999(<code class="literal">10</code>)
  <code class="output">res21:&nbsp;Int&nbsp;=&nbsp;10009</code>
</pre>
      <p>It makes no difference that the <span class="code">more</span> in this case is a parameter to a method call that has already returned. The Scala compiler rearranges things in cases like these so that the captured parameter lives out on the heap, instead of the stack, and thus can outlive the<a id="i-243919082-1"></a><a id="i-1976863198-1"></a> method call that created it. This rearrangement is all taken care of automatically, so you don't have to worry about it. Capture any variable you like: <span class="code">val</span>, <span class="code">var</span>, or parameter.</p>
      <h3 id="sec-fancy-parameters">8.8 Special function call forms</h3>
      <p>Most functions and function calls you encounter will be as you have seen so far in this chapter. The function will have a fixed number of parameters, the call will have an equal number of arguments, and the arguments will be specified in the same order and number as the parameters.</p>
      <p>Since function calls are so central to programming in Scala, however, a few special forms of function definitions and function calls have been added to the language to address some special needs. Scala supports repeated parameters, named arguments, and default arguments.</p>
      <h4>Repeated parameters</h4>
      <p>Scala<a id="i1567203046-1"></a><a id="i-580179190-2"></a><a id="i2051741460-1"></a><a id="i-1544402352-2"></a> allows you to indicate that the last parameter to a function may be repeated. This allows clients to pass variable length argument lists to the function. To denote a repeated parameter, place an asterisk after the type of the parameter. For example:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;echo(args:&nbsp;<code class="typename">String</code>*)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(arg&nbsp;&lt;-&nbsp;args)&nbsp;println(arg)
  <code class="output">echo:&nbsp;(args:&nbsp;String*)Unit</code>
</pre>
      <p>Defined this way, <span class="code">echo</span> can be called with zero to many <span class="code">String</span> arguments:</p> <pre>  scala&gt;&nbsp;echo()
  <br>  scala&gt;&nbsp;echo(<code class="quotedstring">"one"</code>)
  <code class="output">one</code>
  <br>  scala&gt;&nbsp;echo(<code class="quotedstring">"hello"</code>,&nbsp;<code class="quotedstring">"world!"</code>)
  <code class="output">hello</code>
  <code class="output">world!</code>
</pre>
      <p>Inside the function, the type of the repeated parameter is a <span class="code">Seq</span> of the declared type of the parameter. Thus, the type of <span class="code">args</span> inside the <span class="code">echo</span> function, which is declared as type "<span class="code">String*</span>" is actually <span class="code">Seq[String]</span>. Nevertheless, if you have an array of the appropriate type, and you attempt to pass it as a repeated parameter, you'll get a compiler error:<a id="i-677980410-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;seq&nbsp;=&nbsp;<code class="typename">Seq</code>(<code class="quotedstring">"What's"</code>,&nbsp;<code class="quotedstring">"up"</code>,&nbsp;<code class="quotedstring">"doc?"</code>)
  <code class="output">seq:&nbsp;Seq[String]&nbsp;=&nbsp;Seq(What's,&nbsp;up,&nbsp;doc?)</code>
  <br>  scala&gt;&nbsp;echo(seq)
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Seq[String]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required:&nbsp;String</code>
  <br>  </pre>
      <p>To accomplish this, you'll need to append the array argument with a colon and an _* symbol,<a id="i-170392618-1"></a> like this:<a id="i-1842939016-1"></a><a id="i2101376046-1"></a></p> <pre>  scala&gt;&nbsp;echo(seq:&nbsp;_*)
  <code class="output">What's</code>
  <code class="output">up</code>
  <code class="output">doc?</code>
</pre>
      <p>This notation tells the compiler to pass each element of <span class="code">seq</span> as its own argument to <span class="code">echo</span>, rather than all of it as a single argument.</p>
      <h4>Named arguments</h4>
      <p>In a normal function call, the arguments in the call are matched one by one in the order of the parameters of the called function:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;speed(distance:&nbsp;<code class="typename">Float</code>,&nbsp;time:&nbsp;<code class="typename">Float</code>):&nbsp;<code class="typename">Float</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance&nbsp;/&nbsp;time
  <code class="output">speed:&nbsp;(distance:&nbsp;Float,&nbsp;time:&nbsp;Float)Float</code>
  <br>  scala&gt;&nbsp;speed(<code class="literal">100</code>,&nbsp;<code class="literal">10</code>)
  <code class="output">res27:&nbsp;Float&nbsp;=&nbsp;10.0</code>
</pre>
      <p>In this call, the 100 is matched to <span class="code">distance</span> and the 10 to <span class="code">time</span>. The 100 and 10 are matched in the same order as the formal parameters are listed.</p>
      <p>Named arguments<a id="i1416238505-1"></a><a id="i-700806123-1"></a><a id="i23167279-1"></a> allow you to pass arguments to a function in a different order. The syntax is simply that each argument is preceded by a parameter name and an equals sign. For example, the following call to speed is equivalent to <span class="code">speed(100,10)</span>:</p> <pre>  scala&gt;&nbsp;speed(distance&nbsp;=&nbsp;<code class="literal">100</code>,&nbsp;time&nbsp;=&nbsp;<code class="literal">10</code>)
  <code class="output">res28:&nbsp;Float&nbsp;=&nbsp;10.0</code>
</pre>
      <p>Called with named arguments, the arguments can be reversed without changing the meaning:</p> <pre>  scala&gt;&nbsp;speed(time&nbsp;=&nbsp;<code class="literal">10</code>,&nbsp;distance&nbsp;=&nbsp;<code class="literal">100</code>)
  <code class="output">res29:&nbsp;Float&nbsp;=&nbsp;10.0</code>
</pre>
      <p>It is also possible to mix positional and named arguments. In that case, the positional arguments come first. Named arguments are most frequently used in combination with default parameter values.</p>
      <h4>Default parameter values</h4>
      <p>Scala lets you specify default values<a id="i869856667-1"></a> for function parameters. The argument for such a parameter can optionally be omitted from a function call, in which case the corresponding argument will be filled in with the default.</p>
      <p>An example is shown in <a href="#lst-default">Listing 8.3</a>. Function <span class="code">printTime</span> has one parameter, <span class="code">out</span>, and it has a default value of <span class="code">Console.out</span>. <a id="lst-default"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;printTime(out:&nbsp;<code class="typename">java.io.PrintStream</code>&nbsp;=&nbsp;Console.out)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;out.println(<code class="quotedstring">"time&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;System.currentTimeMillis())
</pre>
      <h5>Listing 8.3 - A parameter with a default value.</h5>
      <p>If you call the function as <span class="code">printTime()</span>, thus specifying no argument to be used for <span class="code">out</span>, then <span class="code">out</span> will be set to its default value of <span class="code">Console.out</span>. You could also call the function with an explicit output stream. For example, you could send logging to the standard error output by calling the function as <span class="code">printTime(Console.err)</span>.</p>
      <p>Default parameters are especially helpful when used in combination with named parameters. In <a href="#lst-default2">Listing 8.4</a>, function <span class="code">printTime2</span> has two optional parameters. The <span class="code">out</span> parameter has a default of <span class="code">Console.out</span>, and the <span class="code">divisor</span> parameter has a default value of <span class="code">1</span>. <a id="lst-default2"></a></p> <pre>  <code class="vem">def</code>&nbsp;printTime2(out:&nbsp;<code class="typename">java.io.PrintStream</code>&nbsp;=&nbsp;Console.out,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;divisor:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="literal">1</code>)&nbsp;=
  &nbsp;&nbsp;out.println(<code class="quotedstring">"time&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;System.currentTimeMillis()/divisor)
</pre>
      <h5>Listing 8.4 - A function with two parameters that have defaults.</h5>
      <p>Function <span class="code">printTime2</span> can be called as <span class="code">printTime2()</span> to have both parameters filled in with their default values. Using named arguments, however, either one of the parameters can be specified while leaving the other as the default. To specify the output stream, call it like this:</p> <pre>  printTime2(out&nbsp;=&nbsp;Console.err)
</pre>
      <p>To specify the time divisor, call it like this:</p> <pre>  printTime2(divisor&nbsp;=&nbsp;<code class="literal">1000</code>)
</pre>
      <h3 id="sec-tail-recursion">8.9 Tail recursion</h3>
      <p>In <a href="#sec-while-loops">Section 7.2</a>, we<a id="i1651241320-1"></a><a id="i1113229075-1"></a><a id="i2133301138-1"></a> mentioned that to transform a <span class="code">while</span> loop that updates <span class="code">var</span>s into a more functional style that uses only <span class="code">val</span>s, you may sometimes need to use recursion. Here's an example of a recursive function that approximates a value by repeatedly improving a guess until it is good enough:</p> <pre>  <code class="vem">def</code>&nbsp;approximate(guess:&nbsp;<code class="typename">Double</code>):&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(isGoodEnough(guess))&nbsp;guess
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;approximate(improve(guess))
</pre>
      <p>A function like this is often used in search problems, with appropriate implementations for <span class="code">isGoodEnough</span> and <span class="code">improve</span>. If you want the <span class="code">approximate</span> function to run faster, you might be tempted to write it with a <span class="code">while</span> loop to try and speed it up, like this:</p> <pre>  <code class="vem">def</code>&nbsp;approximateLoop(initialGuess:&nbsp;<code class="typename">Double</code>):&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;guess&nbsp;=&nbsp;initialGuess
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(!isGoodEnough(guess))
  &nbsp;&nbsp;&nbsp;&nbsp;guess&nbsp;=&nbsp;improve(guess)
  &nbsp;&nbsp;guess
  }
</pre>
      <p>Which of the two versions of <span class="code">approximate</span> is preferable? In terms of brevity and <span class="code">var</span> avoidance, the first, functional one wins. But is the imperative approach perhaps more efficient? In fact, if we measure execution times, it turns out that<a id="i1671917386-1"></a> they are almost exactly the same!</p>
      <p>This might seem surprising because a recursive call looks much more "expansive" than a simple jump from the end of a loop to its beginning. However, in the case of <span class="code">approximate</span> above, the Scala compiler is able to apply an important optimization. Note that the recursive call is the last thing that happens in the evaluation of function <span class="code">approximate</span>'s body. Functions like <span class="code">approximate</span>, which call themselves as their last action, are called <a href="#g2133301346"><em>tail recursive</em></a>.<a id="i-2133336344-1"></a><a id="i1640045089-1"></a> The Scala compiler detects tail recursion and replaces it with a jump back to the beginning of the function, after updating the function parameters with the new values.</p>
      <p>The moral is that you should not shy away from using recursive algorithms to solve your problem. Often, a recursive solution is more elegant and concise than a loop-based one. If the solution is tail recursive, there won't be any runtime overhead to be paid.</p>
      <h4>Tracing tail-recursive functions</h4>
      <p>A tail-recursive function will not build a new stack frame for each call; all calls will execute in a single frame. This may surprise a programmer inspecting a stack trace of a program that failed. For example, this<a id="i10962622-1"></a> function calls itself some number of times then throws an exception:</p> <pre>  <code class="vem">def</code>&nbsp;boom(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"boom!"</code>)
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;boom(x&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;+&nbsp;<code class="literal">1</code>
</pre>
      <p>This function is <span style="font-style:italic">not</span> tail recursive, because it performs an increment operation after the recursive call. You'll get what you expect when you run it:</p> <pre>  scala&gt;&nbsp;&nbsp;boom(<code class="literal">3</code>)
  <code class="output">java.lang.Exception:&nbsp;boom!</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:6)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:6)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:6)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:6)</code>
  <code class="output">...</code>
</pre>
      <div class="aside">
        <h3>Tail call optimization</h3>
        <p>The compiled code for <span class="code">approximate</span> is essentially the same as the compiled code for <span class="code">approximateLoop</span>. Both functions compile down to the same thirteen instructions of Java bytecodes. If you look through the bytecodes generated by the Scala compiler for the tail recursive method, <span class="code">approximate</span>, you'll see that although both <span class="code">isGoodEnough</span> and <span class="code">improve</span> are invoked in the body of the method, <span class="code">approximate</span> is not. The Scala compiler optimized away the recursive call<a id="i46846037-1"></a>:</p> <pre>  public&nbsp;double&nbsp;approximate(double);
  &nbsp;&nbsp;Code:
  &nbsp;&nbsp;&nbsp;0:&nbsp;&nbsp;&nbsp;aload_0
  &nbsp;&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;astore_3
  &nbsp;&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;aload_0
  &nbsp;&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;dload_1
  &nbsp;&nbsp;&nbsp;4:&nbsp;&nbsp;&nbsp;invokevirtual&nbsp;&nbsp;&nbsp;#24;&nbsp;//Method&nbsp;isGoodEnough:(D)Z
  &nbsp;&nbsp;&nbsp;7:&nbsp;&nbsp;&nbsp;ifeq&nbsp;&nbsp;&nbsp;&nbsp;12
  &nbsp;&nbsp;&nbsp;10:&nbsp;&nbsp;dload_1
  &nbsp;&nbsp;&nbsp;11:&nbsp;&nbsp;dreturn
  &nbsp;&nbsp;&nbsp;12:&nbsp;&nbsp;aload_0
  &nbsp;&nbsp;&nbsp;13:&nbsp;&nbsp;dload_1
  &nbsp;&nbsp;&nbsp;14:&nbsp;&nbsp;invokevirtual&nbsp;&nbsp;&nbsp;#27;&nbsp;//Method&nbsp;improve:(D)D
  &nbsp;&nbsp;&nbsp;17:&nbsp;&nbsp;dstore_1
  &nbsp;&nbsp;&nbsp;18:&nbsp;&nbsp;goto&nbsp;&nbsp;&nbsp;&nbsp;2
</pre>
      </div>
      <p>If you now modify <span class="code">boom</span> so that it does become tail recursive:</p> <pre>  <code class="vem">def</code>&nbsp;bang(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"bang!"</code>)
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;bang(x&nbsp;-&nbsp;<code class="literal">1</code>)
</pre>
      <p>You'll get:</p> <pre>  scala&gt;&nbsp;bang(<code class="literal">5</code>)
  <code class="output">java.lang.Exception:&nbsp;bang!</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:6)&nbsp;...</code>
</pre>
      <p>This time, you see only a single stack frame for <span class="code">bang</span>. You might think that <span class="code">bang</span> crashed before it called itself, but this is not the case. If you think you might be confused by tail-call optimizations when looking at a stack trace, you can turn them off by giving the following argument to the <span class="code">scala</span> shell or to the <span class="code">scalac</span> compiler:<a id="i-1882129636-1"></a><a id="i2131054531-1"></a></p> <pre>  -g:notailcalls
</pre>
      <p>With that option specified, you will get a longer stack trace:</p> <pre>  scala&gt;&nbsp;bang(<code class="literal">5</code>)
  <code class="output">java.lang.Exception:&nbsp;bang!</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:6)&nbsp;...</code>
</pre>
      <h4>Limits of tail recursion</h4>
      <p>The use of tail recursion in Scala is fairly limited because the JVM<a id="i2022023743-1"></a><a id="i1086960686-1"></a> instruction set makes implementing more advanced forms of tail recursion very difficult. Scala only optimizes directly recursive calls back to the same function making the call. If the recursion is indirect, as in the following example of two mutually recursive functions, no optimization is possible:</p> <pre>  <code class="vem">def</code>&nbsp;isEven(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">true</code>&nbsp;<code class="vem">else</code>&nbsp;isOdd(x&nbsp;-&nbsp;<code class="literal">1</code>)
  <code class="vem">def</code>&nbsp;isOdd(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">false</code>&nbsp;<code class="vem">else</code>&nbsp;isEven(x&nbsp;-&nbsp;<code class="literal">1</code>)
</pre>
      <p>You also won't get a tail-call optimization if the final call goes to a function value. Consider for instance the following recursive code:</p> <pre>  <code class="vem">val</code>&nbsp;funValue&nbsp;=&nbsp;nestedFun&nbsp;_
  <code class="vem">def</code>&nbsp;nestedFun(x:&nbsp;<code class="typename">Int</code>)&nbsp;:&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;!=&nbsp;<code class="literal">0</code>)&nbsp;{&nbsp;println(x);&nbsp;funValue(x&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;}
  }
</pre>
      <p>The <span class="code">funValue</span> variable refers to a function value that essentially wraps a call to <span class="code">nestedFun</span>. When you apply the function value to an argument, it turns around and applies <span class="code">nestedFun</span> to that same argument, and returns the result. Therefore, you might hope the Scala compiler would perform a tail-call optimization, but in this case it would not. Tail-call optimization is limited to situations where a method or nested function calls itself directly as its last operation, without going through a function value or some other intermediary. (If you don't fully understand tail recursion yet, see <a href="#sec-tail-recursion">Section 8.9</a>).</p>
      <h3>8.10 Conclusion</h3>
      <p>This chapter has given you a grand tour of functions in Scala. In addition to methods, Scala provides local functions, function literals, and function values. In addition to normal function calls, Scala provides partially applied functions and functions with repeated parameters. When possible, function calls are implemented as optimized tail calls, and thus many nice-looking recursive functions run just as quickly as hand-optimized versions that use <span class="code">while</span> loops. The next chapter will build on these foundations and show how Scala's rich support for functions helps you abstract over control.</p>
      <hr>
      <h4>Footnotes for Chapter 8:</h4>
      <p><a id="footnotemain8-1"></a>[1] In this book, we usually won't check command-line arguments for validity in example applications, both to save trees and reduce boilerplate code that can obscure the example's important code. The trade-off is that instead of producing a helpful error message when given bad input, our example applications will throw an exception.</p>
      <p><a id="footnotemain8-2"></a>[2] Every function value is an instance of some class that extends one of several <span class="code">FunctionN</span> traits in package <span class="code">scala</span>, such as <span class="code">Function0</span> for functions with no parameters, <span class="code">Function1</span> for functions with one parameter, and so on. Each <span class="code">FunctionN</span> trait has an <span class="code">apply</span> method used to invoke the function.</p>
      <p><a id="footnotemain8-3"></a>[3] A <span class="code">foreach</span> method is defined in trait <span class="code">Iterable</span>, a common supertrait of <span class="code">List</span>, <span class="code">Set</span>, <span class="code">Array</span>, and <span class="code">Map</span>. See <a href="#chap-working-with-other-collections">Chapter 17</a> for the details.</p>
      <p><a id="footnotemain8-4"></a>[4] The generated class extends trait <span class="code">Function3</span>, which declares a three-arg <span class="code">apply</span> method.</p>
      <p><a id="footnotemain8-5"></a>[5] By contrast, Java's inner classes<a id="i706520282-1"></a> do not allow you to access modifiable variables in surrounding scopes at all, so there is no difference between capturing a variable and capturing its currently held value.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-control-abstraction">Chapter 9</a></h2>
      <h1>Control Abstraction</h1>
      <p>In <a href="#chap-built-in-control-structures">Chapter 7</a>, we pointed out that Scala doesn't have many built-in control abstractions because it gives you the ability to create your own. In the previous chapter, you learned about function values. In this chapter, we'll show you how to apply function values to create new control abstractions. Along the way, you'll also learn about currying and by-name parameters.</p>
      <h3 id="sec-reducing-code-dup">9.1 Reducing code duplication</h3>
      <p>All functions are separated into common parts, which are the same<a id="i14092899-2"></a><a id="i-1950695486-2"></a> in every invocation of the function, and non-common parts, which may vary from one function invocation to the next. The common parts are in the body of the function, while the non-common parts must be supplied via arguments. When you use a function value as an argument, the non-common part of the algorithm is itself some other algorithm! At each invocation of such a function, you can pass in a different function value as an argument, and the invoked function will, at times of its choosing, invoke the passed function value. These <em>higher-order functions</em>—functions that take functions as parameters—give you extra opportunities to condense and simplify code<a id="i1069366433-1"></a><a id="i319271759-1"></a>.</p>
      <p>One benefit of higher-order functions is they enable you to create control abstractions that allow you to reduce code duplication. For example, suppose you are writing a file browser, and you want to provide an API that allows users to search for files matching some criterion. First, you add a facility to search for files whose names end in a particular string. This would enable your users to find, for example, all files with a "<span class="texttt">.scala</span>" extension. You could provide such an API by defining a public <span class="code">filesEnding</span> method inside a singleton object like this:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">FileMatcher</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;filesHere&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">java.io.File</code>(<code class="quotedstring">"."</code>)).listFiles
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;filesEnding(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;file.getName.endsWith(query))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
  }
</pre>
      <p>The <span class="code">filesEnding</span> method obtains the list of all files in the current directory using the private helper method <span class="code">filesHere</span>, then filters them based on whether each file name ends with the user-specified query. Given <span class="code">filesHere</span> is private, the <span class="code">filesEnding</span> method is the only accessible method defined in <span class="code">FileMatcher</span>, the API you provide to your users.</p>
      <p>So far so good, and there is no repeated code yet. Later on, though, you decide to let people search based on any part of the file name. This is good for when your users cannot remember if they named a file <span class="texttt">phb-important.doc</span>, <span class="texttt">stupid-phb-report.doc</span>, <span class="texttt">may2003salesdoc.phb</span>, or something entirely different; they just know that "phb" appears in the name somewhere. You go back to work and add this function to your <span class="code">FileMatcher</span> API:</p> <pre>  <code class="vem">def</code>&nbsp;filesContaining(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;file.getName.contains(query))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
</pre>
      <p>This function works just like <span class="code">filesEnding</span>. It searches <span class="code">filesHere</span>, checks the name, and returns the file if the name matches. The only difference is that this function uses <span class="code">contains</span> instead of <span class="code">endsWith</span>.</p>
      <p>The months go by, and the program becomes more successful. Eventually, you give in to the requests of a few power users who want to search based on regular expressions. These sloppy guys have immense directories with thousands of files, and they would like to do things like find all "pdf" files that have "oopsla" in the title somewhere. To support them, you write this function:</p> <pre>  <code class="vem">def</code>&nbsp;filesRegex(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;file.getName.matches(query))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
</pre>
      <p>Experienced programmers will notice all of this repetition and wonder if it can be factored into a common helper function. Doing it the obvious way does not work, however. You would like to be able to do the following:</p> <pre>  <code class="vem">def</code>&nbsp;filesMatching(query:&nbsp;<code class="typename">String</code>,&nbsp;<i>method</i>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;file.getName.<i>method</i>(query))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
</pre>
      <p>This approach would work in some dynamic languages, but Scala does not allow pasting together code at runtime like this. So what do you do?</p>
      <p>Function values provide an answer.<a id="i2141458026-2"></a> While you cannot pass around a method name as a value, you can get the same effect by passing around a function value that calls the method for you. In this case, you could add a <span class="code">matcher</span> parameter to the method whose sole purpose is to check a file name against a query:</p> <pre>  <code class="vem">def</code>&nbsp;filesMatching(query:&nbsp;<code class="typename">String</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;matcher:&nbsp;(<code class="typename">String</code>,&nbsp;<code class="typename">String</code>)&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;matcher(file.getName,&nbsp;query))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
  }
</pre>
      <p>In this version of the method, the <span class="code">if</span> clause now uses <span class="code">matcher</span> to check the file name against the query. Precisely what this check does depends on what is specified as the matcher. Take a look, now, at the type of <span class="code">matcher</span> itself. It is a function, and thus has a <span class="code">=&gt;</span> in the type. This function takes two string arguments—the file name and the query—and returns a boolean, so the type of this function is <span class="code">(String,</span>&nbsp;<span class="code">String)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span>.</p>
      <p>Given this new <span class="code">filesMatching</span> helper method, you can simplify the three searching methods by having them call the helper method, passing in an appropriate function:</p> <pre>  <code class="vem">def</code>&nbsp;filesEnding(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;filesMatching(query,&nbsp;_.endsWith(_))
  <br>  <code class="vem">def</code>&nbsp;filesContaining(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;filesMatching(query,&nbsp;_.contains(_))
  <br>  <code class="vem">def</code>&nbsp;filesRegex(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;filesMatching(query,&nbsp;_.matches(_))
</pre>
      <p>The function literals shown in this example use the placeholder syntax, introduced in the previous chapter, which may not as yet feel very natural to you.<a id="i1101169360-1"></a><a id="i788093512-2"></a><a id="i-383997826-2"></a><a id="i603770043-2"></a> So here's a clarification of how placeholders are used: The function literal <span class="code">_.endsWith(_)</span>, used in the <span class="code">filesEnding</span> method, means the same thing as:</p> <pre>  (fileName:&nbsp;<code class="typename">String</code>,&nbsp;query:&nbsp;<code class="typename">String</code>)&nbsp;=&gt;&nbsp;fileName.endsWith(query)
</pre>
      <p>Because <span class="code">filesMatching</span> takes a function that requires two <span class="code">String</span> arguments, you need not specify the types of the arguments; you could just write <span class="code">(fileName,</span>&nbsp;<span class="code">query)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">fileName.endsWith(query)</span>. Since the parameters are each used only once in the body of the function (<i>i.e.</i>, the first parameter, <span class="code">fileName</span>, is used first in the body, and the second parameter, <span class="code">query</span>, is used second), you can use the placeholder syntax: <span class="code">_.endsWith(_)</span>. The first underscore is a placeholder for the first parameter, the file name, and the second underscore a placeholder for the second parameter, the query string.</p>
      <p>This code is already simplified, but it can actually be even shorter. Notice that the query gets passed to <span class="code">filesMatching</span>, but <span class="code">filesMatching</span> does nothing with the query except to pass it back to the passed <span class="code">matcher</span> function. This passing back and forth is unnecessary because the caller already knew the query to begin with! You might as well remove the query parameter from <span class="code">filesMatching</span> and <span class="code">matcher</span>, thus simplifying the code as shown in <a href="#lst-closures-reduce">Listing 9.1</a>.</p>
      <p><a id="lst-closures-reduce"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">FileMatcher</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;filesHere&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">java.io.File</code>(<code class="quotedstring">"."</code>)).listFiles
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;filesMatching(matcher:&nbsp;<code class="typename">String</code>&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<code class="vem">if</code>&nbsp;matcher(file.getName))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;file
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;filesEnding(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filesMatching(_.endsWith(query))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;filesContaining(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filesMatching(_.contains(query))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;filesRegex(query:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filesMatching(_.matches(query))
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 9.1 - Using closures to reduce code duplication.</h5>
      <p>This example demonstrates the way in which first-class functions can help you eliminate code duplication<a id="i532436688-1"></a> where it would be very difficult to do so without them. In Java, for example, you could create an interface containing a method that takes one <span class="code">String</span> and returns a <span class="code">Boolean</span>, then create and pass anonymous inner class instances that implement this interface to <span class="code">filesMatching</span>. Although this approach would remove the code duplication you are trying to eliminate, it would, at the same time, add as much or more new code. Thus the benefit is not worth the cost, and you may as well live with the duplication.</p>
      <p>Moreover, this example demonstrates how closures can help you reduce code duplication<a id="i1093320088-2"></a>. The function literals used in the previous example, such as <span class="code">_.endsWith(_)</span> and <span class="code">_.contains(_)</span>, are instantiated at runtime into function values that are <em>not</em> closures because they don't capture any free variables. Both variables used in the expression, <span class="code">_.endsWith(_)</span>, for example, are represented by underscores, which means they are taken from arguments to the function. Thus, <span class="code">_.endsWith(_)</span> uses two bound variables, and no free variables. By contrast, the function literal <span class="code">_.endsWith(query)</span>, used in the most recent example, contains one bound variable, the argument represented by the underscore, and one free variable named <span class="code">query</span>. It is only because Scala supports closures that you were able to remove the <span class="code">query</span> parameter from <span class="code">filesMatching</span> in the most recent example, thereby simplifying the code even further.</p>
      <h3>9.2 Simplifying client code</h3>
      <p>The previous example demonstrated that higher-order functions can help reduce code duplication as you implement an API. Another important use of higher-order functions is to put them in an API itself to make client code more concise. A good example is provided by the special-purpose looping methods of Scala's collection types.<a href="#footnotemain9-1">[1]</a> Many of these are listed in <a href="#tab-listmethods">Table 3.1</a> in <a href="#chap-next-steps-in-scala">Chapter 3</a>, but take a look at just one example for now to see why these methods are so useful.</p>
      <p>Consider <span class="code">exists</span>, a method that determines whether a passed value is contained in a collection<a id="i1794232640-1"></a>. You could, of course, search for an element by having a <span class="code">var</span> initialized to false, looping through the collection checking each item, and setting the <span class="code">var</span> to true if you find what you are looking for. Here's a method that uses this approach to determine whether a passed <span class="code">List</span> contains a negative number:</p> <pre>  <code class="vem">def</code>&nbsp;containsNeg(nums:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;exists&nbsp;=&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(num&nbsp;&lt;-&nbsp;nums)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(num&nbsp;&lt;&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;=&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;exists
  }
</pre>
      <p>If you define this method in the interpreter, you can call it like this:</p> <pre>  scala&gt;&nbsp;containsNeg(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>))
  <code class="output">res0:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;containsNeg(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;-<code class="literal">3</code>,&nbsp;<code class="literal">4</code>))
  <code class="output">res1:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>A more concise way to define the method, though, is by calling the higher-order function <span class="code">exists</span> on the passed <span class="code">List</span>, like this:</p> <pre>  <code class="vem">def</code>&nbsp;containsNeg(nums:&nbsp;<code class="typename">List[Int]</code>)&nbsp;=&nbsp;nums.exists(_&nbsp;&lt;&nbsp;<code class="literal">0</code>)
</pre>
      <p>This version of <span class="code">containsNeg</span> yields the same results as the previous:</p> <pre>  scala&gt;&nbsp;containsNeg(<code class="typename">Nil</code>)
  <code class="output">res2:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;containsNeg(<code class="typename">List</code>(<code class="literal">0</code>,&nbsp;-<code class="literal">1</code>,&nbsp;-<code class="literal">2</code>))
  <code class="output">res3:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>The <span class="code">exists</span> method represents a control abstraction. It is a special-purpose looping construct provided by the Scala library, rather than built into the Scala language like <span class="code">while</span> or <span class="code">for</span>. In the previous section, the higher-order function, <span class="code">filesMatching</span>, reduces code duplication in the implementation of the <span class="code">object</span> <span class="code">FileMatcher</span>. The <span class="code">exists</span> method provides a similar benefit, but because <span class="code">exists</span> is public in Scala's collections API, the code duplication it reduces is client code of that API. If <span class="code">exists</span> didn't exist, and you wanted to write a <span class="code">containsOdd</span> method to test whether a list contains odd numbers, you might write it like this:</p> <pre>  <code class="vem">def</code>&nbsp;containsOdd(nums:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;exists&nbsp;=&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(num&nbsp;&lt;-&nbsp;nums)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(num&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;=&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;exists
  }
</pre>
      <p>If you compare the body of <span class="code">containsNeg</span> with that of <span class="code">containsOdd</span>, you'll find that everything is repeated except the test condition of an <span class="code">if</span> expression. Using <span class="code">exists</span>, you could write this instead:</p> <pre>  <code class="vem">def</code>&nbsp;containsOdd(nums:&nbsp;<code class="typename">List[Int]</code>)&nbsp;=&nbsp;nums.exists(_&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">1</code>)
</pre>
      <p>The body of the code in this version is again identical to the body of the corresponding <span class="code">containsNeg</span> method (the version that uses <span class="code">exists</span>), except the condition for which to search is different. Yet the amount of code duplication is much smaller because all of the looping infrastructure is factored out into the <span class="code">exists</span> method itself.</p>
      <p>There are many other looping methods in Scala's standard library. As with <span class="code">exists</span>, they can often shorten your code if you recognize opportunities to use them.</p>
      <h3 id="sec-currying">9.3 Currying</h3>
      <p>In Chapter 1, we said that Scala allows you to create new control abstractions that "feel like native language support." Although the examples you've seen so far are indeed control abstractions, it is unlikely anyone would mistake them for native language support. To understand how to make control abstractions that feel more like language extensions, you first need to understand the functional programming technique called <a href="#g575993339"><em>currying</em></a>.<a id="i575993339-1"></a></p>
      <p>A curried function is applied to multiple argument lists, instead of just one. <a href="#lst-plain-old-function">Listing 9.2</a> shows a regular, non-curried function, which adds two <span class="code">Int</span> parameters, <span class="code">x</span> and <span class="code">y</span>.</p>
      <p><a id="lst-plain-old-function"></a></p> <pre>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">def</code>&nbsp;plainOldSum(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;x&nbsp;+&nbsp;y
  <code class="output">&nbsp;&nbsp;plainOldSum:&nbsp;(x:&nbsp;Int,&nbsp;y:&nbsp;Int)Int</code>
  <br>  &nbsp;&nbsp;scala&gt;&nbsp;plainOldSum(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">&nbsp;&nbsp;res4:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <h5>Listing 9.2 - Defining and invoking a "plain old" function.</h5>
      <p>By contrast, <a href="#lst-curried-function">Listing 9.3</a> shows a similar function that's curried. Instead of one list of two <span class="code">Int</span> parameters, you apply this function to two lists of one <span class="code">Int</span> parameter each.</p>
      <p><a id="lst-curried-function"></a></p> <pre>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">def</code>&nbsp;curriedSum(x:&nbsp;<code class="typename">Int</code>)(y:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;x&nbsp;+&nbsp;y
  <code class="output">&nbsp;&nbsp;curriedSum:&nbsp;(x:&nbsp;Int)(y:&nbsp;Int)Int</code>
  <br>  &nbsp;&nbsp;scala&gt;&nbsp;curriedSum(<code class="literal">1</code>)(<code class="literal">2</code>)
  <code class="output">&nbsp;&nbsp;res5:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <h5>Listing 9.3 - Defining and invoking a curried function.</h5>
      <p>What's happening here is that when you invoke <span class="code">curriedSum</span>, you actually get two traditional function invocations back to back. The first function invocation takes a single <span class="code">Int</span> parameter named <span class="code">x</span>, and returns a function value for the second function. This second function takes the <span class="code">Int</span> parameter <span class="code">y</span>. Here's a function named <span class="code">first</span> that does in spirit what the first traditional function invocation of <span class="code">curriedSum</span> would do:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;first(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;(y:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y
  <code class="output">first:&nbsp;(x:&nbsp;Int)Int&nbsp;=&gt;&nbsp;Int</code>
</pre>
      <p>Applying the first function to <span class="code">1</span>—in other words, invoking the first function and passing in <span class="code">1</span>—yields the second function:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;second&nbsp;=&nbsp;first(<code class="literal">1</code>)
  <code class="output">second:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1044/1220897602@5c6fae3c</code>
</pre>
      <p>Applying the second function to <span class="code">2</span> yields the result:</p> <pre>  scala&gt;&nbsp;second(<code class="literal">2</code>)
  <code class="output">res6:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <p>These <span class="code">first</span> and <span class="code">second</span> functions are just an illustration of the currying process. They are not directly connected to the <span class="code">curriedSum</span> function. Nevertheless, there is a way to get an actual reference to <span class="code">curriedSum</span>'s "second" function. You can use the placeholder notation to use <span class="code">curriedSum</span> in a partially applied function expression, like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;onePlus&nbsp;=&nbsp;curriedSum(<code class="literal">1</code>)_
  <code class="output">onePlus:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1054/711248671@3644d12a</code>
</pre>
      <p>The underscore in <span class="code">curriedSum(1)_</span> is a placeholder for the second parameter list.<a href="#footnotemain9-2">[2]</a><a id="i-877041491-1"></a> The result is a reference to a function that, when invoked, adds one to its sole <span class="code">Int</span> argument and returns the result:</p> <pre>  scala&gt;&nbsp;onePlus(<code class="literal">2</code>)
  <code class="output">res7:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <p>And here's how you'd get a function that adds two to its sole <span class="code">Int</span> argument:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;twoPlus&nbsp;=&nbsp;curriedSum(<code class="literal">2</code>)_
  <code class="output">twoPlus:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;$$Lambda$1055/473485349@48b85dc5</code>
  <br>  scala&gt;&nbsp;twoPlus(<code class="literal">2</code>)
  <code class="output">res8:&nbsp;Int&nbsp;=&nbsp;4</code>
</pre>
      <h3 id="sec-control-structures">9.4 Writing new control structures</h3>
      <p>In languages with first-class functions, you can effectively make new control structures even though the syntax of the language is fixed. All you need to do is create methods that take functions as arguments.</p>
      <p>For example, here is the "twice" control structure, which repeats an operation two times and returns the result:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;twice(op:&nbsp;<code class="typename">Double</code>&nbsp;=&gt;&nbsp;<code class="typename">Double</code>,&nbsp;x:&nbsp;<code class="typename">Double</code>)&nbsp;=&nbsp;op(op(x))
  <code class="output">twice:&nbsp;(op:&nbsp;Double&nbsp;=&gt;&nbsp;Double,&nbsp;x:&nbsp;Double)Double</code>
  <br>  scala&gt;&nbsp;twice(_&nbsp;+&nbsp;<code class="literal">1</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">res9:&nbsp;Double&nbsp;=&nbsp;7.0</code>
</pre>
      <p>The type of <span class="code">op</span> in this example is <span class="code">Double</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Double</span>, which means it is a function that takes one <span class="code">Double</span> as an argument and returns another <span class="code">Double</span>.</p>
      <p>Any time you find a control pattern repeated in multiple parts of your code, you should think about implementing it as a new control structure. Earlier in the chapter you saw <span class="code">filesMatching</span>, a very specialized control pattern. Consider now a more widely used coding pattern: open a resource, operate on it, and then close the resource. You can capture this in a control abstraction using a method like the following: <a id="exa-first-with-print-writer"></a></p> <pre>  <code class="vem">def</code>&nbsp;withPrintWriter(file:&nbsp;<code class="typename">File</code>,&nbsp;op:&nbsp;<code class="typename">PrintWriter</code>&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;writer&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrintWriter</code>(file)
  &nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;op(writer)
  &nbsp;&nbsp;}&nbsp;<code class="vem">finally</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;writer.close()
  &nbsp;&nbsp;}
  }
</pre>
      <p>Given such a method, you can use it like this:</p> <pre>  withPrintWriter(
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">File</code>(<code class="quotedstring">"date.txt"</code>),
  &nbsp;&nbsp;writer&nbsp;=&gt;&nbsp;writer.println(<code class="vem">new</code>&nbsp;<code class="typename">java.util.Date</code>)
  )
</pre>
      <p>The advantage of using this method is that it's <span class="code">withPrintWriter</span>, not user code, that assures the file is closed at the end. So it's impossible to forget to close the file. This technique is called the <em>loan pattern</em>, because a control-abstraction function, such as <span class="code">withPrintWriter</span>, opens a resource and "loans" it to a function.<a id="i-531276704-2"></a><a id="i850457101-2"></a><a id="i193663324-2"></a> For instance, <span class="code">withPrintWriter</span> in the previous example loans a <span class="code">PrintWriter</span> to the function, <span class="code">op</span>. When the function completes, it signals that it no longer needs the "borrowed" resource. The resource is then closed in a <span class="code">finally</span> block, to ensure it is indeed closed, regardless of whether the function completes by returning normally or throwing an exception.</p>
      <p>One way in which you can make the client code look a bit more like a built-in control structure is to use curly braces instead of parentheses to surround the argument list. In any method invocation in Scala in which you're passing in exactly one argument, you can opt to use curly braces to surround the argument instead of parentheses.<a id="i-2010619769-1"></a><a id="i798707221-1"></a><a id="i-1201222106-1"></a></p>
      <p>For example, instead of:</p> <pre>  scala&gt;&nbsp;println(<code class="quotedstring">"Hello,&nbsp;world!"</code>)
  <code class="output">Hello,&nbsp;world!</code>
</pre>
      <p>You could write:</p> <pre>  scala&gt;&nbsp;println&nbsp;{&nbsp;<code class="quotedstring">"Hello,&nbsp;world!"</code>&nbsp;}
  <code class="output">Hello,&nbsp;world!</code>
</pre>
      <p>In the second example, you used curly braces instead of parentheses to surround the arguments to <span class="code">println</span>. This curly braces technique will work, however, only if you're passing in one argument. Here's an attempt at violating that rule:<a id="i724160184-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;<code class="quotedstring">"Hello,&nbsp;world!"</code>
  <code class="output">g:&nbsp;String&nbsp;=&nbsp;Hello,&nbsp;world!</code>
  <br>  scala&gt;&nbsp;g.substring&nbsp;{&nbsp;<code class="literal">7</code>,&nbsp;<code class="literal">9</code>&nbsp;}
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;';'&nbsp;expected&nbsp;but&nbsp;','&nbsp;found.</code>
</pre>
      <p>Because you are attempting to pass in two arguments to <span class="code">substring</span>, you get an error when you try to surround those arguments with curly braces. Instead, you'll need to use parentheses:</p> <pre>  scala&gt;&nbsp;g.substring(<code class="literal">7</code>,&nbsp;<code class="literal">9</code>)
  <code class="output">res12:&nbsp;String&nbsp;=&nbsp;wo</code>
</pre>
      <p>The purpose of this ability to substitute curly braces for parentheses for passing in one argument is to enable client programmers to write function literals between curly braces. This can make a method call feel more like a control abstraction. Take the <span class="code">withPrintWriter</span> method defined previously as an example. In its most recent form, <span class="code">withPrintWriter</span> takes two arguments, so you can't use curly braces. Nevertheless, because the function passed to <span class="code">withPrintWriter</span> is the last argument in the list, you can use currying to pull the first argument, the <span class="code">File</span>, into a separate argument list. This will leave the function as the lone parameter of the second argument list. <a href="#lst-loan-pattern">Listing 9.4</a> shows how you'd need to redefine <span class="code">withPrintWriter</span>.</p>
      <p><a id="lst-loan-pattern"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;withPrintWriter(file:&nbsp;<code class="typename">File</code>)(op:&nbsp;<code class="typename">PrintWriter</code>&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;writer&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrintWriter</code>(file)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op(writer)
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">finally</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.close()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 9.4 - Using the loan pattern to write to a file.</h5>
      <p>The new version differs from the old one only in that there are now two parameter lists with one parameter each instead of one parameter list with two parameters. Look between the two parameters. In the previous version of <span class="code">withPrintWriter</span>, shown <a href="#exa-first-with-print-writer">here</a>, you see ...<span class="code">File,</span>&nbsp;<span class="code">op</span>.... But in this version, you see ...<span class="code">File)(op</span>.... Given the above definition, you can call the method with a more pleasing syntax:</p> <pre>  <code class="vem">val</code>&nbsp;file&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">File</code>(<code class="quotedstring">"date.txt"</code>)
  <br>  withPrintWriter(file)&nbsp;{&nbsp;writer&nbsp;=&gt;
  &nbsp;&nbsp;writer.println(<code class="vem">new</code>&nbsp;<code class="typename">java.util.Date</code>)
  }
</pre>
      <p>In this example, the first argument list, which contains one <span class="code">File</span> argument, is written surrounded by parentheses. The second argument list, which contains one function argument, is surrounded by curly braces.</p>
      <h3 id="sec-by-name-parameters">9.5 By-name parameters</h3>
      <p>The <span class="code">withPrintWriter</span> method shown in the previous section differs from built-in control structures of the language, such as <span class="code">if</span> and <span class="code">while</span>, in that the code between the curly braces takes an argument. The function passed to <span class="code">withPrintWriter</span> requires one argument of type <span class="code">PrintWriter</span>. This argument shows up as the "<span class="code">writer</span>&nbsp;<span class="code">=&gt;</span>" in:</p> <pre>  withPrintWriter(file)&nbsp;{&nbsp;writer&nbsp;=&gt;
  &nbsp;&nbsp;writer.println(<code class="vem">new</code>&nbsp;<code class="typename">java.util.Date</code>)
  }
</pre>
      <p>But what if you want to implement something more like <span class="code">if</span> or <span class="code">while</span>, where there is no value to pass into the code between the curly braces? To help with such situations, Scala provides by-name parameters.<a id="i-1931276111-1"></a><a id="i-2031769303-1"></a></p>
      <p>As a concrete example, suppose you want to implement an assertion construct called <span class="code">myAssert</span>.<a href="#footnotemain9-3">[3]</a> The <span class="code">myAssert</span> function will take a function value as input and consult a flag to decide what to do. If the flag is set, <span class="code">myAssert</span> will invoke the passed function and verify that it returns <span class="code">true</span>. If the flag is turned off, <span class="code">myAssert</span> will quietly do nothing at all.</p>
      <p>Without using by-name parameters, you could write <span class="code">myAssert</span> like this:</p> <pre>  <code class="vem">var</code>&nbsp;assertionsEnabled&nbsp;=&nbsp;<code class="vem">true</code>
  <br>  <code class="vem">def</code>&nbsp;myAssert(predicate:&nbsp;()&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(assertionsEnabled&nbsp;&amp;&amp;&nbsp;!predicate())
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">AssertionError</code>
</pre>
      <p>The definition is fine, but using it is a little bit awkward:</p> <pre>  myAssert(()&nbsp;=&gt;&nbsp;<code class="literal">5</code>&nbsp;&gt;&nbsp;<code class="literal">3</code>)
</pre>
      <p>You would really prefer to leave out the empty parameter list and <span class="code">=&gt;</span> symbol in the function literal and write the code like this:</p> <pre>  myAssert(<code class="literal">5</code>&nbsp;&gt;&nbsp;<code class="literal">3</code>)&nbsp;<code class="comment">//&nbsp;Won't&nbsp;work,&nbsp;because&nbsp;missing&nbsp;()&nbsp;=&gt;&nbsp;</code>
</pre>
      <p>By-name parameters exist precisely so that you can do this. To make a by-name parameter, you give the parameter a type starting with <span class="code">=&gt;</span> instead of <span class="code">()</span>&nbsp;<span class="code">=&gt;</span>. For example, you could change <span class="code">myAssert</span>'s <span class="code">predicate</span> parameter into a by-name parameter by changing its type, "<span class="code">()</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span>", into "<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span>". <a href="#lst-by-name-parameter">Listing 9.5</a> shows how that would look:</p>
      <p><a id="lst-by-name-parameter"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;byNameAssert(predicate:&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(assertionsEnabled&nbsp;&amp;&amp;&nbsp;!predicate)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">AssertionError</code>
</pre>
      <h5>Listing 9.5 - Using a by-name parameter.</h5>
      <p>Now you can leave out the empty parameter in the property you want to assert. The result is that using <span class="code">byNameAssert</span> looks exactly like using a built-in control structure:</p> <pre>  byNameAssert(<code class="literal">5</code>&nbsp;&gt;&nbsp;<code class="literal">3</code>)
</pre>
      <p>A by-name type, in which the empty parameter list, <span class="code">()</span>, is left out, is only allowed for parameters. There is no such thing as a by-name variable or a by-name field.</p>
      <p>Now, you may be wondering why you couldn't simply write <span class="code">myAssert</span> using a plain old <span class="code">Boolean</span> for the type of its parameter, like this:</p> <pre>  <code class="vem">def</code>&nbsp;boolAssert(predicate:&nbsp;<code class="typename">Boolean</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(assertionsEnabled&nbsp;&amp;&amp;&nbsp;!predicate)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">AssertionError</code>
</pre>
      <p>This formulation is also legal, of course, and the code using this version of <span class="code">boolAssert</span> would still look exactly as before:</p> <pre>  boolAssert(<code class="literal">5</code>&nbsp;&gt;&nbsp;<code class="literal">3</code>)
</pre>
      <p>Nevertheless, one difference exists between these two approaches that is important to note. Because the type of <span class="code">boolAssert</span>'s parameter is <span class="code">Boolean</span>, the expression inside the parentheses in <span class="code">boolAssert(5</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">3)</span> is evaluated <em>before</em> the call to <span class="code">boolAssert</span>. The expression <span class="code">5</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">3</span> yields <span class="code">true</span>, which is passed to <span class="code">boolAssert</span>. By contrast, because the type of <span class="code">byNameAssert</span>'s <span class="code">predicate</span> parameter is <span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span>, the expression inside the parentheses in <span class="code">byNameAssert(5</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">3)</span> is <em>not</em> evaluated before the call to <span class="code">byNameAssert</span>. Instead a function value will be created whose <span class="code">apply</span> method will evaluate <span class="code">5</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">3</span>, and this function value will be passed to <span class="code">byNameAssert</span>.</p>
      <p>The difference between the two approaches, therefore, is that if assertions are disabled, you'll see any side effects that the expression inside the parentheses may have in <span class="code">boolAssert</span>, but not in <span class="code">byNameAssert</span>. For example, if assertions are disabled, attempting to assert on "<span class="code">x</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">0</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">0</span>" will yield an exception in <span class="code">boolAssert</span>'s case:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="literal">5</code>
  <code class="output">x:&nbsp;Int&nbsp;=&nbsp;5</code>
  <br>  scala&gt;&nbsp;assertionsEnabled&nbsp;=&nbsp;<code class="vem">false</code>
  <code class="output">mutated&nbsp;assertionsEnabled</code>
  <br>  scala&gt;&nbsp;boolAssert(x&nbsp;/&nbsp;<code class="literal">0</code>&nbsp;==&nbsp;<code class="literal">0</code>)
  <code class="output">java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero</code>
  <code class="output">&nbsp;&nbsp;...&nbsp;27&nbsp;elided</code>
</pre>
      <p>But attempting to assert on the same code in <span class="code">byNameAssert</span>'s case will <em>not</em> yield an exception:</p> <pre>  scala&gt;&nbsp;byNameAssert(x&nbsp;/&nbsp;<code class="literal">0</code>&nbsp;==&nbsp;<code class="literal">0</code>)
</pre>
      <h3>9.6 Conclusion</h3>
      <p>This chapter has shown you how to build on Scala's rich function support to build control abstractions. You can use functions within your code to factor out common control patterns, and you can take advantage of higher-order functions in the Scala library to reuse control patterns that are common across all programmers' code. We also discussed how to use currying and by-name parameters so that your own higher-order functions can be used with a concise syntax.</p>
      <p>In the previous chapter and this one, you have seen quite a lot of information about functions. The next few chapters will go back to discussing more object-oriented features of the language.</p>
      <hr>
      <h4>Footnotes for Chapter 9:</h4>
      <p><a id="footnotemain9-1"></a>[1] These special-purpose looping methods are defined in trait <span class="code">Iterable</span>, which is extended by <span class="code">List</span>, <span class="code">Set</span>, and <span class="code">Map</span>. See <a href="#chap-working-with-other-collections">Chapter 17</a> for a discussion.</p>
      <p><a id="footnotemain9-2"></a>[2] In the previous chapter, when the placeholder notation was used on traditional methods, like <span class="code">println</span>&nbsp;<span class="code">_</span>, you had to leave a space between the name and the underscore. In this case you don't, because whereas <span class="code">println_</span> is a legal identifier in Scala, <span class="code">curriedSum(1)_</span> is not.</p>
      <p><a id="footnotemain9-3"></a>[3] You'll call this <span class="code">myAssert</span>, not <span class="code">assert</span>, because Scala provides an <span class="code">assert</span> of its own, which will be described in <a href="#sec-assert">Section 14.1</a>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-composition-and-inheritance">Chapter 10</a></h2>
      <h1>Composition and Inheritance</h1>
      <p><a href="#chap-functional-objects">Chapter 6</a> introduced some basic object-oriented aspects of Scala. This chapter picks up where <a href="#chap-functional-objects">Chapter 6</a> left off and dives into Scala's support for object-oriented programming in much greater detail.</p>
      <p>We'll compare two fundamental relationships between classes: composition and inheritance. Composition means one class holds a reference to another, using the referenced class to help it fulfill its mission. Inheritance is the superclass/subclass relationship.</p>
      <p>In addition to these topics, we'll discuss abstract classes, parameterless methods, extending classes, overriding methods and fields, parametric fields, invoking superclass constructors, polymorphism and dynamic binding, final members and classes, and factory objects and methods.</p>
      <h3>10.1 A two-dimensional layout library</h3>
      <p>As a running example in this chapter, we'll create a library for building and rendering two-dimensional layout elements. Each element will represent a rectangle filled with text. For convenience, the library will provide factory methods named "<span class="code">elem</span>" that construct new elements from passed data. For example, you'll be able to create a layout element containing a string using a factory method with the following signature:</p> <pre>  elem(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Element</code>
</pre>
      <p>As you can see, elements will be modeled with a type named <span class="code">Element</span>. You'll be able to call <span class="code">above</span> or <span class="code">beside</span> on an element, passing in a second element, to get a new element that combines the two. For example, the following expression would construct a larger element consisting of two columns, each with a height of two:</p> <pre>  <code class="vem">val</code>&nbsp;column1&nbsp;=&nbsp;elem(<code class="quotedstring">"hello"</code>)&nbsp;above&nbsp;elem(<code class="quotedstring">"***"</code>)
  <code class="vem">val</code>&nbsp;column2&nbsp;=&nbsp;elem(<code class="quotedstring">"***"</code>)&nbsp;above&nbsp;elem(<code class="quotedstring">"world"</code>)
  column1&nbsp;beside&nbsp;column2
</pre>
      <p>Printing the result of this expression would give you:</p> <pre>  hello&nbsp;***&nbsp;&nbsp;
  &nbsp;***&nbsp;world
</pre>
      <p>Layout elements are a good example of a system in which objects can be constructed from simple parts with the aid of composing operators. In this chapter, we'll define classes that enable element objects to be constructed from arrays, lines, and rectangles. These basic element objects will be the simple parts. We'll also define composing operators <span class="code">above</span> and <span class="code">beside</span>. Such composing operators are also often called <span style="font-style:italic"> combinators</span> because they combine elements of some domain into new elements<a id="i-649047625-1"></a>.</p>
      <p>Thinking in terms of combinators is generally a good way to approach library design: it pays to think about the fundamental ways to construct objects in an application domain. What are the simple objects? In what ways can more interesting objects be constructed out of simpler ones? How do combinators hang together? What are the most general combinations? Do they satisfy any interesting laws?<a id="i3314449-1"></a> If you have good answers to these questions, your library design is on track.</p>
      <h3 id="sec-abstract-classes">10.2 Abstract classes</h3>
      <p>Our first task is to define type <span class="code">Element</span>, which represents layout elements. Since elements are two dimensional rectangles of characters, it makes sense to include a member, <span class="code">contents</span>, that refers to the contents of a layout element<a id="i-860903178-1"></a>. The contents can be represented as an array of strings, where each string represents a line. Hence, the type of the result returned by <span class="code">contents</span> will be <span class="code">Array[String]</span>. <a href="#lst-abstract-method-class">Listing 10.1</a> shows what it will look like.</p>
      <p><a id="lst-abstract-method-class"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 10.1 - Defining an abstract method and class.</h5>
      <p>In this class, <span class="code">contents</span> is declared as a method that has no implementation. In other words, the method is an <span style="font-style:italic">abstract</span> member of class <span class="code">Element</span>. A class with abstract members must itself be declared abstract, which is done by writing an <span class="code">abstract</span> modifier in front of the <span class="code">class</span> keyword<a id="i1203833450-1"></a><a id="i-860903178-2"></a>:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Element</code>&nbsp;...
</pre>
      <p>The <span class="code">abstract</span> modifier signifies that the class may have abstract members that do not have an implementation. As a result, you cannot instantiate an abstract class. If you try to do so, you'll get a compiler error:<a id="i-983091129-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Element</code>
  <code class="output">&lt;console&gt;:5:&nbsp;error:&nbsp;class&nbsp;Element&nbsp;is&nbsp;abstract;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;cannot&nbsp;be&nbsp;instantiated</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Element</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>Later in this chapter, you'll see how to create subclasses of class <span class="code">Element</span>, which you'll be able to instantiate because they fill in the missing definition for <span class="code">contents</span>.</p>
      <p>Note that the <span class="code">contents</span> method in class <span class="code">Element</span> does not carry an <span class="code">abstract</span> modifier. A method is abstract if it does not have an implementation (<i>i.e.</i>, no equals sign or body). Unlike Java, no abstract modifier is necessary (or allowed) on method declarations. Methods that have an implementation are called <span style="font-style:italic"> concrete</span><a id="i-141831446-1"></a>.<a id="i-1171687261-1"></a></p>
      <p>Another bit of terminology distinguishes between <span style="font-style:italic"> declarations</span> and <span style="font-style:italic">definitions</span>. Class <span class="code">Element</span> <a href="#g1542341994"><em>declares</em></a> the abstract method <span class="code">contents</span>, but currently <a href="#g-1335633477"><em>defines</em></a> no concrete methods. In the next section, however, we'll enhance <span class="code">Element</span> by defining some concrete methods.</p>
      <h3 id="sec-uniform-access-principle">10.3 Defining parameterless methods</h3>
      <p>As a next step, we'll add methods to <span class="code">Element</span> that reveal its width and height, as shown in <a href="#lst-parameterless-methods">Listing 10.2</a>.<a id="i1448211194-1"></a><a id="i1133207124-1"></a> The <span class="code">height</span> method returns the number of lines in <span class="code">contents</span>. The <span class="code">width</span> method returns the length of the first line, or if there are no lines in the element, returns zero. (This means you cannot define an element with a height of zero and a non-zero width.)</p>
      <p><a id="lst-parameterless-methods"></a></p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;height:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;contents.length
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;width:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="vem">if</code>&nbsp;(height&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="literal">0</code>&nbsp;<code class="vem">else</code>&nbsp;contents(<code class="literal">0</code>).length
  }
</pre>
      <h5>Listing 10.2 - Defining parameterless methods <span class="code">width</span> and <span class="code">height</span>.</h5>
      <p>Note that none of <span class="code">Element</span>'s three methods has a parameter list, not even an empty one. For example, instead of:</p> <pre>  <code class="vem">def</code>&nbsp;width():&nbsp;<code class="typename">Int</code>
</pre>
      <p>the method is defined without parentheses:</p> <pre>  <code class="vem">def</code>&nbsp;width:&nbsp;<code class="typename">Int</code>
</pre>
      <p>Such <a href="#g-1903107585"><em>parameterless methods</em></a> are quite common in Scala.<a id="i-1718164274-2"></a><a id="i1976561855-2"></a> By contrast, methods defined with empty parentheses, such as <span class="code">def</span>&nbsp;<span class="code">height():</span>&nbsp;<span class="code">Int</span>, are called <em>empty-paren methods</em>.<a id="i1343251059-1"></a><a id="i1617330716-1"></a><a id="i1755483330-1"></a> The recommended convention is to use a parameterless method whenever there are no parameters <em>and</em> the method accesses mutable state only by reading fields of the containing object (in particular, it does not change mutable state). This convention supports the <span style="font-style:italic">uniform access principle</span>,<a href="#footnotemain10-1">[1]</a> which says that client code should not be affected by a decision to implement an attribute as a field or method<a id="i758262274-1"></a>.</p>
      <p>For instance, we could implement <span class="code">width</span> and <span class="code">height</span> as fields, instead of methods, simply by changing the <span class="code">def</span> in each definition to a <span class="code">val</span>:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;height&nbsp;=&nbsp;contents.length
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;width&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(height&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="literal">0</code>&nbsp;<code class="vem">else</code>&nbsp;contents(<code class="literal">0</code>).length
  }
</pre>
      <p>The two pairs of definitions are completely equivalent from a client's point of view. The only difference is that field accesses might be slightly faster than method invocations because the field values are pre-computed when the class is initialized, instead of being computed on each method call. On the other hand, the fields require extra memory space in each <span class="code">Element</span> object. So it depends on the usage profile of a class whether an attribute is better represented as a field or method, and that usage profile might change over time. The point is that clients of the <span class="code">Element</span> class should not be affected when its internal implementation changes.</p>
      <p>In particular, a client of class <span class="code">Element</span> should not need to be rewritten if a field of that class gets changed into an access function, so long as the access function is <span style="font-style:italic">pure</span> (<i>i.e.</i>, it does not have any side effects and does not depend on mutable state<a id="i-242056329-1"></a>). The client should not need to care either way.</p>
      <p>So far so good. But there's still a slight complication that has to do with the way Java handles things. The problem is that Java does not implement the uniform access principle. So it's <span class="code">string.length()</span> in Java, not <span class="code">string.length</span>, even though it's <span class="code">array.length</span>, not <span class="code">array.length()</span>. Needless to say, this is very confusing.</p>
      <p>To bridge that gap, Scala is very liberal when it comes to mixing parameterless and empty-paren methods. In particular, you can override a parameterless method with an empty-paren method, and <i>vice versa</i>. You can also leave off the empty parentheses on an invocation of any function that takes no arguments. For instance, the following two lines are both legal in Scala:</p> <pre>  <code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>).toString
  <code class="quotedstring">"abc"</code>.length
</pre>
      <p>In principle it's possible to leave out all empty parentheses in Scala function calls. However, it's still recommended to write the empty parentheses when the invoked method represents more than a property of its receiver object. For instance, empty parentheses are appropriate if the method performs I/O, writes reassignable variables (<span class="code">var</span>s), or reads <span class="code">var</span>s other than the receiver's fields, either directly or indirectly by using mutable objects. That way, the parameter list acts as a visual clue that some interesting computation is triggered by the call. For instance:</p> <pre>  <code class="quotedstring">"hello"</code>.length&nbsp;&nbsp;<code class="comment">//&nbsp;no&nbsp;()&nbsp;because&nbsp;no&nbsp;side-effect</code>
  println()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;better&nbsp;to&nbsp;not&nbsp;drop&nbsp;the&nbsp;()</code>
</pre>
      <p>To summarize, it is encouraged in Scala to define methods that take no parameters and have no side effects as parameterless methods (<i>i.e.</i>, leaving off the empty parentheses). On the other hand, you should never define a method that has side-effects without parentheses, because invocations of that method would then look like a field selection. So your clients might be surprised to see the side effects.</p>
      <p>Similarly, whenever you invoke a function that has side effects, be sure to include the empty parentheses when you write the invocation. Another way to think about this is if the function you're calling performs an operation, use the parentheses. But if it merely provides access to a property, leave the parentheses off.</p>
      <h3 id="sec-extending-classes">10.4 Extending classes</h3>
      <p>We still need to be able to create new element objects. You have already seen that "<span class="code">new</span>&nbsp;<span class="code">Element</span>" cannot be used for this because class <span class="code">Element</span> is abstract. To instantiate an element, therefore, we will need to create a subclass that extends <span class="code">Element</span> and implements the abstract <span class="code">contents</span> method. <a href="#lst-defining-subclass">Listing 10.3</a> shows one possible way to do that:<a id="i-1408184354-1"></a><a id="i-1305664359-1"></a></p>
      <p><a id="lst-defining-subclass"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ArrayElement</code>(conts:&nbsp;<code class="typename">Array[String]</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>&nbsp;=&nbsp;conts
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 10.3 - Defining <span class="code">ArrayElement</span> as a subclass of <span class="code">Element</span>.</h5>
      <p>Class <span class="code">ArrayElement</span> is defined to <span style="font-style:italic">extend</span> class <span class="code">Element</span>. Just like in Java, you use an extends clause after the class name to express this:</p> <pre>  ...&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;...
</pre>
      <div class="figure">
        <a id="fig-element-family"></a>
        <p><img src="ArrayElement160.png" alt="images/ArrayElement160.png"></p>
      </div>
      <h5> Figure 10.1 - Class diagram for <span class="code">ArrayElement</span>.</h5>
      <p>Such an extends clause has two effects: It makes class <span class="code">ArrayElement</span> <span style="font-style:italic">inherit</span> all non-private members from class <span class="code">Element</span>, and it makes the type <span class="code">ArrayElement</span> a <span style="font-style:italic">subtype</span> of the type <span class="code">Element</span>. Given <span class="code">ArrayElement</span> extends <span class="code">Element</span>, class <span class="code">ArrayElement</span> is called a <span style="font-style:italic"> subclass</span> of class <span class="code">Element</span>.<a id="i-1485346100-1"></a> Conversely, <span class="code">Element</span> is a <em>superclass</em> of <span class="code">ArrayElement</span>.<a id="i1436252235-1"></a> If you leave out an <span class="code">extends</span> clause, the Scala compiler implicitly assumes your class extends from <span class="code">scala.AnyRef</span>, which on the Java platform is the same as class <span class="code">java.lang.Object</span>. Thus, class <span class="code">Element</span> implicitly extends class <span class="code">AnyRef</span>. You can see these inheritance relationships in <a href="#fig-element-family">Figure 10.1</a>.</p>
      <p><span style="font-style:italic">Inheritance</span> means that all members of the superclass are also members of the subclass, with two exceptions. First, private members of the superclass are not inherited in a subclass. Second, a member of a superclass is not inherited if a member with the same name and parameters is already implemented in the subclass. In that case we say the member of the subclass <span style="font-style:italic">overrides</span> the member of the superclass. If the member in the subclass is concrete and the member of the superclass is abstract, we also say that the concrete member <span style="font-style:italic">implements</span> the abstract one.</p>
      <p>For example, the <span class="code">contents</span> method in <span class="code">ArrayElement</span> overrides (or alternatively: implements) abstract method <span class="code">contents</span> in class <span class="code">Element</span>.<a href="#footnotemain10-2">[2]</a> By contrast, class <span class="code">ArrayElement</span> inherits the <span class="code">width</span> and <span class="code">height</span> methods from class <span class="code">Element</span>. For example, given an <span class="code">ArrayElement</span> <span class="code">ae</span>, you can query its width using <span class="code">ae.width</span>, as if <span class="code">width</span> were defined in class <span class="code">ArrayElement</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;ae&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="typename">Array</code>(<code class="quotedstring">"hello"</code>,&nbsp;<code class="quotedstring">"world"</code>))
  <code class="output">ae:&nbsp;ArrayElement&nbsp;=&nbsp;ArrayElement@5ae66c98</code>
  <br>  scala&gt;&nbsp;ae.width
  <code class="output">res0:&nbsp;Int&nbsp;=&nbsp;5</code>
</pre>
      <p><span style="font-style:italic">Subtyping</span> means that a value of the subclass can be used wherever a value of the superclass is required. For example:</p> <pre>  <code class="vem">val</code>&nbsp;e:&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="typename">Array</code>(<code class="quotedstring">"hello"</code>))
</pre>
      <p>Variable <span class="code">e</span> is defined to be of type <span class="code">Element</span>, so its initializing value should also be an <span class="code">Element</span>. In fact, the initializing value's type is <span class="code">ArrayElement</span>. This is OK, because class <span class="code">ArrayElement</span> extends class <span class="code">Element</span>, and as a result, the type <span class="code">ArrayElement</span> is compatible with the type <span class="code">Element</span>.<a href="#footnotemain10-3">[3]</a></p>
      <p><a href="#fig-element-family">Figure 10.1</a> also shows the <em>composition</em> relationship that exists between <span class="code">ArrayElement</span> and <span class="code">Array[String]</span><a id="i-838923862-1"></a>. This relationship is called composition because class <span class="code">ArrayElement</span> is "composed" out of an <span class="code">Array[String]</span>, in that the Scala compiler will place into the binary class it generates for <span class="code">ArrayElement</span> a field that holds a reference to the passed <span class="code">conts</span> array. We'll discuss some design considerations concerning composition and inheritance later in this chapter, in <a href="#sec-using-composition-and-inheritance">Section 10.11</a>.</p>
      <h3 id="sec-two-name-spaces">10.5 Overriding methods and fields</h3>
      <p>The uniform access principle is just one aspect where Scala treats<a id="i-1224666293-1"></a><a id="i496223825-1"></a><a id="i1471166698-1"></a> fields and methods more uniformly than Java. Another difference is that in Scala, fields and methods belong to the same namespace. This makes it possible for a field to override a parameterless method. For instance, you could change the implementation of <span class="code">contents</span> in class <span class="code">ArrayElement</span> from a method to a field without having to modify the abstract method definition of <span class="code">contents</span> in class <span class="code">Element</span>, as shown in <a href="#lst-overriding-with-field">Listing 10.4</a>:</p>
      <p><a id="lst-overriding-with-field"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ArrayElement</code>(conts:&nbsp;<code class="typename">Array[String]</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>&nbsp;=&nbsp;conts
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 10.4 - Overriding a parameterless method with a field.</h5>
      <p>Field <span class="code">contents</span> (defined with a <span class="code">val</span>) in this version of <span class="code">ArrayElement</span> is a perfectly good implementation of the parameterless method <span class="code">contents</span> (declared with a <span class="code">def</span>) in class <span class="code">Element</span>. On the other hand, in Scala it is forbidden to define a field and method with the same name in the same class, whereas this is allowed in Java.</p>
      <p>For example, this Java class would compile just fine:</p> <pre>  //&nbsp;This&nbsp;is&nbsp;Java
  class&nbsp;CompilesFine&nbsp;{
  &nbsp;&nbsp;private&nbsp;int&nbsp;f&nbsp;=&nbsp;0;
  &nbsp;&nbsp;public&nbsp;int&nbsp;f()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
  &nbsp;&nbsp;}
  }
</pre>
      <p>But the corresponding Scala class would not compile:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">WontCompile</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;f&nbsp;=&nbsp;<code class="literal">0</code>&nbsp;<code class="comment">//&nbsp;Won't&nbsp;compile,&nbsp;because&nbsp;a&nbsp;field&nbsp;</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;f&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;and&nbsp;method&nbsp;have&nbsp;the&nbsp;same&nbsp;name</code>
  }
</pre>
      <p>Generally, Scala has just two namespaces for definitions in place of Java's four.<a id="i765341585-1"></a> Java's four namespaces are fields, methods, types, and packages. By contrast, Scala's two namespaces are:</p>
      <ul>
        <li>values (fields, methods, packages, and singleton objects) </li>
        <li>types (class and trait names) </li>
      </ul>
      <p>The reason Scala places fields and methods into the same namespace is precisely so you can override a parameterless method with a <span class="code">val</span>, something you can't do with Java.<a href="#footnotemain10-4">[4]</a></p>
      <h3 id="sec-parametric-fields">10.6 Defining parametric fields</h3>
      <p>Consider again the definition of class <span class="code">ArrayElement</span> shown in the previous section. It has a<a id="i-590826255-2"></a> parameter <span class="code">conts</span> whose sole purpose is to be copied into the <span class="code">contents</span> field. The name <span class="code">conts</span> of the parameter was chosen just so that it would look similar to the field name <span class="code">contents</span> without actually clashing with it. This is a "code smell," a sign that there may be some unnecessary redundancy and repetition in your code.</p>
      <p>You can avoid the code smell by combining the parameter and the field in a single <a href="#g-1177929110"><em>parametric field</em></a> definition,<a id="i763174956-1"></a> as shown in <a href="#lst-parametric-field">Listing 10.5</a><a id="i2138903369-2"></a>:</p>
      <p><a id="lst-parametric-field"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ArrayElement</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>
  &nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>
</pre>
      <h5>Listing 10.5 - Defining <span class="code">contents</span> as a parametric field.</h5>
      <p>Note that now the <span class="code">contents</span> parameter is prefixed by <span class="code">val</span>. This is a shorthand that defines at the same time a parameter and field with the same name. Specifically, class <span class="code">ArrayElement</span> now has an (unreassignable) field <span class="code">contents</span>, which can be accessed from outside the class. The field is initialized with the value of the parameter. It's as if the class had been written as follows, where <span class="code">x123</span> is an arbitrary fresh name for the parameter:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ArrayElement</code>(x123:&nbsp;<code class="typename">Array[String]</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>&nbsp;=&nbsp;x123
  }
</pre>
      <p>You can also prefix a class parameter with <span class="code">var</span>, in which case the corresponding field would be reassignable.<a id="i332825445-1"></a> Finally, it is possible to add modifiers, such as <span class="code">private</span>, <span class="code">protected</span>,<a href="#footnotemain10-5">[5]</a> or <span class="code">override</span> to these parametric fields, just as you can for any other class member.<a id="i-23781736-1"></a><a id="i1026131843-1"></a><a id="i1623377591-1"></a> Consider, for instance, the following class definitions:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Cat</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;dangerous&nbsp;=&nbsp;<code class="vem">false</code>
  }
  <code class="vem">class</code>&nbsp;<code class="typename">Tiger</code>(
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;dangerous:&nbsp;<code class="typename">Boolean</code>,
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;age:&nbsp;<code class="typename">Int</code>
  )&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Cat</code>
</pre>
      <p><span class="code">Tiger</span>'s definition is a shorthand for the following alternate class definition with an overriding member <span class="code">dangerous</span> and a <span class="code">private</span> member <span class="code">age</span>:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Tiger</code>(param1:&nbsp;<code class="typename">Boolean</code>,&nbsp;param2:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Cat</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;dangerous&nbsp;=&nbsp;param1
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;age&nbsp;=&nbsp;param2
  }
</pre>
      <p>Both members are initialized from the corresponding parameters. We chose the names of those parameters, <span class="code">param1</span> and <span class="code">param2</span>, arbitrarily. The important thing was that they not clash with any other name in scope.</p>
      <h3>10.7 Invoking superclass constructors</h3>
      <p>You now have a complete system consisting of two classes: an abstract class <span class="code">Element</span>, which is extended by a concrete class <span class="code">ArrayElement</span>. You might also envision other ways to express an element.<a id="i1670701927-1"></a><a id="i-1862849439-1"></a><a id="i685242324-1"></a> For example, clients might want to create a layout element consisting of a single line given by a string. Object-oriented programming makes it easy to extend a system with new data-variants. You can simply add subclasses. For example, <a href="#lst-invoking-superclass-constructor">Listing 10.6</a> shows a <span class="code">LineElement</span> class that extends <span class="code">ArrayElement</span>:</p>
      <p><a id="lst-invoking-superclass-constructor"></a></p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">LineElement</code>(s:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="typename">Array</code>(s))&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;width&nbsp;=&nbsp;s.length
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;height&nbsp;=&nbsp;<code class="literal">1</code>
  }
</pre>
      <h5>Listing 10.6 - Invoking a superclass constructor.</h5>
      <p>Since <span class="code">LineElement</span> extends <span class="code">ArrayElement</span>, and <span class="code">ArrayElement</span>'s constructor takes a parameter (an <span class="code">Array[String]</span>), <span class="code">LineElement</span> needs to pass an argument to the primary constructor of its superclass. To invoke a superclass constructor, you simply place the argument or arguments you want to pass in parentheses following the name of the superclass.<a id="i-2005725727-1"></a> For example, class <span class="code">LineElement</span> passes <span class="code">Array(s)</span> to <span class="code">ArrayElement</span>'s primary constructor by placing it in parentheses after the superclass <span class="code">ArrayElement</span>'s name:</p> <pre>  ...&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="typename">Array</code>(s))&nbsp;...
</pre>
      <p>With the new subclass, the inheritance hierarchy for layout elements now looks as shown in <a href="#fig-line-element">Figure 10.2</a>.</p>
      <div class="figure">
        <a id="fig-line-element"></a>
        <p><img src="LineElement160.png" alt="images/LineElement160.png"></p>
      </div>
      <h5> Figure 10.2 - Class diagram for <span class="code">LineElement</span>.</h5>
      <h3 id="sec-using-override-modifiers">10.8 Using <span class="code">override</span> modifiers</h3>
      <p>Note that the definitions of <span class="code">width</span> and <span class="code">height</span> in <span class="code">LineElement</span> carry an <span class="code">override</span> modifier. In <a href="#sec-reimp-tostring">Section 6.3</a>, you saw this modifier in the definition of a <span class="code">toString</span> method.<a id="i1201360043-2"></a> Scala requires such a modifier for all members that override a concrete member in a parent class. The modifier is optional if a member implements an abstract member with the same name. The modifier is forbidden if a member does not override or implement some other member in a base class. Since <span class="code">height</span> and <span class="code">width</span> in class <span class="code">LineElement</span> override concrete definitions in class <span class="code">Element</span>, <span class="code">override</span> is required.</p>
      <p>This rule provides useful information for the compiler that helps avoid some hard-to-catch errors and makes system evolution safer. For instance, if you happen to misspell the method or accidentally give it a different parameter list, the compiler will respond with an error message:<a id="i934798591-1"></a></p> <pre>  $&nbsp;scalac&nbsp;LineElement.scala&nbsp;
  <code class="output">.../LineElement.scala:50:</code>
  <code class="output">error:&nbsp;method&nbsp;hight&nbsp;overrides&nbsp;nothing</code>
  <code class="output">&nbsp;&nbsp;override&nbsp;def&nbsp;hight&nbsp;=&nbsp;1</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^&nbsp;</code>
</pre>
      <p>The <span class="code">override</span> convention is even more important when it comes to system evolution. Say you defined a library of 2D drawing methods. You made it publicly available, and it is widely used. In the next version of the library you want to add to your base class <span class="code">Shape</span> a new method with this signature:</p> <pre>  <code class="vem">def</code>&nbsp;hidden():&nbsp;<code class="typename">Boolean</code>
</pre>
      <p>Your new method will be used by various drawing methods to determine whether a shape needs to be drawn. This could lead to a significant speedup, but you cannot do this without the risk of breaking client code. After all, a client could have defined a subclass of <span class="code">Shape</span> with a different implementation of <span class="code">hidden</span>. Perhaps the client's method actually makes the receiver object disappear instead of testing whether the object is hidden. Because the two versions of <span class="code">hidden</span> override each other, your drawing methods would end up making objects disappear, which is certainly not what you want!</p>
      <p>These "accidental overrides" are the most common manifestation of what is called the "fragile base class" problem. The problem is that if you add new members to base classes (which we usually call superclasses) in a class hierarchy, you risk breaking client code. Scala cannot completely solve the fragile base class problem, but it improves on the situation compared to Java.<a href="#footnotemain10-6">[6]</a> If the drawing library and its clients were written in Scala, then the client's original implementation of <span class="code">hidden</span> could not have had an <span class="code">override</span> modifier, because at the time there was no other method with that name.</p>
      <p>Once you add the <span class="code">hidden</span> method to the second version of your shape class, a recompile of the client would give an error like the following:<a id="i-2133711083-1"></a></p> <pre>  <code class="output">.../Shapes.scala:6:&nbsp;error:&nbsp;error&nbsp;overriding&nbsp;method</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;hidden&nbsp;in&nbsp;class&nbsp;Shape&nbsp;of&nbsp;type&nbsp;()Boolean;</code>
  <code class="output">method&nbsp;hidden&nbsp;needs&nbsp;`override'&nbsp;modifier</code>
  <code class="output">def&nbsp;hidden():&nbsp;Boolean&nbsp;=&nbsp;</code>
  <code class="output">^</code>
</pre>
      <p>That is, instead of wrong behavior your client would get a compile-time error, which is usually much preferable.</p>
      <h3>10.9 Polymorphism and dynamic binding</h3>
      <p>You saw in <a href="#sec-extending-classes">Section 10.4</a> that a variable of type <span class="code">Element</span> could refer to an object of type <span class="code">ArrayElement</span>. The name for this phenomenon is <em>polymorphism</em>, which means "many shapes" or "many forms." In this case, <span class="code">Element</span> objects can have many forms.<a href="#footnotemain10-7">[7]</a></p>
      <p>So far, you've seen two such forms: <span class="code">ArrayElement</span> and <span class="code">LineElement</span>. You can create more forms of <span class="code">Element</span> by defining new <span class="code">Element</span> subclasses. For example, you could define a new form of <span class="code">Element</span> that has a given width and height, and is filled everywhere with a given character:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">UniformElement</code>(
  &nbsp;&nbsp;ch:&nbsp;<code class="typename">Char</code>,&nbsp;
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>,
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>&nbsp;
  )&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;line&nbsp;=&nbsp;ch.toString&nbsp;*&nbsp;width
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;contents&nbsp;=&nbsp;Array.fill(height)(line)
  }
</pre>
      <p>The inheritance hierarchy for class <span class="code">Element</span> now looks as shown in <a href="#fig-layout-elements">Figure 10.3</a>. As a result, Scala will accept all of the following assignments, because the type of the assigning expression conforms to the type of the defined variable:</p> <pre>  <code class="vem">val</code>&nbsp;e1:&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="typename">Array</code>(<code class="quotedstring">"hello"</code>,&nbsp;<code class="quotedstring">"world"</code>))
  <code class="vem">val</code>&nbsp;ae:&nbsp;<code class="typename">ArrayElement</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">LineElement</code>(<code class="quotedstring">"hello"</code>)
  <code class="vem">val</code>&nbsp;e2:&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;ae
  <code class="vem">val</code>&nbsp;e3:&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">UniformElement</code>(<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
</pre>
      <p>If you check the inheritance hierarchy, you'll find that in each of these four <span class="code">val</span> definitions, the type of the expression to the right of the equals sign is below the type of the <span class="code">val</span> being initialized to the left of the equals sign.</p>
      <div class="figure">
        <a id="fig-layout-elements"></a>
        <p><img src="elementFamily160.png" alt="images/elementFamily160.png"></p>
      </div>
      <h5> Figure 10.3 - Class hierarchy of layout elements.</h5>
      <p>The other half of the story, however, is that method invocations on variables and expressions are <em>dynamically bound</em>.<a id="i-1297249718-1"></a> This means that the actual method implementation invoked is determined at run time based on the class of the object, not the type of the variable or expression. To demonstrate this behavior, we'll temporarily remove all existing members from our <span class="code">Element</span> classes and add a method named <span class="code">demo</span> to <span class="code">Element</span>. We'll override <span class="code">demo</span> in <span class="code">ArrayElement</span> and <span class="code">LineElement</span>, but not in <span class="code">UniformElement</span>:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;demo()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Element's&nbsp;implementation&nbsp;invoked"</code>)
  &nbsp;&nbsp;}
  }
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">ArrayElement</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;demo()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"ArrayElement's&nbsp;implementation&nbsp;invoked"</code>)
  &nbsp;&nbsp;}
  }
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">LineElement</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ArrayElement</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;demo()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"LineElement's&nbsp;implementation&nbsp;invoked"</code>)
  &nbsp;&nbsp;}
  }
  <br>  <code class="comment">//&nbsp;UniformElement&nbsp;inherits&nbsp;Element's&nbsp;demo</code>
  <code class="vem">class</code>&nbsp;<code class="typename">UniformElement</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;
</pre>
      <p>If you enter this code into the interpreter, you can then define this method that takes an <span class="code">Element</span> and invokes <span class="code">demo</span> on it:</p> <pre>  <code class="vem">def</code>&nbsp;invokeDemo(e:&nbsp;<code class="typename">Element</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;e.demo()
  }
</pre>
      <p>If you pass an <span class="code">ArrayElement</span> to <span class="code">invokeDemo</span>, you'll see a message indicating <span class="code">ArrayElement</span>'s implementation of <span class="code">demo</span> was invoked, even though the type of the variable, <span class="code">e</span>, on which <span class="code">demo</span> was invoked is <span class="code">Element</span>:</p> <pre>  scala&gt;&nbsp;invokeDemo(<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>)
  <code class="output">ArrayElement's&nbsp;implementation&nbsp;invoked</code>
</pre>
      <p>Similarly, if you pass a <span class="code">LineElement</span> to <span class="code">invokeDemo</span>, you'll see a message that indicates <span class="code">LineElement</span>'s <span class="code">demo</span> implementation was invoked:</p> <pre>  scala&gt;&nbsp;invokeDemo(<code class="vem">new</code>&nbsp;<code class="typename">LineElement</code>)
  <code class="output">LineElement's&nbsp;implementation&nbsp;invoked</code>
</pre>
      <p>The behavior when passing a <span class="code">UniformElement</span> may at first glance look suspicious, but it is correct:</p> <pre>  scala&gt;&nbsp;invokeDemo(<code class="vem">new</code>&nbsp;<code class="typename">UniformElement</code>)
  <code class="output">Element's&nbsp;implementation&nbsp;invoked</code>
</pre>
      <p>Because <span class="code">UniformElement</span> does not override <span class="code">demo</span>, it inherits the implementation of <span class="code">demo</span> from its superclass, <span class="code">Element</span>. Thus, <span class="code">Element</span>'s implementation is the correct implementation of <span class="code">demo</span> to invoke when the class of the object is <span class="code">UniformElement</span>.</p>
      <h3>10.10 Declaring final members</h3>
      <p>Sometimes when designing an inheritance hierarchy, you want to ensure that a member cannot be overridden by subclasses. In Scala, as in Java, you do this by adding a <span class="code">final</span> modifier to the member.<a id="i-34445759-1"></a> As shown in <a href="#lst-final-method">Listing 10.7</a>, you could place a <span class="code">final</span> modifier on <span class="code">ArrayElement</span>'s demo method.</p>
      <p><a id="lst-final-method"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ArrayElement</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;demo()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"ArrayElement's&nbsp;implementation&nbsp;invoked"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 10.7 - Declaring a final method.</h5>
      <p>Given this version of <span class="code">ArrayElement</span>, an attempt to override demo in its subclass, <span class="code">LineElement</span>, would not compile:<a id="i-44166214-1"></a></p> <pre>  <code class="output">elem.scala:18:&nbsp;error:&nbsp;error&nbsp;overriding&nbsp;method&nbsp;demo</code>
  <code class="output">&nbsp;&nbsp;&nbsp;in&nbsp;class&nbsp;ArrayElement&nbsp;of&nbsp;type&nbsp;()Unit;</code>
  <code class="output">method&nbsp;demo&nbsp;cannot&nbsp;override&nbsp;final&nbsp;member</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;def&nbsp;demo()&nbsp;=&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>You may also at times want to ensure that an entire class not be subclassed. To do this you simply declare the entire class final by adding a <span class="code">final</span> modifier to the class declaration. For example, <a href="#lst-final-class">Listing 10.8</a> shows how you would declare <span class="code">ArrayElement</span> final:</p>
      <p><a id="lst-final-class"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ArrayElement</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;demo()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"ArrayElement's&nbsp;implementation&nbsp;invoked"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 10.8 - Declaring a final class.</h5>
      <p>With this version of <span class="code">ArrayElement</span>, any attempt at defining a subclass would fail to compile:<a id="i-1180851066-1"></a></p> <pre>  <code class="output">elem.scala:&nbsp;18:&nbsp;error:&nbsp;illegal&nbsp;inheritance&nbsp;from&nbsp;final&nbsp;class</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;ArrayElement</code>
  <code class="output">&nbsp;&nbsp;class&nbsp;LineElement&nbsp;extends&nbsp;ArrayElement&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>We'll now remove the <span class="code">final</span> modifiers and <span class="code">demo</span> methods, and go back to the earlier implementation of the <span class="code">Element</span> family. We'll focus our attention in the remainder of this chapter to completing a working version of the layout library.</p>
      <h3 id="sec-using-composition-and-inheritance">10.11 Using composition and inheritance</h3>
      <p>Composition and inheritance are two ways to define a new class in terms of another existing class.<a id="i-838923862-2"></a><a id="i-613838584-1"></a> If what you're after is primarily code reuse, you should in general prefer composition to inheritance. Only inheritance suffers from the fragile base class problem, in which you can inadvertently break subclasses by changing a superclass.</p>
      <p>One question you can ask yourself about an inheritance relationship is whether it models an <em>is-a</em><a id="i-422624999-1"></a> relationship.<a href="#footnotemain10-8">[8]</a> For example, it would be reasonable to say that <span class="code">ArrayElement</span> <em>is-an</em> <span class="code">Element</span>. Another question you can ask is whether clients will want to use the subclass type as a superclass type.<a href="#footnotemain10-9">[9]</a> In the case of <span class="code">ArrayElement</span>, we do indeed expect clients will want to use an <span class="code">ArrayElement</span> as an <span class="code">Element</span>.</p>
      <p>If you ask these questions about the inheritance relationships shown in <a href="#fig-layout-elements">Figure 10.3</a>, do any of the relationships seem suspicious? In particular, does it seem obvious to you that a <span class="code">LineElement</span> <em>is-an</em> <span class="code">ArrayElement</span>? Do you think clients would ever need to use a <span class="code">LineElement</span> as an <span class="code">ArrayElement</span>?</p>
      <p>In fact, we defined <span class="code">LineElement</span> as a subclass of <span class="code">ArrayElement</span> primarily to reuse <span class="code">ArrayElement</span>'s definition of <span class="code">contents</span>. Perhaps it would be better, therefore, to define <span class="code">LineElement</span> as a direct subclass of <span class="code">Element</span>, like this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">LineElement</code>(s:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;contents&nbsp;=&nbsp;<code class="typename">Array</code>(s)
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;width&nbsp;=&nbsp;s.length
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;height&nbsp;=&nbsp;<code class="literal">1</code>
  }
</pre>
      <p>In the previous version, <span class="code">LineElement</span> had an inheritance relationship with <span class="code">ArrayElement</span>, from which it inherited <span class="code">contents</span>. It now has a composition relationship with <span class="code">Array</span>: it holds a reference to an array of strings from its own <span class="code">contents</span> field.<a href="#footnotemain10-10">[10]</a> Given this implementation of <span class="code">LineElement</span>, the inheritance hierarchy for <span class="code">Element</span> now looks as shown in <a href="#fig-new-line-element">Figure 10.4</a>.</p>
      <div class="figure">
        <a id="fig-new-line-element"></a>
        <p><img src="elementFamily2160.png" alt="images/elementFamily2160.png"></p>
      </div>
      <h5> Figure 10.4 - Class hierarchy with revised <span class="code">LineElement</span>.</h5>
      <h3 id="sec-impl-above-beside-tostring">10.12 Implementing <span class="code">above</span>, <span class="code">beside</span>, and <span class="code">toString</span></h3>
      <p>As a next step, we'll implement method <span class="code">above</span> in class <span class="code">Element</span>. Putting one element above another means concatenating the two <span class="code">contents</span> values of the elements. So a first draft of method <span class="code">above</span> could look like this:</p> <pre>  <code class="vem">def</code>&nbsp;above(that:&nbsp;<code class="typename">Element</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="vem">this</code>.contents&nbsp;++&nbsp;that.contents)
</pre>
      <p>The <span class="code">++</span> operation concatenates two arrays. Arrays in Scala are represented as Java arrays, but support many more methods<a id="i-1409164998-1"></a>. Specifically, arrays in Scala can be converted to instances of a class <span class="code">scala.Seq</span>, which represents sequence-like structures and contains a number of methods for accessing and transforming sequences.<a id="i-161349850-1"></a> Some other array methods will be explained in this chapter and a more comprehensive discussion will be given in <a href="#chap-working-with-other-collections">Chapter 17</a>.</p>
      <p>In fact, the code shown previously is not quite sufficient because it does not let you put elements of different widths on top of each other. To keep things simple in this section, however, we'll leave this as is and only pass elements of the same length to <span class="code">above</span>. In <a href="#sec-heighten-and-widen">Section 10.14</a>, we'll make an enhancement to <span class="code">above</span> so that clients can use it to combine elements of different widths.</p>
      <p>The next method to implement is <span class="code">beside</span>. To put two elements beside each other, we'll create a new element in which every line results from concatenating corresponding lines of the two elements. As before, to keep things simple, we'll start by assuming the two elements have the same height. This leads to the following design of method <span class="code">beside</span>:</p> <pre>  <code class="vem">def</code>&nbsp;beside(that:&nbsp;<code class="typename">Element</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;contents&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[String]</code>(<code class="vem">this</code>.contents.length)
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;<code class="vem">this</code>.contents.length)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;contents(i)&nbsp;=&nbsp;<code class="vem">this</code>.contents(i)&nbsp;+&nbsp;that.contents(i)
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(contents)
  }
</pre>
      <p>The <span class="code">beside</span> method first allocates a new array,<a id="i-1690228669-1"></a> <span class="code">contents</span>, and fills it with the concatenation of the corresponding array elements in <span class="code">this.contents</span> and <span class="code">that.contents</span>. It finally produces a new <span class="code">ArrayElement</span> containing the new <span class="code">contents</span>.</p>
      <p>Although this implementation of <span class="code">beside</span> works, it is in an imperative style, the telltale sign of which is the loop in which we index through arrays. Alternatively, the method could be abbreviated to one expression:</p> <pre>  <code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;(line1,&nbsp;line2)&nbsp;&lt;-&nbsp;<code class="vem">this</code>.contents&nbsp;zip&nbsp;that.contents
  &nbsp;&nbsp;)&nbsp;<code class="vem">yield</code>&nbsp;line1&nbsp;+&nbsp;line2
  )
</pre>
      <p>Here, the two arrays, <span class="code">this.contents</span> and <span class="code">that.contents</span>, are transformed into an array of pairs (as <span class="code">Tuple2</span>s are called)<a id="i1832062192-1"></a> using the <span class="code">zip</span> operator. The <span class="code">zip</span> operator picks corresponding elements in its two operands and forms an array of pairs. For instance, this expression:</p> <pre>  <code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;zip&nbsp;<code class="typename">Array</code>(<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"b"</code>)
</pre>
      <p>will evaluate to:</p> <pre>  <code class="typename">Array</code>((<code class="literal">1</code>,&nbsp;<code class="quotedstring">"a"</code>),&nbsp;(<code class="literal">2</code>,&nbsp;<code class="quotedstring">"b"</code>))
</pre>
      <p>If one of the two operand arrays is longer than the other, <span class="code">zip</span> will drop the remaining elements. In the expression above, the third element of the left operand, <span class="code">3</span>, does not form part of the result, because it does not have a corresponding element in the right operand.</p>
      <p>The zipped array is then iterated over by a <span class="code">for</span> expression. Here, the syntax "<span class="code">for</span>&nbsp;<span class="code">((line1,</span>&nbsp;<span class="code">line2)</span>&nbsp;<span class="code">&lt;-</span> ...<span class="code">)</span>" allows you to name both elements of a pair in one <span style="font-style:italic">pattern</span> (<i>i.e.</i>, <span class="code">line1</span> stands now for the first element of the pair, and <span class="code">line2</span> stands for the second). Scala's pattern-matching system will be described in detail in <a href="#chap-case-classes-and-pattern-matching">Chapter 15</a>. For now, you can just think of this as a way to define two <span class="code">val</span>s, <span class="code">line1</span> and <span class="code">line2</span>, for each step of the iteration.</p>
      <p>The <span class="code">for</span> expression has a <span class="code">yield</span> part and therefore yields a result. The result is of the same kind as the expression iterated over (<i>i.e.</i>, it is an array). Each element of the array is the result of concatenating the corresponding lines, <span class="code">line1</span> and <span class="code">line2</span>. So the end result of this code is the same as in the first version of <span class="code">beside</span>, but because it avoids explicit array indexing, the result is obtained in a less error-prone way.</p>
      <p>You still need a way to display elements. As usual, this is done by defining a <span class="code">toString</span> method that returns an element formatted as a string. Here is its definition:</p> <pre>  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;contents&nbsp;mkString&nbsp;<code class="quotedstring">"\n"</code>
</pre>
      <p>The implementation of <span class="code">toString</span> makes use of <span class="code">mkString</span>, which is defined for all sequences, including arrays. As you saw in <a href="#sec-refactoring-imperative-code">Section 7.8</a>, an expression like "<span class="code">arr</span> <span class="code">mkString</span> <span class="code">sep</span>" returns a string consisting of all elements of the array <span class="code">arr</span>. Each element is mapped to a string by calling its <span class="code">toString</span> method. A separator string <span class="code">sep</span> is inserted between consecutive element strings. So the expression, "<span class="code">contents</span> <span class="code">mkString</span> <span class="code">"\n"</span>" formats the <span class="code">contents</span> array as a string, where each array element appears on a line by itself.</p>
      <p><a id="lst-element-with-three-methods"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;width:&nbsp;<code class="typename">Int</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(height&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="literal">0</code>&nbsp;<code class="vem">else</code>&nbsp;contents(<code class="literal">0</code>).length
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;height:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;contents.length
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;above(that:&nbsp;<code class="typename">Element</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="vem">this</code>.contents&nbsp;++&nbsp;that.contents)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;beside(that:&nbsp;<code class="typename">Element</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(line1,&nbsp;line2)&nbsp;&lt;-&nbsp;<code class="vem">this</code>.contents&nbsp;zip&nbsp;that.contents
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<code class="vem">yield</code>&nbsp;line1&nbsp;+&nbsp;line2
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;contents&nbsp;mkString&nbsp;<code class="quotedstring">"\n"</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 10.9 - Class <span class="code">Element</span> with <span class="code">above</span>, <span class="code">beside</span>, and <span class="code">toString</span>.</h5>
      <p>Note that <span class="code">toString</span> does not carry an empty parameter list. This follows the recommendations for the uniform access principle, because <span class="code">toString</span> is a pure method that does not take any parameters. With the addition of these three methods, class <span class="code">Element</span> now looks as shown in <a href="#lst-element-with-three-methods">Listing 10.9</a>.</p>
      <h3>10.13 Defining a factory object</h3>
      <p>You now have a hierarchy of classes for layout elements. This<a id="i-640194953-2"></a> hierarchy could be presented to your clients "as is," but you might also choose to hide the hierarchy behind a factory object.<a id="i867568852-1"></a></p>
      <p>A factory object contains methods that construct other objects. Clients would then use these factory methods to construct objects, rather than constructing the objects directly with <span class="code">new</span>. An advantage of this approach is that object creation can be centralized and the details of how objects are represented with classes can be hidden. This hiding will both<a id="i593484137-1"></a> make your library simpler for clients to understand, because less detail is exposed, and provide you with more opportunities to change your library's implementation later without breaking client code.</p>
      <p>The first task in constructing a factory for layout elements is to choose where the factory methods should be located. Should they be members of a singleton object or of a class? What should the containing object or class be called? There are many possibilities. A straightforward solution is to create a companion object of class <span class="code">Element</span> and make this the factory object for layout elements. That way, you need to expose only the class/object combo of <span class="code">Element</span> to your clients, and you can hide the three implementation classes <span class="code">ArrayElement</span>, <span class="code">LineElement</span>, and <span class="code">UniformElement</span>.</p>
      <p><a href="#lst-factory-object-and-methods">Listing 10.10</a> is a design of the <span class="code">Element</span> object that follows this scheme. The <span class="code">Element</span> object contains three overloaded variants of an <span class="code">elem</span> method and each constructs a different kind of layout object.</p>
      <p><a id="lst-factory-object-and-methods"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem(contents:&nbsp;<code class="typename">Array[String]</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(contents)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem(chr:&nbsp;<code class="typename">Char</code>,&nbsp;width:&nbsp;<code class="typename">Int</code>,&nbsp;height:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">UniformElement</code>(chr,&nbsp;width,&nbsp;height)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem(line:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">LineElement</code>(line)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 10.10 - A factory object with factory methods.</h5>
      <p>With the advent of these factory methods, it makes sense to change the implementation of class <span class="code">Element</span> so that it goes through the <span class="code">elem</span> factory methods rather than creating new <span class="code">ArrayElement</span> instances explicitly. To call the factory methods without qualifying them with <span class="code">Element</span>, the name of the singleton object, we will import <span class="code">Element.elem</span> at the top of the source file. In other words, instead of invoking the factory methods with <span class="code">Element.elem</span> inside class <span class="code">Element</span>, we'll import <span class="code">Element.elem</span> so we can just call the factory methods by their simple name, <span class="code">elem</span>. <a href="#lst-element-using-factory-methods">Listing 10.11</a> shows what class <span class="code">Element</span> will look like after these changes.</p>
      <p><a id="lst-element-using-factory-methods"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;Element.elem
  <br>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;width:&nbsp;<code class="typename">Int</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(height&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;<code class="literal">0</code>&nbsp;<code class="vem">else</code>&nbsp;contents(<code class="literal">0</code>).length
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;height:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;contents.length
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;above(that:&nbsp;<code class="typename">Element</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(<code class="vem">this</code>.contents&nbsp;++&nbsp;that.contents)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;beside(that:&nbsp;<code class="typename">Element</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(line1,&nbsp;line2)&nbsp;&lt;-&nbsp;<code class="vem">this</code>.contents&nbsp;zip&nbsp;that.contents
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<code class="vem">yield</code>&nbsp;line1&nbsp;+&nbsp;line2
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;contents&nbsp;mkString&nbsp;<code class="quotedstring">"\n"</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 10.11 - Class <span class="code">Element</span> refactored to use factory methods.</h5>
      <p>In addition, given the factory methods, the subclasses, <span class="code">ArrayElement</span>, <span class="code">LineElement</span>, and <span class="code">UniformElement</span>, could now be private because they no longer need to be accessed directly by clients. In Scala, you can define classes and singleton objects inside other classes and singleton objects.<a id="i1315254152-1"></a><a id="i1968015105-1"></a><a id="i-1545427464-1"></a> One way to make the <span class="code">Element</span> subclasses private is to place them inside the <span class="code">Element</span> singleton object and declare them private there. The classes will still be accessible to the three <span class="code">elem</span> factory methods, where they are needed. <a href="#lst-hiding-implementation">Listing 10.12</a> shows how that will look.</p>
      <h3 id="sec-heighten-and-widen">10.14 Heighten and widen</h3>
      <p>We need one last enhancement. The version of <span class="code">Element</span> shown in <a href="#lst-element-using-factory-methods">Listing 10.11</a> is not quite sufficient because it does not allow clients to place elements of different widths on top of each other, or place elements of different heights beside each other.</p>
      <p>For example, evaluating the following expression won't work correctly, because the second line in the combined element is longer than the first:</p> <pre>  <code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="typename">Array</code>(<code class="quotedstring">"hello"</code>))&nbsp;above&nbsp;
  <code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="typename">Array</code>(<code class="quotedstring">"world!"</code>))
</pre>
      <p>Similarly, evaluating the following expression would not work properly, because the first <span class="code">ArrayElement</span> has a height of two and the second a height of only one:</p> <pre>  <code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="typename">Array</code>(<code class="quotedstring">"one"</code>,&nbsp;<code class="quotedstring">"two"</code>))&nbsp;beside&nbsp;
  <code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(<code class="typename">Array</code>(<code class="quotedstring">"one"</code>))
</pre>
      <p><a href="#lst-widen-heighten-methods">Listing 10.13</a> shows a private helper method, <span class="code">widen</span>, which takes a width and returns an <span class="code">Element</span> of that width. The result contains the contents of this <span class="code">Element</span>, centered, padded to the left and right by any spaces needed to achieve the required width. <a href="#lst-widen-heighten-methods">Listing 10.13</a> also shows a similar method, <span class="code">heighten</span>, which performs the same function in the vertical direction. The <span class="code">widen</span> method is invoked by <span class="code">above</span> to ensure that <span class="code">Element</span>s placed above each other have the same width. Similarly, the <span class="code">heighten</span> method is invoked by <span class="code">beside</span> to ensure that elements placed beside each other have the same height. With these changes, the layout library is ready for use.</p>
      <p><a id="lst-hiding-implementation"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ArrayElement</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;contents:&nbsp;<code class="typename">Array[String]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">LineElement</code>(s:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;contents&nbsp;=&nbsp;<code class="typename">Array</code>(s)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;width&nbsp;=&nbsp;s.length
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;height&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">UniformElement</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch:&nbsp;<code class="typename">Char</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;line&nbsp;=&nbsp;ch.toString&nbsp;*&nbsp;width
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;contents&nbsp;=&nbsp;Array.fill(height)(line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem(contents:&nbsp;&nbsp;<code class="typename">Array[String]</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayElement</code>(contents)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem(chr:&nbsp;<code class="typename">Char</code>,&nbsp;width:&nbsp;<code class="typename">Int</code>,&nbsp;height:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">UniformElement</code>(chr,&nbsp;width,&nbsp;height)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem(line:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">LineElement</code>(line)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 10.12 - Hiding implementation with private classes.</h5>
      <p><a id="lst-widen-heighten-methods"></a></p> <pre>  <code class="vem">import</code>&nbsp;Element.elem
  <br>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Element</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;contents:&nbsp;&nbsp;<code class="typename">Array[String]</code>
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;width:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;contents(<code class="literal">0</code>).length
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;height:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;contents.length
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;above(that:&nbsp;<code class="typename">Element</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;this1&nbsp;=&nbsp;<code class="vem">this</code>&nbsp;widen&nbsp;that.width
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;that1&nbsp;=&nbsp;that&nbsp;widen&nbsp;<code class="vem">this</code>.width
  &nbsp;&nbsp;&nbsp;&nbsp;elem(this1.contents&nbsp;++&nbsp;that1.contents)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;beside(that:&nbsp;<code class="typename">Element</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;this1&nbsp;=&nbsp;<code class="vem">this</code>&nbsp;heighten&nbsp;that.height
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;that1&nbsp;=&nbsp;that&nbsp;heighten&nbsp;<code class="vem">this</code>.height
  &nbsp;&nbsp;&nbsp;&nbsp;elem(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;((line1,&nbsp;line2)&nbsp;&lt;-&nbsp;this1.contents&nbsp;zip&nbsp;that1.contents)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;line1&nbsp;+&nbsp;line2)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;widen(w:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(w&nbsp;&lt;=&nbsp;width)&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;left&nbsp;=&nbsp;elem(<code class="quotedstring">'&nbsp;'</code>,&nbsp;(w&nbsp;-&nbsp;width)&nbsp;/&nbsp;<code class="literal">2</code>,&nbsp;height)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;right&nbsp;=&nbsp;elem(<code class="quotedstring">'&nbsp;'</code>,&nbsp;w&nbsp;-&nbsp;width&nbsp;-&nbsp;left.width,&nbsp;height)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;beside&nbsp;<code class="vem">this</code>&nbsp;beside&nbsp;right
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;heighten(h:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(h&nbsp;&lt;=&nbsp;height)&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;top&nbsp;=&nbsp;elem(<code class="quotedstring">'&nbsp;'</code>,&nbsp;width,&nbsp;(h&nbsp;-&nbsp;height)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;bot&nbsp;=&nbsp;elem(<code class="quotedstring">'&nbsp;'</code>,&nbsp;width,&nbsp;h&nbsp;-&nbsp;height&nbsp;-&nbsp;top.height)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top&nbsp;above&nbsp;<code class="vem">this</code>&nbsp;above&nbsp;bot
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;contents&nbsp;mkString&nbsp;<code class="quotedstring">"\n"</code>
  }
</pre>
      <h5>Listing 10.13 - <span class="code">Element</span> with <span class="code">widen</span> and <span class="code">heighten</span> methods.</h5>
      <h3 id="sec-putting-it-together">10.15 Putting it all together</h3>
      <p>A fun way to exercise almost all elements of the layout library is to write a program that draws a spiral with a given number of edges. This <span class="code">Spiral</span> program, shown in <a href="#lst-spiral-app">Listing 10.14</a>, will do just that.</p>
      <p><a id="lst-spiral-app"></a></p> <pre>  <code class="vem">import</code>&nbsp;Element.elem
  <br>  <code class="vem">object</code>&nbsp;<code class="typename">Spiral</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;space&nbsp;=&nbsp;elem(<code class="quotedstring">"&nbsp;"</code>)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;corner&nbsp;=&nbsp;elem(<code class="quotedstring">"+"</code>)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;spiral(nEdges:&nbsp;<code class="typename">Int</code>,&nbsp;direction:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(nEdges&nbsp;==&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(<code class="quotedstring">"+"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;sp&nbsp;=&nbsp;spiral(nEdges&nbsp;-&nbsp;<code class="literal">1</code>,&nbsp;(direction&nbsp;+&nbsp;<code class="literal">3</code>)&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">4</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;verticalBar&nbsp;=&nbsp;elem(<code class="quotedstring">'|'</code>,&nbsp;<code class="literal">1</code>,&nbsp;sp.height)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;horizontalBar&nbsp;=&nbsp;elem(<code class="quotedstring">'-'</code>,&nbsp;sp.width,&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(direction&nbsp;==&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(corner&nbsp;beside&nbsp;horizontalBar)&nbsp;above&nbsp;(sp&nbsp;beside&nbsp;space)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="vem">if</code>&nbsp;(direction&nbsp;==&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sp&nbsp;above&nbsp;space)&nbsp;beside&nbsp;(corner&nbsp;above&nbsp;verticalBar)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="vem">if</code>&nbsp;(direction&nbsp;==&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(space&nbsp;beside&nbsp;sp)&nbsp;above&nbsp;(horizontalBar&nbsp;beside&nbsp;corner)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(verticalBar&nbsp;above&nbsp;corner)&nbsp;beside&nbsp;(space&nbsp;above&nbsp;sp)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;nSides&nbsp;=&nbsp;args(<code class="literal">0</code>).toInt
  &nbsp;&nbsp;&nbsp;&nbsp;println(spiral(nSides,&nbsp;<code class="literal">0</code>))
  &nbsp;&nbsp;}
  }
</pre>
      <h5>Listing 10.14 - The <span class="code">Spiral</span> application.</h5>
      <p>Because <span class="code">Spiral</span> is a standalone object with a <span class="code">main</span> method with the proper signature, it is a Scala application. <span class="code">Spiral</span> takes one command-line argument, an integer, and draws a spiral with the specified number of edges. For example, you could draw a six-edge spiral, as shown on the left, and larger spirals, as shown on the right.</p> <pre>  $&nbsp;scala&nbsp;Spiral&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;scala&nbsp;Spiral&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;scala&nbsp;Spiral&nbsp;17
  +-----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+----------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+----------------
  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  |&nbsp;+-+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;+------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;+------------+&nbsp;
  |&nbsp;+&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;
  |&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;+--+&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;+--------+&nbsp;|&nbsp;
  +---+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;++&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;+----+&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;+----+&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;++&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;+--+&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;+------+&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;+----------+&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+--------------+&nbsp;
</pre>
      <h3>10.16 Conclusion</h3>
      <p>In this section, you saw more concepts related to object-oriented programming in Scala. Among others, you encountered abstract classes, inheritance and subtyping, class hierarchies, parametric fields, and method overriding. You should have developed a feel for constructing a non-trivial class hierarchy in Scala. We'll work with the layout library again in <a href="#chap-assertions-and-tests">Chapter 14</a>.</p>
      <hr>
      <h4>Footnotes for Chapter 10:</h4>
      <p><a id="footnotemain10-1"></a>[1] Meyer, <em>Object-Oriented Software Construction</em> <a href="#meyer-oo-soft-con">[Mey00]</a><a id="i1013925756-1"></a><a id="i730601900-1"></a></p>
      <p><a id="footnotemain10-2"></a>[2] One flaw with this design is that because the returned array is mutable, clients could change it. For the book we'll keep things simple, but were <span class="code">ArrayElement</span> part of a real project, you might consider returning a <em>defensive copy</em> of the array instead. Another problem is we aren't currently ensuring that every <span class="code">String</span> element of the <span class="code">contents</span> array has the same length. This could be solved by checking the precondition in the primary constructor and throwing an exception if it is violated.</p>
      <p><a id="footnotemain10-3"></a>[3] For more perspective on the difference between subclass and subtype, see the glossary entry for <a href="#g-1867567750"><em>subtype</em></a>.</p>
      <p><a id="footnotemain10-4"></a>[4] The reason that packages share the same namespace as fields and methods in Scala is to enable you to import packages (in addition to just the names of types) and the fields and methods of singleton objects. This is also something you can't do in Java. It will be described in <a href="#sec-imports">Section 13.3</a>.</p>
      <p><a id="footnotemain10-5"></a>[5] The <span class="code">protected</span> modifier, which grants access to subclasses, will be covered in detail in <a href="#chap-packages-and-imports">Chapter 13</a>.</p>
      <p><a id="footnotemain10-6"></a>[6] In Java 1.5, an <span class="code">@Override</span> annotation was introduced that works similarly to Scala's <span class="code">override</span> modifier, but unlike Scala's <span class="code">override</span>, is not required.</p>
      <p><a id="footnotemain10-7"></a>[7] This kind of polymorphism is called <em>subtyping polymorphism</em><a id="i63796807-1"></a><a id="i367948816-1"></a>. Another kind of polymorphism in Scala called <em>universal polymorphism</em> is discussed in <a href="#chap-type-parameterization">Chapter 19</a>.</p>
      <p><a id="footnotemain10-8"></a>[8] Meyers, <em>Effective C++</em><a id="i-1960871386-1"></a><a id="i-1839614926-1"></a> <a href="#meyers-effective-cpp">[Mey91]</a></p>
      <p><a id="footnotemain10-9"></a>[9] Eckel, <em>Thinking in Java</em><a id="i1711840479-1"></a><a id="i-107465203-1"></a> <a href="#eckel-thinking-in-java">[Eck98]</a></p>
      <p><a id="footnotemain10-10"></a>[10] Class <span class="code">ArrayElement</span> also has a composition relationship with <span class="code">Array</span>, because its parametric <span class="code">contents</span> field holds a reference to an array of strings. The code for <span class="code">ArrayElement</span> is shown in <a href="#lst-parametric-field">Listing 10.5</a> <a href="#lst-parametric-field">here</a>. Its composition relationship is represented in class diagrams by a diamond, as shown, for example, in <a href="#fig-element-family">Figure 10.1</a> <a href="#fig-element-family">here</a>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-scalas-hierarchy">Chapter 11</a></h2>
      <h1>Scala's Hierarchy</h1>
      <p>Now that you've seen the details of class inheritance in the previous chapter, it is a good time to take a step back and look at Scala's class hierarchy as a whole. In Scala, every class inherits from a common superclass named <span class="code">Any</span>. Because every class is a subclass of <span class="code">Any</span>, the methods defined in <span class="code">Any</span> are "universal" methods: they may be invoked on any object. Scala also defines some interesting classes at the bottom of the hierarchy, <span class="code">Null</span> and <span class="code">Nothing</span>, which essentially act as common <em>sub</em>classes. For example, just as <span class="code">Any</span> is a superclass of every other class, <span class="code">Nothing</span> is a subclass of every other class. In this chapter, we'll give you a tour of Scala's class hierarchy.</p>
      <h3 id="sec-scalas-class-hierarchy">11.1 Scala's class hierarchy</h3>
      <p><a href="#fig-class-hierarchy">Figure 11.1</a> shows an outline of Scala's class hierarchy. At the top of the hierarchy is class <span class="code">Any</span>, which defines methods that include the following:</p> <pre>  <code class="vem">final</code>&nbsp;<code class="vem">def</code>&nbsp;==(that:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>
  <code class="vem">final</code>&nbsp;<code class="vem">def</code>&nbsp;!=(that:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>
  <code class="vem">def</code>&nbsp;equals(that:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>
  <code class="vem">def</code>&nbsp;##:&nbsp;<code class="typename">Int</code>
  <code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>
  <code class="vem">def</code>&nbsp;toString:&nbsp;<code class="typename">String</code>
</pre>
      <p>Because every class inherits from <span class="code">Any</span>, every object in a Scala program can be compared using<a id="i-1583721442-2"></a><a id="i1095465388-2"></a><a id="i15383763-2"></a><a id="i-1108611945-2"></a> <span class="code">==</span>, <span class="code">!=</span>, or <span class="code">equals</span>; hashed using <span class="code">##</span> or <span class="code">hashCode</span>; and<a id="i1926521799-1"></a> formatted using <span class="code">toString</span>.<a id="i-1787342122-1"></a><a id="i-720005867-2"></a> The equality and inequality methods, <span class="code">==</span> and <span class="code">!=</span>, are declared <span class="code">final</span> in class <span class="code">Any</span>, so they cannot be overridden in subclasses. The <span class="code">==</span> method is essentially the same as <span class="code">equals</span> and <span class="code">!=</span><a id="i-1939382283-1"></a> is always the negation of <span class="code">equals</span>.<a href="#footnotemain11-1">[1]</a> So individual classes can tailor what <span class="code">==</span> or <span class="code">!=</span> means by overriding the <span class="code">equals</span> method. We'll show an example later in this chapter.</p>
      <p><a id="fig-class-hierarchy"></a></p>
      <div style="text-align: center">
        <img src="scalaHierarchy160.png" alt="images/scalaHierarchy160.png">
        <h5>Class hierarchy of Scala.<a id="i-395909855-1"></a><a id="i1570311014-1"></a><a id="i1398855960-1"></a><a id="i1276473496-1"></a><a id="i-1121985306-1"></a><a id="i2002716718-1"></a><a id="i695215832-1"></a><a id="i-345413291-1"></a></h5>
      </div>
      <p>The root class <span class="code">Any</span> has two subclasses: <span class="code">AnyVal</span> and <span class="code">AnyRef</span>. <span class="code">AnyVal</span> is the parent class of <span style="font-style:italic">value classes</span> in Scala.<a id="i-20487049-1"></a><a id="i499600205-1"></a><a id="i785702719-1"></a><a id="i-2060175836-1"></a> While you can define your own value classes (see <a href="#sec-value-classes">Section 11.4</a>), there are nine value classes built into Scala: <span class="code">Byte</span>, <span class="code">Short</span>, <span class="code">Char</span>, <span class="code">Int</span>, <span class="code">Long</span>, <span class="code">Float</span>, <span class="code">Double</span>, <span class="code">Boolean</span>, and <span class="code">Unit</span>. The first eight of these correspond to Java's primitive types, and their values are<a id="i884498802-3"></a> represented at run time as Java's primitive values. The instances of these classes are all written as literals in Scala. For example, <span class="code">42</span> is an instance of <span class="code">Int</span>, <span class="code">'x'</span> is an instance of <span class="code">Char</span>, and <span class="code">false</span> an instance of <span class="code">Boolean</span>. You cannot create instances of these classes using <span class="code">new</span>. This is enforced by the "trick" that value classes are all defined to be both abstract and final.</p>
      <p>So if you were to write:</p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Int</code>
</pre>
      <p>you would get:</p> <pre>  <code class="output">&lt;console&gt;:5:&nbsp;error:&nbsp;class&nbsp;Int&nbsp;is&nbsp;abstract;&nbsp;cannot&nbsp;be&nbsp;</code>
  <code class="output">instantiated</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Int</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>The other value class, <span class="code">Unit</span>, corresponds roughly to Java's <span class="code">void</span> type; it is used as the result type of a method that does not otherwise return an interesting result. <span class="code">Unit</span> has a single instance value, which is written <span class="code">()</span>, as discussed in <a href="#sec-while-loops">Section 7.2</a>.</p>
      <p>As explained in <a href="#chap-basic-types-and-operations">Chapter 5</a>, the value classes support the usual arithmetic and boolean operators as methods. For instance, <span class="code">Int</span> has methods named <span class="code">+</span> and <span class="code">*</span>, and <span class="code">Boolean</span> has methods named <span class="code">||</span> and <span class="code">&amp;&amp;</span>. Value classes also inherit all methods from class <span class="code">Any</span>. You can test this in the interpreter:</p> <pre>  scala&gt;&nbsp;<code class="literal">42.</code>toString
  <code class="output">res1:&nbsp;String&nbsp;=&nbsp;42</code>
  <br>  scala&gt;&nbsp;<code class="literal">42.</code>hashCode
  <code class="output">res2:&nbsp;Int&nbsp;=&nbsp;42</code>
  <br>  scala&gt;&nbsp;<code class="literal">42</code>&nbsp;equals&nbsp;<code class="literal">42</code>
  <code class="output">res3:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>Note that the value class space is flat; all value classes are subtypes of <span class="code">scala.AnyVal</span>, but they do not subclass each other. Instead there are implicit conversions between different value class types. For example, an instance of class <span class="code">scala.Int</span> is automatically widened (by an implicit conversion) to an instance of class <span class="code">scala.Long</span> when required.</p>
      <p>As mentioned in <a href="#sec-rich-wrappers">Section 5.10</a>, implicit conversions are also used to add more functionality to value types. For instance, the type <span class="code">Int</span> supports all of the operations below:</p> <pre>  scala&gt;&nbsp;<code class="literal">42</code>&nbsp;max&nbsp;<code class="literal">43</code>
  <code class="output">res4:&nbsp;Int&nbsp;=&nbsp;43</code>
  <br>  scala&gt;&nbsp;<code class="literal">42</code>&nbsp;min&nbsp;<code class="literal">43</code>
  <code class="output">res5:&nbsp;Int&nbsp;=&nbsp;42</code>
  <br>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;until&nbsp;<code class="literal">5</code>
  <code class="output">res6:&nbsp;scala.collection.immutable.Range&nbsp;=&nbsp;Range&nbsp;1&nbsp;until&nbsp;5</code>
  <br>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">5</code>
  <code class="output">res7:&nbsp;scala.collection.immutable.Range.Inclusive</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Range&nbsp;1&nbsp;to&nbsp;5</code>
  <br>  scala&gt;&nbsp;3.abs
  <code class="output">res8:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br>  scala&gt;&nbsp;(-<code class="literal">3</code>).abs
  <code class="output">res9:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <p>Here's how this works: The methods <span class="code">min</span>, <span class="code">max</span>, <span class="code">until</span>, <span class="code">to</span>,<a id="i-256644535-3"></a><a id="i-2103371977-2"></a><a id="i-1690228669-2"></a><a id="i574171488-3"></a><a id="i-1171773097-2"></a> and <span class="code">abs</span> are all defined in a class <span class="code">scala.runtime.RichInt</span>, and there is an implicit conversion from class <span class="code">Int</span> to <span class="code">RichInt</span>. The conversion is applied whenever a method is invoked on an <span class="code">Int</span> that is undefined in <span class="code">Int</span> but defined in <span class="code">RichInt</span>. Similar "booster classes" and implicit conversions exist for the other value classes. Implicit conversions will be discussed in detail in <a href="#chap-implicit-conversions-and-parameters">Chapter 21</a>.</p>
      <p>The other subclass of the root class <span class="code">Any</span> is class <span class="code">AnyRef</span>. This is the base class of all <span style="font-style:italic">reference classes</span> in Scala.<a id="i-1054988553-1"></a> As mentioned previously, on the Java platform <span class="code">AnyRef</span> is in fact just an alias for class<a id="i-786400333-1"></a> <span class="code">java.lang.Object</span>. So classes written in Java, as well as classes written in Scala, all inherit from <span class="code">AnyRef</span>.<a href="#footnotemain11-2">[2]</a> One way to think of <span class="code">java.lang.Object</span>, therefore, is as the way <span class="code">AnyRef</span> is implemented on the Java platform. Thus, although you can use <span class="code">Object</span> and <span class="code">AnyRef</span> interchangeably in Scala programs on the Java platform, the recommended style is to use <span class="code">AnyRef</span> everywhere.<a id="i-1076915945-1"></a></p>
      <h3 id="sec-impl-primitives">11.2 How primitives are implemented</h3>
      <p>How is all this implemented? In fact, Scala stores integers in the<a id="i-911544850-1"></a> same way as Java—as 32-bit words. This is important for efficiency on the JVM and also for interoperability with Java libraries. Standard operations like addition or multiplication are implemented as primitive operations. However, Scala uses the "backup" class <span class="code">java.lang.Integer</span> whenever an integer needs to be seen as a (Java) object. This happens for instance when invoking the <span class="code">toString</span> method on an integer number or when assigning an integer to a variable of type <span class="code">Any</span>. Integers of type <span class="code">Int</span> are converted transparently to "boxed integers" of type <span class="code">java.lang.Integer</span> whenever necessary.<a id="i292516588-1"></a><a id="i1431094886-1"></a></p>
      <p>All this sounds a lot like auto-boxing in Java 5 and it is indeed quite similar. There's one crucial difference though: Boxing in Scala is much less visible than boxing in Java. Try the following in Java:</p> <pre>  <code class="comment">//&nbsp;This&nbsp;is&nbsp;Java</code>
  boolean&nbsp;isEqual(int&nbsp;x,&nbsp;int&nbsp;y)&nbsp;{
  &nbsp;&nbsp;<code class="vem">return</code>&nbsp;x&nbsp;==&nbsp;y;
  }
  System.out.println(isEqual(<code class="literal">421</code>,&nbsp;<code class="literal">421</code>));
</pre>
      <p>You will surely get <span class="code">true</span>. Now, change the argument types of <span class="code">isEqual</span> to <span class="code">java.lang.Integer</span> (or <span class="code">Object</span>, the result will be the same):</p> <pre>  <code class="comment">//&nbsp;This&nbsp;is&nbsp;Java</code>
  boolean&nbsp;isEqual(<code class="typename">Integer</code>&nbsp;x,&nbsp;<code class="typename">Integer</code>&nbsp;y)&nbsp;{
  &nbsp;&nbsp;<code class="vem">return</code>&nbsp;x&nbsp;==&nbsp;y;
  }
  System.out.println(isEqual(<code class="literal">421</code>,&nbsp;<code class="literal">421</code>));
</pre>
      <p>You will find that you get <span class="code">false</span>! What happens is that the number <span class="code">421</span> gets boxed twice, so that the arguments for <span class="code">x</span> and <span class="code">y</span> are two different objects. Because <span class="code">==</span> means reference equality on reference types,<a id="i1544052809-2"></a> and <span class="code">Integer</span> is a reference type, the result is <span class="code">false</span>. This is one aspect where it shows that Java is not a pure object-oriented language. There is a difference between primitive types and reference types that can be clearly observed.</p>
      <p>Now try the same experiment in Scala:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;isEqual(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;x&nbsp;==&nbsp;y
  <code class="output">isEqual:&nbsp;(x:&nbsp;Int,&nbsp;y:&nbsp;Int)Boolean</code>
  <br>  scala&gt;&nbsp;isEqual(<code class="literal">421</code>,&nbsp;<code class="literal">421</code>)
  <code class="output">res10:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;isEqual(x:&nbsp;<code class="typename">Any</code>,&nbsp;y:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;x&nbsp;==&nbsp;y
  <code class="output">isEqual:&nbsp;(x:&nbsp;Any,&nbsp;y:&nbsp;Any)Boolean</code>
  <br>  scala&gt;&nbsp;isEqual(<code class="literal">421</code>,&nbsp;<code class="literal">421</code>)
  <code class="output">res11:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>The equality operation <span class="code">==</span> in Scala is designed to be transparent with respect to the type's representation. For value types, it is the natural (numeric or boolean) equality. For reference types other than Java's boxed numeric types, <span class="code">==</span> is treated as an alias of the <span class="code">equals</span> method inherited from <span class="code">Object</span>. That method is originally defined as reference equality, but is overridden by many subclasses to implement their natural notion of equality. This also means that in Scala you never fall into Java's well-known trap concerning string comparisons. In Scala, string comparison works as it should:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="quotedstring">"abcd"</code>.substring(<code class="literal">2</code>)
  <code class="output">x:&nbsp;String&nbsp;=&nbsp;cd</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="quotedstring">"abcd"</code>.substring(<code class="literal">2</code>)
  <code class="output">y:&nbsp;String&nbsp;=&nbsp;cd</code>
  <br>  scala&gt;&nbsp;x&nbsp;==&nbsp;y
  <code class="output">res12:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>In Java, the result of comparing <span class="code">x</span> with <span class="code">y</span> would be false. The programmer should have used <span class="code">equals</span> in this case, but it is easy to forget.</p>
      <p>However, there are situations where you need reference equality instead of user-defined equality. For example, in some situations where efficiency is paramount, you would like to <em>hash cons</em><a id="i1337872025-1"></a><a id="i-1199948289-1"></a> with some classes and compare their instances with reference equality.<a href="#footnotemain11-3">[3]</a> For these cases, class <span class="code">AnyRef</span> defines an additional <span class="code">eq</span> method, which cannot be<a id="i-795280463-2"></a><a id="i2030434891-2"></a> overridden and is implemented as reference equality (<i>i.e.</i>, it behaves like <span class="code">==</span> in Java for reference types). There's also the negation of <span class="code">eq</span>, which is called <span class="code">ne</span>.<a id="i-1620977796-2"></a><a id="i1319501024-2"></a> For example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">String</code>(<code class="quotedstring">"abc"</code>)
  <code class="output">x:&nbsp;String&nbsp;=&nbsp;abc</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">String</code>(<code class="quotedstring">"abc"</code>)
  <code class="output">y:&nbsp;String&nbsp;=&nbsp;abc</code>
  <br>  scala&gt;&nbsp;x&nbsp;==&nbsp;y
  <code class="output">res13:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;x&nbsp;eq&nbsp;y
  <code class="output">res14:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;x&nbsp;ne&nbsp;y
  <code class="output">res15:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>Equality in Scala is discussed further in <a href="#chap-object-equality">Chapter 30</a>.</p>
      <h3 id="sec-bottom-types">11.3 Bottom types</h3>
      <p>At the bottom of the type hierarchy in <a href="#fig-class-hierarchy">Figure 11.1</a> you see the two classes <span class="code">scala.Null</span> and <span class="code">scala.Nothing</span>. These are special types that handle some "corner cases" of Scala's object-oriented type system in a uniform way.<a id="i794065476-1"></a><a id="i-1885936564-1"></a></p>
      <p>Class <span class="code">Null</span> is the type of the <span class="code">null</span> reference; it is a subclass of every reference class (<i>i.e.</i>, every class that itself inherits from <span class="code">AnyRef</span>). <span class="code">Null</span> is not compatible with value types.<a id="i-1844978241-1"></a><a id="i-597441587-1"></a><a id="i473754008-1"></a> You cannot, for example, assign a <span class="code">null</span> value to an integer variable:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;i:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="vem">null</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;an&nbsp;expression&nbsp;of&nbsp;type&nbsp;Null&nbsp;is&nbsp;ineligible&nbsp;for&nbsp;</code>
  <code class="output">implicit&nbsp;conversion</code>
</pre>
      <p>Type <span class="code">Nothing</span> is at the very bottom of Scala's class hierarchy; it is a subtype of every other type. However, there exist no values of this type whatsoever. Why does it make sense to have a type without values? As discussed in <a href="#sec-try-expressions">Section 7.4</a>, one use of <span class="code">Nothing</span> is that it signals abnormal termination.</p>
      <p>For instance there's the <span class="code">error</span> method in the <span class="code">sys</span> object of Scala's standard library, which is defined like this:</p> <pre>  <code class="vem">def</code>&nbsp;error(message:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Nothing</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">RuntimeException</code>(message)
</pre>
      <p>The return type of <span class="code">error</span> is <span class="code">Nothing</span>, which tells users that the method will not return normally (it throws an exception instead). Because <span class="code">Nothing</span> is a subtype of every other type, you can use methods like <span class="code">error</span> in very flexible ways. For instance:</p> <pre>  <code class="vem">def</code>&nbsp;divide(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(y&nbsp;!=&nbsp;<code class="literal">0</code>)&nbsp;x&nbsp;/&nbsp;y&nbsp;
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;sys.error(<code class="quotedstring">"can't&nbsp;divide&nbsp;by&nbsp;zero"</code>)
</pre>
      <p>The "then" branch of the conditional, <span class="code">x</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">y</span>, has type <span class="code">Int</span>, whereas the else branch, the call to <span class="code">error</span>, has type <span class="code">Nothing</span>. Because <span class="code">Nothing</span> is a subtype of <span class="code">Int</span>, the type of the whole conditional is <span class="code">Int</span>, as required.</p>
      <h3 id="sec-value-classes">11.4 Defining your own value classes</h3>
      <p>As mentioned in <a href="#sec-scalas-class-hierarchy">Section 11.1</a>, you can define your own value classes to augment the ones that are built in. Like the built-in value classes, an instance of your value class will usually compile to Java bytecode that does not use the wrapper class. In contexts where a wrapper is needed, such as with generic code, the value will get boxed and unboxed automatically.</p>
      <p>Only certain classes can be made into value classes. For a class to be a value class, it must have exactly one parameter and it must have nothing inside it except <span class="code">def</span>s. Furthermore, no other class can extend a value class, and a value class cannot redefine <span class="code">equals</span> or <span class="code">hashCode</span>.</p>
      <p>To define a value class, make it a subclass of <span class="code">AnyVal</span>, and put <span class="code">val</span> before the one parameter. Here is an example value class:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Dollars</code>(<code class="vem">val</code>&nbsp;amount:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyVal</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString()&nbsp;=&nbsp;<code class="quotedstring">"$"</code>&nbsp;+&nbsp;amount
  }
</pre>
      <p>As described in <a href="#sec-parametric-fields">Section 10.6</a>, the <span class="code">val</span> prefix allows the <span class="code">amount</span> parameter to be accessed as a field. For example, the following code creates an instance of the value class, then retrieves the amount from it:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;money&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Dollars</code>(<code class="literal">1000000</code>)
  <code class="output">money:&nbsp;Dollars&nbsp;=&nbsp;$1000000</code>
  scala&gt;&nbsp;money.amount
  <code class="output">res16:&nbsp;Int&nbsp;=&nbsp;1000000</code>
</pre>
      <p>In this example, <span class="code">money</span> refers to an instance of the value class. It is of type <span class="code">Dollars</span> in Scala source code, but the compiled Java bytecode will use type <span class="code">Int</span> directly.</p>
      <p>This example defines a <span class="code">toString</span> method, and the compiler figures out when to use it. That's why printing <span class="code">money</span> gives <span class="code">$1000000</span>, with a dollar sign, but printing <span class="code">money.amount</span> gives <span class="code">1000000</span>. You can even define multiple value types that are all backed by the same <span class="code">Int</span> value. For example:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">SwissFrancs</code>(<code class="vem">val</code>&nbsp;amount:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyVal</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString()&nbsp;=&nbsp;s<code class="quotedstring">"$amount&nbsp;CHF"</code>
  }
</pre>
      <p>Even though both <span class="code">Dollars</span> and <span class="code">SwissFrancs</span> are represented as integers, it works fine to use them in the same scope:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;dollars&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Dollars</code>(<code class="literal">1000</code>)
  <code class="output">dollars:&nbsp;Dollars&nbsp;=&nbsp;$1000</code>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;francs&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SwissFrancs</code>(<code class="literal">1000</code>)
  <code class="output">francs:&nbsp;SwissFrancs&nbsp;=&nbsp;1000&nbsp;CHF</code>
</pre>
      <h4>Avoiding a types monoculture</h4>
      <p>To get the most benefit from the Scala class hierarchy, try to define a new class for each domain concept, even when it would be possible to reuse the same class for different purposes. Even if such a class is a so-called <em>tiny type</em><a id="i1646427993-1"></a> with no methods or fields, defining the additional class is a way to help the compiler be helpful to you.</p>
      <p>For example, suppose you are writing some code to generate HTML. In HTML, a style name is represented as a string. So are anchor identifiers. HTML itself is also a string, so if you wanted, you could define helper code using strings to represent all of these things, like this:</p> <pre>  <code class="vem">def</code>&nbsp;title(text:&nbsp;<code class="typename">String</code>,&nbsp;anchor:&nbsp;<code class="typename">String</code>,&nbsp;style:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">String</code>&nbsp;=
  &nbsp;&nbsp;s<code class="quotedstring">"&lt;a&nbsp;id='$anchor'&gt;&lt;h1&nbsp;class='$style'&gt;$text&lt;/h1&gt;&lt;/a&gt;"</code>
</pre>
      <p>That type signature has four strings in it! Such <em>stringly typed</em><a id="i84163557-1"></a> code is technically strongly typed, but since everything in sight is of type <span class="code">String</span>, the compiler cannot help you detect the use of one when you meant to write the other. For example, it won't stop you from this travesty:</p> <pre>  scala&gt;&nbsp;title(<code class="quotedstring">"chap:vcls"</code>,&nbsp;<code class="quotedstring">"bold"</code>,&nbsp;<code class="quotedstring">"Value&nbsp;Classes"</code>)
  <code class="output">res17:&nbsp;String&nbsp;=&nbsp;&lt;a&nbsp;id='bold'&gt;&lt;h1&nbsp;class='Value&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Classes'&gt;chap:vcls&lt;/h1&gt;&lt;/a&gt;</code>
</pre>
      <p>This HTML is mangled. The intended display text "Value Classes" is being used as a style class, and the text being displayed is "chap.vcls," which was supposed to be an anchor. To top it off, the actual anchor identifier is "bold," which is supposed to be a style class. Despite this comedy of errors, the compiler utters not a peep.</p>
      <p>The compiler can be more helpful if you define a tiny type for each domain concept. For example, you could define a small class for styles, anchor identifiers, display text, and HTML. Since these classes have one parameter and no members, they can be defined as value classes:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Anchor</code>(<code class="vem">val</code>&nbsp;value:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyVal</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Style</code>(<code class="vem">val</code>&nbsp;value:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyVal</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Text</code>(<code class="vem">val</code>&nbsp;value:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyVal</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Html</code>(<code class="vem">val</code>&nbsp;value:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyVal</code>
</pre>
      <p>Given these classes, it is possible to write a version of <span class="code">title</span> that has a less trivial type signature:</p> <pre>  <code class="vem">def</code>&nbsp;title(text:&nbsp;<code class="typename">Text</code>,&nbsp;anchor:&nbsp;<code class="typename">Anchor</code>,&nbsp;style:&nbsp;<code class="typename">Style</code>):&nbsp;<code class="typename">Html</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Html</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;s<code class="quotedstring">"&lt;a&nbsp;id='${anchor.value}'&gt;"</code>&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s<code class="quotedstring">"&lt;h1&nbsp;class='${style.value}'&gt;"</code>&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text.value&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"&lt;/h1&gt;&lt;/a&gt;"</code>
  &nbsp;&nbsp;)
</pre>
      <p>If you try to use this version with the arguments in the wrong order, the compiler can now detect the error. For example:</p> <pre>  scala&gt;&nbsp;title(<code class="vem">new</code>&nbsp;<code class="typename">Anchor</code>(<code class="quotedstring">"chap:vcls"</code>),&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Style</code>(<code class="quotedstring">"bold"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Text</code>(<code class="quotedstring">"Value&nbsp;Classes"</code>))
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Anchor</code>
  <code class="output">&nbsp;required:&nbsp;Text</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Style</code>
  <code class="output">&nbsp;required:&nbsp;Anchor</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Text("Value&nbsp;Classes"))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">On&nbsp;line&nbsp;2:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Text</code>
  <code class="output">&nbsp;required:&nbsp;Style</code>
</pre>
      <h3>11.5 Conclusion</h3>
      <p>In this chapter we showed you the classes at the top and bottom of Scala's class hierarchy. Now that you've gotten a good foundation on class inheritance in Scala, you're ready to understand mixin composition. In the next chapter, you'll learn about traits.</p>
      <hr>
      <h4>Footnotes for Chapter 11:</h4>
      <p><a id="footnotemain11-1"></a>[1] The only case where <span class="code">==</span> does not directly call <span class="code">equals</span> is for Java's boxed numeric classes, such as <span class="code">Integer</span> or <span class="code">Long</span>. In Java, a <span class="code">new</span>&nbsp;<span class="code">Integer(1)</span> does not <span class="code">equal</span> a <span class="code">new</span>&nbsp;<span class="code">Long(1)</span> even though for primitive values <span class="code">1</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">1L</span>. Since Scala is a more regular language than Java, it was necessary to correct this discrepancy by special-casing the <span class="code">==</span> method for these classes. Likewise, the <span class="code">##</span> method provides a Scala version of hashing that is the same as Java's <span class="code">hashCode</span>, except for boxed numeric types, where it works consistently with <span class="code">==</span>. For instance <span class="code">new</span>&nbsp;<span class="code">Integer(1)</span> and <span class="code">new</span>&nbsp;<span class="code">Long(1)</span> hash the same with <span class="code">##</span> even though their Java <span class="code">hashCode</span>s are different.</p>
      <p><a id="footnotemain11-2"></a>[2] The reason <span class="code">AnyRef</span> alias exists, instead of just using the name <span class="code">java.lang.Object</span>, is because Scala was originally designed to work on both the Java and .NET platforms. On .NET, <span class="code">AnyRef</span> was an alias for <span class="code">System.Object</span>.<a id="i77181-2"></a></p>
      <p><a id="footnotemain11-3"></a>[3] You hash cons instances of a class by caching all instances you have created in a weak collection. Then, any time you want a new instance of the class, you first check the cache. If the cache already has an element equal to the one you are about to create, you can reuse the existing instance. As a result of this arrangement, any two instances that are equal with <span class="code">equals()</span> are also equal with reference equality.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-traits-and-mixins">Chapter 12</a></h2>
      <h1>Traits</h1>
      <p><a id="i-865710043-1"></a></p>
      <p>Traits are a fundamental unit of code reuse in Scala. A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Unlike class inheritance, in which each class must inherit from just one superclass, a class can mix in any number of traits. This chapter shows you how traits work and shows two of the most common ways they are useful: widening thin interfaces to rich ones, and defining stackable modifications. It also shows how to use the <span class="code">Ordered</span> trait and compares traits to the multiple inheritance of other languages.</p>
      <h3>12.1 How traits work</h3>
      <p>A trait definition looks just like a class definition except that it uses the keyword <span class="code">trait</span>. An example is shown in <a href="#lst-defining-a-trait">Listing 12.1</a>:</p>
      <p><a id="lst-defining-a-trait"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Philosophical</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;philosophize()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"I&nbsp;consume&nbsp;memory,&nbsp;therefore&nbsp;I&nbsp;am!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 12.1 - The definition of trait <span class="code">Philosophical</span>.</h5>
      <p>This trait is named <span class="code">Philosophical</span>. It does not declare a superclass, so like a class, it has the default superclass of <span class="code">AnyRef</span>. It defines one method, named <span class="code">philosophize</span>, which is concrete. It's a simple trait, just enough to show how traits work.</p>
      <p>Once a trait is defined, it can be <em>mixed in</em> to a class using either the <span class="code">extends</span> or <span class="code">with</span> keywords.<a id="i-1415422629-1"></a> Scala programmers "mix in" traits rather than inherit from them, because mixing in a trait has important differences from the multiple inheritance found in many other languages.<a id="i-917586794-1"></a> This issue is discussed in <a href="#sec-traits-vs-multi">Section 12.6</a>. For example, <a href="#lst-extending-a-trait">Listing 12.2</a> shows a class that mixes in the <span class="code">Philosophical</span> trait using <span class="code">extends</span>:</p>
      <p><a id="lst-extending-a-trait"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Frog</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Philosophical</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;<code class="quotedstring">"green"</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 12.2 - Mixing in a trait using <span class="code">extends</span>.</h5>
      <p>You can use the <span class="code">extends</span> keyword to mix in a trait; in that case you implicitly inherit the trait's superclass. For instance, in <a href="#lst-extending-a-trait">Listing 12.2</a>, class <span class="code">Frog</span> subclasses <span class="code">AnyRef</span> (the superclass of <span class="code">Philosophical</span>) and mixes in <span class="code">Philosophical</span>. Methods inherited from a trait can be used just like methods inherited from a superclass. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;frog&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Frog</code>
  <code class="output">frog:&nbsp;Frog&nbsp;=&nbsp;green</code>
  <br>  scala&gt;&nbsp;frog.philosophize()
  <code class="output">I&nbsp;consume&nbsp;memory,&nbsp;therefore&nbsp;I&nbsp;am!</code>
</pre>
      <p>A trait also defines a type. Here's an example in which <span class="code">Philosophical</span> is used as a type:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;phil:&nbsp;<code class="typename">Philosophical</code>&nbsp;=&nbsp;frog&nbsp;&nbsp;
  <code class="output">phil:&nbsp;Philosophical&nbsp;=&nbsp;green</code>
  <br>  scala&gt;&nbsp;phil.philosophize()
  <code class="output">I&nbsp;consume&nbsp;memory,&nbsp;therefore&nbsp;I&nbsp;am!</code>
</pre>
      <p>The type of <span class="code">phil</span> is <span class="code">Philosophical</span>, a trait. Thus, variable <span class="code">phil</span> could have been initialized with any object whose class mixes in <span class="code">Philosophical</span>.</p>
      <p>If you wish to mix a trait into a class that explicitly extends a superclass, you use <span class="code">extends</span> to indicate the superclass and <span class="code">with</span> to mix in the trait. <a href="#lst-mixing-in-using-with">Listing 12.3</a> shows an example. If you want to mix in multiple traits, you add more <span class="code">with</span> clauses. For example, given a trait <span class="code">HasLegs</span>, you could mix both <span class="code">Philosophical</span> and <span class="code">HasLegs</span> into <span class="code">Frog</span> as shown in <a href="#lst-multiple-withs">Listing 12.4</a>.</p>
      <p><a id="lst-mixing-in-using-with"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Animal</code>
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Frog</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Philosophical</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;<code class="quotedstring">"green"</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 12.3 - Mixing in a trait using <span class="code">with</span>.<a id="i1578124431-1"></a></h5>
      <p><a id="lst-multiple-withs"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Animal</code>
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">HasLegs</code>
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Frog</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Philosophical</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">HasLegs</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;<code class="quotedstring">"green"</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 12.4 - Mixing in multiple traits.</h5>
      <p>In the examples you've seen so far, class <span class="code">Frog</span> has inherited an implementation of <span class="code">philosophize</span> from trait <span class="code">Philosophical</span>. Alternatively, <span class="code">Frog</span> could override <span class="code">philosophize</span>. The syntax looks the same as overriding a method declared in a superclass. Here's an example:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Animal</code>
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">Frog</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Philosophical</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;<code class="quotedstring">"green"</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;philosophize()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"It&nbsp;ain't&nbsp;easy&nbsp;being&nbsp;"</code>&nbsp;+&nbsp;toString&nbsp;+&nbsp;<code class="quotedstring">"!"</code>)
  &nbsp;&nbsp;}
  }
</pre>
      <p>Because this new definition of <span class="code">Frog</span> still mixes in trait <span class="code">Philosophical</span>, you can still use it from a variable of that type. But because <span class="code">Frog</span> overrides <span class="code">Philosophical</span>'s implementation of <span class="code">philosophize</span>, you'll get a new behavior when you call it:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;phrog:&nbsp;<code class="typename">Philosophical</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Frog</code>
  <code class="output">phrog:&nbsp;Philosophical&nbsp;=&nbsp;green</code>
  <br>  scala&gt;&nbsp;phrog.philosophize()
  <code class="output">It&nbsp;ain't&nbsp;easy&nbsp;being&nbsp;green!</code>
</pre>
      <p>At this point you might philosophize that traits are like Java interfaces with concrete methods, but they can actually do much more. Traits can, for example, declare fields and maintain state. In fact, you can do anything in a trait definition that you can do in a class definition, and the syntax looks exactly the same, with only two exceptions.</p>
      <p>First, a trait cannot have any "class" parameters (<i>i.e.</i>, parameters passed to the primary constructor of a class). In other words, although you could define a class like this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>)
</pre>
      <p>The following attempt to define a trait would not compile:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">NoPoint</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="comment">//&nbsp;Does&nbsp;not&nbsp;compile</code>
</pre>
      <p>You'll find out in <a href="#sec-val-init">Section 20.5</a> how to work around this restriction.</p>
      <p>The other difference between classes and traits is that whereas in classes, <span class="code">super</span> calls are statically bound, in traits,<a id="i-718179772-1"></a> they are dynamically bound.<a id="i-1297249718-2"></a> If you write "<span class="code">super.toString</span>" in a class, you know exactly which method implementation will be invoked. When you write the same thing in a trait, however, the method implementation to invoke for the <span class="code">super</span> call is undefined when you define the trait. Rather, the implementation to invoke will be determined anew each time the trait is mixed into a concrete class. This curious behavior of <span class="code">super</span> is key to allowing traits to work as <em>stackable modifications</em>, which will be described in <a href="#sec-stackable-modifications">Section 12.5</a>. The rules for resolving <span class="code">super</span> calls will be given in <a href="#sec-traits-vs-multi">Section 12.6</a>.</p>
      <h3>12.2 Thin versus rich interfaces</h3>
      <p>One major use of traits is to automatically add methods to a class in terms of methods the class already has. That is, traits can enrich a <em>thin</em> interface, making it into a <em>rich</em> interface.</p>
      <p>Thin versus rich interfaces represents a commonly faced trade-off in object-oriented design. The trade-off is between the implementers and the clients of an interface. A rich interface has many methods, which make it convenient for the caller. Clients can pick a method that exactly matches the functionality they need. A thin interface, on the other hand, has fewer methods, and thus is easier on the implementers. Clients calling into a thin interface, however, have to write more code. Given the smaller selection of methods to call, they may have to choose a less than perfect match for their needs and write extra code to use it.</p>
      <p>Java's interfaces are more often thin than rich. For example, interface <span class="code">CharSequence</span>, which was introduced in Java 1.4, is a thin interface common to all string-like classes that hold a sequence of characters. Here's its definition when seen as a Scala trait:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">CharSequence</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;charAt(index:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Char</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;length:&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;subSequence(start:&nbsp;<code class="typename">Int</code>,&nbsp;end:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">CharSequence</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;toString():&nbsp;<code class="typename">String</code>
  }
</pre>
      <p>Although most of the dozens of methods in class <span class="code">String</span> would apply to any <span class="code">CharSequence</span>, Java's <span class="code">CharSequence</span> interface declares only four methods. Had <span class="code">CharSequence</span> instead included the full <span class="code">String</span> interface, it would have placed a large burden on implementers of <span class="code">CharSequence</span>. Every programmer that implemented <span class="code">CharSequence</span> in Java would have had to define dozens more methods. Because Scala traits can contain concrete methods, they make rich interfaces far more convenient.</p>
      <p>Adding a concrete method to a trait tilts the thin-rich trade-off heavily towards rich interfaces. Unlike in Java, adding a concrete method to a Scala trait is a one-time effort. You only need to implement the method once, in the trait itself, instead of needing to reimplement it for every class that mixes in the trait. Thus, rich interfaces are less work to provide in Scala than in a language without traits.</p>
      <p>To enrich an interface using traits, simply define a trait with a small number of abstract methods—the thin part of the trait's interface—and a potentially large number of concrete methods, all implemented in terms of the abstract methods. Then you can mix the enrichment trait into a class, implement the thin portion of the interface, and end up with a class that has all of the rich interface available.</p>
      <h3>12.3 Example: Rectangular objects</h3>
      <p>Graphics libraries often have many different classes that represent something rectangular. Some examples are windows, bitmap images, and regions selected with a mouse. To make these rectangular objects convenient to use, it is nice if the library provides geometric queries, such as <span class="code">width</span>, <span class="code">height</span>, <span class="code">left</span>, <span class="code">right</span>, <span class="code">topLeft</span>, and so on. However, many such methods exist that would be nice to have, so it can be a large burden on library writers to provide all of them for all rectangular objects in a Java library. If such a library were written in Scala, by contrast, the library writer could use traits to easily supply all of these convenience methods on all the classes they like.</p>
      <p>To see how, first imagine what the code would look like without traits. There would be some basic geometric classes like <span class="code">Point</span> and <span class="code">Rectangle</span>:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">Rectangle</code>(<code class="vem">val</code>&nbsp;topLeft:&nbsp;<code class="typename">Point</code>,&nbsp;<code class="vem">val</code>&nbsp;bottomRight:&nbsp;<code class="typename">Point</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;left&nbsp;=&nbsp;topLeft.x
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;right&nbsp;=&nbsp;bottomRight.x
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;width&nbsp;=&nbsp;right&nbsp;-&nbsp;left
  &nbsp;&nbsp;<code class="comment">//&nbsp;and&nbsp;many&nbsp;more&nbsp;geometric&nbsp;methods...</code>
  }
</pre>
      <p>This <span class="code">Rectangle</span> class takes two points in its primary constructor: the coordinates of the top-left and bottom-right corners. It then implements many convenience methods, such as <span class="code">left</span>, <span class="code">right</span>, and <span class="code">width</span>, by performing simple calculations on these two points.</p>
      <p>Another class a graphics library might have is a 2-D graphical widget:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Component</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;topLeft:&nbsp;<code class="typename">Point</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;bottomRight:&nbsp;<code class="typename">Point</code>
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;left&nbsp;=&nbsp;topLeft.x
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;right&nbsp;=&nbsp;bottomRight.x
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;width&nbsp;=&nbsp;right&nbsp;-&nbsp;left
  &nbsp;&nbsp;<code class="comment">//&nbsp;and&nbsp;many&nbsp;more&nbsp;geometric&nbsp;methods...</code>
  }
</pre>
      <p>Notice that the definitions of <span class="code">left</span>, <span class="code">right</span>, and <span class="code">width</span> are exactly the same in the two classes. They will also be the same, aside from minor variations, in any other classes for rectangular objects.</p>
      <p>This repetition can be eliminated with an enrichment trait. The trait will have two abstract methods: one that returns the top-left coordinate of the object, and another that returns the bottom-right coordinate. It can then supply concrete implementations of all the other geometric queries. <a href="#lst-enrichment-trait">Listing 12.5</a> shows what it will look like:</p>
      <p><a id="lst-enrichment-trait"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Rectangular</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;topLeft:&nbsp;<code class="typename">Point</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;bottomRight:&nbsp;<code class="typename">Point</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;left&nbsp;=&nbsp;topLeft.x
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;right&nbsp;=&nbsp;bottomRight.x
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;width&nbsp;=&nbsp;right&nbsp;-&nbsp;left
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;and&nbsp;many&nbsp;more&nbsp;geometric&nbsp;methods...</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 12.5 - Defining an enrichment trait.</h5>
      <p>Class <span class="code">Component</span> can mix in this trait to get all the geometric methods provided by <span class="code">Rectangular</span>:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Component</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Rectangular</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;other&nbsp;methods...</code>
  }
</pre>
      <p>Similarly, <span class="code">Rectangle</span> itself can mix in the trait:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Rectangle</code>(<code class="vem">val</code>&nbsp;topLeft:&nbsp;<code class="typename">Point</code>,&nbsp;<code class="vem">val</code>&nbsp;bottomRight:&nbsp;<code class="typename">Point</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Rectangular</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;other&nbsp;methods...</code>
  }
</pre>
      <p>Given these definitions, you can create a <span class="code">Rectangle</span> and call geometric methods such as <span class="code">width</span> and <span class="code">left</span> on it:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rect&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rectangle</code>(<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">1</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">10</code>,&nbsp;<code class="literal">10</code>))
  <code class="output">rect:&nbsp;Rectangle&nbsp;=&nbsp;Rectangle@5f5da68c</code>
  <br>  scala&gt;&nbsp;rect.left
  <code class="output">res2:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;rect.right
  <code class="output">res3:&nbsp;Int&nbsp;=&nbsp;10</code>
  <br>  scala&gt;&nbsp;rect.width
  <code class="output">res4:&nbsp;Int&nbsp;=&nbsp;9</code>
</pre>
      <h3 id="sec-the-ordered-trait">12.4 The <span class="code">Ordered</span> trait</h3>
      <p>Comparison is another domain where a rich interface is convenient.<a id="i2068605051-1"></a><a id="i795809807-1"></a> Whenever you compare two objects that are ordered, it is convenient if you use a single method call to ask about the precise comparison you want. If you want "is less than," you would like to call <span class="code">&lt;</span>, and if you want "is less than or equal," you would like to call <span class="code">&lt;=</span>. With a thin comparison interface, you might just have the <span class="code">&lt;</span> method, and you would sometimes have to write things like "<span class="code">(x</span>&nbsp;<span class="code">&lt;</span>&nbsp;<span class="code">y)</span>&nbsp;<span class="code">||</span>&nbsp;<span class="code">(x</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">y)</span>". A rich interface would provide you with all of the usual comparison operators, thus allowing you to directly write things like "<span class="code">x</span>&nbsp;<span class="code">&lt;=</span>&nbsp;<span class="code">y</span>".</p>
      <p>Before looking at <span class="code">Ordered</span>, imagine what you might do without it. Suppose you took the <span class="code">Rational</span> class from <a href="#chap-functional-objects">Chapter 6</a> and added comparison operations to it. You would end up with something like this:<a href="#footnotemain12-1">[1]</a></p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;...</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;&lt;&nbsp;(that:&nbsp;<code class="typename">Rational</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.numer&nbsp;*&nbsp;that.denom&nbsp;&lt;&nbsp;that.numer&nbsp;*&nbsp;<code class="vem">this</code>.denom
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;&gt;&nbsp;(that:&nbsp;<code class="typename">Rational</code>)&nbsp;=&nbsp;that&nbsp;&lt;&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;&lt;=&nbsp;(that:&nbsp;<code class="typename">Rational</code>)&nbsp;=&nbsp;(<code class="vem">this</code>&nbsp;&lt;&nbsp;that)&nbsp;||&nbsp;(<code class="vem">this</code>&nbsp;==&nbsp;that)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;&gt;=&nbsp;(that:&nbsp;<code class="typename">Rational</code>)&nbsp;=&nbsp;(<code class="vem">this</code>&nbsp;&gt;&nbsp;that)&nbsp;||&nbsp;(<code class="vem">this</code>&nbsp;==&nbsp;that)
  }
</pre>
      <p>This class defines four comparison operators (<span class="code">&lt;</span>, <span class="code">&gt;</span>, <span class="code">&lt;=</span>, and <span class="code">&gt;=</span>), and it's a classic demonstration of the costs of defining a rich interface. First, notice that three of the comparison operators are defined in terms of the first one. For example, <span class="code">&gt;</span> is defined as the reverse of <span class="code">&lt;</span>, and <span class="code">&lt;=</span> is defined as literally "less than or equal." Next, notice that all three of these methods would be the same for any other class that is comparable. There is nothing special about rational numbers regarding <span class="code">&lt;=</span>. In a comparison context, <span class="code">&lt;=</span> is <em>always</em> used to mean "less than or equals." Overall, there is quite a lot of boilerplate code in this class which would be the same in any other class that implements comparison operations.</p>
      <p>This problem is so common that Scala provides a trait to help with it. The trait is called <span class="code">Ordered</span>. To use it, you replace all of the individual comparison methods with a single <span class="code">compare</span> method.<a id="i1970675952-1"></a> The <span class="code">Ordered</span> trait then defines <span class="code">&lt;</span>, <span class="code">&gt;</span>, <span class="code">&lt;=</span>, and <span class="code">&gt;=</span> for you in terms of this one method. Thus, trait <span class="code">Ordered</span> allows you to enrich a class with comparison methods by implementing only one method, <span class="code">compare</span>.</p>
      <p>Here is how it looks if you define comparison operations on <span class="code">Rational</span> by using the <span class="code">Ordered</span> trait:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Ordered[Rational]</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;...</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;compare(that:&nbsp;<code class="typename">Rational</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">this</code>.numer&nbsp;*&nbsp;that.denom)&nbsp;-&nbsp;(that.numer&nbsp;*&nbsp;<code class="vem">this</code>.denom)
  }
</pre>
      <p>There are just two things to do. First, this version of <span class="code">Rational</span> mixes in the <span class="code">Ordered</span> trait. Unlike the traits you have seen so far, <span class="code">Ordered</span> requires you to specify a <a href="#g772613699"><em>type parameter</em></a> when you mix it in. Type parameters are not discussed in detail until <a href="#chap-type-parameterization">Chapter 19</a>, but for now all you need to know is that when you mix in <span class="code">Ordered</span>, you must actually mix in <span class="code">Ordered[</span><em>C</em><span class="code">]</span>, where <em>C</em> is the class whose elements you compare. In this case, <span class="code">Rational</span> mixes in <span class="code">Ordered[Rational]</span>.</p>
      <p>The second thing you need to do is define a <span class="code">compare</span> method for comparing two objects. This method should compare the receiver, <span class="code">this</span>, with the object passed as an argument to the method. It should return an integer that is zero if the objects are the same, negative if receiver is less than the argument, and positive if the receiver is greater than the argument.</p>
      <p>In this case, the comparison method of <span class="code">Rational</span> uses a formula based on converting the fractions to a common denominator and then subtracting the resulting numerators. Given this mixin and the definition of <span class="code">compare</span>, class <span class="code">Rational</span> now has all four comparison methods:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;half&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">half:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;third&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">third:&nbsp;Rational&nbsp;=&nbsp;1/3</code>
  <br>  scala&gt;&nbsp;half&nbsp;&lt;&nbsp;third
  <code class="output">res5:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;half&nbsp;&gt;&nbsp;third
  <code class="output">res6:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>Any time you implement a class that is ordered by some comparison, you should consider mixing in the <span class="code">Ordered</span> trait. If you do, you will provide the class's users with a rich set of comparison methods.</p>
      <p>Beware that the <span class="code">Ordered</span> trait does not define <span class="code">equals</span> for you, because it is unable to do so. The problem is that implementing <span class="code">equals</span> in terms of <span class="code">compare</span> requires checking the type of the passed object, and because of type erasure, <span class="code">Ordered</span> itself cannot do this test. Thus, you need to define <span class="code">equals</span> yourself, even if you inherit <span class="code">Ordered</span>. You'll find out how to go about this in <a href="#chap-object-equality">Chapter 30</a>.</p>
      <p>The complete <span class="code">Ordered</span> trait, minus comments and compatibility cruft, is as follows:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">Ordered[T]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;compare(that:&nbsp;T):&nbsp;<code class="typename">Int</code>
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;&lt;(that:&nbsp;T):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;(<code class="vem">this</code>&nbsp;compare&nbsp;that)&nbsp;&lt;&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;&gt;(that:&nbsp;T):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;(<code class="vem">this</code>&nbsp;compare&nbsp;that)&nbsp;&gt;&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;&lt;=(that:&nbsp;T):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;(<code class="vem">this</code>&nbsp;compare&nbsp;that)&nbsp;&lt;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;&gt;=(that:&nbsp;T):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;(<code class="vem">this</code>&nbsp;compare&nbsp;that)&nbsp;&gt;=&nbsp;<code class="literal">0</code>
  }
</pre>
      <p>Do not worry much about the <span class="code">T</span>'s and <span class="code">[T]</span>'s. <span class="code">T</span> here is a <a href="#g772613699">type parameter</a>, as described in detail in <a href="#chap-type-parameterization">Chapter 19</a>. For understanding the <span class="code">Ordered</span> trait, just think of it as "the same type as the receiver". You can then see that this trait defines one abstract method, <span class="code">compare</span>, which is expected to compare the receiver (<span class="code">this</span>) against another object of the same type as the receiver (<span class="code">that</span>). Given this one method, <span class="code">Ordered</span> can then provide concrete definitions for <span class="code">&lt;</span>, <span class="code">&gt;</span>, <span class="code">&lt;=</span>, and <span class="code">&gt;=</span>.</p>
      <h3 id="sec-stackable-modifications">12.5 Traits as stackable modifications</h3>
      <p>You have now seen one major use of traits: turning a thin interface<a id="i-590612839-1"></a> into a rich one. Now we'll turn to a second major use: providing stackable modifications to classes. Traits let you <em>modify</em> the methods of a class, and they do so in a way that allows you to <em>stack</em> those modifications with each other.</p>
      <p>As an example, consider stacking modifications to a queue of integers. The queue will have two operations: <span class="code">put</span>, which places integers in the queue, and <span class="code">get</span>, which takes them back out. Queues are first-in, first-out, so <span class="code">get</span> should return the integers in the same order they were put in the queue.</p>
      <p>Given a class that implements such a queue, you could define traits to perform modifications such as these:</p>
      <ul>
        <li><span class="code">Doubling</span>: double all integers that are put in the queue </li>
        <li><span class="code">Incrementing</span>: increment all integers that are put in the queue </li>
        <li><span class="code">Filtering</span>: filter out negative integers from a queue </li>
      </ul>
      <p>These three traits represent <em>modifications</em>, because they modify the behavior of an underlying queue class rather than defining a full queue class themselves. The three are also <em>stackable</em>. You can select any of the three you like, mix them into a class, and obtain a new class that has all of the modifications you chose.</p>
      <p>An abstract <span class="code">IntQueue</span> class is shown in <a href="#lst-class-intqueue">Listing 12.6</a>. <span class="code">IntQueue</span> has a <span class="code">put</span> method that adds new integers to the queue, and a <span class="code">get</span> method that removes and returns them. A basic implementation of <span class="code">IntQueue</span> that uses an <span class="code">ArrayBuffer</span> is shown in <a href="#lst-basic-intqueue">Listing 12.7</a>.</p>
      <p><a id="lst-class-intqueue"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">IntQueue</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;get():&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;put(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Unit</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 12.6 - Abstract class <span class="code">IntQueue</span>.</h5>
      <p><a id="lst-basic-intqueue"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable.ArrayBuffer
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">BasicIntQueue</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IntQueue</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayBuffer[Int]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;get()&nbsp;=&nbsp;buf.remove(<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;put(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{&nbsp;buf&nbsp;+=&nbsp;x&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 12.7 - A <span class="code">BasicIntQueue</span> implemented with an <span class="code">ArrayBuffer</span>.</h5>
      <p>Class <span class="code">BasicIntQueue</span> has a private field holding an array buffer. The <span class="code">get</span> method removes an entry from one end of the buffer, while the <span class="code">put</span> method adds elements to the other end. Here's how this implementation looks when you use it:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;queue&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BasicIntQueue</code>
  <code class="output">queue:&nbsp;BasicIntQueue&nbsp;=&nbsp;BasicIntQueue@23164256</code>
  <br>  scala&gt;&nbsp;queue.put(<code class="literal">10</code>)
  <br>  scala&gt;&nbsp;queue.put(<code class="literal">20</code>)
  <br>  scala&gt;&nbsp;queue.get()
  <code class="output">res9:&nbsp;Int&nbsp;=&nbsp;10</code>
  <br>  scala&gt;&nbsp;queue.get()
  <code class="output">res10:&nbsp;Int&nbsp;=&nbsp;20</code>
</pre>
      <p>So far so good. Now take a look at using traits to modify this behavior. <a href="#lst-doubling-trait">Listing 12.8</a> shows a trait that doubles integers as they are put in the queue. The <span class="code">Doubling</span> trait has two funny things going on. The first is that it declares a superclass, <span class="code">IntQueue</span>. This declaration means that the trait can only be mixed into a class that also extends <span class="code">IntQueue</span>. Thus, you can mix <span class="code">Doubling</span> into <span class="code">BasicIntQueue</span>, but not into <span class="code">Rational</span>.</p>
      <p><a id="lst-doubling-trait"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Doubling</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IntQueue</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;put(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{&nbsp;<code class="vem">super</code>.put(<code class="literal">2</code>&nbsp;*&nbsp;x)&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 12.8 - The <span class="code">Doubling</span> stackable modification trait.</h5>
      <p>The second funny thing is that the trait has a <span class="code">super</span> call on a method declared abstract. Such calls are illegal for normal classes because they will certainly fail at run time. For a trait, however, such a call can actually succeed. Since <span class="code">super</span> calls in a trait are dynamically bound, the <span class="code">super</span> call in trait <span class="code">Doubling</span> will work so long as the trait is mixed in <em>after</em> another trait or class that gives a concrete definition to the method.</p>
      <p>This arrangement is frequently needed with traits that implement stackable modifications. To tell the compiler you are doing this on purpose, you must mark such methods as <span class="code">abstract</span> <span class="code">override</span>.<a id="i-1048822646-1"></a> This combination of modifiers is only allowed for members of traits, not classes, and it means that the trait must be mixed into some class that has a concrete definition of the method in question.</p>
      <p>There is a lot going on with such a simple trait, isn't there! Here's how it looks to use the trait:</p> <pre>  scala&gt;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">MyQueue</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">BasicIntQueue</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Doubling</code>
  <code class="output">defined&nbsp;class&nbsp;MyQueue</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;queue&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MyQueue</code>
  <code class="output">queue:&nbsp;MyQueue&nbsp;=&nbsp;MyQueue@44bbf788</code>
  <br>  scala&gt;&nbsp;queue.put(<code class="literal">10</code>)
  <br>  scala&gt;&nbsp;queue.get()
  <code class="output">res12:&nbsp;Int&nbsp;=&nbsp;20</code>
</pre>
      <p>In the first line in this interpreter session, we define class <span class="code">MyQueue</span>, which extends <span class="code">BasicIntQueue</span> and mixes in <span class="code">Doubling</span>. We then put a 10 in the queue, but because <span class="code">Doubling</span> has been mixed in, the 10 is doubled. When we get an integer from the queue, it is a 20.</p>
      <p>Note that <span class="code">MyQueue</span> defines no new code. It simply identifies a class and mixes in a trait. In this situation, you could supply "<span class="code">BasicIntQueue</span> <span class="code">with</span> <span class="code">Doubling</span>" directly to <span class="code">new</span> instead of defining a named class. It would look as shown in <a href="#lst-new-with">Listing 12.9</a>:</p>
      <p><a id="lst-new-with"></a></p> <pre>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">val</code>&nbsp;queue&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BasicIntQueue</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Doubling</code>
  <code class="output">&nbsp;&nbsp;queue:&nbsp;BasicIntQueue&nbsp;with&nbsp;Doubling&nbsp;=&nbsp;$anon$1@141f05bf</code>
  <br>  &nbsp;&nbsp;scala&gt;&nbsp;queue.put(<code class="literal">10</code>)
  <br>  &nbsp;&nbsp;scala&gt;&nbsp;queue.get()
  <code class="output">&nbsp;&nbsp;res14:&nbsp;Int&nbsp;=&nbsp;20</code>
</pre>
      <h5>Listing 12.9 - Mixing in a trait when instantiating with <span class="code">new</span>.</h5>
      <p> To see how to stack modifications, we need to define the other two modification traits, <span class="code">Incrementing</span> and <span class="code">Filtering</span>. Implementations of these traits are shown in <a href="#lst-incrementing-filtering">Listing 12.10</a>:</p>
      <p><a id="lst-incrementing-filtering"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Incrementing</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IntQueue</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;put(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{&nbsp;<code class="vem">super</code>.put(x&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Filtering</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IntQueue</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;put(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;&gt;=&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">super</code>.put(x)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 12.10 - Stackable modification traits <span class="code">Incrementing</span> and <span class="code">Filtering</span>.</h5>
      <p>Given these modifications, you can now pick and choose which ones you want for a particular queue. For example, here is a queue that both filters negative numbers and adds one to all numbers that it keeps:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;queue&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">BasicIntQueue</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Incrementing</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Filtering</code>)
  <code class="output">queue:&nbsp;BasicIntQueue&nbsp;with&nbsp;Incrementing&nbsp;with&nbsp;Filtering...</code>
  <br>  scala&gt;&nbsp;queue.put(-<code class="literal">1</code>);&nbsp;queue.put(<code class="literal">0</code>);&nbsp;queue.put(<code class="literal">1</code>)
  <br>  scala&gt;&nbsp;queue.get()
  <code class="output">res16:&nbsp;Int&nbsp;=&nbsp;1</code>
</pre> <pre>  scala&gt;&nbsp;queue.get()
  <code class="output">res17:&nbsp;Int&nbsp;=&nbsp;2</code>
</pre>
      <p>The order of mixins is significant.<a href="#footnotemain12-2">[2]</a> The precise rules are given in the following section, but, roughly speaking, traits further to the right take effect first. When you call a method on a class with mixins, the method in the trait furthest to the right is called first. If that method calls <span class="code">super</span>, it invokes the method in the next trait to its left, and so on. In the previous example, <span class="code">Filtering</span>'s <span class="code">put</span> is invoked first, so it removes integers that were negative to begin with. <span class="code">Incrementing</span>'s <span class="code">put</span> is invoked second, so it adds one to those integers that remain.</p>
      <p>If you reverse the order, first integers will be incremented, and <em>then</em> the integers that are still negative will be discarded:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;queue&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">BasicIntQueue</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Filtering</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Incrementing</code>)
  <code class="output">queue:&nbsp;BasicIntQueue&nbsp;with&nbsp;Filtering&nbsp;with&nbsp;Incrementing...</code>
  <br>  scala&gt;&nbsp;queue.put(-<code class="literal">1</code>);&nbsp;queue.put(<code class="literal">0</code>);&nbsp;queue.put(<code class="literal">1</code>)
  <br>  scala&gt;&nbsp;queue.get()
  <code class="output">res19:&nbsp;Int&nbsp;=&nbsp;0</code>
  <br>  scala&gt;&nbsp;queue.get()
  <code class="output">res20:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;queue.get()
  <code class="output">res21:&nbsp;Int&nbsp;=&nbsp;2</code>
</pre>
      <p>Overall, code written in this style gives you a great deal of flexibility. You can define sixteen different classes by mixing in these three traits in different combinations and orders. That's a lot of flexibility for a small amount of code, so you should keep your eyes open for opportunities to arrange code as stackable modifications.</p>
      <h3 id="sec-traits-vs-multi">12.6 Why not multiple inheritance?<a id="i-1992074038-1"></a><a id="i1595934381-1"></a><a id="i-1280910181-1"></a></h3>
      <p>Traits are a way to inherit from multiple class-like constructs, but they differ in important ways from the multiple inheritance present in many languages. One difference is especially important: the interpretation of <span class="code">super</span>. With multiple inheritance, the method called by a <span class="code">super</span> call can be determined right where the call appears. With traits, the method called is determined by a <em>linearization</em> of the classes and traits that are mixed into a class. This is the difference that enables the stacking of modifications described in the previous section.</p>
      <p>Before looking at linearization, take a moment to consider how to stack modifications in a language with traditional multiple inheritance. Imagine the following code, but this time interpreted as multiple inheritance instead of trait mixin:</p> <pre>  <code class="comment">//&nbsp;Multiple&nbsp;inheritance&nbsp;thought&nbsp;experiment</code>
  <code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BasicIntQueue</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Incrementing</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Doubling</code>
  q.put(<code class="literal">42</code>)&nbsp;&nbsp;<code class="comment">//&nbsp;which&nbsp;put&nbsp;would&nbsp;be&nbsp;called?</code>
</pre>
      <p>The first question is: Which <span class="code">put</span> method would get invoked by this call? Perhaps the rule would be that the last superclass wins, in which case <span class="code">Doubling</span> would get called. <span class="code">Doubling</span> would double its argument and call <span class="code">super.put</span>, and that would be it. No incrementing would happen! Likewise, if the rule were that the first superclass wins, the resulting queue would increment integers but not double them. Thus neither ordering would work.</p>
      <p>You might also entertain the possibility of allowing programmers to identify exactly which superclass method they want when they say <span class="code">super</span>. For example, imagine the following Scala-like code, in which <span class="code">super</span> appears to be explicitly invoked on both <span class="code">Incrementing</span> and <span class="code">Doubling</span>:</p> <pre>  <code class="comment">//&nbsp;Multiple&nbsp;inheritance&nbsp;thought&nbsp;experiment</code>
  <code class="vem">trait</code>&nbsp;<code class="typename">MyQueue</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">BasicIntQueue</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Incrementing</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Doubling</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;put(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;Incrementing.super.put(x)&nbsp;<code class="comment">//&nbsp;(Not&nbsp;real&nbsp;Scala)</code>
  &nbsp;&nbsp;&nbsp;&nbsp;Doubling.super.put(x)
  &nbsp;&nbsp;}
  }
</pre>
      <p>This approach would give us new problems (with the verbosity of this attempt being the least of its problems). What would happen is that the base class's <span class="code">put</span> method would get called <em>twice</em>—once with an incremented value and once with a doubled value, but neither time with an incremented, doubled value.</p>
      <p>There is simply no good solution to this problem using multiple inheritance. You would have to back up in your design and factor the code differently. By contrast, the traits solution in Scala is straightforward. You simply mix in <span class="code">Incrementing</span> and <span class="code">Doubling</span>, and Scala's special treatment of <span class="code">super</span> in traits makes it all work out. Something is clearly different here from traditional multiple inheritance, but what? As hinted previously, the answer is linearization. When you instantiate a class with <span class="code">new</span>, Scala takes the class, and all of its inherited classes and traits, and puts them in a single, <em>linear</em> order. Then, whenever you call <span class="code">super</span> inside one of those classes, the invoked method is the next one up the chain. If all of the methods but the last call <span class="code">super</span>, the net result is stackable behavior.</p>
      <p>The precise order of the linearization is described in the language specification. It is a little bit complicated, but the main thing you need to know is that, in any linearization, a class is always linearized in front of <em>all</em> its superclasses and mixed in traits. Thus, when you write a method that calls <span class="code">super</span>, that method is definitely modifying the behavior of the superclasses and mixed in traits, not the other way around.</p>
      <div class="note">
        <h4>Note</h4>
        <p>The remainder of this section describes the details of linearization. You can safely skip the rest of this section if you are not interested in understanding those details right now.</p>
      </div>
      <p>The main properties of Scala's linearization are illustrated by the following example: Say you have a class <span class="code">Cat</span>, which inherits from a superclass <span class="code">Animal</span> and two supertraits <span class="code">Furry</span> and <span class="code">FourLegged</span>. <span class="code">FourLegged</span> extends in turn another trait <span class="code">HasLegs</span>:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Animal</code>&nbsp;
  <code class="vem">trait</code>&nbsp;<code class="typename">Furry</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>
  <code class="vem">trait</code>&nbsp;<code class="typename">HasLegs</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>
  <code class="vem">trait</code>&nbsp;<code class="typename">FourLegged</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">HasLegs</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Cat</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Furry</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">FourLegged</code>
</pre>
      <p>Class <span class="code">Cat</span>'s inheritance hierarchy and linearization are shown in <a href="#fig-linearization">Figure 12.1</a>. Inheritance is indicated using traditional UML notation:<a href="#footnotemain12-3">[3]</a> arrows with white, triangular arrowheads indicate inheritance, with the arrowhead pointing to the supertype. The arrows with darkened, non-triangular arrowheads depict linearization. The darkened arrowheads point in the direction in which <span class="code">super</span> calls will be resolved.</p>
      <div class="figure">
        <a id="fig-linearization"></a>
        <p><img src="linearization160.png" alt="images/linearization160.png"></p>
      </div>
      <h5> Figure 12.1 - Inheritance hierarchy and linearization of class <span class="code">Cat</span>.</h5>
      <p>The linearization of <span class="code">Cat</span> is computed from back to front as follows. The <span style="font-style:italic">last</span> part of the linearization of <span class="code">Cat</span> is the linearization of its superclass, <span class="code">Animal</span>. This linearization is copied over without any changes. (The linearization of each of these types is shown in <a href="#tab-linearization-several">Table 12.1</a> <a href="#tab-linearization-several">here</a>.) Because <span class="code">Animal</span> doesn't explicitly extend a superclass or mix in any supertraits, it by default extends <span class="code">AnyRef</span>, which extends <span class="code">Any</span>. <span class="code">Animal</span>'s linearization, therefore, looks like:</p>
      <div style="text-align: center">
        <img src="AnimalLine160.png" alt="images/AnimalLine160.png">
      </div>
      <p>The second to last part is the linearization of the first mixin, trait <span class="code">Furry</span>, but all classes that are already in the linearization of <span class="code">Animal</span> are left out now, so that each class appears only once in <span class="code">Cat</span>'s linearization. The result is:</p>
      <div style="text-align: center">
        <img src="FurryLine160.png" alt="images/FurryLine160.png">
      </div>
      <p>This is preceded by the linearization of <span class="code">FourLegged</span>, where again any classes that have already been copied in the linearizations of the superclass or the first mixin are left out:</p>
      <div style="text-align: center">
        <img src="FourLeggedLine160.png" alt="images/FourLeggedLine160.png">
      </div>
      <p>Finally, the first class in the linearization of <span class="code">Cat</span> is <span class="code">Cat</span> itself:</p>
      <div style="text-align: center">
        <img src="CatLine160.png" alt="images/CatLine160.png">
      </div>
      <p>When any of these classes and traits invokes a method via <span class="code">super</span>, the implementation invoked will be the first implementation to its right in the linearization.</p>
      <p><a id="tab-linearization-several"></a></p>
      <h5>Table 12.1 - Linearization of types in <span class="code">Cat</span>'s hierarchy</h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> <span style="font-size:medium"><span style="font-weight:bold">Type</span></span> </td>
              <td> <span style="font-size:medium"><span style="font-weight:bold">Linearization</span></span> </td>
            </tr>
            <tr class="topline ">
              <td> <span class="code">Animal</span> </td>
              <td> Animal, AnyRef, Any </td>
            </tr>
            <tr>
              <td> <span class="code">Furry</span> </td>
              <td> Furry, Animal, AnyRef, Any </td>
            </tr>
            <tr>
              <td> <span class="code">FourLegged</span> </td>
              <td> FourLegged, HasLegs, Animal, AnyRef, Any </td>
            </tr>
            <tr>
              <td> <span class="code">HasLegs</span> </td>
              <td> HasLegs, Animal, AnyRef, Any </td>
            </tr>
            <tr class="bottomline">
              <td> <span class="code">Cat</span> </td>
              <td> Cat, FourLegged, HasLegs, Furry, Animal, AnyRef, Any </td>
            </tr>
          </tbody>
        </table>
      </div>
      <h3>12.7 To trait or not to trait?</h3>
      <p>Whenever you implement a reusable collection of behavior, you will have to decide whether you want to use a trait or an abstract class. There is no firm rule, but this section contains a few guidelines to consider.</p>
      <p><em>If the behavior will not be reused</em>, then make it a concrete class. It is not reusable behavior after all.</p>
      <p><em>If it might be reused in multiple, unrelated classes</em>, make it a trait. Only traits can be mixed into different parts of the class hierarchy.</p>
      <p><em>If you want to inherit from it in Java code</em>, use an abstract class. Since traits with code do not have a close Java analog, it tends to be awkward to inherit from a trait in a Java class. Inheriting from a Scala class, meanwhile, is exactly like inheriting from a Java class. As one exception, a Scala trait with only abstract members translates directly to a Java interface, so you should feel free to define such traits even if you expect Java code to inherit from it. See <a href="#chap-combining-scala-and-java">Chapter 31</a> for more information on working with Java and Scala together.</p>
      <p><em>If you plan to distribute it in compiled form</em>, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class. The issue is that when a trait gains or loses a member, any classes that inherit from it must be recompiled, even if they have not changed. If outside clients will only call into the behavior, instead of inheriting from it, then using a trait is fine.</p>
      <p><em>If you still do not know</em>, after considering the above, then start by making it as a trait. You can always change it later, and in general using a trait keeps more options open.</p>
      <h3>12.8 Conclusion</h3>
      <p>This chapter has shown you how traits work and how to use them in several common idioms. You saw that traits are similar to multiple inheritance. But because traits interpret <span class="code">super</span> using linearization, they both avoid some of the difficulties of traditional multiple inheritance and allow you to stack behaviors. You also saw the <span class="code">Ordered</span> trait and learned how to write your own enrichment traits.</p>
      <p>Now that you have seen all of these facets, it is worth stepping back and taking another look at traits as a whole. Traits do not merely support the idioms described in this chapter; they are a fundamental unit of code that is reusable through inheritance. As such, many experienced Scala programmers start with traits when they are at the early stages of implementation. Each trait can hold less than an entire concept, a mere fragment of a concept. As the design solidifies, the fragments can be combined into more complete concepts through trait mixin.</p>
      <hr>
      <h4>Footnotes for Chapter 12:</h4>
      <p><a id="footnotemain12-1"></a>[1] This example is based on the <span class="code">Rational</span> class shown in <a href="#lst-overloaded-methods">Listing 6.5</a> <a href="#lst-overloaded-methods">here</a>, with <span class="code">equals</span>, <span class="code">hashCode</span>, and modifications to ensure a positive <span class="code">denom</span> added.</p>
      <p><a id="footnotemain12-2"></a>[2] Once a trait is mixed into a class, you can alternatively call it a <em>mixin</em>.</p>
      <p><a id="footnotemain12-3"></a>[3] Rumbaugh, <i>et. al.</i>, <em>The Unified Modeling Language Reference Manual</em>. <a href="#rumbaugh-uml">[Rum04]</a><a id="i-1488083405-1"></a><a id="i-1072078781-1"></a></p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-packages-and-imports">Chapter 13</a></h2>
      <h1>Packages and Imports</h1>
      <p>When working on a program, especially a large one, it is important to minimize <em>coupling</em>—the extent to which the various parts of the program rely on the other parts. Low coupling reduces the risk that a small, seemingly innocuous change in one part of the program will have devastating consequences in another part. One way to minimize coupling is to write in a modular style. You divide the program into a number of smaller modules, each of which has an inside and an outside. When working on the inside of a module—its <em>implementation</em>—you need only coordinate with other programmers working on that very same module. Only when you must change the outside of a module—its <em>interface</em>—is it necessary to coordinate with developers working on other modules.<a id="i750867693-1"></a></p>
      <p>This chapter shows several constructs that help you program in a modular style. It shows how to place things in packages, make names visible through imports, and control the visibility of definitions through access modifiers. The constructs are similar in spirit to constructs in Java, but there are some differences—usually ways that are more consistent—so it's worth reading this chapter even if you already know Java.</p>
      <h3>13.1 Putting code in packages</h3>
      <p>Scala code resides in the Java platform's global hierarchy of packages. The example code you've seen so far in this book has been in the <em>unnamed</em> package.<a id="i305704921-1"></a><a id="i38834278-1"></a> You can place code into named packages in Scala in two ways. First, you can place the contents of an entire file into a package by putting a <span class="code">package</span> clause at the top of the file, as shown in <a href="#lst-entire-file-package">Listing 13.1</a>.</p>
      <p><a id="lst-entire-file-package"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets.navigation
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>
</pre>
      <h5>Listing 13.1 - Placing the contents of an entire file into a package.<a id="i-1154528502-1"></a></h5>
      <p>The <span class="code">package</span> clause of <a href="#lst-entire-file-package">Listing 13.1</a> places class <span class="code">Navigator</span> into the package named <span class="code">bobsrockets.navigation</span>. Presumably, this is the navigation software developed by Bob's Rockets, Inc.</p>
      <div class="note">
        <h4>Note</h4> Because Scala code is part of the Java ecosystem, it is recommended to follow Java's reverse-domain-name convention for Scala packages that you release to the public. Thus, a better name for <span class="code">Navigator</span>'s package might be <span class="code">com.bobsrockets.navigation</span>. In this chapter, however, we'll leave off the "<span class="code">com.</span>" to make the examples easier to understand.
      </div>
      <p>The other way you can place code into packages in Scala is more like C# namespaces.<a id="i-999496559-1"></a> You follow a package clause by a section in curly braces that contains the definitions that go into the package. This syntax is called a <em>packaging</em>.<a id="i1802065795-1"></a> The packaging shown in <a href="#lst-dot-and-nested">Listing 13.2</a> has the same effect as the code in <a href="#lst-entire-file-package">Listing 13.1</a>: <a id="lst-dot-and-nested"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets.navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.2 - Long form of a simple package declaration.</h5>
      <p>For such simple examples, you might as well use the syntactic sugar shown in <a href="#lst-entire-file-package">Listing 13.1</a>. However, one use of the more general notation is to have different parts of a file in different packages. For example, you might include a class's tests in the same file as the original code, but put the tests in a different package, as shown<a id="i-1775661018-1"></a> in <a href="#lst-nesting-packages">Listing 13.3</a>.</p>
      <p><a id="lst-nesting-packages"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;navigation&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;tests&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation.tests</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">NavigatorSuite</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.3 - Multiple packages in the same file.</h5>
      <p><a id="lst-concise"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.navigation.StarMap</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">StarMap</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">StarMap</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Ship</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.navigation.Navigator</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;nav&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">navigation.Navigator</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;fleets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Fleet</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.Ship</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;addShip()&nbsp;=&nbsp;{&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Ship</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.4 - Concise access to classes and packages.</h5>
      <p><a id="lst-enclosing"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Ship</code>
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets.fleets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Fleet</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Doesn't&nbsp;compile!&nbsp;Ship&nbsp;is&nbsp;not&nbsp;in&nbsp;scope.</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;addShip()&nbsp;=&nbsp;{&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Ship</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.5 - Symbols in enclosing packages not automatically available.</h5>
      <p><a id="lst-hiding-packages"></a></p> <pre>  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;launch.scala</code>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Booster3</code>
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;bobsrockets.scala</code>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Booster1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">MissionControl</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;booster1&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">launch.Booster1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;booster2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">bobsrockets.launch.Booster2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;booster3&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;_root_.launch.Booster3
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">package</code>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Booster2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.6 - Accessing hidden package names.</h5>
      <h3>13.2 Concise access to related code</h3>
      <p>When code is divided into a package hierarchy, it doesn't just help people browse through the code. It also tells the compiler that code in the same package is related in some way to each other. Scala takes advantage of this relatedness by allowing short, unqualified names when accessing code that is in the same package.</p>
      <p><a href="#lst-concise">Listing 13.4</a> gives three simple examples. First, as you would expect, a class can be accessed from within its own package without needing a prefix. That's why <span class="code">new</span>&nbsp;<span class="code">StarMap</span> compiles. Class <span class="code">StarMap</span> is in the same package, <span class="code">bobsrockets.navigation</span>, as the <span class="code">new</span> expression that accesses it, so the package name doesn't need to be prefixed.</p>
      <p>Second, a package itself can be accessed from its containing package without needing a prefix. In <a href="#lst-concise">Listing 13.4</a>, look at how class <span class="code">Navigator</span> is instantiated. The <span class="code">new</span> expression appears in package <span class="code">bobsrockets</span>, which is the containing package of <span class="code">bobsrockets.navigation</span>. Thus, it can access package <span class="code">bobsrockets.navigation</span> as simply <span class="code">navigation</span>.</p>
      <p>Third, when using the curly-braces packaging syntax, all names accessible in scopes outside the packaging are also available inside it. An example in <a href="#lst-concise">Listing 13.4</a> is the way <span class="code">addShip()</span> creates a new <span class="code">Ship</span>. The method is defined within two packagings: an outer one for <span class="code">bobsrockets</span>, and an inner one for <span class="code">bobsrockets.fleets</span>. Since <span class="code">Ship</span> is accessible in the outer packaging, it can be referenced from within <span class="code">addShip()</span>.</p>
      <p>Note that this kind of access is only available if you explicitly nest the packagings. If you stick to one package per file, then—like in Java—the only names available will be the ones defined in the current package. In <a href="#lst-enclosing">Listing 13.5</a>, the packaging of <span class="code">bobsrockets.fleets</span> has been moved to the top level. Since it is no longer enclosed in a packaging for <span class="code">bobsrockets</span>, names from <span class="code">bobsrockets</span> are not immediately in scope. As a result, <span class="code">new</span>&nbsp;<span class="code">Ship</span> gives a compile error. If nesting packages with braces shifts your code uncomfortably to the right, you can also use multiple package clauses without the braces.<a href="#footnotemain13-1">[1]</a> For instance, the code below also defines class <span class="code">Fleet</span> in two nested packages <span class="code">bobsrockets</span> and <span class="code">fleets</span>, just like you saw it in <a href="#lst-concise">Listing 13.4</a>:</p> <pre>  <code class="vem">package</code>&nbsp;bobsrockets
  <code class="vem">package</code>&nbsp;fleets
  <code class="vem">class</code>&nbsp;<code class="typename">Fleet</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.Ship</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;addShip()&nbsp;=&nbsp;{&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Ship</code>&nbsp;}
  }
</pre>
      <p>One final trick is important to know. Sometimes, you end up coding in a heavily crowded scope where package names are hiding each other. In <a href="#lst-hiding-packages">Listing 13.6</a>, the scope of class <span class="code">MissionControl</span> includes three separate packages named <span class="code">launch</span>! There's one <span class="code">launch</span> in <span class="code">bobsrockets.navigation</span>, one in <span class="code">bobsrockets</span>, and one at the top level. How would you reference each of <span class="code">Booster1</span>, <span class="code">Booster2</span>, and <span class="code">Booster3</span>?<a id="i-370748244-1"></a><a id="i-33124968-1"></a></p>
      <p>Accessing the first one is easiest. A reference to <span class="code">launch</span> by itself will get you to package <span class="code">bobsrockets.navigation.launch</span>, because that is the <span class="code">launch</span> package defined in the closest enclosing scope. Thus, you can refer to the first booster class as simply <span class="code">launch.Booster1</span>. Referring to the second one also is not tricky. You can write <span class="code">bobsrockets.launch.Booster2</span> and be clear about which one you are referencing. That leaves the question of the third booster class: How can you access <span class="code">Booster3</span>, considering that a nested <span class="code">launch</span> package shadows the top-level one?</p>
      <p>To help in this situation, Scala provides a package named <span class="code">_root_</span> that is outside any package a user can write. Put another way, every top-level package you can write is treated as a member of package <span class="code">_root_</span>. For example, both <span class="code">launch</span> and <span class="code">bobsrockets</span> of <a href="#lst-hiding-packages">Listing 13.6</a> are members of package <span class="code">_root_</span>. As a result, <span class="code">_root_.launch</span> gives you the top-level <span class="code">launch</span> package, and <span class="code">_root_.launch.Booster3</span> designates the outermost booster class.</p>
      <h3 id="sec-imports">13.3 Imports</h3>
      <p>In Scala, packages and their members can be imported using <span class="code">import</span><a id="i1926037870-2"></a> clauses. Imported items can then be accessed by a simple name like <span class="code">File</span>, as opposed to requiring a qualified name like <span class="code">java.io.File</span>. For example, consider the code shown in <a href="#lst-bobs-fruits">Listing 13.7</a>.</p>
      <p><a id="lst-bobs-fruits"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsdelights
  <br>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Fruit</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;name:&nbsp;<code class="typename">String</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">String</code>
  &nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Fruits</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Apple</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>(<code class="quotedstring">"apple"</code>,&nbsp;<code class="quotedstring">"red"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Orange</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>(<code class="quotedstring">"orange"</code>,&nbsp;<code class="quotedstring">"orange"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Pear</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>(<code class="quotedstring">"pear"</code>,&nbsp;<code class="quotedstring">"yellowish"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;menu&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Orange</code>,&nbsp;<code class="typename">Pear</code>)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.7 - Bob's delightful fruits, ready for import.</h5>
      <p>An <span class="code">import</span> clause makes members of a package or object available by their names alone without needing to prefix them by the package or object name. Here are some simple examples:</p> <pre>  <code class="comment">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;Fruit</code>
  <code class="vem">import</code>&nbsp;bobsdelights.Fruit
  <br>  <code class="comment">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;all&nbsp;members&nbsp;of&nbsp;bobsdelights</code>
  <code class="vem">import</code>&nbsp;bobsdelights._
  <br>  <code class="comment">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;all&nbsp;members&nbsp;of&nbsp;Fruits</code>
  <code class="vem">import</code>&nbsp;bobsdelights.Fruits._
</pre>
      <p>The first of these corresponds to Java's single type import and the second to Java's <em>on-demand</em> import.<a id="i-410901588-1"></a><a id="i-1858203568-1"></a> The only difference is that Scala's on-demand imports are written with a trailing underscore (<span class="code">_</span>) instead of an asterisk (<span class="code">*</span>). (After all, <span class="code">*</span> is a valid identifier in Scala!) The third import clause above corresponds to Java's import of static class fields.</p>
      <p>These three imports give you a taste of what imports can do, but Scala imports are actually much more general. For one, imports in Scala can appear anywhere, not just at the beginning of a compilation unit. Also, they can refer to arbitrary values. For instance, the import shown in <a href="#lst-importing-object-members">Listing 13.8</a> is possible: <a id="lst-importing-object-members"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;showFruit(fruit:&nbsp;<code class="typename">Fruit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;fruit._
  &nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+&nbsp;<code class="quotedstring">"s&nbsp;are&nbsp;"</code>&nbsp;+&nbsp;color)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.8 - Importing the members of a regular (not singleton) object.</h5>
      <p>Method <span class="code">showFruit</span> imports all members of its parameter <span class="code">fruit</span>, which is of type <span class="code">Fruit</span>. The subsequent <span class="code">println</span> statement can refer to <span class="code">name</span> and <span class="code">color</span> directly. These two references are equivalent to <span class="code">fruit.name</span> and <span class="code">fruit.color</span>. This syntax is particularly useful when you use objects as modules, which will be described in <a href="#chap-modular-programming-using-objects">Chapter 29</a>.</p>
      <div class="aside">
        <h3>Scala's flexible imports</h3>
        <p>Scala's <span class="code">import</span> clauses are quite a bit more flexible than Java's. There are three principal differences. In Scala, imports:</p>
        <ul>
          <li>may appear anywhere </li>
          <li>may refer to objects (singleton or regular) in addition to packages </li>
          <li>let you rename and hide some of the imported members </li>
        </ul>
      </div>
      <p>Another way Scala's imports are flexible is that they can import packages themselves, not just their non-package members. This is only natural if you think of nested packages being contained in their surrounding package. For example, in <a href="#lst-importing-package-name">Listing 13.9</a>, the package <span class="code">java.util.regex</span> is imported. This makes <span class="code">regex</span> usable as a simple name. To access the <span class="code">Pattern</span> singleton object from the <span class="code">java.util.regex</span> package, you can just say, <span class="code">regex.Pattern</span>, as shown in <a href="#lst-importing-package-name">Listing 13.9</a>:</p>
      <p><a id="lst-importing-package-name"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.util.regex
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">AStarB</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Accesses&nbsp;java.util.regex.Pattern</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;pat&nbsp;=&nbsp;regex.Pattern.compile(<code class="quotedstring">"a*b"</code>)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.9 - Importing a package name.</h5>
      <p>Imports in Scala can also rename or hide members. This is done with an <span style="font-style:italic">import selector clause</span> enclosed in braces, which follows the object from which members are imported. Here are some examples:<a id="i-1172048805-1"></a><a id="i-303565265-1"></a><a id="i1981623788-1"></a><a id="i-1574838534-1"></a></p>
      <p><span class="code">import</span>&nbsp;<span class="code">Fruits.{Apple,</span>&nbsp;<span class="code">Orange}</span></p>
      <p><br> This imports just members <span class="code">Apple</span> and <span class="code">Orange</span> from object <span class="code">Fruits</span>.</p>
      <p><span class="code">import</span>&nbsp;<span class="code">Fruits.{Apple</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">McIntosh,</span>&nbsp;<span class="code">Orange}</span></p>
      <p><br> This imports the two members <span class="code">Apple</span> and <span class="code">Orange</span> from object<a id="i-252838726-1"></a><a id="i-1444404533-1"></a> <span class="code">Fruits</span>. However, the <span class="code">Apple</span> object is renamed to <span class="code">McIntosh</span>, so this object can be accessed with either <span class="code">Fruits.Apple</span> or <span class="code">McIntosh</span>. A renaming clause is always of the form "<span class="code">&lt;original-name&gt;</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">&lt;new-name&gt;</span>".</p>
      <p><span class="code">import</span>&nbsp;<span class="code">java.sql.{Date</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">SDate}</span></p>
      <p><br> This imports the SQL date class as <span class="code">SDate</span>, so that you can simultaneously import the normal Java date class as simply <span class="code">Date</span>.</p>
      <p><span class="code">import</span>&nbsp;<span class="code">java.{sql</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">S}</span></p>
      <p><br> This imports the <span class="code">java.sql</span> package as <span class="code">S</span>, so that you can write things like <span class="code">S.Date</span>.</p>
      <p><span class="code">import</span>&nbsp;<span class="code">Fruits.{_}</span></p>
      <p><br> This imports all members from object <span class="code">Fruits</span>. It means the same thing as <span class="code">import</span>&nbsp;<span class="code">Fruits._</span>.<a id="i91932059-1"></a></p>
      <p><span class="code">import</span>&nbsp;<span class="code">Fruits.{Apple</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">McIntosh,</span>&nbsp;<span class="code">_}</span></p>
      <p><br> This imports all members from object <span class="code">Fruits</span> but renames <span class="code">Apple</span> to <span class="code">McIntosh</span>.</p>
      <p><span class="code">import</span>&nbsp;<span class="code">Fruits.{Pear</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">_,</span>&nbsp;<span class="code">_}</span><a id="i1258079951-1"></a></p>
      <p><br> This imports all members of <span class="code">Fruits</span> <span style="font-style:italic">except</span> <span class="code">Pear</span>. A clause of the form "<span class="code">&lt;original-name&gt;</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">_</span>" excludes <span class="code">&lt;original-name&gt;</span> from the names that are imported. In a sense, renaming something to `<span class="code">_</span>' means hiding it altogether. This is useful to avoid<a id="i-236944399-1"></a> ambiguities. Say you have two packages, <span class="code">Fruits</span> and <span class="code">Notebooks</span>, which both define a class <span class="code">Apple</span>. If you want to get just the notebook named <span class="code">Apple</span>, and not the fruit, you could still use two imports on demand like this:</p> <pre>  <code class="vem">import</code>&nbsp;Notebooks._
  <code class="vem">import</code>&nbsp;Fruits.{<code class="typename">Apple</code>&nbsp;=&gt;&nbsp;_,&nbsp;_}
</pre>
      <p>This would import all <span class="code">Notebooks</span> and all <span class="code">Fruits</span>, except for <span class="code">Apple</span>.</p>
      <p><br> These examples demonstrate the great flexibility Scala offers when it comes to importing members selectively and possibly under different names. In summary, an import selector can consist of the following:</p>
      <ul>
        <li>A simple name <span class="code">x</span>. This includes <span class="code">x</span> in the set of imported names. </li>
        <li>A renaming clause <span class="code">x</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">y</span>. This makes the member named <span class="code">x</span> visible under the name <span class="code">y</span>. </li>
        <li>A hiding clause <span class="code">x</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">_</span>. This excludes <span class="code">x</span> from the set of imported names. </li>
        <li>A <em>catch-all</em> `<span class="code">_</span>'. This imports all members except those members mentioned in a preceding clause. If a catch-all is given, it must come last in the list of import selectors. </li>
      </ul>
      <p>The simpler import clauses shown at the beginning of this section can be seen as special abbreviations of import clauses with a selector clause. For example, "<span class="code">import</span>&nbsp;<span class="code">p._</span>" is equivalent to "<span class="code">import</span>&nbsp;<span class="code">p.{_}</span>" and "<span class="code">import</span>&nbsp;<span class="code">p.n</span>" is equivalent to "<span class="code">import</span>&nbsp;<span class="code">p.{n}</span>".</p>
      <h3>13.4 Implicit imports</h3>
      <p>Scala adds some imports implicitly to every program. In essence, it is as if<a id="i-1027603681-1"></a><a id="i586706545-2"></a><a id="i1384274725-1"></a> the following three import clauses had been added to the top of every source file with extension "<span class="code">.scala</span>":</p> <pre>  <code class="vem">import</code>&nbsp;java.lang._&nbsp;<code class="comment">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;java.lang&nbsp;package</code>
  <code class="vem">import</code>&nbsp;scala._&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;scala&nbsp;package</code>
  <code class="vem">import</code>&nbsp;Predef._&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;Predef&nbsp;object</code>
</pre>
      <p>The <span class="code">java.lang</span> package contains standard Java classes. It is always implicitly imported in Scala source files.<a href="#footnotemain13-2">[2]</a> Because <span class="code">java.lang</span> is imported implicitly, you can write <span class="code">Thread</span> instead of <span class="code">java.lang.Thread</span>, for instance.</p>
      <p>As you have no doubt realized by now, the <span class="code">scala</span> package contains the standard Scala library, with many common classes and objects. Because <span class="code">scala</span> is imported implicitly, you can write <span class="code">List</span> instead of <span class="code">scala.List</span>, for instance.</p>
      <p>The <span class="code">Predef</span> object contains many definitions of types, methods, and implicit conversions that are commonly used on Scala programs. For example, because <span class="code">Predef</span> is imported implicitly, you can write <span class="code">assert</span> instead of <span class="code">Predef.assert</span>.</p>
      <p>These three import clauses are treated a bit specially in that later imports overshadow earlier ones. For instance, the <span class="code">StringBuilder</span> class is defined both in package <span class="code">scala</span> and, from Java version 1.5 on, also in package <span class="code">java.lang</span>. Because the <span class="code">scala</span> import overshadows the <span class="code">java.lang</span> import, the simple name <span class="code">StringBuilder</span> will refer to <span class="code">scala.StringBuilder</span>, not <span class="code">java.lang.StringBuilder</span>.</p>
      <h3 id="sec-access-modifiers">13.5 Access modifiers</h3>
      <p>Members of packages, classes, or objects can be labeled with the<a id="i436061376-1"></a> access modifiers <span class="code">private</span> and <span class="code">protected</span>. These modifiers restrict access to the members to certain regions of code. Scala's treatment of access modifiers roughly follows Java's but there are some important differences which are explained in this section.</p>
      <h4>Private members</h4>
      <p>Private members in Scala are treated similarly to Java. A member labeled<a id="i-698337515-1"></a><a id="i835454125-1"></a> <span class="code">private</span> is visible only inside the class or object that contains the member definition. In Scala, this rule applies also for inner classes. This treatment is more consistent, but differs from Java. Consider the example shown in <a href="#lst-private-access-differs">Listing 13.10</a>.</p>
      <p><a id="lst-private-access-differs"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Outer</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Inner</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;f()&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"f"</code>)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">InnerMost</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()&nbsp;<code class="comment">//&nbsp;OK</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">Inner</code>).f()&nbsp;<code class="comment">//&nbsp;error:&nbsp;f&nbsp;is&nbsp;not&nbsp;accessible</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.10 - How private access differs in Scala and Java.</h5>
      <p>In Scala, the access <span class="code">(new</span>&nbsp;<span class="code">Inner).f()</span> is illegal because <span class="code">f</span> is declared <span class="code">private</span> in <span class="code">Inner</span> and the access is not from within class <span class="code">Inner</span>. By contrast, the first access to <span class="code">f</span> in class <span class="code">InnerMost</span> is OK, because that access is contained in the body of class <span class="code">Inner</span>. Java would permit both accesses because it lets an outer class access private members of its inner classes.</p>
      <h4>Protected members</h4>
      <p>Access to <span class="code">protected</span> members in Scala is also a bit more restrictive than in Java.<a id="i-711542007-1"></a> In Scala, a <span class="code">protected</span> member is only accessible from subclasses of the class in which the member is defined. In Java such accesses are also possible from other classes in the same package. In Scala, there is another way to achieve this effect<a href="#footnotemain13-3">[3]</a> so <span class="code">protected</span> is free to be left as is. The example shown in <a href="#lst-protected-access-differs">Listing 13.11</a> illustrates protected accesses. <a id="lst-protected-access-differs"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;p&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Super</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;f()&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"f"</code>)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Sub</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Super</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Other</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">Super</code>).f()&nbsp;&nbsp;<code class="comment">//&nbsp;error:&nbsp;f&nbsp;is&nbsp;not&nbsp;accessible</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.11 - How protected access differs in Scala and Java.</h5>
      <p>In <a href="#lst-protected-access-differs">Listing 13.11</a>, the access to <span class="code">f</span> in class <span class="code">Sub</span> is OK because <span class="code">f</span> is declared <span class="code">protected</span> in <span class="code">Super</span> and <span class="code">Sub</span> is a subclass of <span class="code">Super</span>. By contrast the access to <span class="code">f</span> in <span class="code">Other</span> is not permitted, because <span class="code">Other</span> does not inherit from <span class="code">Super</span>. In Java, the latter access would be still permitted because <span class="code">Other</span> is in the same package as <span class="code">Sub</span>.</p>
      <h4>Public members</h4>
      <p>Scala has no explicit modifier for public members: Any member not labeled <span class="code">private</span> or <span class="code">protected</span> is public. Public members can be accessed from anywhere.</p>
      <p><a id="lst-access-qualifiers"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;bobsrockets
  <br>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[bobsrockets]&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Navigator</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">protected</code>[navigation]&nbsp;<code class="vem">def</code>&nbsp;useStarChart()&nbsp;=&nbsp;{}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">LegOfJourney</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="typename">Navigator</code>]&nbsp;<code class="vem">val</code>&nbsp;distance&nbsp;=&nbsp;<code class="literal">100</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;speed&nbsp;=&nbsp;<code class="literal">200</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;navigation._
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Vehicle</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[launch]&nbsp;<code class="vem">val</code>&nbsp;guide&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Navigator</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.12 - Flexible scope of protection with access qualifiers.</h5>
      <h4>Scope of protection</h4>
      <p><a id="subsec-scope-of-protection"></a></p>
      <p>Access modifiers in Scala can be augmented with qualifiers. A modifier of the form <span class="code">private[X]</span> or <span class="code">protected[X]</span> means that access is private or protected "up to" <span class="code">X</span>, where <span class="code">X</span> designates some enclosing package, class or singleton object.<a id="i488929967-1"></a></p>
      <p>Qualified access modifiers give you very fine-grained control over visibility. In particular they enable you to express Java's accessibility notions, such as package private, package protected, or private up to outermost class, which are not directly expressible with simple modifiers in Scala. But they also let you express accessibility rules that cannot be expressed in Java.</p>
      <p><a href="#lst-access-qualifiers">Listing 13.12</a> presents an example with many access qualifiers being used. In this listing, class <span class="code">Navigator</span> is labeled <span class="code">private[bobsrockets]</span>. This means that this class is visible in all classes and objects that are contained in package <span class="code">bobsrockets</span>. In particular, the access to <span class="code">Navigator</span> in object <span class="code">Vehicle</span> is permitted because <span class="code">Vehicle</span> is contained in package <span class="code">launch</span>, which is contained in <span class="code">bobsrockets</span>. On the other hand, all code outside the package <span class="code">bobsrockets</span> cannot access class <span class="code">Navigator</span>.</p>
      <p>This technique is quite useful in large projects that span several packages. It allows you to define things that are visible in several sub-packages of your project but that remain hidden from clients external to your project. The same technique is not possible in Java. There, once a definition escapes its immediate package boundary, it is visible to the world at large.</p>
      <p>Of course, the qualifier of a <span class="code">private</span> may also be the directly enclosing package. An example is the access modifier of <span class="code">guide</span> in object <span class="code">Vehicle</span> in <a href="#lst-access-qualifiers">Listing 13.12</a>. Such an access modifier is equivalent to Java's package-private access.<a id="i908525335-1"></a></p>
      <p><a id="tab-leg-of-journey-private"></a></p>
      <h5>Table 13.1 - Effects of private qualifiers on <span class="code">LegOfJourney.distance</span></h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> <em>no access modifier</em> </td>
              <td> public access </td>
            </tr>
            <tr>
              <td> <span class="code">private[bobsrockets]</span> </td>
              <td> access within outer package </td>
            </tr>
            <tr>
              <td> <span class="code">private[navigation]</span> </td>
              <td> same as package visibility in Java </td>
            </tr>
            <tr>
              <td> <span class="code">private[Navigator]</span> </td>
              <td> same as <span class="code">private</span> in Java </td>
            </tr>
            <tr>
              <td> <span class="code">private[LegOfJourney]</span> </td>
              <td> same as <span class="code">private</span> in Scala </td>
            </tr>
            <tr class="bottomline">
              <td> <span class="code">private[this]</span> </td>
              <td> access only from same object </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>All qualifiers can also be applied to <span class="code">protected</span>, with the same meaning as <span class="code">private</span>. That is, a modifier <span class="code">protected[X]</span> in a class <span class="code">C</span> allows access to the labeled definition in all subclasses of <span class="code">C</span> and also within the enclosing package, class, or object <span class="code">X</span>. For instance, the <span class="code">useStarChart</span> method in <a href="#lst-access-qualifiers">Listing 13.12</a> is accessible in all subclasses of <span class="code">Navigator</span> and also in all code contained in the enclosing package <span class="code">navigation</span>. It thus corresponds exactly to the meaning of <span class="code">protected</span> in Java.</p>
      <p>The qualifiers of <span class="code">private</span> can also refer to an enclosing class or object. For instance the <span class="code">distance</span> variable in class <span class="code">LegOfJourney</span> in <a href="#lst-access-qualifiers">Listing 13.12</a> is labeled <span class="code">private[Navigator]</span>, so it is visible from everywhere in class <span class="code">Navigator</span>. This gives the same access capabilities as for private members of inner classes in Java. A <span class="code">private[C]</span> where <span class="code">C</span> is the outermost enclosing class is the same as just <span class="code">private</span> in Java.<a id="i570723644-1"></a><a id="i-1579182668-1"></a></p>
      <p>Finally, Scala also has an access modifier that is even more<a id="i-1909160422-1"></a><a id="i623710400-1"></a> restrictive than <span class="code">private</span>. A definition labeled <span class="code">private[this]</span> is accessible only from within the same object that contains the definition. Such a definition is called <span style="font-style:italic">object-private</span>. For instance, the definition of <span class="code">speed</span> in class <span class="code">Navigator</span> in <a href="#lst-access-qualifiers">Listing 13.12</a> is object-private. This means that any access must not only be within class <span class="code">Navigator</span>, it must also be made from the very same instance of <span class="code">Navigator</span>. Thus the accesses "<span class="code">speed</span>" and "<span class="code">this.speed</span>" would be legal from within <span class="code">Navigator</span>.</p>
      <p>The following access, though, would not be allowed, even if it appeared inside class <span class="code">Navigator</span>:</p> <pre>  <code class="vem">val</code>&nbsp;other&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Navigator</code>
  other.speed&nbsp;<code class="comment">//&nbsp;this&nbsp;line&nbsp;would&nbsp;not&nbsp;compile</code>
</pre>
      <p>Marking a member <span class="code">private[this]</span> is a guarantee that it will not be seen from other objects of the same class. This can be useful for documentation. It also sometimes lets you write more general variance annotations (see <a href="#variance-object-local">Section 19.7</a> for details).</p>
      <p>To summarize, <a href="#tab-leg-of-journey-private">Table 13.1</a> <a href="#tab-leg-of-journey-private">here</a> lists the effects of <span class="code">private</span> qualifiers. Each line shows a qualified private modifier and what it would mean if such a modifier were attached to the <span class="code">distance</span> variable declared in class <span class="code">LegOfJourney</span> in <a href="#lst-access-qualifiers">Listing 13.12</a>.</p>
      <h4>Visibility and companion objects</h4>
      <p><a id="i-565810484-1"></a></p>
      <p>In Java, static members and instance members belong to the same class, so access modifiers apply uniformly to them. You have already seen that in Scala there are no static members; instead you can have a companion object that contains members that exist only once. For instance, in <a href="#lst-companion-private">Listing 13.13</a> object <span class="code">Rocket</span> is a companion of class <span class="code">Rocket</span>. <a id="lst-companion-private"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rocket</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;Rocket.fuel
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;canGoHomeAgain&nbsp;=&nbsp;fuel&nbsp;&gt;&nbsp;<code class="literal">20</code>
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Rocket</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;fuel&nbsp;=&nbsp;<code class="literal">10</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;chooseStrategy(rocket:&nbsp;<code class="typename">Rocket</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(rocket.canGoHomeAgain)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goHome()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pickAStar()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;goHome()&nbsp;=&nbsp;{}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;pickAStar()&nbsp;=&nbsp;{}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.13 - Accessing private members of companion classes and objects.</h5>
      <p>Scala's access rules privilege companion objects and classes when it comes to private or protected accesses. A class shares all its access rights with its companion object and <i>vice versa</i>. In particular, an object can access all private members of its companion class, just as a class can access all private members of its companion object.</p>
      <p>For instance, the <span class="code">Rocket</span> class in <a href="#lst-companion-private">Listing 13.13</a> can access method <span class="code">fuel</span>, which is declared <span class="code">private</span> in object <span class="code">Rocket</span>. Analogously, the <span class="code">Rocket</span> object can access the private method <span class="code">canGoHomeAgain</span> in class <span class="code">Rocket</span>.</p>
      <p>One exception where the similarity between Scala and Java breaks down concerns <span class="code">protected</span> <span class="code">static</span> members. A protected static member of a Java class <span class="code">C</span> can be accessed in all subclasses of <span class="code">C</span>. By contrast, a <span class="code">protected</span> member in a companion object makes no sense, as singleton objects don't have any subclasses.</p>
      <h3 id="sec-package-objects">13.6 Package objects</h3>
      <p>So far, the only code you have seen added to packages are classes, traits, and standalone objects. These are by far the most common definitions that are placed at the top level of a package. But Scala doesn't limit you to just those—Any kind of definition that you can put inside a class can also be at the top level of a package. If you have some helper method you'd like to be in scope for an entire package, go ahead and put it right at the top level of the package.</p>
      <p>To do so, put the definitions in a <em>package object</em><a id="i-853360368-1"></a>. Each package is allowed to have one package object. Any definitions placed in a package object are considered members of the package itself.</p>
      <p>An example is shown in <a href="#lst-package-object">Listing 13.14</a>. File <span class="texttt">package.scala</span> holds a package object for package <span class="code">bobsdelights</span>. Syntactically, a package object looks much like one of the curly-braces packagings shown earlier in the chapter. The only difference is that it includes the <span class="code">object</span> keyword. It's a package <em>object</em>, not a <em>package</em>. The contents of the curly braces can include any definitions you like. In this case, the package object includes the <span class="code">showFruit</span> utility method from <a href="#lst-importing-object-members">Listing 13.8</a>.</p>
      <p>Given that definition, any other code in any package can import the method just like it would import a class. For example, <a href="#lst-package-object">Listing 13.14</a> also shows the standalone object <span class="code">PrintMenu</span>, which is located in a different package. <span class="code">PrintMenu</span> can import the utility method <span class="code">showFruit</span> in the same way it would import the class <span class="code">Fruit</span>.</p>
      <p><a id="lst-package-object"></a></p> <pre>  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;bobsdelights/package.scala</code>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;<code class="vem">object</code>&nbsp;bobsdelights&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;showFruit(fruit:&nbsp;<code class="typename">Fruit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;fruit._
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+&nbsp;<code class="quotedstring">"s&nbsp;are&nbsp;"</code>&nbsp;+&nbsp;color)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;In&nbsp;file&nbsp;PrintMenu.scala</code>
  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;printmenu
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;bobsdelights.Fruits
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;bobsdelights.showFruit
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">PrintMenu</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(fruit&nbsp;&lt;-&nbsp;Fruits.menu)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showFruit(fruit)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 13.14 - A package object.</h5>
      <p>Looking ahead, there are other uses of package objects for kinds of definitions you haven't seen yet. Package objects are frequently used to hold package-wide type aliases (<a href="#chap-abstract-members">Chapter 20</a>) and implicit conversions (<a href="#chap-implicit-conversions-and-parameters">Chapter 21</a>). The top-level <span class="code">scala</span> package has a package object, and its definitions are available to all Scala code.</p>
      <p>Package objects are compiled to class files named <span class="code">package.class</span> that are located in the directory of the package that they augment. It's useful to keep the same convention for source files. So you would typically put the source file of the package object <span class="code">bobsdelights</span> of <a href="#lst-package-object">Listing 13.14</a> into a file named <span class="code">package.scala</span> that resides in the <span class="code">bobsdelights</span> directory.</p>
      <h3>13.7 Conclusion</h3>
      <p>In this chapter, you saw the basic constructs for dividing a program into packages. This gives you a simple and useful kind of modularity, so that you can work with very large bodies of code without different parts of the code trampling on each other. Scala's system is the same in spirit as Java's packages, but there are some differences where Scala chooses to be more consistent or more general.</p>
      <p>Looking ahead, <a href="#chap-modular-programming-using-objects">Chapter 29</a> describes a more flexible module system than division into packages. In addition to letting you separate code into several namespaces, that approach allows modules to be parameterized and inherit from each other. In the next chapter, we'll turn our attention to assertions and unit testing.</p>
      <hr>
      <h4>Footnotes for Chapter 13:</h4>
      <p><a id="footnotemain13-1"></a>[1] This style of multiple package clauses without braces is called <em>chained package clauses</em><a id="i2070019594-1"></a><a id="i-1154528502-2"></a>.</p>
      <p><a id="footnotemain13-2"></a>[2] Scala also originally had an implementation on <span class="code">.NET</span>.<a id="i77181-3"></a>, where namespace <span class="code">System</span>, the <span class="code">.NET</span> analogue of package <span class="code">java.lang</span>, was imported instead.</p>
      <p><a id="footnotemain13-3"></a>[3] Using <span class="textit">qualifiers</span>, described in "Scope of protection" <a href="#subsec-scope-of-protection">here</a>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-assertions-and-tests">Chapter 14</a></h2>
      <h1>Assertions and Tests</h1>
      <p>Assertions and tests are two important ways you can check that the software you write behaves as you expect. In this chapter, we'll show you several options you have in Scala to write and run them.<a id="i2091567537-1"></a></p>
      <h3 id="sec-assert">14.1 Assertions</h3>
      <p>Assertions in Scala are written as calls of a predefined method <span class="code">assert</span>.<a id="i1445339835-2"></a><a id="i-176392533-2"></a><a href="#footnotemain14-1">[1]</a> The expression <span class="code">assert(condition)</span> throws an <span class="code">AssertionError</span> if <span class="code">condition</span> does not hold.<a id="i-1578657506-1"></a> There's also a two-argument version of <span class="code">assert</span>: The expression <span class="code">assert(condition,</span>&nbsp;<span class="code">explanation)</span> tests <span class="code">condition</span> and, if it does not hold, throws an <span class="code">AssertionError</span> that contains the given explanation. The type of explanation is <span class="code">Any</span>, so you can pass any object as the explanation. The <span class="code">assert</span> method will call <span class="code">toString</span> on it to get a string explanation to place inside the <span class="code">AssertionError</span>. For example, in the method named "<span class="code">above</span>" of class <span class="code">Element</span>, shown in <a href="#lst-widen-heighten-methods">Listing 10.13</a> <a href="#lst-widen-heighten-methods">here</a>, you might place an assert after the calls to <span class="code">widen</span> to make sure that the widened elements have equal widths. This is shown in <a href="#lst-using-an-assert">Listing 14.1</a>.</p>
      <p><a id="lst-using-an-assert"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;above(that:&nbsp;<code class="typename">Element</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;this1&nbsp;=&nbsp;<code class="vem">this</code>&nbsp;widen&nbsp;that.width&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;that1&nbsp;=&nbsp;that&nbsp;widen&nbsp;<code class="vem">this</code>.width&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;assert(this1.width&nbsp;==&nbsp;that1.width)
  &nbsp;&nbsp;&nbsp;&nbsp;elem(this1.contents&nbsp;++&nbsp;that1.contents)&nbsp;
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 14.1 - Using an assertion.</h5>
      <p>Another way you might choose to do this is to check the widths at the end of the <span class="code">widen</span> method, right before you return the value. You can accomplish this by storing the result in a <span class="code">val</span>, performing an assertion on the result, then mentioning the <span class="code">val</span> last so the result is returned if the assertion succeeds. However, you can do this more concisely with a convenience method in <span class="code">Predef</span> named <span class="code">ensuring</span>, as shown in <a href="#lst-using-ensuring">Listing 14.2</a>.<a id="i1797680614-1"></a><a id="i538992544-1"></a></p>
      <p>The <span class="code">ensuring</span> method can be used with any result type because of an implicit conversion.<a id="i456777265-2"></a> Although it looks in this code as if we're invoking <span class="code">ensuring</span> on <span class="code">widen</span>'s result, which is type <span class="code">Element</span>, we're actually invoking <span class="code">ensuring</span> on a type to which <span class="code">Element</span> is implicitly converted. The <span class="code">ensuring</span> method takes one argument, a predicate function that takes a result type and returns <span class="code">Boolean</span>, and passes the result to the predicate. If the predicate returns true, <span class="code">ensuring</span> will return the result; otherwise, <span class="code">ensuring</span> will throw an <span class="code">AssertionError</span>.</p>
      <p>In this example, the predicate is "<span class="code">w</span>&nbsp;<span class="code">&lt;=</span>&nbsp;<span class="code">_.width</span>". The underscore is a placeholder for the one argument passed to the predicate, the <span class="code">Element</span> result of the <span class="code">widen</span> method. If the width passed as <span class="code">w</span> to <span class="code">widen</span> is less than or equal to the <span class="code">width</span> of the result <span class="code">Element</span>, the predicate will result in true, and <span class="code">ensuring</span> will result in the <span class="code">Element</span> on which it was invoked. Because this is the last expression of the <span class="code">widen</span> method, <span class="code">widen</span> itself will then result in the <span class="code">Element</span>.</p>
      <p><a id="lst-using-ensuring"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;widen(w:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(w&nbsp;&lt;=&nbsp;width)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;left&nbsp;=&nbsp;elem(<code class="quotedstring">'&nbsp;'</code>,&nbsp;(w&nbsp;-&nbsp;width)&nbsp;/&nbsp;<code class="literal">2</code>,&nbsp;height)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;right&nbsp;=&nbsp;elem(<code class="quotedstring">'&nbsp;'</code>,&nbsp;w&nbsp;-&nbsp;width&nbsp;-&nbsp;left.width,&nbsp;height)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;beside&nbsp;<code class="vem">this</code>&nbsp;beside&nbsp;right&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;ensuring&nbsp;(w&nbsp;&lt;=&nbsp;_.width)
</pre>
      <h5>Listing 14.2 - Using <span class="code">ensuring</span> to assert a function's result.</h5>
      <p>Assertions can be enabled and disabled using the JVM's <span class="code">-ea</span> and <span class="code">-da</span> command-line flags. When enabled, each assertion serves as a little test that uses the actual data encountered as the software runs. In the remainder of this chapter, we'll focus on the writing of external tests, which provide their own test data and run independently from the application.</p>
      <h3>14.2 Testing in Scala</h3>
      <p>You have many options for testing in Scala, from established Java tools,<a id="i-1422446064-2"></a><a id="i2091567537-2"></a><a id="i-2030836876-3"></a> such as JUnit and TestNG, to tools written in Scala, such as ScalaTest, specs2, and ScalaCheck.<a id="i-517954686-1"></a><a id="i122343128-2"></a><a id="i-896072934-1"></a> For the remainder of this chapter, we'll give you a quick tour of these tools. We'll start with ScalaTest.</p>
      <p>ScalaTest is the most flexible Scala test framework: it can be easily customized to solve different problems. ScalaTest's flexibility means teams can use whatever testing style fits their needs best. For example, for teams familar with JUnit, the <span class="code">AnyFunSuite</span> style will feel comfortable and familiar. <a href="#lst-test-function">Listing 14.3</a> shows an example.</p>
      <p><a id="lst-test-function"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest.funsuite.AnyFunSuite
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;Element.elem
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ElementSuite</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyFunSuite</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;test(<code class="quotedstring">"elem&nbsp;result&nbsp;should&nbsp;have&nbsp;passed&nbsp;width"</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;ele&nbsp;=&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(ele.width&nbsp;==&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 14.3 - Writing tests with <span class="code">AnyFunSuite</span>.</h5>
      <p>The central concept in ScalaTest is the <span class="textit">suite</span>, a collection of tests. A <span class="textit">test</span> can be anything with a name that can start and either succeed, fail, be pending, or canceled. Trait <span class="code">Suite</span> is the central unit of composition in ScalaTest. <span class="code">Suite</span> declares "lifecycle" methods defining a default way to run tests, which can be overridden to customize how tests are written and run.</p>
      <p>ScalaTest offers <span class="textit">style traits</span> that extend <span class="code">Suite</span> and override lifecycle methods to support different testing styles. It also provides <span class="textit">mixin traits</span> that override lifecycle methods to address particular testing needs. You define test classes by composing <span class="code">Suite</span> style and mixin traits, and define test suites by composing <span class="code">Suite</span> instances.</p>
      <p><span class="code">AnyFunSuite</span>, which is extended by the test class shown in <a href="#lst-test-function">Listing 14.3</a>, is an example of a testing style. The "<span class="code">Fun</span>" in <span class="code">AnyFunSuite</span> stands for function; "<span class="code">test</span>" is a method defined in <span class="code">AnyFunSuite</span>, which is invoked by the primary constructor of <span class="code">ElementSuite</span>. You specify the name of the test as a string between the parentheses and the test code itself between curly braces. The test code is a function passed as a by-name parameter to <span class="code">test</span>, which registers it for later execution.</p>
      <p>ScalaTest is integrated into common build tools (such as sbt and Maven) and IDEs (such as IntelliJ IDEA and Eclipse). You can also run a <span class="code">Suite</span> directly via ScalaTest's <span class="code">Runner</span> application or from the Scala interpreter simply by invoking <span class="code">execute</span> on it. Here's an example:</p> <pre>  scala&gt;&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">ElementSuite</code>).execute()
  <code class="output">ElementSuite:</code>
  <code class="output">-&nbsp;elem&nbsp;result&nbsp;should&nbsp;have&nbsp;passed&nbsp;width</code>
</pre>
      <p>All ScalaTest styles, including <span class="code">AnyFunSuite</span>, are designed to encourage the writing of focused tests with descriptive names. In addition, all styles generate specification-like output that can facilitate communication among stakeholders. The style you choose dictates only how the declarations of your tests will look. Everything else in ScalaTest works consistently the same way no matter what style you choose.<a href="#footnotemain14-2">[2]</a></p>
      <h3>14.3 Informative failure reports</h3>
      <p>The test in <a href="#lst-test-function">Listing 14.3</a> attempts to create an element of width 2 and assert that the width of the resulting element is indeed 2. Were this assertion to fail, the failure report would include the filename and line number of the offending assertion, and an informative error message:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;width&nbsp;=&nbsp;<code class="literal">3</code>
  <code class="output">width:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br>  scala&gt;&nbsp;assert(width&nbsp;==&nbsp;<code class="literal">2</code>)
  <code class="output">org.scalatest.exceptions.TestFailedException:</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;did&nbsp;not&nbsp;equal&nbsp;2</code>
</pre>
      <p>To provide descriptive error messages when assertions fail, ScalaTest analyzes the expressions passed to each <span class="code">assert</span> invocation at compile time. If you prefer to see even more detailed information about assertion failures, you can use ScalaTest's <span class="code">Diagrams</span>, assertions whose error messages display a diagram of the expression passed to <span class="code">assert</span>:</p> <pre>  scala&gt;&nbsp;assert(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>).contains(<code class="literal">4</code>))
  <code class="output">org.scalatest.exceptions.TestFailedException:</code>
  <br>  &nbsp;&nbsp;assert(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>).contains(<code class="literal">4</code>))
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;4</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
</pre>
      <p>ScalaTest's <span class="code">assert</span> methods do not differentiate between the actual and expected result in error messages. They just indicate that the left operand did not equal the right operand, or show the values in a diagram. If you wish to emphasize the distinction between actual and expected, you can alternatively use ScalaTest's <span class="code">assertResult</span> method, like this:</p> <pre>  assertResult(<code class="literal">2</code>)&nbsp;{
  &nbsp;&nbsp;ele.width
  }
</pre>
      <p>With this expression you indicate that you expect the code between the curly braces to result in 2. Were the code between the braces to result in 3, you'd see the message, "<span class="code">Expected</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">but</span>&nbsp;<span class="code">got</span>&nbsp;<span class="code">3</span>" in the test failure report.</p>
      <p>If you want to check that a method throws an expected exception, you can use ScalaTest's <span class="code">assertThrows</span> method, like this:</p> <pre>  assertThrows[<code class="typename">IllegalArgumentException</code>]&nbsp;{
  &nbsp;&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;-<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  }
</pre>
      <p>If the code between the curly braces throws a different exception than expected, or throws no exception, <span class="code">assertThrows</span> will complete abruptly with a <span class="code">TestFailedException</span>. You'll get a helpful error message in the failure report, such as:</p> <pre>  Expected&nbsp;IllegalArgumentException&nbsp;to&nbsp;be&nbsp;thrown,
  &nbsp;&nbsp;but&nbsp;NegativeArraySizeException&nbsp;was&nbsp;thrown.
</pre>
      <p>On the other hand, if the code completes abruptly with an instance of the passed exception class, <span class="code">assertThrows</span> will return normally. If you wish to inspect the expected exception further, you can use <span class="code">intercept</span> instead of <span class="code">assertThrows</span>. The <span class="code">intercept</span> method works the same as <span class="code">assertThrows</span>, except if the expected exception is thrown, <span class="code">intercept</span> returns it:</p> <pre>  <code class="vem">val</code>&nbsp;caught&nbsp;=
  &nbsp;&nbsp;intercept[<code class="typename">ArithmeticException</code>]&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">1</code>&nbsp;/&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;}
  <br>  assert(caught.getMessage&nbsp;==&nbsp;<code class="quotedstring">"/&nbsp;by&nbsp;zero"</code>)
</pre>
      <p>In short, ScalaTest's assertions work hard to provide useful failure messages that will help you diagnose and fix problems in your code.</p>
      <h3>14.4 Tests as specifications</h3>
      <p>In the <em>behavior-driven development</em> (BDD) testing style, the emphasis is on writing human-readable specifications of the expected behavior of code and accompanying tests that verify the code has the specified behavior.<a id="i2079947888-1"></a> ScalaTest includes several traits that facilitate this style of testing. An example using one such trait, <span class="code">AnyFlatSpec</span>, is shown in <a href="#lst-scalatest-spec-example">Listing 14.4</a>.</p>
      <p><a id="lst-scalatest-spec-example"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest.flatspec.AnyFlatSpec
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest.matchers.should.Matchers
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;Element.elem
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ElementSpec</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyFlatSpec</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Matchers</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"A&nbsp;UniformElement"</code>&nbsp;should
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"have&nbsp;a&nbsp;width&nbsp;equal&nbsp;to&nbsp;the&nbsp;passed&nbsp;value"</code>&nbsp;in&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;ele&nbsp;=&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ele.width&nbsp;should&nbsp;be&nbsp;(<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;should&nbsp;<code class="quotedstring">"have&nbsp;a&nbsp;height&nbsp;equal&nbsp;to&nbsp;the&nbsp;passed&nbsp;value"</code>&nbsp;in&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;ele&nbsp;=&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ele.height&nbsp;should&nbsp;be&nbsp;(<code class="literal">3</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;should&nbsp;<code class="quotedstring">"throw&nbsp;an&nbsp;IAE&nbsp;if&nbsp;passed&nbsp;a&nbsp;negative&nbsp;width"</code>&nbsp;in&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;an&nbsp;[<code class="typename">IllegalArgumentException</code>]&nbsp;should&nbsp;be&nbsp;thrownBy&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;-<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 14.4 - Specifying and testing behavior with an <span class="code">AnyFlatSpec</span>.</h5>
      <p>In a <span class="code">AnyFlatSpec</span>, you write tests as <em>specifier clauses</em>. You start by writing a name for the <em>subject</em> under test as a string (<span class="code">"A</span>&nbsp;<span class="code">UniformElement"</span> in <a href="#lst-scalatest-spec-example">Listing 14.4</a>), then <span class="code">should</span> (or <span class="code">must</span> or <span class="code">can</span>), then a string that specifies a bit of behavior required of the subject, then <span class="code">in</span>. In the curly braces following <span class="code">in</span>, you write code that tests the specified behavior. In subsequent clauses you can write <span class="code">it</span> to refer to the most recently given subject. When a <span class="code">AnyFlatSpec</span> is executed, it will run each specifier clause as a ScalaTest test. <span class="code">AnyFlatSpec</span> (and ScalaTest's other specification traits) generate output that reads like a specification when run. For example, here's what the output will look like if you run <span class="code">ElementSpec</span> from <a href="#lst-scalatest-spec-example">Listing 14.4</a> in the interpreter:</p> <pre>  scala&gt;&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">ElementSpec</code>).execute()
  <code class="output">A&nbsp;UniformElement</code>
  <code class="output">-&nbsp;should&nbsp;have&nbsp;a&nbsp;width&nbsp;equal&nbsp;to&nbsp;the&nbsp;passed&nbsp;value</code>
  <code class="output">-&nbsp;should&nbsp;have&nbsp;a&nbsp;height&nbsp;equal&nbsp;to&nbsp;the&nbsp;passed&nbsp;value</code>
  <code class="output">-&nbsp;should&nbsp;throw&nbsp;an&nbsp;IAE&nbsp;if&nbsp;passed&nbsp;a&nbsp;negative&nbsp;width</code>
</pre>
      <p><a href="#lst-scalatest-spec-example">Listing 14.4</a> also illustrates ScalaTest's <em>matchers</em> domain-specific language (DSL).<a id="i-1267542082-1"></a> By mixing in trait <span class="code">Matchers</span>, you can write assertions that read more like natural language. ScalaTest provides many matchers in its DSL, and also enables you to define new matchers with custom failure messages. The matchers shown in <a href="#lst-scalatest-spec-example">Listing 14.4</a> include the "<span class="code">should</span>&nbsp;<span class="code">be</span>" and "<span class="code">an</span>&nbsp;<span class="code">[</span> ...<span class="code">]</span>&nbsp;<span class="code">should</span>&nbsp;<span class="code">be</span>&nbsp;<span class="code">thrownBy</span>&nbsp;<span class="code">{</span> ...<span class="code">}</span>&nbsp;<span class="code"></span>" syntax. You can alternatively mix in <span class="code">MustMatchers</span> if you prefer <span class="code">must</span> to <span class="code">should</span>. For example, mixing in <span class="code">MustMatchers</span> would allow you to write expressions such as:</p> <pre>  result&nbsp;must&nbsp;be&nbsp;&gt;=&nbsp;<code class="literal">0</code>
  map&nbsp;must&nbsp;contain&nbsp;key&nbsp;<code class="quotedstring">'c'</code>
</pre>
      <p>If the last assertion failed, you'd see an error message similar to:</p> <pre>  <code class="typename">Map</code>(<code class="quotedstring">'a'</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">'b'</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)&nbsp;did&nbsp;not&nbsp;contain&nbsp;key&nbsp;<code class="quotedstring">'c'</code>
</pre>
      <p>The specs2 testing framework, an open source tool written in Scala by Eric Torreborre<a id="i774197993-1"></a>, also supports the BDD style of testing but with a different syntax.<a id="i-896072934-2"></a> For example, you could use specs2 to write the test shown in <a href="#lst-specs2-example">Listing 14.5</a>:</p>
      <p><a id="lst-specs2-example"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.specs2._
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;Element.elem
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">ElementSpecification</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Specification</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"A&nbsp;UniformElement"</code>&nbsp;should&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"have&nbsp;a&nbsp;width&nbsp;equal&nbsp;to&nbsp;the&nbsp;passed&nbsp;value"</code>&nbsp;in&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;ele&nbsp;=&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ele.width&nbsp;must&nbsp;be_==(<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"have&nbsp;a&nbsp;height&nbsp;equal&nbsp;to&nbsp;the&nbsp;passed&nbsp;value"</code>&nbsp;in&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;ele&nbsp;=&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ele.height&nbsp;must&nbsp;be_==(<code class="literal">3</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"throw&nbsp;an&nbsp;IAE&nbsp;if&nbsp;passed&nbsp;a&nbsp;negative&nbsp;width"</code>&nbsp;in&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;-<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;must
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throwA[<code class="typename">IllegalArgumentException</code>]
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 14.5 - Specifying and testing behavior with the specs2 framework.</h5>
      <p>Like ScalaTest, specs2 provides a matchers DSL. You can see some examples of specs2 matchers in action in <a href="#lst-specs2-example">Listing 14.5</a> in the lines that contain "<span class="code">must</span>&nbsp;<span class="code">be_==</span>" and "<span class="code">must</span>&nbsp;<span class="code">throwA</span>".<a href="#footnotemain14-3">[3]</a> You can use specs2 standalone, but it is also integrated with ScalaTest and JUnit, so you can run specs2 tests with those tools as well.</p>
      <p>One of the big ideas of BDD is that tests can be used to facilitate communication between the people who decide what a software system should do, the people who implement the software, and the people who determine whether the software is finished and working. Although any of ScalaTest's or specs2's styles can be used in this manner, ScalaTest's <span class="code">AnyFeatureSpec</span> in particular is designed for it. <a href="#lst-scalatest-featurespec-example">Listing 14.6</a> shows an example:</p>
      <p><a id="lst-scalatest-featurespec-example"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest._
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest.featurespec.AnyFeatureSpec
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">TVSetSpec</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyFeatureSpec</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">GivenWhenThen</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Feature</code>(<code class="quotedstring">"TV&nbsp;power&nbsp;button"</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Scenario</code>(<code class="quotedstring">"User&nbsp;presses&nbsp;power&nbsp;button&nbsp;when&nbsp;TV&nbsp;is&nbsp;off"</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Given</code>(<code class="quotedstring">"a&nbsp;TV&nbsp;set&nbsp;that&nbsp;is&nbsp;switched&nbsp;off"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">When</code>(<code class="quotedstring">"the&nbsp;power&nbsp;button&nbsp;is&nbsp;pressed"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Then</code>(<code class="quotedstring">"the&nbsp;TV&nbsp;should&nbsp;switch&nbsp;on"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pending
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 14.6 - Using tests to facilitate communication among stakeholders.</h5>
      <p><span class="code">AnyFeatureSpec</span> is designed to guide conversations about software requirements: You must identify specific <span class="textit">features</span>, then specify those features in terms of <span class="textit">scenarios</span>. The <span class="code">Given</span>, <span class="code">When</span>, and <span class="code">Then</span> methods (provided by trait <span class="code">GivenWhenThen</span>) can help focus the conversation on the specifics of individual scenarios. The <span class="code">pending</span> call at the end indicates that neither the test nor the actual behavior has been implemented—just the specification. Once all the tests and specified behavior have been implemented, the tests will pass and the requirements can be deemed to have been met.</p>
      <h3>14.5 Property-based testing</h3>
      <p>Another useful testing tool for Scala is ScalaCheck, an open source framework written by Rickard Nilsson. ScalaCheck enables you to specify properties that the code under test must obey.<a id="i568084816-1"></a><a id="i-517954686-2"></a> For each property, ScalaCheck will generate data and execute assertions that check whether the property holds. <a href="#lst-property-based-tests">Listing 14.7</a> shows an example of using ScalaCheck from a ScalaTest <span class="code">AnyWordSpec</span> that mixes in trait <span class="code">ScalaCheckPropertyChecks</span>.</p>
      <p><a id="lst-property-based-tests"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest.wordspec.AnyWordSpec
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.scalatestplus.scalacheck.ScalaCheckPropertyChecks
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest.matchers.must.Matchers._
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;Element.elem
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ElementSpec</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AnyWordSpec</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">ScalaCheckPropertyChecks</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"elem&nbsp;result"</code>&nbsp;must&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"have&nbsp;passed&nbsp;width"</code>&nbsp;in&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forAll&nbsp;{&nbsp;(w:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whenever&nbsp;(w&nbsp;&gt;&nbsp;<code class="literal">0</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;w&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">100</code>,&nbsp;<code class="literal">3</code>).width&nbsp;must&nbsp;equal&nbsp;(w&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">100</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 14.7 - Writing property-based tests with ScalaCheck.</h5>
      <p><span class="code">AnyWordSpec</span> is a ScalaTest style class. The <span class="code">PropertyChecks</span> trait provides several <span class="code">forAll</span> methods that allow you to mix property-based tests with traditional assertion-based or matcher-based tests. In this example, we check a property that the <span class="code">elem</span> factory should obey. ScalaCheck properties are expressed as function values that take as parameters the data needed by the property's assertions. This data will be generated by ScalaCheck. In the property shown in <a href="#lst-property-based-tests">Listing 14.7</a>, the data is an integer named <span class="code">w</span> that represents a width. Inside the body of the function, you see this code:</p> <pre>  whenever&nbsp;(w&nbsp;&gt;&nbsp;<code class="literal">0</code>)&nbsp;{
  &nbsp;&nbsp;elem(<code class="quotedstring">'x'</code>,&nbsp;w&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">100</code>,&nbsp;<code class="literal">3</code>).width&nbsp;must&nbsp;equal&nbsp;(w&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">100</code>)
  }
</pre>
      <p>The <span class="code">whenever</span> clause indicates that whenever the left hand expression is true, the expression on the right must hold true. Thus in this case, the expression in the block must hold true whenever <span class="code">w</span> is greater than 0. The right-hand expression in this case will yield true if the width passed to the <span class="code">elem</span> factory is the same as the width of the <span class="code">Element</span> returned by the factory.</p>
      <p>With this small amount of code, ScalaCheck will generate several values for <span class="code">w</span> and test each one, looking for a value for which the property doesn't hold. If the property holds true for every value ScalaCheck tries, the test will pass. Otherwise, the test will throw a <span class="code">TestFailedException</span> that contains information including the value that caused the failure.</p>
      <h3>14.6 Organizing and running tests</h3>
      <p>Each framework mentioned in this chapter provides some mechanism for organizing and running tests. In this section, we'll give a quick overview of ScalaTest's approach. To get the full story on any of these frameworks, however, you'll need to consult their documentation.</p>
      <p>In ScalaTest, you organize large test suites by nesting <span class="code">Suite</span>s inside <span class="code">Suite</span>s.<a id="i-318258231-1"></a> When a <span class="code">Suite</span> is executed, it will execute its nested <span class="code">Suite</span>s as well as its tests. The nested <span class="code">Suite</span>s will in turn execute their nested <span class="code">Suite</span>s, and so on. A large test suite, therefore, is represented as a tree of <span class="code">Suite</span> objects. When you execute the root <span class="code">Suite</span> in the tree, all <span class="code">Suite</span>s in the tree will be executed.</p>
      <p>You can nest suites manually or automatically. To nest manually, you either override the <span class="code">nestedSuites</span> method on your <span class="code">Suite</span>s or pass the <span class="code">Suite</span>s you want to nest to the constructor of class <span class="code">Suites</span>, which ScalaTest provides for this purpose. To nest automatically, you provide package names to ScalaTest's <span class="code">Runner</span>, which will discover <span class="code">Suite</span>s automatically, nest them under a root <span class="code">Suite</span>, and execute the root <span class="code">Suite</span>.</p>
      <p>You can invoke ScalaTest's <span class="code">Runner</span> application from the command line or via a build tool, such as sbt, maven, or ant. The simplest way to invoke <span class="code">Runner</span> on the command line is via the <span class="code">org.scalatest.run</span> application. This application expects a fully qualified test class name. For example, to run the test class shown in <a href="#lst-scalatest-featurespec-example">Listing 14.6</a>, you must compile it with:</p> <pre>  $&nbsp;scalac&nbsp;-cp&nbsp;scalatest-app.jar:scala-xml.jar&nbsp;TVSetSpec.scala
</pre>
      <p>Then you can run it with:</p> <pre>  $&nbsp;scala&nbsp;-cp&nbsp;scalatest-app.jar:scala-xml.jar&nbsp;org.scalatest.run&nbsp;TVSetSpec
</pre>
      <div class="figure">
        <a id="fig-scalatest-gui"></a>
        <p><img src="scalaTestOutput53.png" alt="images/scalaTestOutput53.png"></p>
      </div>
      <h5> Figure 14.1 - The output of <span class="code">org.scalatest.run</span>.</h5>
      <p>With <span class="code">-cp</span> you place the <span class="code">scalatest-app</span> and <span class="code">scala-xml</span> JAR files on the class path. (When downloaded, the JAR file names will include embedded version numbers.) The next token, <span class="code">org.scalatest.run</span>, is the fully qualified application name. Scala will run this application and pass the remaining tokens as command line arguments. The <span class="code">TVSetSpec</span> argument specifies the suite to execute. The result is shown in <a href="#fig-scalatest-gui">Figure 14.1</a>.</p>
      <h3>14.7 Conclusion</h3>
      <p>In this chapter you saw examples of mixing assertions directly in production code, as well as writing them externally in tests. You saw that as a Scala programmer, you can take advantage of popular testing tools from the Java community, such as JUnit and TestNG, as well as newer tools designed explicitly for Scala, such as ScalaTest, ScalaCheck, and specs2. Both in-code assertions and external tests can help you achieve your software quality goals. We felt that these techniques are important enough to justify the short detour from the Scala tutorial that this chapter represented. In the next chapter, however, we'll return to the language tutorial and cover a very useful aspect of Scala: pattern matching.</p>
      <hr>
      <h4>Footnotes for Chapter 14:</h4>
      <p><a id="footnotemain14-1"></a>[1] The <span class="code">assert</span> method is defined in the <span class="code">Predef</span> singleton object, whose members are automatically imported into every Scala source file.</p>
      <p><a id="footnotemain14-2"></a>[2] More detail on ScalaTest is available from <span class="code">http://www.scalatest.org/</span>.</p>
      <p><a id="footnotemain14-3"></a>[3] You can download specs2 from <span class="code">http://specs2.org/</span>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-case-classes-and-pattern-matching">Chapter 15</a></h2>
      <h1>Case Classes and Pattern Matching</h1>
      <p>This chapter introduces <em>case classes</em> and <em>pattern matching</em>, twin constructs that support you when writing regular, non-encapsulated data structures. These two constructs are particularly helpful for tree-like recursive data.</p>
      <p>If you have programmed in a functional language before, then you will probably recognize pattern matching. But case classes will be new to you. Case classes are Scala's way to allow pattern matching on objects without requiring a large amount of boilerplate. Generally, all you need to do is add a single <span class="code">case</span> keyword to each class that you want to be pattern matchable.</p>
      <p>This chapter starts with a simple example of case classes and pattern matching. It then goes through all of the kinds of patterns that are supported, talks about the role of <em>sealed</em> classes, discusses the <span class="code">Option</span> type, and shows some non-obvious places in the language where pattern matching is used. Finally, a larger, more realistic example of pattern matching is shown.</p>
      <h3>15.1 A simple example</h3>
      <p>Before delving into all the rules and nuances of pattern matching, it is worth looking at a simple example to get the general idea. Let's say you need to write a library that manipulates arithmetic expressions, perhaps as part of a domain-specific language you are designing.</p>
      <p>A first step to tackling this problem is the definition of the input data. To keep things simple, we'll concentrate on arithmetic expressions consisting of variables, numbers, and unary and binary operations. This is expressed by the hierarchy of Scala classes shown in <a href="#lst-case-classes">Listing 15.1</a>.</p>
      <p><a id="lst-case-classes"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Var</code>(name:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Number</code>(num:&nbsp;<code class="typename">Double</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">UnOp</code>(operator:&nbsp;<code class="typename">String</code>,&nbsp;arg:&nbsp;<code class="typename">Expr</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">BinOp</code>(operator:&nbsp;<code class="typename">String</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left:&nbsp;<code class="typename">Expr</code>,&nbsp;right:&nbsp;<code class="typename">Expr</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
</pre>
      <h5>Listing 15.1 - Defining case classes.</h5>
      <p>The hierarchy includes an abstract base class <span class="code">Expr</span> with four subclasses, one for each kind of expression being considered.<a href="#footnotemain15-1">[1]</a> The bodies of all five classes are empty. As mentioned previously, in Scala you can leave out the braces around an empty class body if you wish, so <span class="code">class</span>&nbsp;<span class="code">C</span> is the same as <span class="code">class</span>&nbsp;<span class="code">C</span>&nbsp;<span class="code">{}</span>.</p>
      <h4>Case classes</h4>
      <p>The other noteworthy thing about the declarations of <a href="#lst-case-classes">Listing 15.1</a> is that each subclass has<a id="i-502971380-1"></a><a id="i1163509252-1"></a> a <span class="code">case</span> modifier. Classes with such a modifier are called <span style="font-style:italic">case classes</span>. Using the modifier makes the Scala compiler add some syntactic conveniences to your class.</p>
      <p>First, it adds a factory method with the name of the class. This means that, for instance, you can write <span class="code">Var("x")</span> to construct a <span class="code">Var</span> object, instead of the slightly longer <span class="code">new</span>&nbsp;<span class="code">Var("x")</span>:<a id="i-1645439037-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;v&nbsp;=&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>)
  <code class="output">v:&nbsp;Var&nbsp;=&nbsp;Var(x)</code>
</pre>
      <p>The factory methods are particularly nice when you nest them. Because there are no noisy <span class="code">new</span> keywords sprinkled throughout the code, you can take in the expression's structure at a glance:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;op&nbsp;=&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;<code class="typename">Number</code>(<code class="literal">1</code>),&nbsp;v)
  <code class="output">op:&nbsp;BinOp&nbsp;=&nbsp;BinOp(+,Number(1.0),Var(x))</code>
</pre>
      <p>The second syntactic convenience is that all arguments in the parameter list of a case class implicitly get a <span class="code">val</span> prefix, so they are maintained as fields:</p> <pre>  scala&gt;&nbsp;v.name
  <code class="output">res0:&nbsp;String&nbsp;=&nbsp;x</code>
  <br>  scala&gt;&nbsp;op.left
  <code class="output">res1:&nbsp;Expr&nbsp;=&nbsp;Number(1.0)</code>
</pre>
      <p>Third, the compiler adds "natural" implementations of methods <span class="code">toString</span>, <span class="code">hashCode</span>, and <span class="code">equals</span> to your class. They will<a id="i311333302-1"></a><a id="i-567433454-1"></a><a id="i811694371-1"></a> print, hash, and compare a whole tree consisting of the class and (recursively) all its arguments. Since <span class="code">==</span> in Scala always delegates to <span class="code">equals</span>, this means that elements of case classes are always compared structurally:</p> <pre>  scala&gt;&nbsp;println(op)
  <code class="output">BinOp(+,Number(1.0),Var(x))</code>
  <br>  scala&gt;&nbsp;op.right&nbsp;==&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>)
  <code class="output">res3:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>Finally, the compiler adds a <span class="code">copy</span> method to your class for making modified copies. This method is useful for making a new instance of the class that is the same as another one except that one or two attributes are different. The method works by using named and default parameters (see <a href="#sec-fancy-parameters">Section 8.8</a>). You specify the changes you'd like to make by using named parameters. For any parameter you don't specify, the value from the old object is used. As an example, here is how you can make an operation just like <span class="code">op</span> except that the operator has changed:</p> <pre>  scala&gt;&nbsp;op.copy(operator&nbsp;=&nbsp;<code class="quotedstring">"-"</code>)
  <code class="output">res4:&nbsp;BinOp&nbsp;=&nbsp;BinOp(-,Number(1.0),Var(x))</code>
</pre>
      <p>All these conventions add a lot of convenience—at a small price. You have to write the case modifier, and your classes and objects become a bit larger. They are larger because additional methods are generated and an implicit field is added for each constructor parameter. However, the biggest advantage of case classes is that they support pattern matching.</p>
      <h4>Pattern matching</h4>
      <p>Say you want to simplify arithmetic expressions of the kinds<a id="i-1124185517-1"></a><a id="i-174768992-1"></a> just presented. There is a multitude of possible simplification rules. The following three rules just serve as an illustration:</p> <pre>  <code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<i>e</i>))&nbsp;&nbsp;=&gt;&nbsp;<i>e</i>&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Double&nbsp;negation</code>
  <code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;<i>e</i>,&nbsp;<code class="typename">Number</code>(<code class="literal">0</code>))&nbsp;=&gt;&nbsp;<i>e</i>&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Adding&nbsp;zero</code>
  <code class="typename">BinOp</code>(<code class="quotedstring">"*"</code>,&nbsp;<i>e</i>,&nbsp;<code class="typename">Number</code>(<code class="literal">1</code>))&nbsp;=&gt;&nbsp;<i>e</i>&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Multiplying&nbsp;by&nbsp;one</code>
</pre>
      <p>Using pattern matching, these rules can be taken almost as they are to form the core of a simplification function in Scala, as shown in <a href="#lst-simplify-top">Listing 15.2</a>. The function, <span class="code">simplifyTop</span>, can be used like this:</p> <pre>  scala&gt;&nbsp;simplifyTop(<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>))))
  <code class="output">res4:&nbsp;Expr&nbsp;=&nbsp;Var(x)</code>
</pre>
      <p><a id="lst-simplify-top"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;simplifyTop(expr:&nbsp;<code class="typename">Expr</code>):&nbsp;<code class="typename">Expr</code>&nbsp;=&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;e))&nbsp;&nbsp;=&gt;&nbsp;e&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Double&nbsp;negation</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;e,&nbsp;<code class="typename">Number</code>(<code class="literal">0</code>))&nbsp;=&gt;&nbsp;e&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Adding&nbsp;zero</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"*"</code>,&nbsp;e,&nbsp;<code class="typename">Number</code>(<code class="literal">1</code>))&nbsp;=&gt;&nbsp;e&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Multiplying&nbsp;by&nbsp;one</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;expr
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.2 - The <span class="code">simplifyTop</span> function, which does a pattern match.</h5>
      <p>The right-hand side of <span class="code">simplifyTop</span> consists of a <span class="code">match</span> expression. <span class="code">match</span> corresponds to <span class="code">switch</span> in Java, but it's written after the selector expression. In other words, it's:<a id="i-451801752-1"></a></p> <pre>  <code style="font-style:italic">selector</code>&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;<code style="font-style:italic">alternatives</code>&nbsp;}
</pre>
      <p>instead of:</p> <pre>  switch&nbsp;(<code style="font-style:italic">selector</code>)&nbsp;{&nbsp;<code style="font-style:italic">alternatives</code>&nbsp;}
</pre>
      <p>A pattern match includes a sequence of <em>alternatives</em>,<a id="i1524854239-2"></a> each starting with the keyword <span class="code">case</span>. Each alternative includes a <em>pattern</em> and one or more expressions, which will be evaluated if the pattern matches. An arrow symbol <span class="code">=&gt;</span> separates the pattern from the expressions.</p>
      <p>A <span class="code">match</span> expression is evaluated by trying each of the patterns in the order they are written. The first pattern that matches is selected, and the part following the arrow is selected and executed.</p>
      <p>A <em>constant pattern</em> like <span class="code">"+"</span> or <span class="code">1</span> matches values that are equal<a id="i-1897505825-1"></a><a id="i-612986830-1"></a> to the constant with respect to <span class="code">==</span>. A <em>variable pattern</em> like<a id="i-1540579321-1"></a><a id="i-256060326-1"></a> <span class="code">e</span> matches every value. The variable then refers to that value in the right hand side of the case clause. In this example, note that the first three alternatives evaluate to <span class="code">e</span>, a variable that is bound within the associated pattern. The <em>wildcard pattern</em> (<span class="code">_</span>) also matches<a id="i-615307671-1"></a><a id="i669211324-1"></a> every value, but it does not introduce a variable name to refer to that value. In <a href="#lst-simplify-top">Listing 15.2</a>, notice how the <span class="code">match</span> ends with a default case that does nothing to the expression. Instead, it just results in <span class="code">expr</span>, the expression matched upon.</p>
      <p>A <em>constructor pattern</em> looks like <span class="code">UnOp("-",</span>&nbsp;<span class="code">e)</span>. This pattern<a id="i-881203127-1"></a><a id="i-1934430442-1"></a> matches all values of type <span class="code">UnOp</span> whose first argument matches <span class="code">"-"</span>. Its second argument will be bound to the name <span class="code">e</span>. Note that the arguments to the constructor are themselves patterns. This allows you to write deep patterns using a concise notation. Here's an example:</p> <pre>  <code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;e))
</pre>
      <p>Imagine trying to implement this same functionality using the visitor design pattern!<a href="#footnotemain15-2">[2]</a> Almost as awkward, imagine implementing it as a long sequence of <span class="code">if</span> statements, type tests, and type casts.</p>
      <h4><span class="code">match</span> compared to <span class="code">switch</span></h4>
      <p>Match expressions can be seen as a generalization of Java-style <span class="code">switch</span>es. A Java-style <span class="code">switch</span> can be naturally expressed as a <span class="code">match</span> expression, where each pattern is a constant and the last pattern may be a wildcard (which represents the default case of the <span class="code">switch</span>).</p>
      <p>However, there are three differences to keep in mind: First, <span class="code">match</span> is an <span style="font-style:italic">expression</span> in Scala (<i>i.e.</i>, it always results in a value). Second, Scala's alternative expressions never "fall through" into the next case. Third, if none of the patterns match, an exception named <span class="code">MatchError</span><a id="i1620352635-1"></a> is thrown. This means you always have to make sure that all cases are covered, even if it means adding a default case where there's nothing to do.</p>
      <p><a id="lst-default-case"></a></p> <pre>  &nbsp;&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(op,&nbsp;left,&nbsp;right)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(s<code class="quotedstring">"$expr&nbsp;is&nbsp;a&nbsp;binary&nbsp;operation"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.3 - A pattern match with an empty "default" case.</h5>
      <p><a href="#lst-default-case">Listing 15.3</a> shows an example. The second case is necessary because without it, the <span class="code">match</span> expression would throw a <span class="code">MatchError</span> for every <span class="code">expr</span> argument that is not a <span class="code">BinOp</span>. In this example, no code is specified for that second case, so if that case runs it does nothing. The result of either case is the unit value `<span class="code">()</span>', which is also the result of the entire <span class="code">match</span> expression.</p>
      <h3 id="sec-kinds-of-patterns">15.2 Kinds of patterns</h3>
      <p>The previous example showed several kinds of patterns in quick succession. Now take a minute to look at each pattern in detail.</p>
      <p>The syntax of patterns is easy, so do not worry about that too much. All patterns look exactly like the corresponding expression. For instance, given the hierarchy of <a href="#lst-case-classes">Listing 15.1</a>, the pattern <span class="code">Var(x)</span> matches any variable expression, binding <span class="code">x</span> to the name of the variable. Used as an expression, <span class="code">Var(x)</span>—exactly the same syntax—recreates an equivalent object, assuming <span class="code">x</span> is already bound to the variable's name. Since the syntax of patterns is so transparent, the main thing to pay attention to is just what kinds of patterns are possible.</p>
      <h4>Wildcard patterns</h4>
      <p>The wildcard pattern (<span class="code">_</span>) matches any object whatsoever. You have<a id="i669211324-2"></a><a id="i-615307671-2"></a> already seen it used as a default, catch-all alternative,<a id="i-149672069-1"></a> like this:</p> <pre>  expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(op,&nbsp;left,&nbsp;right)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;println(s<code class="quotedstring">"$expr&nbsp;is&nbsp;a&nbsp;binary&nbsp;operation"</code>)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="comment">//&nbsp;handle&nbsp;the&nbsp;default&nbsp;case</code>
  }
</pre>
      <p>Wildcards can also be used to ignore parts of an object that you do not care about. For example, the previous example does not actually care what the elements of a binary operation are; it just checks whether or not it is a binary operation. Thus, the code can just as well use the wildcard pattern for the elements of the <span class="code">BinOp</span>, as shown in <a href="#lst-wildcard-patterns">Listing 15.4</a>.</p>
      <p><a id="lst-wildcard-patterns"></a></p> <pre>  expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(_,&nbsp;_,&nbsp;_)&nbsp;=&gt;&nbsp;println(s<code class="quotedstring">"$expr&nbsp;is&nbsp;a&nbsp;binary&nbsp;operation"</code>)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"It's&nbsp;something&nbsp;else"</code>)
  }
</pre>
      <h5>Listing 15.4 - A pattern match with wildcard patterns.</h5>
      <h4>Constant patterns</h4>
      <p>A constant pattern matches only itself. Any literal may be used as a<a id="i-1897505825-2"></a><a id="i-612986830-2"></a> constant. For example, <span class="code">5</span>, <span class="code">true</span>, and <span class="code">"hello"</span> are all constant patterns. Also, any <span class="code">val</span> or singleton object can be used as a constant. For example, <span class="code">Nil</span>, a singleton object, is a pattern that matches only the empty list. <a href="#lst-constant-patterns">Listing 15.5</a> shows some examples of constant patterns:</p>
      <p><a id="lst-constant-patterns"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;describe(x:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;x&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="literal">5</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"five"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">true</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"truth"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"hello"</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"hi!"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Nil</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"the&nbsp;empty&nbsp;list"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="quotedstring">"something&nbsp;else"</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.5 - A pattern match with constant patterns.</h5>
      <p>Here is how the pattern match shown in <a href="#lst-constant-patterns">Listing 15.5</a> looks in action:</p> <pre>  scala&gt;&nbsp;describe(<code class="literal">5</code>)
  <code class="output">res6:&nbsp;String&nbsp;=&nbsp;five</code>
  <br>  scala&gt;&nbsp;describe(<code class="vem">true</code>)
  <code class="output">res7:&nbsp;String&nbsp;=&nbsp;truth</code>
  <br>  scala&gt;&nbsp;describe(<code class="quotedstring">"hello"</code>)
  <code class="output">res8:&nbsp;String&nbsp;=&nbsp;hi!</code>
  <br>  scala&gt;&nbsp;describe(<code class="typename">Nil</code>)
  <code class="output">res9:&nbsp;String&nbsp;=&nbsp;the&nbsp;empty&nbsp;list</code>
  <br>  scala&gt;&nbsp;describe(<code class="typename">List</code>(<code class="literal">1</code>,<code class="literal">2</code>,<code class="literal">3</code>))
  <code class="output">res10:&nbsp;String&nbsp;=&nbsp;something&nbsp;else</code>
</pre>
      <h4>Variable patterns</h4>
      <p><a id="subsec-kinds-of-patterns-variables"></a></p>
      <p>A variable pattern matches any object, just like a wildcard. But unlike a<a id="i-1540579321-2"></a><a id="i-256060326-2"></a> wildcard, Scala binds the variable to whatever the object is. You can then use this variable to act on the object further. For example, <a href="#lst-variable-pattern">Listing 15.6</a> shows a pattern match that has a special case for zero, and a default case for all other values. The default case uses a variable pattern so that it has a name for the value, no matter what it is.</p>
      <p><a id="lst-variable-pattern"></a></p> <pre>  &nbsp;&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="literal">0</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"zero"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;somethingElse&nbsp;=&gt;&nbsp;<code class="quotedstring">"not&nbsp;zero:&nbsp;"</code>&nbsp;+&nbsp;somethingElse
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.6 - A pattern match with a variable pattern.</h5>
      <h5>Variable or constant?</h5>
      <p>Constant patterns can have symbolic names. You saw this already when we used <span class="code">Nil</span> as a pattern. Here is a related example, where a pattern match involves the constants <span class="code">E</span> (2.71828...) and <span class="code">Pi</span> (3.14159...):</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;math.{E,&nbsp;<code class="typename">Pi</code>}
  <code class="output">import&nbsp;math.{E,&nbsp;Pi}</code>
  <br>  scala&gt;&nbsp;E&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Pi</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;<code class="typename">Pi</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="quotedstring">"OK"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">res11:&nbsp;String&nbsp;=&nbsp;OK</code>
</pre>
      <p>As expected, <span class="code">E</span> does not match <span class="code">Pi</span>, so the "strange math" case is not used.</p>
      <p>How does the Scala compiler know that <span class="code">Pi</span> is a constant imported from <span class="code">scala.math</span>, and not a variable that stands for the selector value itself? Scala uses a simple lexical rule for disambiguation: a simple name starting with a lowercase letter is taken to be a pattern variable; all other references are taken to be constants. To see the difference, create a lowercase alias for <span class="code">pi</span> and try with that:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;pi&nbsp;=&nbsp;<code class="typename">math.Pi</code>
  <code class="output">pi:&nbsp;Double&nbsp;=&nbsp;3.141592653589793</code>
  <br>  scala&gt;&nbsp;E&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;pi&nbsp;=&gt;&nbsp;<code class="quotedstring">"strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;pi
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">res12:&nbsp;String&nbsp;=&nbsp;strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;2.718281828459045</code>
</pre>
      <p>Here the compiler will not even let you add a default case at all. Since <span class="code">pi</span> is a variable pattern, it will match all inputs, and so no cases following it can be reached:</p> <pre>  scala&gt;&nbsp;E&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;pi&nbsp;=&gt;&nbsp;<code class="quotedstring">"strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;pi
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="quotedstring">"OK"</code>&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;pi&nbsp;=&gt;&nbsp;"strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;"&nbsp;+&nbsp;pi</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">On&nbsp;line&nbsp;2:&nbsp;warning:&nbsp;patterns&nbsp;after&nbsp;a&nbsp;variable&nbsp;pattern&nbsp;cannot&nbsp;</code>
  <code class="output">match&nbsp;(SLS&nbsp;8.1.1)</code>
</pre>
      <p>You can still use a lowercase name for a pattern constant, if you need to, by using one of two tricks. First, if the constant is a field of some object, you can prefix it with a qualifier. For instance, <span class="code">pi</span> is a variable pattern, but <span class="code">this.pi</span> or <span class="code">obj.pi</span> are constants even though they start with lowercase letters. If that does not work (because <span class="code">pi</span> is a local variable, say), you can alternatively enclose the variable name in back ticks. For instance, <span class="code">`pi`</span> would again be interpreted as a constant, not as a variable:<a id="i1325362414-1"></a></p> <pre>  scala&gt;&nbsp;E&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;`pi`&nbsp;=&gt;&nbsp;<code class="quotedstring">"strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;pi
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="quotedstring">"OK"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">res14:&nbsp;String&nbsp;=&nbsp;OK</code>
</pre>
      <p>As you can see, the back-tick syntax for identifiers is used for two different purposes in Scala to help you code your way out of unusual circumstances. Here you see that it can be used to treat a lowercase identifier as a constant in a pattern match. Earlier on, in <a href="#sec-literal-identifier">Section 6.10</a>, you saw that it can also be used to treat a keyword as an ordinary identifier, <i>e.g.</i>, writing <span class="code">Thread.`yield`()</span> treats <span class="code">yield</span> as an identifier rather than a keyword.</p>
      <h4>Constructor patterns</h4>
      <p>Constructors are where pattern matching becomes really powerful. A<a id="i-881203127-2"></a><a id="i-1934430442-2"></a> constructor pattern looks like "<span class="code">BinOp("+",</span>&nbsp;<span class="code">e,</span>&nbsp;<span class="code">Number(0))</span>". It consists of a name (<span class="code">BinOp</span>) and then a number of patterns within parentheses: <span class="code">"+"</span>, <span class="code">e</span>, and <span class="code">Number(0)</span>. Assuming the name designates a case class, such a pattern means to first check that the object is a member of the named case class, and then to check that the constructor parameters of the object match the extra patterns supplied.</p>
      <p>These extra patterns mean that Scala patterns support <em>deep matches</em>. Such patterns not only check the top-level object supplied, but also the contents of the object against further patterns. Since the extra patterns can themselves be constructor patterns, you can use them to check arbitrarily deep into an object. For example, the pattern shown in <a href="#lst-constructor-patterns">Listing 15.7</a> checks that the top-level object is a <span class="code">BinOp</span>, that its third constructor parameter is a <span class="code">Number</span>, and that the value field of that number is <span class="code">0</span>. This pattern is one line long yet checks three levels deep.</p>
      <p><a id="lst-constructor-patterns"></a></p> <pre>  &nbsp;&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;e,&nbsp;<code class="typename">Number</code>(<code class="literal">0</code>))&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"a&nbsp;deep&nbsp;match"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.7 - A pattern match with a constructor pattern.</h5>
      <h4>Sequence patterns</h4>
      <p><a id="sec-pat-sequences"></a></p>
      <p>You can match against sequence types, like <span class="code">List</span> or <span class="code">Array</span>, just<a id="i1331042402-1"></a><a id="i-1679405899-1"></a> like you match against case classes. Use the same syntax, but now you can specify any number of elements within the pattern. <a href="#lst-fixed-sequence">Listing 15.8</a> shows a pattern that checks for a three-element list starting with zero.</p>
      <p><a id="lst-fixed-sequence"></a></p> <pre>  &nbsp;&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(<code class="literal">0</code>,&nbsp;_,&nbsp;_)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"found&nbsp;it"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.8 - A sequence pattern with a fixed length.</h5>
      <p>If you want to match against a sequence without specifying how long it can be, you can specify <span class="code">_*</span> as the last element of the pattern. This funny-looking pattern matches any number of elements within a sequence, including zero elements. <a href="#lst-arbitrary-sequence">Listing 15.9</a> shows an example that matches any list that starts with zero, regardless of how long the list is.</p>
      <p><a id="lst-arbitrary-sequence"></a></p> <pre>  &nbsp;&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(<code class="literal">0</code>,&nbsp;_*)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"found&nbsp;it"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.9 - A sequence pattern with an arbitrary length.</h5>
      <h4>Tuple patterns</h4>
      <p>You can match against tuples too. A pattern like <span class="code">(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c)</span><a id="i-1134485445-1"></a><a id="i-2090433336-1"></a> matches an arbitrary 3-tuple. An example is shown in <a href="#lst-tuple-pattern">Listing 15.10</a>.</p>
      <p><a id="lst-tuple-pattern"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;tupleDemo(expr:&nbsp;<code class="typename">Any</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(a,&nbsp;b,&nbsp;c)&nbsp;&nbsp;=&gt;&nbsp;&nbsp;println(<code class="quotedstring">"matched&nbsp;"</code>&nbsp;+&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>
      <h5>Listing 15.10 - A pattern match with a tuple pattern.</h5>
      <p>If you load the <span class="code">tupleDemo</span> method shown in <a href="#lst-tuple-pattern">Listing 15.10</a> into the interpreter, and pass to it a tuple with three elements, you'll see:</p> <pre>  scala&gt;&nbsp;tupleDemo((<code class="quotedstring">"a&nbsp;"</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="quotedstring">"-tuple"</code>))
  <code class="output">matched&nbsp;a&nbsp;3-tuple</code>
</pre>
      <h4>Typed patterns</h4>
      <p>You can use a <em>typed pattern</em> as a convenient replacement for type tests and type casts. <a href="#lst-typed-patterns">Listing 15.11</a> shows an example.</p>
      <p><a id="lst-typed-patterns"></a></p> <pre>  <code class="vem">def</code>&nbsp;generalSize(x:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;x&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;s:&nbsp;<code class="typename">String</code>&nbsp;=&gt;&nbsp;s.length
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;m:&nbsp;<code class="typename">Map[_,&nbsp;_]</code>&nbsp;=&gt;&nbsp;m.size
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;-<code class="literal">1</code>
  }
</pre>
      <h5>Listing 15.11 - A pattern match with typed patterns.</h5>
      <p>Here are a few examples of using <span class="code">generalSize</span> in the Scala interpreter:</p> <pre>  scala&gt;&nbsp;generalSize(<code class="quotedstring">"abc"</code>)
  <code class="output">res16:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br>  scala&gt;&nbsp;generalSize(<code class="typename">Map</code>(<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'a'</code>,&nbsp;<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'b'</code>))
  <code class="output">res17:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;generalSize(<code class="typename">math.Pi</code>)
  <code class="output">res18:&nbsp;Int&nbsp;=&nbsp;-1</code>
</pre>
      <p>The <span class="code">generalSize</span> method returns the size or length of objects of various types. Its argument is of type <span class="code">Any</span>, so it could be any value. If the argument is a <span class="code">String</span>, the method returns the string's length. The pattern "<span class="code">s:</span>&nbsp;<span class="code">String</span>" is a typed pattern; it matches every (non-null) instance of <span class="code">String</span>. The pattern variable <span class="code">s</span> then refers to that string.</p>
      <p>Note that even though <span class="code">s</span> and <span class="code">x</span> refer to the same value, the type of <span class="code">x</span> is <span class="code">Any</span>, while the type of <span class="code">s</span> is <span class="code">String</span>. So you can write <span class="code">s.length</span> in the alternative expression that corresponds to the pattern, but you could not write <span class="code">x.length</span>, because the type <span class="code">Any</span> does not have a <span class="code">length</span> member.<a id="i1877140953-1"></a><a id="i921193062-1"></a> <a id="i-378444118-1"></a><a id="i1486257235-1"></a> An equivalent but more long-winded way that achieves the effect of a match against a typed pattern employs a type test followed by a type cast. Scala uses a different syntax than Java for these. To test whether an expression <span class="code">expr</span> has type <span class="code">String</span>, say, you write:</p> <pre>  expr.isInstanceOf[<code class="typename">String</code>]
</pre>
      <p>To cast the same expression to type <span class="code">String</span>, you use:<a id="i-1504091967-1"></a><a id="i1385408228-1"></a><a id="i-1701093140-1"></a><a id="i-316974287-1"></a></p> <pre>  expr.asInstanceOf[<code class="typename">String</code>]
</pre>
      <p>Using a type test and cast, you could rewrite the first case of the previous <span class="code">match</span> expression as shown in <a href="#lst-is-as-instanceof">Listing 15.12</a>.</p>
      <p><a id="lst-is-as-instanceof"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x.isInstanceOf[<code class="typename">String</code>])&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;x.asInstanceOf[<code class="typename">String</code>]
  &nbsp;&nbsp;&nbsp;&nbsp;s.length
  &nbsp;&nbsp;}&nbsp;<code class="vem">else</code>&nbsp;...
</pre>
      <h5>Listing 15.12 - Using <span class="code">isInstanceOf</span> and <span class="code">asInstanceOf</span> (poor style).</h5>
      <p>The operators <span class="code">isInstanceOf</span> and <span class="code">asInstanceOf</span> are treated as predefined methods of class <span class="code">Any</span> that take a type parameter in square brackets. In fact, <span class="code">x.asInstanceOf[String]</span> is a special case of a method invocation with an explicit type parameter <span class="code">String</span>.</p>
      <p>As you will have noted by now, writing type tests and casts is rather verbose in Scala. That's intentional because it is not encouraged practice. You are usually better off using a pattern match with a typed pattern. That's particularly true if you need to do both a type test and a type cast, because both operations are then rolled into a single pattern match.</p>
      <p>The second case of the <span class="code">match</span> expression in <a href="#lst-typed-patterns">Listing 15.11</a> contains the typed pattern "<span class="code">m:</span>&nbsp;<span class="code">Map[_,</span>&nbsp;<span class="code">_]</span>". This pattern matches any value that is a <span class="code">Map</span> of some arbitrary key and value types, and lets <span class="code">m</span> refer to that value. Therefore, <span class="code">m.size</span> is well typed and returns the size of the map. The underscores in the type pattern<a href="#footnotemain15-3">[3]</a> are like wildcards in other patterns. You could have also used (lowercase) type variables instead.</p>
      <h5>Type erasure</h5>
      <p>Can you also test for a map with specific element types? This would be handy, say, for testing whether a given value is a map from type <span class="code">Int</span> to type <span class="code">Int</span>. Let's try:</p>
      <p><a id="i-1582199503-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;isIntIntMap(x:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;x&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;m:&nbsp;<code class="typename">Map[Int,&nbsp;Int]</code>&nbsp;=&gt;&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;m:&nbsp;Map[Int,&nbsp;Int]&nbsp;=&gt;&nbsp;true</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">On&nbsp;line&nbsp;2:&nbsp;warning:&nbsp;non-variable&nbsp;type&nbsp;argument&nbsp;Int&nbsp;in&nbsp;type&nbsp;</code>
  <code class="output">pattern&nbsp;scala.collection.immutable.Map[Int,Int]&nbsp;(the&nbsp;</code>
  <code class="output">underlying&nbsp;of&nbsp;Map[Int,Int])&nbsp;is&nbsp;unchecked&nbsp;since&nbsp;it&nbsp;is&nbsp;</code>
  <code class="output">eliminated&nbsp;by&nbsp;erasure</code>
</pre>
      <p>Scala uses the <span style="font-style:italic">erasure</span> model of generics,<a id="i-1494561943-1"></a><a id="i-557245309-1"></a> just like Java does. This means that no information about type arguments is maintained at runtime. Consequently, there is no way to determine at runtime whether a given <span class="code">Map</span> object has been created with two <span class="code">Int</span> arguments, rather than with arguments of different types. All the system can do is determine that a value is a <span class="code">Map</span> of some arbitrary type parameters. You can verify this behavior by applying <span class="code">isIntIntMap</span> to arguments of different instances of class <span class="code">Map</span>:</p> <pre>  scala&gt;&nbsp;isIntIntMap(<code class="typename">Map</code>(<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>))
  <code class="output">res19:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;isIntIntMap(<code class="typename">Map</code>(<code class="quotedstring">"abc"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"abc"</code>))
  <code class="output">res20:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>The first application returns <span class="code">true</span>, which looks correct, but the second application also returns <span class="code">true</span>, which might be a surprise. To alert you to the possibly non-intuitive runtime behavior, the compiler emits unchecked warnings like the one shown previously.</p>
      <p>The only exception to the erasure rule is arrays, because they are handled specially in Java as well as in Scala. The element type of an array is stored with the array value, so you can pattern match on it. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;isStringArray(x:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;x&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;a:&nbsp;<code class="typename">Array[String]</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"yes"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="quotedstring">"no"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">isStringArray:&nbsp;(x:&nbsp;Any)String</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;as&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="quotedstring">"abc"</code>)
  <code class="output">as:&nbsp;Array[String]&nbsp;=&nbsp;Array(abc)</code>
  <br>  scala&gt;&nbsp;isStringArray(as)
  <code class="output">res21:&nbsp;String&nbsp;=&nbsp;yes</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;ai&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">ai:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;isStringArray(ai)
  <code class="output">res22:&nbsp;String&nbsp;=&nbsp;no</code>
</pre>
      <h4>Variable binding</h4>
      <p><a id="sec-var-binding"></a></p>
      <p>In addition to the standalone variable patterns, you can also add a<a id="i-199464286-1"></a><a id="i1053833551-1"></a> variable to any other pattern. You simply write the variable name, an at sign (<span class="code">@</span>), and then the pattern. This gives you a<a id="i404534857-1"></a> variable-binding pattern, which means the pattern is to perform the pattern match as normal, and if the pattern succeeds, set the variable to the matched object just as with a simple variable pattern.</p>
      <p>As an example, <a href="#lst-variable-binding">Listing 15.13</a> shows a pattern match that looks for the absolute value operation being applied twice in a row. Such an expression can be simplified to only take the absolute value one time.</p>
      <p><a id="lst-variable-binding"></a></p> <pre>  &nbsp;&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"abs"</code>,&nbsp;e&nbsp;@&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"abs"</code>,&nbsp;_))&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.13 - A pattern with a variable binding (via the <span class="code">@</span> sign).</h5>
      <p>The example shown in <a href="#lst-variable-binding">Listing 15.13</a> includes a variable-binding pattern with <span class="code">e</span> as the variable and <span class="code">UnOp("abs",</span>&nbsp;<span class="code">_)</span> as the pattern. If the entire pattern match succeeds, then the portion that matched the <span class="code">UnOp("abs",</span>&nbsp;<span class="code">_)</span> part is made available as variable <span class="code">e</span>. The result of the case is just <span class="code">e</span>, because <span class="code">e</span> has the same value as <span class="code">expr</span> but with one less absolute value operation.</p>
      <h3>15.3 Pattern guards</h3>
      <p>Sometimes, syntactic pattern matching is not precise enough. For instance, say you are given the task of formulating a simplification rule that replaces sum expressions with two identical operands, such as <span class="code">e</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">e</span>, by multiplications of two (<i>e.g.</i>, <span class="code">e</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2</span>). In the language of <span class="code">Expr</span> trees, an expression like:</p> <pre>  <code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>),&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>))
</pre>
      <p>would be transformed by this rule to:</p> <pre>  <code class="typename">BinOp</code>(<code class="quotedstring">"*"</code>,&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>),&nbsp;<code class="typename">Number</code>(<code class="literal">2</code>))
</pre>
      <p>You might try to define this rule as follows:<a id="i1430878475-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;simplifyAdd(e:&nbsp;<code class="typename">Expr</code>)&nbsp;=&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;x,&nbsp;x)&nbsp;=&gt;&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"*"</code>,&nbsp;x,&nbsp;<code class="typename">Number</code>(<code class="literal">2</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;BinOp("+",&nbsp;x,&nbsp;x)&nbsp;=&gt;&nbsp;BinOp("*",&nbsp;x,&nbsp;Number(2))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">On&nbsp;line&nbsp;2:&nbsp;error:&nbsp;x&nbsp;is&nbsp;already&nbsp;defined&nbsp;as&nbsp;value&nbsp;x</code>
</pre>
      <p>This fails because Scala restricts patterns to be <span style="font-style:italic">linear</span>: a pattern variable may only appear once in a pattern. However, you can re-formulate<a id="i-2111106818-1"></a> the match with a <a href="#g624636437"><em>pattern guard</em></a>, as shown in <a href="#lst-pattern-guard">Listing 15.14</a>:</p>
      <p><a id="lst-pattern-guard"></a></p> <pre>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">def</code>&nbsp;simplifyAdd(e:&nbsp;<code class="typename">Expr</code>)&nbsp;=&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;x,&nbsp;y)&nbsp;<code class="vem">if</code>&nbsp;x&nbsp;==&nbsp;y&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"*"</code>,&nbsp;x,&nbsp;<code class="typename">Number</code>(<code class="literal">2</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">&nbsp;&nbsp;simplifyAdd:&nbsp;(e:&nbsp;Expr)Expr</code>
</pre>
      <h5>Listing 15.14 - A <span class="code">match</span> expression with a pattern guard.</h5>
      <p>A pattern guard comes after a pattern and starts with an <span class="code">if</span>. The guard can be an arbitrary boolean expression, which typically refers to variables in the pattern. If a pattern guard is present, the match succeeds only if the guard evaluates to <span class="code">true</span>. Hence, the first case above would only match binary operations with two equal operands.</p>
      <p>Some other examples of guarded patterns are:</p> <pre>  <code class="comment">//&nbsp;match&nbsp;only&nbsp;positive&nbsp;integers</code>
  <code class="vem">case</code>&nbsp;n:&nbsp;<code class="typename">Int</code>&nbsp;<code class="vem">if</code>&nbsp;<code class="literal">0</code>&nbsp;&lt;&nbsp;n&nbsp;=&gt;&nbsp;...&nbsp;&nbsp;
  <br>  <code class="comment">//&nbsp;match&nbsp;only&nbsp;strings&nbsp;starting&nbsp;with&nbsp;the&nbsp;letter&nbsp;`a'</code>
  <code class="vem">case</code>&nbsp;s:&nbsp;<code class="typename">String</code>&nbsp;<code class="vem">if</code>&nbsp;s(<code class="literal">0</code>)&nbsp;==&nbsp;<code class="quotedstring">'a'</code>&nbsp;=&gt;&nbsp;...&nbsp;
</pre>
      <h3>15.4 Pattern overlaps</h3>
      <p>Patterns are tried in the order in which they are written. The version of <span class="code">simplify</span> shown in <a href="#lst-case-order-matters">Listing 15.15</a> presents an example where the order of the cases matters.</p>
      <p><a id="lst-case-order-matters"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;simplifyAll(expr:&nbsp;<code class="typename">Expr</code>):&nbsp;<code class="typename">Expr</code>&nbsp;=&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;e))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplifyAll(e)&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;`-'&nbsp;is&nbsp;its&nbsp;own&nbsp;inverse</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;e,&nbsp;<code class="typename">Number</code>(<code class="literal">0</code>))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplifyAll(e)&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;`0'&nbsp;is&nbsp;a&nbsp;neutral&nbsp;element&nbsp;for&nbsp;`+'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"*"</code>,&nbsp;e,&nbsp;<code class="typename">Number</code>(<code class="literal">1</code>))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplifyAll(e)&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;`1'&nbsp;is&nbsp;a&nbsp;neutral&nbsp;element&nbsp;for&nbsp;`*'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">UnOp</code>(op,&nbsp;e)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">UnOp</code>(op,&nbsp;simplifyAll(e))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(op,&nbsp;l,&nbsp;r)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">BinOp</code>(op,&nbsp;simplifyAll(l),&nbsp;simplifyAll(r))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;expr
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.15 - Match expression in which case order matters.</h5>
      <p>The version of simplify shown in <a href="#lst-case-order-matters">Listing 15.15</a> will apply simplification rules everywhere in an expression, not just at the top, as <span class="code">simplifyTop</span> did. It can be derived from <span class="code">simplifyTop</span> by adding two more cases for general unary and binary expressions (cases four and five in <a href="#lst-case-order-matters">Listing 15.15</a>).</p>
      <p>The fourth case has the pattern <span class="code">UnOp(op,</span>&nbsp;<span class="code">e)</span>; <i>i.e.</i>, it matches every unary operation. The operator and operand of the unary operation can be arbitrary. They are bound to the pattern variables <span class="code">op</span> and <span class="code">e</span>, respectively. The alternative in this case applies <span class="code">simplifyAll</span> recursively to the operand <span class="code">e</span> and then rebuilds the same unary operation with the (possibly) simplified operand. The fifth case for <span class="code">BinOp</span> is analogous: it is a "catch-all" case for arbitrary binary operations, which recursively applies the simplification method to its two operands.</p>
      <p>In this example, it is important that the catch-all cases come <span style="font-style:italic">after</span> the more specific simplification rules. If you wrote them in the other order, then the catch-all case would be run in favor of the more specific rules. In many cases, the compiler will even complain if you try. For example, here's a <span class="code">match</span> expression that won't compile because the first case will match anything that would be matched by the second case:<a id="i-1756802201-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;simplifyBad(expr:&nbsp;<code class="typename">Expr</code>):&nbsp;<code class="typename">Expr</code>&nbsp;=&nbsp;expr&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">UnOp</code>(op,&nbsp;e)&nbsp;=&gt;&nbsp;<code class="typename">UnOp</code>(op,&nbsp;simplifyBad(e))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<code class="typename">UnOp</code>(<code class="quotedstring">"-"</code>,&nbsp;e))&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;UnOp("-",&nbsp;UnOp("-",&nbsp;e))&nbsp;=&gt;&nbsp;e</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">On&nbsp;line&nbsp;3:&nbsp;warning:&nbsp;unreachable&nbsp;code</code>
  <code class="output">simplifyBad:&nbsp;(expr:&nbsp;Expr)Expr</code>
</pre>
      <h3 id="sec-sealed-classes">15.5 Sealed classes</h3>
      <p>Whenever you write a pattern match, you need to make sure you have<a id="i1902128432-1"></a><a id="i-975567006-1"></a> covered all of the possible cases. Sometimes you can do this by adding a default case at the end of the match, but that only applies if there is a sensible default behavior. What do you do if there is no default? How can you ever feel safe that you covered all the cases?</p>
      <p>You can enlist the help of the Scala compiler in detecting missing combinations of patterns in a <span class="code">match</span> expression. To do this, the compiler needs to be able to tell which are the possible cases. In general, this is impossible in Scala because new case classes can be defined at any time and in arbitrary compilation units. For instance, nothing would prevent you from adding a fifth case class to the <span class="code">Expr</span> class hierarchy in a different compilation unit from the one where the other four cases are defined.</p>
      <p>The alternative is to make the superclass of your case classes <span style="font-style:italic"> sealed</span>. A sealed class cannot have any new subclasses added except the ones in the same file. This is very useful for pattern matching because it means you only need to worry about the subclasses you already know about. What's more, you get better compiler support as well. If you match against case classes that inherit from a sealed class, the compiler will flag missing combinations of patterns with a warning message.</p>
      <p>If you write a hierarchy of classes intended to be pattern matched, you should consider sealing them. Simply put the <span class="code">sealed</span> keyword in front of the class at the top of the hierarchy. Programmers using your class hierarchy will then feel confident in pattern matching against it. The <span class="code">sealed</span> keyword, therefore, is often a license to pattern match. <a href="#lst-sealed-hierarchy">Listing 15.16</a> shows an example in which <span class="code">Expr</span> is turned into a sealed class.<a id="i-1485759717-1"></a></p>
      <p><a id="lst-sealed-hierarchy"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Var</code>(name:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Number</code>(num:&nbsp;<code class="typename">Double</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">UnOp</code>(operator:&nbsp;<code class="typename">String</code>,&nbsp;arg:&nbsp;<code class="typename">Expr</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">BinOp</code>(operator:&nbsp;<code class="typename">String</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left:&nbsp;<code class="typename">Expr</code>,&nbsp;right:&nbsp;<code class="typename">Expr</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
</pre>
      <h5>Listing 15.16 - A sealed hierarchy of case classes.</h5>
      <p>Now define a pattern match where some of the possible cases are left out:</p> <pre>  <code class="vem">def</code>&nbsp;describe(e:&nbsp;<code class="typename">Expr</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Number</code>(_)&nbsp;=&gt;&nbsp;<code class="quotedstring">"a&nbsp;number"</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Var</code>(_)&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;<code class="quotedstring">"a&nbsp;variable"</code>
  }
</pre>
      <p>You will get a compiler warning like the following:</p> <pre>  <code class="output">warning:&nbsp;match&nbsp;is&nbsp;not&nbsp;exhaustive!</code>
  <code class="output">missing&nbsp;combination&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnOp</code>
  <code class="output">missing&nbsp;combination&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BinOp</code>
</pre>
      <p>Such a warning tells you that there's a risk your code might produce a <span class="code">MatchError</span> exception because some possible patterns (<span class="code">UnOp</span>, <span class="code">BinOp</span>) are not handled. The warning points to a potential source of runtime faults, so it is usually a welcome help in getting your program right.<a id="i738442815-1"></a></p>
      <p>However, at times you might encounter a situation where the compiler is too picky in emitting the warning. For instance, you might know from the context that you will only ever apply the <span class="code">describe</span> method above to expressions that are either <span class="code">Number</span>s or <span class="code">Var</span>s, so you know that no <span class="code">MatchError</span> will be produced. To make the warning go away, you could add a third catch-all case to the method, like this:</p> <pre>  <code class="vem">def</code>&nbsp;describe(e:&nbsp;<code class="typename">Expr</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Number</code>(_)&nbsp;=&gt;&nbsp;<code class="quotedstring">"a&nbsp;number"</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Var</code>(_)&nbsp;=&gt;&nbsp;<code class="quotedstring">"a&nbsp;variable"</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">RuntimeException</code>&nbsp;<code class="comment">//&nbsp;Should&nbsp;not&nbsp;happen</code>
  }
</pre>
      <p>That works, but it is not ideal. You will probably not be very happy that you were forced to add code that will never be executed (or so you think), just to make the compiler shut up.</p>
      <p>A more lightweight alternative is to add an <span class="code">@unchecked</span><a id="i-2035290207-1"></a><a id="i-815574504-1"></a> annotation to the selector expression of the match. This is done as follows:</p> <pre>  <code class="vem">def</code>&nbsp;describe(e:&nbsp;<code class="typename">Expr</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;(e:&nbsp;@unchecked)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Number</code>(_)&nbsp;=&gt;&nbsp;<code class="quotedstring">"a&nbsp;number"</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Var</code>(_)&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;<code class="quotedstring">"a&nbsp;variable"</code>
  }
</pre>
      <p>Annotations are described in <a href="#chap-annotations">Chapter 27</a>. In general, you can add an annotation to an expression in the same way you add a type: follow the expression with a colon and the name of the annotation (preceded by an at sign). For example, in this case you add an <span class="code">@unchecked</span> annotation to the variable <span class="code">e</span>, with "<span class="code">e:</span> <span class="code">@unchecked</span>". The <span class="code">@unchecked</span> annotation has a special meaning for pattern matching. If a <span class="code">match</span>'s selector expression carries this annotation, exhaustivity checking for the patterns that follow will be suppressed.</p>
      <h3>15.6 The <span class="code">Option</span> type</h3>
      <p>Scala has a standard type named <span class="code">Option</span> for optional values. Such a value can be of two forms: <span class="code">Some(x)</span>, where <span class="code">x</span> is the actual value, or the <span class="code">None</span> object, which represents a missing value.<a id="i118074925-1"></a><a id="i-747501716-1"></a><a id="i1519187207-1"></a></p>
      <p>Optional values are produced by some of the standard operations on Scala's collections. For instance, the <span class="code">get</span> method of Scala's <span class="code">Map</span> produces <span class="code">Some(value)</span> if a <span class="code">value</span> corresponding to a given key has been found, or <span class="code">None</span> if the given key is not defined in the <span class="code">Map</span>. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;capitals&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"France"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Paris"</code>,&nbsp;<code class="quotedstring">"Japan"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Tokyo"</code>)
  <code class="output">capitals:&nbsp;scala.collection.immutable.Map[String,String]&nbsp;=&nbsp;</code>
  <code class="output">Map(France&nbsp;-&gt;&nbsp;Paris,&nbsp;Japan&nbsp;-&gt;&nbsp;Tokyo)</code>
  <br>  scala&gt;&nbsp;capitals&nbsp;get&nbsp;<code class="quotedstring">"France"</code>
  <code class="output">res23:&nbsp;Option[String]&nbsp;=&nbsp;Some(Paris)</code>
  <br>  scala&gt;&nbsp;capitals&nbsp;get&nbsp;<code class="quotedstring">"North&nbsp;Pole"</code>
  <code class="output">res24:&nbsp;Option[String]&nbsp;=&nbsp;None</code>
</pre>
      <p>The most common way to take optional values apart is through a pattern match. For instance:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;show(x:&nbsp;<code class="typename">Option[String]</code>)&nbsp;=&nbsp;x&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Some</code>(s)&nbsp;=&gt;&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">None</code>&nbsp;=&gt;&nbsp;<code class="quotedstring">"?"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">show:&nbsp;(x:&nbsp;Option[String])String</code>
  <br>  scala&gt;&nbsp;show(capitals&nbsp;get&nbsp;<code class="quotedstring">"Japan"</code>)
  <code class="output">res25:&nbsp;String&nbsp;=&nbsp;Tokyo</code>
  <br>  scala&gt;&nbsp;show(capitals&nbsp;get&nbsp;<code class="quotedstring">"France"</code>)
  <code class="output">res26:&nbsp;String&nbsp;=&nbsp;Paris</code>
  <br>  scala&gt;&nbsp;show(capitals&nbsp;get&nbsp;<code class="quotedstring">"North&nbsp;Pole"</code>)
  <code class="output">res27:&nbsp;String&nbsp;=&nbsp;?</code>
</pre>
      <p>The <span class="code">Option</span> type is used frequently in Scala programs. Compare this to the dominant idiom in Java of using <span class="code">null</span> to indicate no value.<a id="i-906570700-1"></a><a id="i508928486-1"></a> For example, the <span class="code">get</span> method of <span class="code">java.util.HashMap</span> returns either a value stored in the <span class="code">HashMap</span> or <span class="code">null</span> if no value was found. This approach works for Java but is error prone because it is difficult in practice to keep track of which variables in a program are allowed to be <span class="code">null</span>.</p>
      <p>If a variable is allowed to be <span class="code">null</span>, then you must remember to check it for <span class="code">null</span> every time you use it. When you forget to check, you open the possibility that a <span class="code">NullPointerException</span> may result at runtime. Because such exceptions<a id="i-2004250537-1"></a> may not happen very often, it can be difficult to discover the bug during testing. For Scala, the approach would not work at all because it is possible to store value types in hash maps, and <span class="code">null</span> is not a legal element for a value type. For instance, a <span class="code">HashMap[Int,</span>&nbsp;<span class="code">Int]</span> cannot return <span class="code">null</span> to signify "no element."</p>
      <p>By contrast, Scala encourages the use of <span class="code">Option</span> to indicate an optional value. This approach to optional values has several advantages over Java's. First, it is far more obvious to readers of code that a variable whose type is <span class="code">Option[String]</span> is an optional <span class="code">String</span> than a variable of type <span class="code">String</span>, which may sometimes be <span class="code">null</span>. But most importantly, that programming error described earlier of using a variable that may be <span class="code">null</span> without first checking it for <span class="code">null</span> becomes a type error in Scala. If a variable is of type <span class="code">Option[String]</span> and you try to use it as a <span class="code">String</span>, your Scala program will not compile.</p>
      <h3 id="sec-patterns-everywhere">15.7 Patterns everywhere</h3>
      <p>Patterns are allowed in many parts of Scala, not just in standalone <span class="code">match</span> expressions. Take a look at some other places you can use patterns.</p>
      <h4>Patterns in variable definitions</h4>
      <p>Anytime you define a <span class="code">val</span> or a <span class="code">var</span>, you can use a pattern instead of a simple identifier. For example, you can take apart a tuple and assign each of its parts to its own variable, as shown in <a href="#lst-multiple-variables">Listing 15.17</a>:<a id="i-1873919990-1"></a><a id="i-467993090-1"></a></p>
      <p><a id="lst-multiple-variables"></a></p> <pre>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">val</code>&nbsp;myTuple&nbsp;=&nbsp;(<code class="literal">123</code>,&nbsp;<code class="quotedstring">"abc"</code>)
  <code class="output">&nbsp;&nbsp;myTuple:&nbsp;(Int,&nbsp;String)&nbsp;=&nbsp;(123,abc)</code>
  <br>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">val</code>&nbsp;(number,&nbsp;string)&nbsp;=&nbsp;myTuple
  <code class="output">&nbsp;&nbsp;number:&nbsp;Int&nbsp;=&nbsp;123</code>
  <code class="output">&nbsp;&nbsp;string:&nbsp;String&nbsp;=&nbsp;abc</code>
</pre>
      <h5>Listing 15.17 - Defining multiple variables with one assignment.</h5>
      <p>This construct is quite useful when working with case classes. If you know the precise case class you are working with, then you can deconstruct it with a pattern. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;exp&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"*"</code>,&nbsp;<code class="typename">Number</code>(<code class="literal">5</code>),&nbsp;<code class="typename">Number</code>(<code class="literal">1</code>))
  <code class="output">exp:&nbsp;BinOp&nbsp;=&nbsp;BinOp(*,Number(5.0),Number(1.0))</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">BinOp</code>(op,&nbsp;left,&nbsp;right)&nbsp;=&nbsp;exp
  <code class="output">op:&nbsp;String&nbsp;=&nbsp;*</code>
  <code class="output">left:&nbsp;Expr&nbsp;=&nbsp;Number(5.0)</code>
  <code class="output">right:&nbsp;Expr&nbsp;=&nbsp;Number(1.0)</code>
</pre>
      <h4>Case sequences as partial functions</h4>
      <p><a id="sec-partial-functions"></a></p>
      <p>A sequence of cases (<i>i.e.</i>, alternatives) in curly braces can be used anywhere a function literal can be used.<a id="i773900220-1"></a><a id="i-422039390-1"></a> Essentially, a case sequence <em>is</em> a function literal,<a id="i525081623-1"></a> only more general. Instead of having a single entry point and list of parameters, a case sequence has multiple entry points, each with their own list of parameters. Each case is an entry point to the function, and the parameters are specified with the pattern. The body of each entry point is the right-hand side of the case.</p>
      <p>Here is a simple example:<a id="i844888422-1"></a></p> <pre>  <code class="vem">val</code>&nbsp;withDefault:&nbsp;<code class="typename">Option[Int]</code>&nbsp;=&gt;&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Some</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">None</code>&nbsp;=&gt;&nbsp;<code class="literal">0</code>
  }
</pre>
      <p>The body of this function has two cases. The first case matches a <span class="code">Some</span>, and returns the number inside the <span class="code">Some</span>. The second case matches a <span class="code">None</span>, and returns a default value of zero. Here is this function in use:</p> <pre>  scala&gt;&nbsp;withDefault(<code class="typename">Some</code>(<code class="literal">10</code>))
  <code class="output">res28:&nbsp;Int&nbsp;=&nbsp;10</code>
  <br>  scala&gt;&nbsp;withDefault(<code class="typename">None</code>)
  <code class="output">res29:&nbsp;Int&nbsp;=&nbsp;0</code>
</pre>
      <p>This facility is quite useful for the Akka actors library, because<a id="i2042656-4"></a><a id="i-1422944994-4"></a> it allows its <span class="code">receive</span> method to be defined as a series of cases:</p> <pre>  <code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  <br>  <code class="vem">def</code>&nbsp;receive&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Data</code>(byte)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;byte
  <br>  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">GetChecksum</code>(requester)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;checksum&nbsp;=&nbsp;<code style="font-size:large">~</code>(sum&nbsp;&amp;&nbsp;<code class="literal">0xFF</code>)&nbsp;+&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;requester&nbsp;!&nbsp;checksum
  }
</pre>
      <p>One other generalization is worth noting: a sequence of cases gives you a <em>partial</em> function. If you apply such a function on a value it does not support, it will generate a run-time exception. For example, here is a partial function that returns the second element of a list of integers:</p> <pre>  <code class="vem">val</code>&nbsp;second:&nbsp;<code class="typename">List[Int]</code>&nbsp;=&gt;&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;y&nbsp;::&nbsp;_&nbsp;=&gt;&nbsp;y
  }
</pre>
      <p>When you compile this, the compiler will correctly warn that the match is not exhaustive:<a id="i-160448460-1"></a></p> <pre>  <code class="output">&lt;console&gt;:17:&nbsp;warning:&nbsp;match&nbsp;is&nbsp;not&nbsp;exhaustive!</code>
  <code class="output">missing&nbsp;combination&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nil</code>
</pre>
      <p>This function will succeed if you pass it a three-element list, but not if you pass it an empty list:</p> <pre>  scala&gt;&nbsp;second(<code class="typename">List</code>(<code class="literal">5</code>,&nbsp;<code class="literal">6</code>,&nbsp;<code class="literal">7</code>))
  <code class="output">res24:&nbsp;Int&nbsp;=&nbsp;6</code>
  <br>  scala&gt;&nbsp;second(<code class="typename">List</code>())
  <code class="output">scala.MatchError:&nbsp;List()</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;$anonfun$1.apply(&lt;console&gt;:17)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;$anonfun$1.apply(&lt;console&gt;:17)</code>
</pre>
      <p>If you want to check whether a partial function is defined, you must first tell the compiler that you know you are working with partial functions. The type <span class="code">List[Int]</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Int</span> includes all functions from lists of integers to integers, whether or not the functions are partial. The type that only includes <em>partial</em> functions from lists of integers to integers is written <span class="code">PartialFunction[List[Int],Int]</span>. Here is the <span class="code">second</span> function again, this time written with a partial function type:<a id="i-33298553-1"></a></p> <pre>  <code class="vem">val</code>&nbsp;second:&nbsp;<code class="typename">PartialFunction[List[Int],Int]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;y&nbsp;::&nbsp;_&nbsp;=&gt;&nbsp;y
  }
</pre>
      <p>Partial functions have a method <span class="code">isDefinedAt</span>, which can be<a id="i1604479281-1"></a> used to test whether the function is defined at a particular value. In this case, the function is defined for any list that has at least two elements:</p> <pre>  scala&gt;&nbsp;second.isDefinedAt(<code class="typename">List</code>(<code class="literal">5</code>,<code class="literal">6</code>,<code class="literal">7</code>))
  <code class="output">res30:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;second.isDefinedAt(<code class="typename">List</code>())
  <code class="output">res31:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>The typical example of a partial function is a pattern matching function literal like the one in the previous example. In fact, such an expression gets translated by the Scala compiler to a partial function by translating the patterns twice—once for the implementation of the real function, and once to test whether the function is defined or not.</p>
      <p>For instance, the function literal <span class="code">{</span>&nbsp;<span class="code">case</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">y</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">_</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">y</span>&nbsp;<span class="code">}</span> gets translated to the following partial function value:<a id="i-711183731-1"></a></p> <pre>  <code class="vem">new</code>&nbsp;<code class="typename">PartialFunction[List[Int],&nbsp;Int]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(xs:&nbsp;<code class="typename">List[Int]</code>)&nbsp;=&nbsp;xs&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;y&nbsp;::&nbsp;_&nbsp;=&gt;&nbsp;y&nbsp;
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;isDefinedAt(xs:&nbsp;<code class="typename">List[Int]</code>)&nbsp;=&nbsp;xs&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;y&nbsp;::&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>
      <p>This translation takes effect whenever the declared type of a function literal is <span class="code">PartialFunction</span>. If the declared type is just <span class="code">Function1</span>, or is missing, the function literal is instead translated to a <span class="textit">complete function</span>.<a id="i1866035935-1"></a></p>
      <p>In general, you should try to work with complete functions whenever possible, because using partial functions allows for runtime errors that the compiler cannot help you with. Sometimes partial functions are really helpful though. You might be sure that an unhandled value will never be supplied. Alternatively, you might be using a framework that expects partial functions and so will always check <span class="code">isDefinedAt</span> before calling the function. An example of the latter is the <span class="code">receive</span> method given previously, where the result is a partially defined function, defined precisely for those messages that the caller wants to handle.</p>
      <h4>Patterns in <span class="code">for</span> expressions</h4>
      <p>You can also use a pattern in a <span class="code">for</span> expression, as shown in <a href="#lst-pattern-in-for">Listing 15.18</a>. This <span class="code">for</span> expression retrieves all key/value pairs from the <span class="code">capitals</span> map. Each pair is matched against the pattern <span class="code">(country,</span>&nbsp;<span class="code">city)</span>, which defines the two variables <span class="code">country</span> and <span class="code">city</span>.<a id="i-1272952554-1"></a><a id="i371386352-1"></a></p>
      <p><a id="lst-pattern-in-for"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;((country,&nbsp;city)&nbsp;&lt;-&nbsp;capitals)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"The&nbsp;capital&nbsp;of&nbsp;"</code>&nbsp;+&nbsp;country&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;is&nbsp;"</code>&nbsp;+&nbsp;city)
  <code class="output">The&nbsp;capital&nbsp;of&nbsp;France&nbsp;is&nbsp;Paris</code>
  <code class="output">The&nbsp;capital&nbsp;of&nbsp;Japan&nbsp;is&nbsp;Tokyo</code>
</pre>
      <h5>Listing 15.18 - A <span class="code">for</span> expression with a tuple pattern.</h5>
      <p>The pair pattern shown in <a href="#lst-pattern-in-for">Listing 15.18</a> was special because the match against it can never fail. Indeed, <span class="code">capitals</span> yields a sequence of pairs, so you can be sure that every generated pair can be matched against a pair pattern. But it is equally possible that a pattern might not match a generated value. <a href="#lst-options-to-somes">Listing 15.19</a> shows an example where that is the case.</p>
      <p><a id="lst-options-to-somes"></a></p> <pre>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">val</code>&nbsp;results&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">Some</code>(<code class="quotedstring">"apple"</code>),&nbsp;<code class="typename">None</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Some</code>(<code class="quotedstring">"orange"</code>))
  <code class="output">&nbsp;&nbsp;results:&nbsp;List[Option[String]]&nbsp;=&nbsp;List(Some(apple),&nbsp;None,&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Some(orange))</code>
  <br>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(<code class="typename">Some</code>(fruit)&nbsp;&lt;-&nbsp;results)&nbsp;println(fruit)
  <code class="output">&nbsp;&nbsp;apple</code>
  <code class="output">&nbsp;&nbsp;orange</code>
</pre>
      <h5>Listing 15.19 - Picking elements of a list that match a pattern.</h5>
      <p>As you can see from this example, generated values that do not match the pattern are discarded. For instance, the second element <span class="code">None</span> in the <span class="code">results</span> list does not match the pattern <span class="code">Some(fruit)</span>; therefore it does not show up in the output.</p>
      <h3>15.8 A larger example</h3>
      <p>After having learned the different forms of patterns, you might be interested in seeing them applied in a larger example. The proposed task is to write an expression formatter class that displays an arithmetic expression in a two-dimensional layout. Divisions such as "<span class="code">x</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">(x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span>" should be printed vertically, by placing the numerator on top of the denominator, like this:</p>
      <div style="text-align: center">
        <p><span class="code">&nbsp;&nbsp;x&nbsp;&nbsp;</span><br> <span class="code">-----&nbsp;</span><br> <span class="code">x&nbsp;+&nbsp;1</span><br></p>
      </div>
      <p>As another example, here's the expression <span class="code">((a</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">(b</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">c)</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">n)</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">3)</span> in two dimensional layout:</p>
      <div style="text-align: center">
        <p><span class="code">&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;</span><br> <span class="code">-----&nbsp;+&nbsp;-&nbsp;</span><br> <span class="code">b&nbsp;*&nbsp;c&nbsp;&nbsp;&nbsp;n&nbsp;</span><br> <span class="code">---------&nbsp;</span><br> <span class="code">&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;</span><br></p>
      </div>
      <p>From these examples it looks like the class (we'll call it <span class="code">ExprFormatter</span>) will have to do a fair bit of layout juggling, so it makes sense to use the layout library developed in <a href="#chap-composition-and-inheritance">Chapter 10</a>. We'll also use the <span class="code">Expr</span> family of case classes you saw previously in this chapter, and place both <a href="#chap-composition-and-inheritance">Chapter 10</a>'s layout library and this chapter's expression formatter into named packages. The full code for the example will be shown in <a href="#lst-expr-form-top-half">Listings 15.20</a> and <a href="#lst-expr-form-bottom-half"> 15.21</a>.</p>
      <p>A useful first step is to concentrate on horizontal layout. A structured expression like:</p> <pre>  <code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"*"</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>),&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"y"</code>)),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"z"</code>)),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Number</code>(<code class="literal">1</code>))
</pre>
      <p>should print <span class="code">(x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y)</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">z</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span>. Note that parentheses are mandatory around <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span>, but would be optional around <span class="code">(x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y)</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">z</span>. To keep the layout as legible as possible, your goal should be to omit parentheses wherever they are redundant, while ensuring that all necessary parentheses are present.</p>
      <p>To know where to put parentheses, the code needs to know about the relative precedence of each operator, so it's a good idea to tackle this first. You could express the relative precedence directly as a map literal of the following form:</p> <pre>  <code class="typename">Map</code>(
  &nbsp;&nbsp;<code class="quotedstring">"|"</code>&nbsp;-&gt;&nbsp;<code class="literal">0</code>,&nbsp;<code class="quotedstring">"||"</code>&nbsp;-&gt;&nbsp;<code class="literal">0</code>,
  &nbsp;&nbsp;<code class="quotedstring">"&amp;"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"&amp;&amp;"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;...
  )
</pre>
      <p>However, this would involve some amount of pre-computation of precedences on your part. A more convenient approach is to just define groups of operators of increasing precedence and then calculate the precedence of each operator from that. <a href="#lst-expr-form-top-half">Listing 15.20</a> shows the code.</p>
      <p><a id="lst-expr-form-top-half"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.expr
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.stairwaybook.layout.Element.elem
  <br>  &nbsp;&nbsp;<code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Var</code>(name:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Number</code>(num:&nbsp;<code class="typename">Double</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">UnOp</code>(operator:&nbsp;<code class="typename">String</code>,&nbsp;arg:&nbsp;<code class="typename">Expr</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">BinOp</code>(operator:&nbsp;<code class="typename">String</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left:&nbsp;<code class="typename">Expr</code>,&nbsp;right:&nbsp;<code class="typename">Expr</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Expr</code>
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ExprFormatter</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Contains&nbsp;operators&nbsp;in&nbsp;groups&nbsp;of&nbsp;increasing&nbsp;precedence</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;opGroups&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Array</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"|"</code>,&nbsp;<code class="quotedstring">"||"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"&amp;"</code>,&nbsp;<code class="quotedstring">"&amp;&amp;"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"^"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"=="</code>,&nbsp;<code class="quotedstring">"!="</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"&lt;"</code>,&nbsp;<code class="quotedstring">"&lt;="</code>,&nbsp;<code class="quotedstring">"&gt;"</code>,&nbsp;<code class="quotedstring">"&gt;="</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"+"</code>,&nbsp;<code class="quotedstring">"-"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"*"</code>,&nbsp;<code class="quotedstring">"<code class="texttt">%</code>"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;mapping&nbsp;from&nbsp;operators&nbsp;to&nbsp;their&nbsp;precedence</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;precedence&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;assocs&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;opGroups.length
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op&nbsp;&lt;-&nbsp;opGroups(i)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">yield</code>&nbsp;op&nbsp;-&gt;&nbsp;i
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assocs.toMap
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;unaryPrecedence&nbsp;=&nbsp;opGroups.length
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;fractionPrecedence&nbsp;=&nbsp;-<code class="literal">1</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;continued&nbsp;in&nbsp;Listing&nbsp;15.21...</code>
</pre>
      <h5>Listing 15.20 - The top half of the expression formatter.</h5>
      <p><a id="lst-expr-form-bottom-half"></a></p> <pre>  &nbsp;&nbsp;<code class="comment">//&nbsp;...continued&nbsp;from&nbsp;Listing&nbsp;15.20</code>
  <br>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.stairwaybook.layout.Element
  <br>  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;format(e:&nbsp;<code class="typename">Expr</code>,&nbsp;enclPrec:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Element</code>&nbsp;=
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Var</code>(name)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(name)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Number</code>(num)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;stripDot(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s&nbsp;endsWith&nbsp;<code class="quotedstring">".0"</code>)&nbsp;s.substring(<code class="literal">0</code>,&nbsp;s.length&nbsp;-&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(stripDot(num.toString))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">UnOp</code>(op,&nbsp;arg)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(op)&nbsp;beside&nbsp;format(arg,&nbsp;unaryPrecedence)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"/"</code>,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;top&nbsp;=&nbsp;format(left,&nbsp;fractionPrecedence)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;bot&nbsp;=&nbsp;format(right,&nbsp;fractionPrecedence)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;line&nbsp;=&nbsp;elem(<code class="quotedstring">'-'</code>,&nbsp;top.width&nbsp;max&nbsp;bot.width,&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;frac&nbsp;=&nbsp;top&nbsp;above&nbsp;line&nbsp;above&nbsp;bot
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(enclPrec&nbsp;!=&nbsp;fractionPrecedence)&nbsp;frac
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;elem(<code class="quotedstring">"&nbsp;"</code>)&nbsp;beside&nbsp;frac&nbsp;beside&nbsp;elem(<code class="quotedstring">"&nbsp;"</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(op,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;opPrec&nbsp;=&nbsp;precedence(op)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;l&nbsp;=&nbsp;format(left,&nbsp;opPrec)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;r&nbsp;=&nbsp;format(right,&nbsp;opPrec&nbsp;+&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;oper&nbsp;=&nbsp;l&nbsp;beside&nbsp;elem(<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;op&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>)&nbsp;beside&nbsp;r&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(enclPrec&nbsp;&lt;=&nbsp;opPrec)&nbsp;oper
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;elem(<code class="quotedstring">"("</code>)&nbsp;beside&nbsp;oper&nbsp;beside&nbsp;elem(<code class="quotedstring">")"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;format(e:&nbsp;<code class="typename">Expr</code>):&nbsp;<code class="typename">Element</code>&nbsp;=&nbsp;format(e,&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.21 - The bottom half of the expression formatter.</h5>
      <p>The <span class="code">precedence</span> variable is a map from operators to their precedences, which are integers starting with <span class="code">0</span>. It is calculated using a <span class="code">for</span> expression with two generators. The first generator produces every index <span class="code">i</span> of the <span class="code">opGroups</span> array. The second generator produces every operator <span class="code">op</span> in <span class="code">opGroups(i)</span>. For each such operator the <span class="code">for</span> expression yields an association from the operator <span class="code">op</span> to its index <span class="code">i</span>. Hence, the relative position of an operator in the array is taken to be its precedence.</p>
      <p>Associations are written with an infix arrow, <i>e.g.</i>, <span class="code">op</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">i</span>. So far you have seen associations only as part of map constructions, but they are also values in their own right. In fact, the association <span class="code">op</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">i</span> is nothing else but the pair <span class="code">(op,</span>&nbsp;<span class="code">i)</span>.</p>
      <p>Now that you have fixed the precedence of all binary operators except <span class="code">/</span>, it makes sense to generalize this concept to also cover unary operators. The precedence of a unary operator is higher than the precedence of every binary operator. Thus we can set <span class="code">unaryPrecedence</span> (shown in <a href="#lst-expr-form-top-half">Listing 15.20</a>) to the length of the <span class="code">opGroups</span> array, which is one more than the precedence of the <span class="code">*</span> and <span class="code"><span class="texttt">%</span></span> operators. The precedence of a fraction is treated differently from the other operators because fractions use vertical layout. However, it will prove convenient to assign to the division operator the special precedence value <span class="code">-1</span>, so we'll initialize <span class="code">fractionPrecedence</span> to -1 (shown in <a href="#lst-expr-form-top-half">Listing 15.20</a>).</p>
      <p>After these preparations, you are ready to write the main <span class="code">format</span> method. This method takes two arguments: an expression <span class="code">e</span>, of type <span class="code">Expr</span>, and the precedence <span class="code">enclPrec</span> of the operator directly enclosing the expression <span class="code">e</span>. (If there's no enclosing operator, <span class="code">enclPrec</span> should be zero.) The method yields a layout element that represents a two-dimensional array of characters.</p>
      <p><a href="#lst-expr-form-bottom-half">Listing 15.21</a> shows the remainder of class <span class="code">ExprFormatter</span>, which includes three methods. The first method, <span class="code">stripDot</span>, is a helper method. The next method, the private <span class="code">format</span> method, does most of the work to format expressions. The last method, also named <span class="code">format</span>, is the lone public method in the library, which takes an expression to format. The private <span class="code">format</span> method does its work by performing a pattern match on the kind of expression. The <span class="code">match</span> expression has five cases. We'll discuss each case individually.</p>
      <p>The first case is:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="typename">Var</code>(name)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;elem(name)
</pre>
      <p>If the expression is a variable, the result is an element formed from the variable's name.</p>
      <p>The second case is:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="typename">Number</code>(num)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;stripDot(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s&nbsp;endsWith&nbsp;<code class="quotedstring">".0"</code>)&nbsp;s.substring(<code class="literal">0</code>,&nbsp;s.length&nbsp;-&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;s
  &nbsp;&nbsp;elem(stripDot(num.toString))
</pre>
      <p>If the expression is a number, the result is an element formed from the number's value. The <span class="code">stripDot</span> function cleans up the display of a floating-point number by stripping any <span class="code">".0"</span> suffix from a string.</p>
      <p>The third case is:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="typename">UnOp</code>(op,&nbsp;arg)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;elem(op)&nbsp;beside&nbsp;format(arg,&nbsp;unaryPrecedence)
</pre>
      <p>If the expression is a unary operation <span class="code">UnOp(op,</span>&nbsp;<span class="code">arg)</span> the result is formed from the operation <span class="code">op</span> and the result of formatting the argument <span class="code">arg</span> with the highest-possible environment precedence.<a href="#footnotemain15-4">[4]</a> This means that if <span class="code">arg</span> is a binary operation (but not a fraction) it will always be displayed in parentheses.</p>
      <p>The fourth case is:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"/"</code>,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;top&nbsp;=&nbsp;format(left,&nbsp;fractionPrecedence)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;bot&nbsp;=&nbsp;format(right,&nbsp;fractionPrecedence)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;line&nbsp;=&nbsp;elem(<code class="quotedstring">'-'</code>,&nbsp;top.width&nbsp;max&nbsp;bot.width,&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;frac&nbsp;=&nbsp;top&nbsp;above&nbsp;line&nbsp;above&nbsp;bot
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(enclPrec&nbsp;!=&nbsp;fractionPrecedence)&nbsp;frac
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;elem(<code class="quotedstring">"&nbsp;"</code>)&nbsp;beside&nbsp;frac&nbsp;beside&nbsp;elem(<code class="quotedstring">"&nbsp;"</code>)
</pre>
      <p>If the expression is a fraction, an intermediate result <span class="code">frac</span> is formed by placing the formatted operands <span class="code">left</span> and <span class="code">right</span> on top of each other, separated by an horizontal line element. The width of the horizontal line is the maximum of the widths of the formatted operands. This intermediate result is also the final result unless the fraction appears itself as an argument of another fraction. In the latter case, a space is added on each side of <span class="code">frac</span>. To see the reason why, consider the expression "<span class="code">(a</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">b)</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">c</span>".</p>
      <p>Without the widening correction, formatting this expression would give:</p>
      <div style="text-align: center">
        <p><span class="code">a</span><br> <span class="code">-</span><br> <span class="code">b</span><br> <span class="code">-</span><br> <span class="code">c</span></p>
      </div>
      <p>The problem with this layout is evident—it's not clear where the top-level fractional bar is. The expression above could mean either "<span class="code">(a</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">b)</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">c</span>" or "<span class="code">a</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">(b</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">c)</span>". To disambiguate, a space should be added on each side to the layout of the nested fraction "<span class="code">a</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">b</span>". Then the layout becomes unambiguous:</p>
      <div style="text-align: center">
        <p><span class="code">&nbsp;a&nbsp;</span><br> <span class="code">&nbsp;-&nbsp;</span><br> <span class="code">&nbsp;b&nbsp;</span><br> <span class="code">---</span><br> <span class="code">&nbsp;c&nbsp;</span></p>
      </div>
      <p>The fifth and last case is:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(op,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;opPrec&nbsp;=&nbsp;precedence(op)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;l&nbsp;=&nbsp;format(left,&nbsp;opPrec)&nbsp;
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;r&nbsp;=&nbsp;format(right,&nbsp;opPrec&nbsp;+&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;oper&nbsp;=&nbsp;l&nbsp;beside&nbsp;elem(<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;op&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>)&nbsp;beside&nbsp;r&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(enclPrec&nbsp;&lt;=&nbsp;opPrec)&nbsp;oper
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;elem(<code class="quotedstring">"("</code>)&nbsp;beside&nbsp;oper&nbsp;beside&nbsp;elem(<code class="quotedstring">")"</code>)
</pre>
      <p>This case applies for all other binary operations. Since it comes after the case starting with:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"/"</code>,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;...
</pre>
      <p>you know that the operator <span class="code">op</span> in the pattern <span class="code">BinOp(op,</span>&nbsp;<span class="code">left,</span>&nbsp;<span class="code">right)</span> cannot be a division. To format such a binary operation, one needs to format first its operands <span class="code">left</span> and <span class="code">right</span>. The precedence parameter for formatting the left operand is the precedence <span class="code">opPrec</span> of the operator <span class="code">op</span>, while for the right operand it is one more than that. This scheme ensures that parentheses also reflect the correct associativity.</p>
      <p>For instance, the operation:</p> <pre>  <code class="typename">BinOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"a"</code>),&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"-"</code>,&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"b"</code>),&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"c"</code>)))
</pre>
      <p>would be correctly parenthesized as "<span class="code">a</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">(b</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">c)</span>". The intermediate result <span class="code">oper</span> is then formed by placing the formatted left and right operands side-by-side, separated by the operator. If the precedence of the current operator is smaller than the precedence of the enclosing operator, <span class="code">oper</span> is placed between parentheses; otherwise, it is returned as is.</p>
      <p><a id="lst-express-app"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.stairwaybook.expr._
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Express</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">App</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ExprFormatter</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;e1&nbsp;=&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"*"</code>,&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"/"</code>,&nbsp;<code class="typename">Number</code>(<code class="literal">1</code>),&nbsp;<code class="typename">Number</code>(<code class="literal">2</code>)),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>),&nbsp;<code class="typename">Number</code>(<code class="literal">1</code>)))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;e2&nbsp;=&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"+"</code>,&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"/"</code>,&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>),&nbsp;<code class="typename">Number</code>(<code class="literal">2</code>)),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"/"</code>,&nbsp;<code class="typename">Number</code>(<code class="literal">1.5</code>),&nbsp;<code class="typename">Var</code>(<code class="quotedstring">"x"</code>)))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;e3&nbsp;=&nbsp;<code class="typename">BinOp</code>(<code class="quotedstring">"/"</code>,&nbsp;e1,&nbsp;e2)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;show(e:&nbsp;<code class="typename">Expr</code>)&nbsp;=&nbsp;s<code class="quotedstring">"${println(f.format(e))}\n\n"</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(e&nbsp;&lt;-&nbsp;<code class="typename">Array</code>(e1,&nbsp;e2,&nbsp;e3))&nbsp;show(e)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 15.22 - An application that prints formatted expressions.</h5>
      <p>This finishes the design of the private <span class="code">format</span> function. The only remaining method is the public <span class="code">format</span> method, which allows client programmers to format a top-level expression without passing a precedence argument. <a href="#lst-express-app">Listing 15.22</a> shows a demo program that exercises <span class="code">ExprFormatter</span>.</p>
      <p>Note that, even though this program does not define a <span class="code">main</span> method, it is still a runnable application because it inherits from the <span class="code">App</span> trait. You can run the <span class="code">Express</span> program with the command:</p> <pre>  scala&nbsp;Express
</pre>
      <p>This will give the following output:</p>
      <p><span class="code"> 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> -&nbsp;*&nbsp;(x&nbsp;+&nbsp;1)<br> 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> <br> <br> x&nbsp;&nbsp;&nbsp;1.5<br> -&nbsp;+&nbsp;---<br> 2&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<br> <br> <br> 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> -&nbsp;*&nbsp;(x&nbsp;+&nbsp;1)<br> 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> -----------<br> &nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;1.5&nbsp;&nbsp;<br> &nbsp;&nbsp;-&nbsp;+&nbsp;---&nbsp;&nbsp;<br> &nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp; </span></p>
      <h3>15.9 Conclusion</h3>
      <p>In this chapter, you learned about Scala's case classes and pattern matching in detail. By using them, you can take advantage of several concise idioms not normally available in object-oriented languages. However, Scala's pattern matching goes further than this chapter describes. If you want to use pattern matching on one of your classes, but you do not want to open access to your classes the way case classes do, you can use the <em>extractors</em> described in <a href="#chap-extractors">Chapter 26</a>. In the next chapter, we'll turn our attention to lists.</p>
      <hr>
      <h4>Footnotes for Chapter 15:</h4>
      <p><a id="footnotemain15-1"></a>[1] Instead of an abstract class, we could have also chosen to model the root of that class hierarchy as a trait. Modeling it as an abstract class may be slightly more efficient.<a id="i991539031-1"></a></p>
      <p><a id="footnotemain15-2"></a>[2] Gamma, <i>et. al.</i>, <em>Design Patterns</em> <a href="#gang-of-four">[Gam95]</a><a id="i978021020-1"></a><a id="i-37693691-1"></a></p>
      <p><a id="footnotemain15-3"></a>[3] In the typed pattern, <span class="code">m:</span>&nbsp;<span class="code">Map[_,</span>&nbsp;<span class="code">_]</span>, the "<span class="code">Map[_,</span>&nbsp;<span class="code">_]</span>" portion is called a <span class="textit">type pattern</span>.</p>
      <p><a id="footnotemain15-4"></a>[4] The value of <span class="code">unaryPrecedence</span> is the highest possible precedence, because it was initialized to one more than the precedence of the <span class="code">*</span> and <span class="code"><span class="texttt">%</span></span> operators.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-working-with-lists">Chapter 16</a></h2>
      <h1>Working with Lists</h1>
      <p>Lists are probably the most commonly used data structure in Scala programs<a id="i102982549-2"></a>. This chapter explains lists in detail. We will present many common operations that can be performed on lists. We'll also cover some important design principles for programs working on lists.</p>
      <h3>16.1 List literals</h3>
      <p>You saw lists already in the preceding chapters, so you know that a list containing the elements <span class="code">'a'</span>, <span class="code">'b'</span>, and <span class="code">'c'</span> is written <span class="code">List('a',</span>&nbsp;<span class="code">'b',</span>&nbsp;<span class="code">'c')</span>.<a id="i-2038506824-1"></a> Here are some other examples:</p> <pre>  <code class="vem">val</code>&nbsp;fruit&nbsp;=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"apples"</code>,&nbsp;<code class="quotedstring">"oranges"</code>,&nbsp;<code class="quotedstring">"pears"</code>)
  <code class="vem">val</code>&nbsp;nums&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>)
  <code class="vem">val</code>&nbsp;diag3&nbsp;=
  &nbsp;&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">0</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="literal">0</code>,&nbsp;<code class="literal">1</code>,&nbsp;<code class="literal">0</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="literal">0</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;)
  <code class="vem">val</code>&nbsp;empty&nbsp;=&nbsp;<code class="typename">List</code>()
</pre>
      <p>Lists are quite similar to arrays, but there are two important differences. First, lists are immutable. That is, elements of a list cannot be changed by assignment. Second, lists have a recursive structure (<i>i.e.</i>, a <em>linked list</em><a id="i594306766-1"></a>),<a href="#footnotemain16-1">[1]</a> whereas arrays are flat.</p>
      <h3>16.2 The <span class="code">List</span> type</h3>
      <p>Like arrays, lists are <span style="font-style:italic">homogeneous</span>: the elements of a list all have the same type. The type of a list that has elements of type <span class="code">T</span> is written <span class="code">List[T]</span>. For instance, here are the same four lists with explicit types added:</p> <pre>  <code class="vem">val</code>&nbsp;fruit:&nbsp;<code class="typename">List[String]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"apples"</code>,&nbsp;<code class="quotedstring">"oranges"</code>,&nbsp;<code class="quotedstring">"pears"</code>)
  <code class="vem">val</code>&nbsp;nums:&nbsp;<code class="typename">List[Int]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>)
  <code class="vem">val</code>&nbsp;diag3:&nbsp;<code class="typename">List[List[Int]]</code>&nbsp;=
  &nbsp;&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">0</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="literal">0</code>,&nbsp;<code class="literal">1</code>,&nbsp;<code class="literal">0</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="literal">0</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;)
  <code class="vem">val</code>&nbsp;empty:&nbsp;<code class="typename">List[Nothing]</code>&nbsp;=&nbsp;<code class="typename">List</code>()
</pre>
      <p>The list type in Scala is <span style="font-style:italic">covariant</span><a id="i-1469695991-1"></a>. This means that for each pair of types <span class="code">S</span> and <span class="code">T</span>, if <span class="code">S</span> is a subtype of <span class="code">T</span>, then <span class="code">List[S]</span> is a subtype of <span class="code">List[T]</span>. For instance, <span class="code">List[String]</span> is a subtype of <span class="code">List[Object]</span>. This is natural because every list of strings can also be seen as a list of objects.<a href="#footnotemain16-2">[2]</a></p>
      <p>Note that the empty list has type <span class="code">List[Nothing]</span>.<a id="i-727376847-1"></a> You saw in <a href="#sec-bottom-types">Section 11.3</a> that <span class="code">Nothing</span> is the bottom type in Scala's class hierarchy. It is a subtype of every other Scala type. Because lists are covariant, it follows that <span class="code">List[Nothing]</span> is a subtype of <span class="code">List[T]</span> for any type <span class="code">T</span>. So the empty list object, which has type <span class="code">List[Nothing]</span>, can also be seen as an object of every other list type of the form <span class="code">List[T]</span>. That's why it is permissible to write code like:</p> <pre>  <code class="comment">//&nbsp;List()&nbsp;is&nbsp;also&nbsp;of&nbsp;type&nbsp;List[String]!</code>
  <code class="vem">val</code>&nbsp;xs:&nbsp;<code class="typename">List[String]</code>&nbsp;=&nbsp;<code class="typename">List</code>()&nbsp;&nbsp;
</pre>
      <h3>16.3 Constructing lists</h3>
      <p>All lists are built from two fundamental building blocks, <span class="code">Nil</span><a id="i1899558990-2"></a> and <span class="code">:: </span>(pronounced "cons").<a id="i1411857630-2"></a><a id="i1674095775-2"></a> <span class="code">Nil</span> represents the empty list. The infix operator, <span class="code">::</span>, expresses list extension at the front. That is, <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span> represents a list whose first element is <span class="code">x</span>, followed by (the elements of) list <span class="code">xs</span>. Hence, the previous list values could also have been defined as follows:</p> <pre>  <code class="vem">val</code>&nbsp;fruit&nbsp;=&nbsp;<code class="quotedstring">"apples"</code>&nbsp;::&nbsp;(<code class="quotedstring">"oranges"</code>&nbsp;::&nbsp;(<code class="quotedstring">"pears"</code>&nbsp;::&nbsp;<code class="typename">Nil</code>))
  <code class="vem">val</code>&nbsp;nums&nbsp;&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;::&nbsp;(<code class="literal">2</code>&nbsp;::&nbsp;(<code class="literal">3</code>&nbsp;::&nbsp;(<code class="literal">4</code>&nbsp;::&nbsp;<code class="typename">Nil</code>)))
  <code class="vem">val</code>&nbsp;diag3&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;::&nbsp;(<code class="literal">0</code>&nbsp;::&nbsp;(<code class="literal">0</code>&nbsp;::&nbsp;<code class="typename">Nil</code>)))&nbsp;::
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="literal">0</code>&nbsp;::&nbsp;(<code class="literal">1</code>&nbsp;::&nbsp;(<code class="literal">0</code>&nbsp;::&nbsp;<code class="typename">Nil</code>)))&nbsp;::
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="literal">0</code>&nbsp;::&nbsp;(<code class="literal">0</code>&nbsp;::&nbsp;(<code class="literal">1</code>&nbsp;::&nbsp;<code class="typename">Nil</code>)))&nbsp;::&nbsp;<code class="typename">Nil</code>
  <code class="vem">val</code>&nbsp;empty&nbsp;=&nbsp;<code class="typename">Nil</code>
</pre>
      <p>In fact the previous definitions of <span class="code">fruit</span>, <span class="code">nums</span>, <span class="code">diag3</span>, and <span class="code">empty</span> in terms of <span class="code">List(...)</span> are just wrappers that expand to these definitions. For instance, <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> creates the list <span class="code">1</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">(2</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">(3</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">Nil))</span>.</p>
      <p>Because it ends in a colon, the <span class="code">:: </span>operation associates to the right: <span class="code">A</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">B</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">C</span> is interpreted as <span class="code">A</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">(B</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">C)</span>.<a id="i-1491182453-2"></a><a id="i620923488-2"></a> Therefore, you can drop the parentheses in the previous definitions. For instance:</p> <pre>  <code class="vem">val</code>&nbsp;nums&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;::&nbsp;<code class="literal">2</code>&nbsp;::&nbsp;<code class="literal">3</code>&nbsp;::&nbsp;<code class="literal">4</code>&nbsp;::&nbsp;<code class="typename">Nil</code>
</pre>
      <p>is equivalent to the previous definition of <span class="code">nums</span>.</p>
      <h3>16.4 Basic operations on lists</h3>
      <p>All operations on lists can be expressed in terms of the following three:<a id="i-735890706-2"></a><a id="i849842526-2"></a><a id="i1657074897-2"></a><a id="i-1093268841-2"></a><a id="i1464399372-2"></a><a id="i1464753276-2"></a></p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> <span class="code">head</span> </td>
            <td> returns the first element of a list </td>
          </tr>
          <tr>
            <td> <span class="code">tail</span> </td>
            <td> returns a list consisting of all elements except the first </td>
          </tr>
          <tr>
            <td> <span class="code">isEmpty</span> </td>
            <td> returns <span class="code">true</span> if the list is empty </td>
          </tr>
        </tbody>
      </table>
      <p>These operations are defined as methods of class <span class="code">List</span>. Some examples are shown in <a href="#tab-lists-basics">Table 16.1</a>. The <span class="code">head</span> and <span class="code">tail</span> methods are defined only for non-empty lists. When selected from an empty list, they throw an exception:</p> <pre>  scala&gt;&nbsp;Nil.head
  <code class="output">java.util.NoSuchElementException:&nbsp;head&nbsp;of&nbsp;empty&nbsp;list</code>
</pre>
      <p>As an example of how lists can be processed, consider sorting the elements of a list of numbers into ascending order. One simple way to do so is <span style="font-style:italic">insertion sort</span>,<a id="i132601811-1"></a><a id="i-1814033297-1"></a> which works as follows: To sort a non-empty list <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span>, sort the remainder <span class="code">xs</span> and insert the first element <span class="code">x</span> at the right position in the result. Sorting an empty list yields the empty list. Expressed as Scala code, the insertion sort algorithm looks like:</p> <pre>  <code class="vem">def</code>&nbsp;isort(xs:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">List[Int]</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(xs.isEmpty)&nbsp;<code class="typename">Nil</code>
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;insert(xs.head,&nbsp;isort(xs.tail))
  <br>  <code class="vem">def</code>&nbsp;insert(x:&nbsp;<code class="typename">Int</code>,&nbsp;xs:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">List[Int]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(xs.isEmpty&nbsp;||&nbsp;x&nbsp;&lt;=&nbsp;xs.head)&nbsp;x&nbsp;::&nbsp;xs
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;xs.head&nbsp;::&nbsp;insert(x,&nbsp;xs.tail)
</pre>
      <p><a id="tab-lists-basics"></a></p>
      <h5>Table 16.1 - Basic list operations</h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </td>
              <td> <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span> </td>
            </tr>
            <tr class="topline ">
              <td> <span class="code">empty.isEmpty</span> </td>
              <td> returns <span class="code">true</span> </td>
            </tr>
            <tr>
              <td> <span class="code">fruit.isEmpty</span> </td>
              <td> returns <span class="code">false</span> </td>
            </tr>
            <tr>
              <td> <span class="code">fruit.head</span> </td>
              <td> returns <span class="code">"apples"</span> </td>
            </tr>
            <tr>
              <td> <span class="code">fruit.tail.head</span> </td>
              <td> returns <span class="code">"oranges"</span> </td>
            </tr>
            <tr class="bottomline">
              <td> <span class="code">diag3.head</span> </td>
              <td> returns <span class="code">List(1,</span>&nbsp;<span class="code">0,</span>&nbsp;<span class="code">0)</span> </td>
            </tr>
          </tbody>
        </table>
      </div>
      <h3 id="sec-list-patterns">16.5 List patterns</h3>
      <p>Lists can also be taken apart using pattern matching<a id="i1817770109-1"></a>. List patterns correspond one-by-one to list expressions. You can either match on all elements of a list using a pattern of the form <span class="code">List(...)</span>, or you take lists apart bit by bit using patterns composed from the <span class="code">::</span> operator and the <span class="code">Nil</span> constant.</p>
      <p>Here's an example of the first kind of pattern:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">List</code>(a,&nbsp;b,&nbsp;c)&nbsp;=&nbsp;fruit
  <code class="output">a:&nbsp;String&nbsp;=&nbsp;apples</code>
  <code class="output">b:&nbsp;String&nbsp;=&nbsp;oranges</code>
  <code class="output">c:&nbsp;String&nbsp;=&nbsp;pears</code>
</pre>
      <p>The pattern <span class="code">List(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c)</span> matches lists of length 3, and binds the three elements to the pattern variables <span class="code">a</span>, <span class="code">b</span>, and <span class="code">c</span>. If you don't know the number of list elements beforehand, it's better to match with <span class="code">::</span> instead. For instance, the pattern <span class="code">a</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">rest</span> matches lists of length 2 or greater:</p>
      <div class="aside">
        <h3>About pattern matching on <span class="code">List</span>s</h3>
        <p>If you review the possible forms of patterns explained in <a href="#chap-case-classes-and-pattern-matching">Chapter 15</a>, you might find that neither <span class="code">List(...)</span> nor <span class="code">::</span> look like it fits the kinds of patterns defined there. In fact, <span class="code">List(...)</span> is an instance of a library-defined <em>extractor</em> pattern<a id="i-1414877783-1"></a>. Such patterns will be discussed in <a href="#chap-extractors">Chapter 26</a>. The "cons" pattern <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span> is a special case of an infix operation pattern. As an expression, an infix operation is equivalent to a method call. For patterns, the rules are different: As a pattern, an infix operation such as <span class="code">p</span>&nbsp;<span class="code">op</span>&nbsp;<span class="code">q</span> is equivalent to <span class="code">op(p,</span>&nbsp;<span class="code">q)</span>. That is, the infix operator <span class="code">op</span> is treated as a constructor pattern. In particular, a cons pattern such as <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span> is treated as <span class="code">::(x,</span>&nbsp;<span class="code">xs)</span>.</p>
        <p>This hints that there should be a class named <span class="code">::</span> that corresponds to the pattern constructor. Indeed, there is such a class—it is named <span class="code">scala.::</span> and is exactly the class that builds non-empty lists. So <span class="code">::</span> exists twice in Scala, once as a name of a class in package <span class="code">scala</span> and again as a method in class <span class="code">List</span>. The effect of the method <span class="code">::</span> is to produce an instance of the class <span class="code">scala.::</span>. You'll find out more details about how the List class is implemented in <a href="#chap-implementing-lists">Chapter 22</a>.</p>
      </div> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a&nbsp;::&nbsp;b&nbsp;::&nbsp;rest&nbsp;=&nbsp;fruit
  <code class="output">a:&nbsp;String&nbsp;=&nbsp;apples</code>
  <code class="output">b:&nbsp;String&nbsp;=&nbsp;oranges</code>
  <code class="output">rest:&nbsp;List[String]&nbsp;=&nbsp;List(pears)</code>
</pre>
      <p>Taking<a id="i-986649610-1"></a> lists apart with patterns is an alternative to taking them apart with the basic methods <span class="code">head</span>, <span class="code">tail</span>, and <span class="code">isEmpty</span>. For instance, here's insertion sort<a id="i132601811-2"></a><a id="i-1814033297-2"></a> again, this time written with pattern matching:</p> <pre>  <code class="vem">def</code>&nbsp;isort(xs:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">List[Int]</code>&nbsp;=&nbsp;xs&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;&nbsp;&nbsp;=&gt;&nbsp;<code class="typename">List</code>()
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;insert(x,&nbsp;isort(xs1))
  }
  <br>  <code class="vem">def</code>&nbsp;insert(x:&nbsp;<code class="typename">Int</code>,&nbsp;xs:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">List[Int]</code>&nbsp;=&nbsp;xs&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;&nbsp;=&gt;&nbsp;<code class="typename">List</code>(x)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;y&nbsp;::&nbsp;ys&nbsp;=&gt;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;&lt;=&nbsp;y)&nbsp;x&nbsp;::&nbsp;xs&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;y&nbsp;::&nbsp;insert(x,&nbsp;ys)
  }
</pre>
      <p>Often, pattern matching over lists is clearer than decomposing them with methods, so pattern matching should be a part of your list processing toolbox.</p>
      <p>This is all you need to know about lists in Scala to use them correctly. However, there are also a large number of methods that capture common patterns of operations over lists. These methods make list processing programs more concise and often clearer. The next two sections present the most important methods defined in the <span class="code">List</span> class.</p>
      <h3 id="sec-first-order-methods-on-class-list">16.6 First-order methods on class <span class="code">List</span></h3>
      <p>This section explains most first-order methods defined in the <span class="code">List</span><a id="i-570225502-1"></a><a id="i254621440-1"></a> class. A method is <em>first-order</em> if it does not take any functions as arguments<a id="i-461147607-1"></a>. We will also introduce some recommended techniques to structure programs that operate on lists by using two examples.</p>
      <h4>Concatenating two lists</h4>
      <p>An operation similar to <span class="code">::</span> is list concatenation, written<a id="i-1839436249-2"></a> `<span class="code">:::</span>'. Unlike <span class="code">::</span>, <span class="code">:::</span> takes two lists as operands<a id="i55390901-2"></a><a id="i-1436258358-1"></a>. The result of <span class="code">xs</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">ys</span> is a new list that contains all the elements of <span class="code">xs</span>, followed by all the elements of <span class="code">ys</span>.</p>
      <p>Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)&nbsp;:::&nbsp;<code class="typename">List</code>(<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5)</code>
  <br>  scala&gt;&nbsp;<code class="typename">List</code>()&nbsp;:::&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res1:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;:::&nbsp;<code class="typename">List</code>(<code class="literal">4</code>)
  <code class="output">res2:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4)</code>
</pre>
      <p>Like cons, list concatenation associates to the right. An expression like this:</p> <pre>  xs&nbsp;:::&nbsp;ys&nbsp;:::&nbsp;zs
</pre>
      <p>is interpreted like this:</p> <pre>  xs&nbsp;:::&nbsp;(ys&nbsp;:::&nbsp;zs)
</pre>
      <h4>The Divide and Conquer principle</h4>
      <p>Concatenation (<span class="code">:::</span>) is implemented as a method in class <span class="code">List</span>. It<a id="i673902975-1"></a><a id="i1224006146-1"></a> would also be possible to implement concatenation "by hand," using pattern matching on lists. It's instructive to try to do that yourself, because it shows a common way to implement algorithms using lists. First, we'll settle on a signature for the concatenation method, which we'll call <span class="code">append</span>. In order not to mix things up too much, assume that <span class="code">append</span> is defined outside the <span class="code">List</span> class, so it will take the two lists to be concatenated as parameters. These two lists must agree on their element type, but that element type can be arbitrary. This can be expressed by giving <span class="code">append</span> a type parameter<a href="#footnotemain16-3">[3]</a><a id="i-940554758-1"></a> that represents the element type of the two input lists:</p> <pre>  <code class="vem">def</code>&nbsp;append[T](xs:&nbsp;<code class="typename">List[T]</code>,&nbsp;ys:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>
</pre>
      <p>To design the implementation of <span class="code">append</span>, it pays to remember the "divide and conquer" design principle for programs over recursive data structures such as lists. Many algorithms over lists first split an input list into simpler cases using a pattern match. That's the <span style="font-style:italic">divide</span> part of the principle. They then construct a result for each case. If the result is a non-empty list, some of its parts may be constructed by recursive invocations of the same algorithm. That's the <span style="font-style:italic">conquer</span> part of the principle.</p>
      <p>To apply this principle to the implementation of the <span class="code">append</span> method, the first question to ask is on which list to match. This is less trivial in the case of <span class="code">append</span> than for many other methods because there are two choices. However, the subsequent "conquer" phase tells you that you need to construct a list consisting of all elements of both input lists. Since lists are constructed from the back towards the front, <span class="code">ys</span> can remain intact, whereas <span class="code">xs</span> will need to be taken apart and prepended to <span class="code">ys</span>. Thus, it makes sense to concentrate on <span class="code">xs</span> as a source for a pattern match. The most common pattern match over lists simply distinguishes an empty from a non-empty list. So this gives the following outline of an <span class="code">append</span> method:</p> <pre>  <code class="vem">def</code>&nbsp;append[T](xs:&nbsp;<code class="typename">List[T]</code>,&nbsp;ys:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=
  &nbsp;&nbsp;xs&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;???
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;???
  &nbsp;&nbsp;}
</pre>
      <p>All that remains is to fill in the two places marked with <span class="code">???</span>.<a href="#footnotemain16-4">[4]</a><a id="i883954855-1"></a><a id="i1008284442-1"></a> The first such place is the alternative where the input list <span class="code">xs</span> is empty. In this case concatenation yields the second list:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;ys
</pre>
      <p>The second place left open is the alternative where the input list <span class="code">xs</span> consists of some head <span class="code">x</span> followed by a tail <span class="code">xs1</span>. In this case the result is also a non-empty list. To construct a non-empty list you need to know what the head and the tail of that list should be. You know that the first element of the result list is <span class="code">x</span>. As for the remaining elements, these can be computed by appending the second list, <span class="code">ys</span>, to the rest of the first list, <span class="code">xs1</span>.</p>
      <p>This completes the design and gives:</p> <pre>  <code class="vem">def</code>&nbsp;append[T](xs:&nbsp;<code class="typename">List[T]</code>,&nbsp;ys:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=
  &nbsp;&nbsp;xs&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;x&nbsp;::&nbsp;append(xs1,&nbsp;ys)
  &nbsp;&nbsp;}
</pre>
      <p>The computation of the second alternative illustrated the "conquer" part of the divide and conquer principle: Think first what the shape of the desired output should be, then compute the individual parts of that shape, using recursive invocations of the algorithm where appropriate. Finally, construct the output from these parts.</p>
      <h4>Taking the length of a list: <span class="code">length</span></h4>
      <p>The <span class="code">length</span> method computes the length of a list.<a id="i1353349876-2"></a><a id="i-1852559773-2"></a></p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>).length
  <code class="output">res3:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <p>On lists, unlike arrays, <span class="code">length</span> is a relatively expensive operation. It needs to traverse the whole list to find its end, and therefore takes time proportional to the number of elements in the list. That's why it's not a good idea to replace a test such as <span class="code">xs.isEmpty</span> by <span class="code">xs.length</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">0</span>. The result of the two tests is equivalent, but the second one is slower, in particular if the list <span class="code">xs</span> is long.</p>
      <h4>Accessing the end of a list: <span class="code">init</span> and <span class="code">last</span></h4>
      <p>You know already the basic operations <span class="code">head</span> and <span class="code">tail</span>, which respectively take the first element of a list, and the rest of the list except the first element. They each have a dual operation:<a id="i-1293540834-2"></a><a id="i1464438076-2"></a><a id="i1113811620-2"></a><a id="i1464515266-2"></a> <span class="code">last</span> returns the last element of a (non-empty) list, whereas <span class="code">init</span> returns a list consisting of all elements except the last one:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;abcde&nbsp;=&nbsp;<code class="typename">List</code>(<code class="quotedstring">'a'</code>,&nbsp;<code class="quotedstring">'b'</code>,&nbsp;<code class="quotedstring">'c'</code>,&nbsp;<code class="quotedstring">'d'</code>,&nbsp;<code class="quotedstring">'e'</code>)
  <code class="output">abcde:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</code>
  <br>  scala&gt;&nbsp;abcde.last
  <code class="output">res4:&nbsp;Char&nbsp;=&nbsp;e</code>
  <br>  scala&gt;&nbsp;abcde.init
  <code class="output">res5:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d)</code>
</pre>
      <p>Like <span class="code">head</span> and <span class="code">tail</span>, these methods throw an exception when applied to an empty list:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>().init
  <code class="output">java.lang.UnsupportedOperationException:&nbsp;Nil.init</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;scala.List.init(List.scala:544)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="typename">List</code>().last
  <code class="output">java.util.NoSuchElementException:&nbsp;Nil.last</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;scala.List.last(List.scala:563)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;...</code>
</pre>
      <p>Unlike <span class="code">head</span> and <span class="code">tail</span>, which both run in constant time, <span class="code">init</span> and <span class="code">last</span> need to traverse the whole list to compute their result. As a result, they take time proportional to the length of the list.</p>
      <div class="callout">
        <p><br> It's a good idea to organize your data so that most accesses are at the head of a list, rather than the last element. <br></p>
      </div>
      <h4>Reversing lists: <span class="code">reverse</span></h4>
      <p>If at some point in the computation an algorithm demands frequent accesses to the end of a list, it's sometimes better to reverse the list first and work with the result instead. Here's how to do the reversal:<a id="i1817641200-2"></a><a id="i-2051462346-2"></a></p> <pre>  scala&gt;&nbsp;abcde.reverse&nbsp;
  <code class="output">res6:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</code>
</pre>
      <p>Like all other list operations, <span class="code">reverse</span> creates a new list rather than changing the one it operates on. Since lists are immutable, such a change would not be possible anyway. To verify this, check that the original value of <span class="code">abcde</span> is unchanged after the <span class="code">reverse</span> operation:</p> <pre>  scala&gt;&nbsp;abcde
  <code class="output">res7:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</code>
</pre>
      <p>The <span class="code">reverse</span>, <span class="code">init</span>, and <span class="code">last</span> operations satisfy some laws that can be used for reasoning about computations and for simplifying programs.</p>
      <ol>
        <li><span class="code">reverse</span> is its own inverse: <pre>  xs.reverse.reverse&nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;&nbsp;xs
</pre> </li>
        <li><span class="code">reverse</span> turns <span class="code">init</span> to <span class="code">tail</span> and <span class="code">last</span> to <span class="code">head</span>, except that the elements are reversed: <pre>  xs.reverse.init&nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;&nbsp;xs.tail.reverse
  xs.reverse.tail&nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;&nbsp;xs.init.reverse
  xs.reverse.head&nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;&nbsp;xs.last
  xs.reverse.last&nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;&nbsp;xs.head
</pre> </li>
      </ol>
      <p>Reverse could be implemented using concatenation (<span class="code">:::</span>), like in the following method, <span class="code">rev</span>:</p> <pre>  <code class="vem">def</code>&nbsp;rev[T](xs:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=&nbsp;xs&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;rev(xs1)&nbsp;:::&nbsp;<code class="typename">List</code>(x)
  }
</pre>
      <p>However, this method is less efficient than one would hope for. To study the complexity of <span class="code">rev</span>, assume that the list <span class="code">xs</span> has length <span class="code">n</span>. Notice that there are <span class="code">n</span> recursive calls to <span class="code">rev</span>. Each call except the last involves a list concatenation. List concatenation <span class="code">xs</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">ys</span> takes time proportional to the length of its first argument <span class="code">xs</span>. Hence, the total complexity of <span class="code">rev</span> is:</p>
      <div style="text-align: center">
        <p><i>n</i> + (<i>n</i> - 1) + ... + 1 = (1 + <i>n</i>) * <i>n</i> / 2</p>
      </div>
      <p>In other words, <span class="code">rev</span>'s complexity is quadratic in the length of its input argument. This is disappointing when compared to the standard reversal of a mutable, linked list, which has linear complexity. However, the current implementation of <span class="code">rev</span> is not the best implementation possible. In the example starting <a href="#sec-fastrev">here</a>, you will see how to speed it up.</p>
      <h4>Prefixes and suffixes: <span class="code">drop</span>, <span class="code">take</span>, and <span class="code">splitAt</span></h4>
      <p>The <span class="code">drop</span> and <span class="code">take</span> operations<a id="i-1134266499-1"></a><a id="i1464293147-2"></a><a id="i425822536-1"></a><a id="i-1852559773-3"></a><a id="i1464753331-1"></a><a id="i-567585630-1"></a><a id="i-858153663-1"></a> generalize <span class="code">tail</span> and <span class="code">init</span> in that they return arbitrary prefixes or suffixes of a list. The expression "<span class="code">xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n</span>" returns the first <span class="code">n</span> elements of the list <span class="code">xs</span>. If <span class="code">n</span> is greater than <span class="code">xs.length</span>, the whole list <span class="code">xs</span> is returned. The operation "<span class="code">xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n</span>" returns all elements of the list <span class="code">xs</span>, except for the first <span class="code">n</span> ones. If <span class="code">n</span> is greater than <span class="code">xs.length</span>, the empty list is returned.</p>
      <p>The <span class="code">splitAt</span> operation splits the list at a given index, returning a pair of two lists.<a href="#footnotemain16-5">[5]</a> It is defined by the equality:</p>
      <div style="text-align: center">
        <p><span class="code">xs</span>&nbsp;<span class="code">splitAt</span>&nbsp;<span class="code">n</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">(xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n,</span>&nbsp;<span class="code">xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n)</span></p>
      </div>
      <p>However, <span class="code">splitAt</span> avoids traversing the list <span class="code">xs</span> twice. Here are some examples of these three methods:</p> <pre>  scala&gt;&nbsp;abcde&nbsp;take&nbsp;<code class="literal">2</code>
  <code class="output">res8:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b)</code>
  <br>  scala&gt;&nbsp;abcde&nbsp;drop&nbsp;<code class="literal">2</code>
  <code class="output">res9:&nbsp;List[Char]&nbsp;=&nbsp;List(c,&nbsp;d,&nbsp;e)</code>
  <br>  scala&gt;&nbsp;abcde&nbsp;splitAt&nbsp;<code class="literal">2</code>
  <code class="output">res10:&nbsp;(List[Char],&nbsp;List[Char])&nbsp;=&nbsp;(List(a,&nbsp;b),List(c,&nbsp;d,&nbsp;e))</code>
</pre>
      <h4>Element selection: <span class="code">apply</span> and <span class="code">indices</span></h4>
      <p>Random element selection is supported through the <span class="code">apply</span> method;<a id="i-1534184650-1"></a><a id="i-1854381886-1"></a> however it is a less common operation for lists than it is for arrays.</p> <pre>  scala&gt;&nbsp;abcde&nbsp;apply&nbsp;<code class="literal">2</code>&nbsp;<code class="comment">//&nbsp;rare&nbsp;in&nbsp;Scala</code>
  <code class="output">res11:&nbsp;Char&nbsp;=&nbsp;c</code>
</pre>
      <p>As for all other types, <span class="code">apply</span> is implicitly inserted when an object appears in the function position in a method call. So the line above can be shortened to:</p> <pre>  scala&gt;&nbsp;abcde(<code class="literal">2</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;rare&nbsp;in&nbsp;Scala</code>
  <code class="output">res12:&nbsp;Char&nbsp;=&nbsp;c</code>
</pre>
      <p>One reason why random element selection is less popular for lists than for arrays is that <span class="code">xs(n)</span> takes time proportional to the index <span class="code">n</span>. In fact, <span class="code">apply</span> is simply defined by a combination of <span class="code">drop</span> and <span class="code">head</span>:</p>
      <div style="text-align: center">
        <p><span class="code">xs</span>&nbsp;<span class="code">apply</span>&nbsp;<span class="code">n</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">(xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n).head</span></p>
      </div>
      <p>This definition also makes clear that list indices range from 0 up to the length of the list minus one, the same as for arrays. The <span class="code">indices</span> method<a id="i552445480-1"></a><a id="i-1207917573-1"></a> returns a list consisting of all valid indices of a given list:</p> <pre>  scala&gt;&nbsp;abcde.indices
  <code class="output">res13:&nbsp;scala.collection.immutable.Range</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Range(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4)</code>
</pre>
      <h4>Flattening a list of lists: <span class="code">flatten</span></h4>
      <p>The <span class="code">flatten</span> method takes a list of lists and flattens it out to a single list:<a id="i-2107840238-1"></a><a id="i364853848-1"></a></p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>),&nbsp;<code class="typename">List</code>(<code class="literal">3</code>),&nbsp;<code class="typename">List</code>(),&nbsp;<code class="typename">List</code>(<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)).flatten
  <code class="output">res14:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5)</code>
  scala&gt;&nbsp;fruit.map(_.toCharArray).flatten
  <code class="output">res15:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;p,&nbsp;p,&nbsp;l,&nbsp;e,&nbsp;s,&nbsp;o,&nbsp;r,&nbsp;a,&nbsp;n,&nbsp;g,&nbsp;e,&nbsp;</code>
  <code class="output">s,&nbsp;p,&nbsp;e,&nbsp;a,&nbsp;r,&nbsp;s)</code>
</pre>
      <p>It can only be applied to lists whose elements are all lists. Trying to flatten any other list will give a compilation error:<a id="i497448815-1"></a></p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>).flatten
  <code class="output">&lt;console&gt;:8:&nbsp;error:&nbsp;No&nbsp;implicit&nbsp;view&nbsp;available&nbsp;from&nbsp;Int&nbsp;=&gt;&nbsp;</code>
  <code class="output">scala.collection.IterableOnce[B].</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List(1,&nbsp;2,&nbsp;3).flatten</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <h4>Zipping lists: <span class="code">zip</span> and <span class="code">unzip</span></h4>
      <p>The <span class="code">zip</span> operation takes two lists and forms a list of pairs:<a id="i751157423-1"></a><a id="i1986918773-1"></a></p> <pre>  scala&gt;&nbsp;abcde.indices&nbsp;zip&nbsp;abcde
  <code class="output">res17:&nbsp;scala.collection.immutable.IndexedSeq[(Int,&nbsp;Char)]&nbsp;=&nbsp;</code>
  <code class="output">Vector((0,a),&nbsp;(1,b),&nbsp;(2,c),&nbsp;(3,d),&nbsp;(4,e))</code>
</pre>
      <p>If the two lists are of different length, any unmatched elements are dropped:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;zipped&nbsp;=&nbsp;abcde&nbsp;zip&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">zipped:&nbsp;List[(Char,&nbsp;Int)]&nbsp;=&nbsp;List((a,1),&nbsp;(b,2),&nbsp;(c,3))</code>
</pre>
      <p>A useful special case is to zip a list with its index. This is done most efficiently with the <span class="code">zipWithIndex</span> method, which pairs every element of a list with the position where it appears in the list.<a id="i-735272059-1"></a><a id="i896208311-1"></a></p> <pre>  scala&gt;&nbsp;abcde.zipWithIndex
  <code class="output">res18:&nbsp;List[(Char,&nbsp;Int)]&nbsp;=&nbsp;List((a,0),&nbsp;(b,1),&nbsp;(c,2),&nbsp;(d,3),&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;(e,4))</code>
</pre>
      <p>Any list of tuples can also be changed back to a tuple of lists by using the <span class="code">unzip</span> method<a id="i-1730867960-1"></a><a id="i-1835961540-1"></a>:</p> <pre>  scala&gt;&nbsp;zipped.unzip
  <code class="output">res19:&nbsp;(List[Char],&nbsp;List[Int])</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;(List(a,&nbsp;b,&nbsp;c),List(1,&nbsp;2,&nbsp;3))</code>
</pre>
      <p>The <span class="code">zip</span> and <span class="code">unzip</span> methods provide one way to operate on multiple lists together. See <a href="#sec-lists-zipped">Section 16.9</a> for a more efficient way to do this.</p>
      <h4>Displaying lists: <span class="code">toString</span> and <span class="code">mkString</span></h4>
      <p>The <span class="code">toString</span> operation returns the canonical string representation of a list:<a id="i-683244392-1"></a></p> <pre>  scala&gt;&nbsp;abcde.toString
  <code class="output">res20:&nbsp;String&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</code>
</pre>
      <p>If you want a different representation you can use the <span class="code">mkString</span><a id="i1357784029-2"></a><a id="i746937723-2"></a> method. The operation <span class="code">xs</span>&nbsp;<span class="code">mkString</span>&nbsp;<span class="code">(pre,</span>&nbsp;<span class="code">sep,</span>&nbsp;<span class="code">post)</span> involves four<a id="i-205371607-1"></a> operands: the list <span class="code">xs</span> to be displayed, a prefix string <span class="code">pre</span> to be displayed in front of all elements, a separator string <span class="code">sep</span> to be displayed between successive elements, and a postfix string <span class="code">post</span> to be displayed at the end.</p>
      <p>The result of the operation is the string:</p>
      <div style="text-align: center">
        <p><span class="code">pre</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">xs(0)</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">sep</span>&nbsp;<span class="code">+</span> ...<span class="code">+</span>&nbsp;<span class="code">sep</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">xs(xs.length</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1)</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">post</span></p>
      </div>
      <p>The <span class="code">mkString</span> method has two overloaded variants that let you drop some or all of its arguments. The first variant only takes a separator string:</p>
      <div style="text-align: center">
        <p><span class="code">xs</span>&nbsp;<span class="code">mkString</span>&nbsp;<span class="code">sep</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">xs.mkString("",</span>&nbsp;<span class="code">sep,</span>&nbsp;<span class="code">"")</span></p>
      </div>
      <p>The second variant lets you omit all arguments:</p>
      <div style="text-align: center">
        <p><span class="code">xs.mkString</span>&nbsp;<span class="code"></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">xs</span>&nbsp;<span class="code">mkString</span>&nbsp;<span class="code">""</span></p>
      </div>
      <p>Here are some examples:</p> <pre>  scala&gt;&nbsp;abcde.mkString(<code class="quotedstring">"["</code>,&nbsp;<code class="quotedstring">","</code>,&nbsp;<code class="quotedstring">"]"</code>)
  <code class="output">res21:&nbsp;String&nbsp;=&nbsp;[a,b,c,d,e]</code>
  <br>  scala&gt;&nbsp;abcde&nbsp;mkString&nbsp;<code class="quotedstring">""</code>
  <code class="output">res22:&nbsp;String&nbsp;=&nbsp;abcde</code>
  <br>  scala&gt;&nbsp;abcde.mkString
  <code class="output">res23:&nbsp;String&nbsp;=&nbsp;abcde</code>
  <br>  scala&gt;&nbsp;abcde.mkString(<code class="quotedstring">"List("</code>,&nbsp;<code class="quotedstring">",&nbsp;"</code>,&nbsp;<code class="quotedstring">")"</code>)
  <code class="output">res24:&nbsp;String&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</code>
</pre>
      <p>There are also variants of the <span class="code">mkString</span> methods called <span class="code">addString</span><a id="i-1095177571-1"></a><a id="i-454878362-1"></a> which append the constructed string to a <span class="code">StringBuilder</span> object,<a href="#footnotemain16-6">[6]</a> rather than returning them as a result:<a id="i-2123413502-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">StringBuilder</code>
  <code class="output">buf:&nbsp;StringBuilder&nbsp;=</code>
  <br>  scala&gt;&nbsp;abcde.addString(buf,&nbsp;<code class="quotedstring">"("</code>,&nbsp;<code class="quotedstring">";"</code>,&nbsp;<code class="quotedstring">")"</code>)
  <code class="output">res25:&nbsp;StringBuilder&nbsp;=&nbsp;(a;b;c;d;e)</code>
</pre>
      <p>The <span class="code">mkString</span> and <span class="code">addString</span> methods are inherited from <span class="code">List</span>'s super trait <span class="code">Iterable</span>, so they are applicable to all other collections as well.</p>
      <h4>Converting lists: <span class="code">iterator</span>, <span class="code">toArray</span>, <span class="code">copyToArray</span></h4>
      <p>To convert data between the flat world of arrays and the recursive world of lists, you can use method <span class="code">toArray</span> in class <span class="code">List</span> and <span class="code">toList</span> in class <span class="code">Array</span>:<a id="i-1473690452-1"></a><a id="i-1723195748-1"></a><a id="i-38723342-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;abcde.toArray
  <code class="output">arr:&nbsp;Array[Char]&nbsp;=&nbsp;Array(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</code>
  <br>  scala&gt;&nbsp;arr.toList
  <code class="output">res26:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</code>
</pre>
      <p>There's also a method <span class="code">copyToArray</span>,<a id="i1315859366-1"></a><a id="i-1677368899-1"></a> which copies list elements to successive array positions within some destination array. The operation:</p> <pre>  xs.copyToArray(arr,&nbsp;start)
</pre>
      <p>copies all elements of the list <span class="code">xs</span> to the array <span class="code">arr</span>, beginning with position <span class="code">start</span>. You must ensure that the destination array <span class="code">arr</span> is large enough to hold the list in full. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;arr2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[Int]</code>(<code class="literal">10</code>)
  <code class="output">arr2:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</code>
  <br>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>).copyToArray(arr2,&nbsp;<code class="literal">3</code>)
  <br>  scala&gt;&nbsp;arr2
  <code class="output">res28:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;0,&nbsp;0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</code>
</pre>
      <p>Finally, if you need to access list elements via an iterator, you can use the <span class="code">iterator</span> method:<a id="i2075720641-1"></a><a id="i-2018755942-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;abcde.iterator
  <code class="output">it:&nbsp;Iterator[Char]&nbsp;=&nbsp;&lt;iterator&gt;</code>
</pre> <pre>  scala&gt;&nbsp;it.next
  <code class="output">res29:&nbsp;Char&nbsp;=&nbsp;a</code>
  <br>  scala&gt;&nbsp;it.next
  <code class="output">res30:&nbsp;Char&nbsp;=&nbsp;b</code>
</pre>
      <h4>Example: Merge sort</h4>
      <p>The insertion sort presented earlier is concise to write, but it is not very efficient. Its average complexity is proportional to the<a id="i-2095646335-1"></a> square of the length of the input list. A more efficient algorithm is <span style="font-style:italic">merge sort</span>.<a id="i-1435795620-1"></a><a id="i-1149295482-1"></a></p>
      <div class="pointofinterest">
        <h3>The fast track</h3>
        <p>This example provides another illustration of the divide and conquer principle and currying, as well as a useful discussion of algorithmic complexity. If you prefer to move a bit faster on your first pass through this book, however, you can safely skip to <a href="#sec-higher-order-methods">Section 16.7</a>.</p>
      </div>
      <p>Merge sort works as follows: First, if the list has zero or one elements, it is already sorted, so the list can be returned unchanged. Longer lists are split into two sub-lists, each containing about half the elements of the original list. Each sub-list is sorted by a recursive call to the sort function, and the resulting two sorted lists are then combined in a merge operation.</p>
      <p>For a general implementation of merge sort, you want to leave open the type of list elements to be sorted and the function to be used for the comparison of elements. You obtain a function of maximal generality by passing these two items as parameters. This leads to the implementation shown in <a href="#lst-merge-sort-function">Listing 16.1</a>.</p>
      <p><a id="lst-merge-sort-function"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;msort[T](less:&nbsp;(T,&nbsp;T)&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xs:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;merge(xs:&nbsp;<code class="typename">List[T]</code>,&nbsp;ys:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xs,&nbsp;ys)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(<code class="typename">Nil</code>,&nbsp;_)&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(_,&nbsp;<code class="typename">Nil</code>)&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(x&nbsp;::&nbsp;xs1,&nbsp;y&nbsp;::&nbsp;ys1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(less(x,&nbsp;y))&nbsp;x&nbsp;::&nbsp;merge(xs1,&nbsp;ys)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;y&nbsp;::&nbsp;merge(xs,&nbsp;ys1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;n&nbsp;=&nbsp;xs.length&nbsp;/&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;(ys,&nbsp;zs)&nbsp;=&nbsp;xs&nbsp;splitAt&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merge(msort(less)(ys),&nbsp;msort(less)(zs))
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 16.1 - A merge sort function for <span class="code">List</span>s.</h5>
      <p>The complexity of <span class="code">msort</span> is order (<i>n</i> <i>log</i>(<i>n</i>)), where <i>n</i> is the length of the input list. To see why, note that splitting a list in two and merging two sorted lists each take time proportional to the length of the argument list(s). Each recursive call of <span class="code">msort</span> halves the number of elements in its input, so there are about <i>log</i>(<i>n</i>) consecutive recursive calls until the base case of lists of length 1 is reached. However, for longer lists each call spawns off two further calls. Adding everything up, we obtain at each of the <i>log</i>(<i>n</i>) call levels, every element of the original lists takes part in one split operation and one merge operation.</p>
      <p>Hence, every call level has a total cost proportional to <i>n</i>. Since there are <i>log</i>(<i>n</i>) call levels, we obtain an overall cost proportional to <i>n</i> <i>log</i>(<i>n</i>). That cost does not depend on the initial distribution of elements in the list, so the worst case cost is the same as the average case cost. This property makes merge sort an attractive algorithm for sorting lists.</p>
      <p>Here is an example of how <span class="code">msort</span> is used:</p> <pre>  scala&gt;&nbsp;msort((x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;&lt;&nbsp;y)(<code class="typename">List</code>(<code class="literal">5</code>,&nbsp;<code class="literal">7</code>,&nbsp;<code class="literal">1</code>,&nbsp;<code class="literal">3</code>))
  <code class="output">res31:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;3,&nbsp;5,&nbsp;7)</code>
</pre>
      <p>The <span class="code">msort</span> function is a classical example of the currying concept discussed in <a href="#sec-currying">Section 9.3</a>. Currying<a id="i575993339-2"></a> makes it easy to specialize the function for particular comparison functions. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;intSort&nbsp;=&nbsp;msort((x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;&lt;&nbsp;y)&nbsp;_
  <code class="output">intSort:&nbsp;List[Int]&nbsp;=&gt;&nbsp;List[Int]&nbsp;=&nbsp;&lt;function1&gt;</code>
</pre>
      <p>The <span class="code">intSort</span> variable refers to a function that takes a list of integers and sorts them in numerical order.<a id="i1128745740-2"></a><a id="i1834060518-2"></a><a id="i1842232449-2"></a> As described in <a href="#sec-partially-applied-functions">Section 8.6</a>, an underscore stands for a missing argument list. In this case, the missing argument is the list that should be sorted. As another example, here's how you could define a function that sorts a list of integers in reverse numerical order:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;reverseIntSort&nbsp;=&nbsp;msort((x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;y)&nbsp;_
  <code class="output">reverseIntSort:&nbsp;(List[Int])&nbsp;=&gt;&nbsp;List[Int]&nbsp;=&nbsp;&lt;function&gt;</code>
</pre>
      <p>Because you provided the comparison function already via currying, you now need only provide the list to sort when you invoke the <span class="code">intSort</span> or <span class="code">reverseIntSort</span> functions. Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;mixedInts&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">4</code>,&nbsp;<code class="literal">1</code>,&nbsp;<code class="literal">9</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">5</code>,&nbsp;<code class="literal">8</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">6</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">7</code>)
  <code class="output">mixedInts:&nbsp;List[Int]&nbsp;=&nbsp;List(4,&nbsp;1,&nbsp;9,&nbsp;0,&nbsp;5,&nbsp;8,&nbsp;3,&nbsp;6,&nbsp;2,&nbsp;7)</code>
  <br>  scala&gt;&nbsp;intSort(mixedInts)
  <code class="output">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</code>
  <br>  scala&gt;&nbsp;reverseIntSort(mixedInts)
  <code class="output">res1:&nbsp;List[Int]&nbsp;=&nbsp;List(9,&nbsp;8,&nbsp;7,&nbsp;6,&nbsp;5,&nbsp;4,&nbsp;3,&nbsp;2,&nbsp;1,&nbsp;0)</code>
</pre>
      <h3 id="sec-higher-order-methods">16.7 Higher-order methods on class <span class="code">List</span></h3>
      <p>Many operations over lists have a similar structure. Several patterns appear time and time again.<a id="i-1450817245-1"></a><a id="i1952802169-1"></a> Some examples are: transforming every element of a list in some way, verifying whether a property holds for all elements of a list, extracting from a list elements satisfying a certain criterion, or combining the elements of a list using some operator. In Java, such patterns would usually be expressed by idiomatic combinations of <span class="code">for</span> or <span class="code">while</span> loops. In Scala, they can be expressed more concisely and directly using higher-order operators,<a href="#footnotemain16-7">[7]</a> which are implemented as methods in class <span class="code">List</span>. These higher-order operators are discussed in this section.</p>
      <h4>Mapping over lists: <span class="code">map</span>, <span class="code">flatMap</span> and <span class="code">foreach</span></h4>
      <p>The operation <span class="code">xs</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">f</span><a id="i395196522-2"></a><a id="i1986906032-2"></a> takes as operands a list <span class="code">xs</span> of type <span class="code">List[T]</span> and a function <span class="code">f</span> of type <span class="code">T</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">U</span>. It returns the list that results from applying the function <span class="code">f</span> to each list element in <span class="code">xs</span>. For instance:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)
  <code class="output">res32:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;3,&nbsp;4)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;words&nbsp;=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"the"</code>,&nbsp;<code class="quotedstring">"quick"</code>,&nbsp;<code class="quotedstring">"brown"</code>,&nbsp;<code class="quotedstring">"fox"</code>)
  <code class="output">words:&nbsp;List[String]&nbsp;=&nbsp;List(the,&nbsp;quick,&nbsp;brown,&nbsp;fox)</code>
  <br>  scala&gt;&nbsp;words&nbsp;map&nbsp;(_.length)
  <code class="output">res33:&nbsp;List[Int]&nbsp;=&nbsp;List(3,&nbsp;5,&nbsp;5,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;words&nbsp;map&nbsp;(_.toList.reverse.mkString)
  <code class="output">res34:&nbsp;List[String]&nbsp;=&nbsp;List(eht,&nbsp;kciuq,&nbsp;nworb,&nbsp;xof)</code>
</pre>
      <p>The <span class="code">flatMap</span><a id="i535160876-1"></a><a id="i364816247-1"></a> operator is similar to <span class="code">map</span>, but it takes a function returning a list of elements as its right operand. It applies the function to each list element and returns the concatenation of all function results. The difference between <span class="code">map</span> and <span class="code">flatMap</span> is illustrated in the following example:</p> <pre>  scala&gt;&nbsp;words&nbsp;map&nbsp;(_.toList)
  <code class="output">res35:&nbsp;List[List[Char]]&nbsp;=&nbsp;List(List(t,&nbsp;h,&nbsp;e),&nbsp;List(q,&nbsp;u,&nbsp;i,&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;c,&nbsp;k),&nbsp;List(b,&nbsp;r,&nbsp;o,&nbsp;w,&nbsp;n),&nbsp;List(f,&nbsp;o,&nbsp;x))</code>
  <br>  scala&gt;&nbsp;words&nbsp;flatMap&nbsp;(_.toList)
  <code class="output">res36:&nbsp;List[Char]&nbsp;=&nbsp;List(t,&nbsp;h,&nbsp;e,&nbsp;q,&nbsp;u,&nbsp;i,&nbsp;c,&nbsp;k,&nbsp;b,&nbsp;r,&nbsp;o,&nbsp;w,&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;n,&nbsp;f,&nbsp;o,&nbsp;x)</code>
</pre>
      <p>You see that where <span class="code">map</span> returns a list of lists, <span class="code">flatMap</span> returns a single list in which all element lists are concatenated.</p>
      <p>The differences and interplay between <span class="code">map</span> and <span class="code">flatMap</span> are also demonstrated by the following expression, which constructs a list of all pairs (<i>i</i>, <i>j</i>) such that 1 ≤ <i>j</i> &lt; <i>i</i> &lt; 5:</p> <pre>  scala&gt;&nbsp;List.range(<code class="literal">1</code>,&nbsp;<code class="literal">5</code>)&nbsp;flatMap&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&gt;&nbsp;List.range(<code class="literal">1</code>,&nbsp;i)&nbsp;map&nbsp;(j&nbsp;=&gt;&nbsp;(i,&nbsp;j))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <code class="output">res37:&nbsp;List[(Int,&nbsp;Int)]&nbsp;=&nbsp;List((2,1),&nbsp;(3,1),&nbsp;(3,2),&nbsp;(4,1),&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;(4,2),&nbsp;(4,3))</code>
</pre>
      <p><span class="code">List.range</span> is a utility method that creates a list of all integers in some range.<a id="i2103556958-1"></a><a id="i1320308892-1"></a> It is used twice in this example: once to generate a list of integers from 1 (including) until 5 (excluding), and a second time to generate a list of integers from 1 until <i>i</i>, for each value of <i>i</i> taken from the first list. The <span class="code">map</span> in this expression generates a list of tuples (<i>i</i>, <i>j</i>) where <i>j</i> &lt; <i>i</i>. The outer <span class="code">flatMap</span> in this example generates this list for each <span class="code">i</span> between 1 and 5, and then concatenates all the results. Alternatively, the same list can be constructed with a <span class="code">for</span> expression:</p> <pre>  <code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;List.range(<code class="literal">1</code>,&nbsp;<code class="literal">5</code>);&nbsp;j&nbsp;&lt;-&nbsp;List.range(<code class="literal">1</code>,&nbsp;i))&nbsp;<code class="vem">yield</code>&nbsp;(i,&nbsp;j)
</pre>
      <p>You'll learn more about the interplay of <span class="code">for</span> expressions and list operations in <a href="#chap-for-expressions-revisited.html">Chapter 23</a>.</p>
      <p>The third map-like operation is <span class="code">foreach</span>.<a id="i331113560-2"></a><a id="i465975966-2"></a> Unlike <span class="code">map</span> and <span class="code">flatMap</span>, however, <span class="code">foreach</span> takes a procedure (a function with result type <span class="code">Unit</span>) as right operand. It simply applies the procedure to each list element. The result of the operation itself is again <span class="code">Unit</span>; no list of results is assembled. As an example, here is a concise way of summing up all numbers in a list:</p> <pre>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="output">sum:&nbsp;Int&nbsp;=&nbsp;0</code>
  <br>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)&nbsp;foreach&nbsp;(sum&nbsp;+=&nbsp;_)
  <br>  scala&gt;&nbsp;sum
  <code class="output">res39:&nbsp;Int&nbsp;=&nbsp;15</code>
</pre>
      <h4>Filtering lists: <span class="code">filter</span>, <span class="code">partition</span>, <span class="code">find</span>, <span class="code">takeWhile</span>, <span class="code">dropWhile</span>, and <span class="code">span</span></h4>
      <p>The operation "<span class="code">xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p</span>" takes as operands a list <span class="code">xs</span> of type <span class="code">List[T]</span><a id="i1807572102-2"></a><a id="i-1514694492-2"></a> and a predicate function <span class="code">p</span> of type <span class="code">T</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span>. It yields the list of all elements <span class="code">x</span> in <span class="code">xs</span> for which <span class="code">p(x)</span> is <span class="code">true</span>. For instance:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)&nbsp;filter&nbsp;(_&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">0</code>)
  <code class="output">res40:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;4)</code>
  <br>  scala&gt;&nbsp;words&nbsp;filter&nbsp;(_.length&nbsp;==&nbsp;<code class="literal">3</code>)
  <code class="output">res41:&nbsp;List[String]&nbsp;=&nbsp;List(the,&nbsp;fox)</code>
</pre>
      <p>The <span class="code">partition</span><a id="i-944990523-1"></a><a id="i2039424574-1"></a> method is like filter but returns a pair of lists. One list contains all elements for which the predicate is true, while the other contains all elements for which the predicate is false. It is defined by the equality:</p>
      <div style="text-align: center">
        <p><span class="code">xs</span>&nbsp;<span class="code">partition</span>&nbsp;<span class="code">p</span>&nbsp;<span class="code"></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">(xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p,</span>&nbsp;<span class="code">xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">(!p(_)))</span></p>
      </div>
      <p>Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)&nbsp;partition&nbsp;(_&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">0</code>)
  <code class="output">res42:&nbsp;(List[Int],&nbsp;List[Int])&nbsp;=&nbsp;(List(2,&nbsp;4),List(1,&nbsp;3,&nbsp;5))</code>
</pre>
      <p>The <span class="code">find</span><a id="i383310678-1"></a><a id="i1464344037-1"></a> method is also similar to <span class="code">filter</span>, but it returns the first element satisfying a given predicate, rather than all such elements. The operation <span class="code">xs</span>&nbsp;<span class="code">find</span>&nbsp;<span class="code">p</span> takes a list <span class="code">xs</span> and a predicate <span class="code">p</span> as operands. It returns an optional value. If there is an element <span class="code">x</span> in <span class="code">xs</span> for which <span class="code">p(x)</span> is true, <span class="code">Some(x)</span> is returned. Otherwise, <span class="code">p</span> is false for all elements, and <span class="code">None</span> is returned. Here are some examples:</p> <pre>  scala&gt;&nbsp;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)&nbsp;find&nbsp;(_&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">0</code>)
  <code class="output">res43:&nbsp;Option[Int]&nbsp;=&nbsp;Some(2)</code>
  <br>  scala&gt;&nbsp;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)&nbsp;find&nbsp;(_&nbsp;&lt;=&nbsp;<code class="literal">0</code>)
  <code class="output">res44:&nbsp;Option[Int]&nbsp;=&nbsp;None</code>
</pre>
      <p>The <span class="code">takeWhile</span><a id="i-334215483-1"></a><a id="i1035564606-1"></a> and <span class="code">dropWhile</span><a id="i-648573139-1"></a><a id="i-976962346-1"></a> operators also take a predicate as their right operand. The operation <span class="code">xs</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p</span> takes the longest prefix of list <span class="code">xs</span> such that every element in the prefix satisfies <span class="code">p</span>. Analogously, the operation <span class="code">xs</span>&nbsp;<span class="code">dropWhile</span>&nbsp;<span class="code">p</span> removes the longest prefix from list <span class="code">xs</span> such that every element in the prefix satisfies <span class="code">p</span>. Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;-<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)&nbsp;takeWhile&nbsp;(_&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res45:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;words&nbsp;dropWhile&nbsp;(_&nbsp;startsWith&nbsp;<code class="quotedstring">"t"</code>)
  <code class="output">res46:&nbsp;List[String]&nbsp;=&nbsp;List(quick,&nbsp;brown,&nbsp;fox)</code>
</pre>
      <p>The <span class="code">span</span><a id="i772550245-1"></a><a id="i1464737654-1"></a> method combines <span class="code">takeWhile</span> and <span class="code">dropWhile</span> in one operation, just like <span class="code">splitAt</span> combines <span class="code">take</span> and <span class="code">drop</span>. It returns a pair of two lists, defined by the equality:</p>
      <div style="text-align: center">
        <p><span class="code">xs</span>&nbsp;<span class="code">span</span>&nbsp;<span class="code">p</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">(xs</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p,</span>&nbsp;<span class="code">xs</span>&nbsp;<span class="code">dropWhile</span>&nbsp;<span class="code">p)</span></p>
      </div>
      <p>Like <span class="code">splitAt</span>, <span class="code">span</span> avoids traversing the list <span class="code">xs</span> twice:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;-<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)&nbsp;span&nbsp;(_&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">res47:&nbsp;(List[Int],&nbsp;List[Int])&nbsp;=&nbsp;(List(1,&nbsp;2,&nbsp;3),List(-4,&nbsp;5))</code>
</pre>
      <h4>Predicates over lists: <span class="code">forall</span> and <span class="code">exists</span></h4>
      <p>The operation <span class="code">xs</span>&nbsp;<span class="code">forall</span>&nbsp;<span class="code">p</span><a id="i260029766-2"></a><a id="i-1508992668-2"></a> takes as arguments a list <span class="code">xs</span> and a predicate <span class="code">p</span>. Its result is <span class="code">true</span> if all elements in the list satisfy <span class="code">p</span>. Conversely, the operation <span class="code">xs</span>&nbsp;<span class="code">exists</span>&nbsp;<span class="code">p</span><a id="i339085162-2"></a><a id="i-1529560696-2"></a> returns <span class="code">true</span> if there is an element in <span class="code">xs</span> that satisfies the predicate <span class="code">p</span>. For instance, to find out whether a matrix represented as a list of lists has a row with only zeroes as elements:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;hasZeroRow(m:&nbsp;<code class="typename">List[List[Int]]</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;exists&nbsp;(row&nbsp;=&gt;&nbsp;row&nbsp;forall&nbsp;(_&nbsp;==&nbsp;<code class="literal">0</code>))
  <code class="output">hasZeroRow:&nbsp;(m:&nbsp;List[List[Int]])Boolean</code>
  <br>  scala&gt;&nbsp;hasZeroRow(diag3)
  <code class="output">res48:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <h4>Folding lists: <span class="code">foldLeft</span> and <span class="code">foldRight</span></h4>
      <p>Another common kind of operation combines the elements of a list with some operator. For instance:</p>
      <div style="text-align: center">
        <p><span class="code">sum(List(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c))</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">0</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">c</span></p>
      </div>
      <p>This is a special instance of a fold operation:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;sum(xs:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;xs.foldLeft(<code class="literal">0</code>)(_&nbsp;+&nbsp;_)&nbsp;
  <code class="output">sum:&nbsp;(xs:&nbsp;List[Int])Int</code>
</pre>
      <p>Similarly:</p>
      <div style="text-align: center">
        <p><span class="code">product(List(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c))</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">1</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">a</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">c</span></p>
      </div>
      <p>is a special instance of this fold operation:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;product(xs:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;xs.foldLeft(<code class="literal">1</code>)(_&nbsp;*&nbsp;_)&nbsp;
  <code class="output">product:&nbsp;(xs:&nbsp;List[Int])Int</code>
</pre>
      <p>The <span class="code">xs.foldLeft(z)(op)</span> operation involves<a id="i-1740081977-1"></a><a id="i1387030996-1"></a> three objects: a start value <span class="code">z</span>, a list <span class="code">xs</span>, and a binary operation <span class="code">op</span>. The result of the fold<a id="i487604192-1"></a> is <span class="code">op</span> applied between successive elements of the list prefixed by <span class="code">z</span>. For instance:</p>
      <div style="text-align: center">
        <p><span class="code">List(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c).foldLeft(z)(op)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">op(op(op(z,</span>&nbsp;<span class="code">a),</span>&nbsp;<span class="code">b),</span>&nbsp;<span class="code">c)</span></p>
      </div>
      <p>Or, graphically:</p>
      <div style="text-align: center">
        <img src="optree1160.png" alt="images/optree1160.png">
      </div>
      <p>Here's another example that illustrates how <span class="code">foldLeft</span> is used. To concatenate all words in a list of strings with spaces between them and in front, you can write this:</p> <pre>  scala&gt;&nbsp;&nbsp;words.foldLeft(<code class="quotedstring">""</code>)(_&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;_)
  <code class="output">res49:&nbsp;String&nbsp;=&nbsp;"&nbsp;the&nbsp;quick&nbsp;brown&nbsp;fox"</code>
</pre>
      <p>This gives an extra space at the beginning. To remove the space, you can use this slight variation:</p> <pre>  scala&gt;&nbsp;words.tail.foldLeft(words.head)(_&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;_)
  <code class="output">res50:&nbsp;String&nbsp;=&nbsp;the&nbsp;quick&nbsp;brown&nbsp;fox</code>
</pre>
      <p>The <span class="code">foldLeft</span> operation produces left-leaning operation trees. There is an analog, <span class="code">foldRight</span>,<a id="i411005876-1"></a><a id="i-2058478237-1"></a><a id="i53948911-1"></a> that produces right-leaning trees. For instance:</p>
      <div style="text-align: center">
        <p><span class="code">List(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c).foldRight(z)(op)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">op(a,</span>&nbsp;<span class="code">op(b,</span>&nbsp;<span class="code">op(c,</span>&nbsp;<span class="code">z)))</span></p>
      </div>
      <p>Or, graphically:</p>
      <div style="text-align: center">
        <img src="optree2160.png" alt="images/optree2160.png">
      </div>
      <p>For associative operations, fold left and fold right are equivalent, but there might be a difference in efficiency.<a id="i-1099454431-1"></a> Consider for instance an operation corresponding to the <span class="code">flatten</span> method, which concatenates all elements in a list of lists.<a id="i-652692760-1"></a><a id="i364853848-2"></a> This could be implemented with either fold left or fold right:</p> <pre>  <code class="vem">def</code>&nbsp;flattenLeft[T](xss:&nbsp;<code class="typename">List[List[T]]</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;xss.foldLeft(<code class="typename">List[T]</code>())(_&nbsp;:::&nbsp;_)
  <br>  <code class="vem">def</code>&nbsp;flattenRight[T](xss:&nbsp;<code class="typename">List[List[T]]</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;xss.foldRight(<code class="typename">List[T]</code>())(_&nbsp;:::&nbsp;_)
</pre>
      <p><a id="exa-flatten-right-body"></a> Because list concatenation, <span class="code">xs</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">ys</span>, takes time proportional to its first argument <span class="code">xs</span>, the implementation in terms of fold right in <span class="code">flattenRight</span> is more efficient than the fold left implementation in <span class="code">flattenLeft</span>. The problem is that <span class="code">flattenLeft(xss)</span> copies the first element list <span class="code">xss.head</span> <i>n</i>-1 times, where <i>n</i> is the length of the list <span class="code">xss</span>.</p>
      <p>Note that both versions of <span class="code">flatten</span> require a type annotation on the empty list that is the start value of the fold. This is due to a limitation in Scala's type inferencer, which fails to infer the correct type of the list automatically. If you try to leave out the annotation, you get the following:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;flattenRight[T](xss:&nbsp;<code class="typename">List[List[T]]</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xss.foldRight(<code class="typename">List</code>())(_&nbsp;:::&nbsp;_)
  <code class="output">&lt;console&gt;:8:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;List[T]</code>
  <code class="output">&nbsp;required:&nbsp;List[Nothing]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xss.foldRight(List())(_&nbsp;:::&nbsp;_)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>To find out why the type inferencer goes wrong, you'll need to know about the types of the fold methods and how they are implemented. More on this in <a href="#sec-understanding-scalas-type-inference-algorithm">Section 16.10</a>.</p>
      <h4>Example: List reversal using fold</h4>
      <p><a id="sec-fastrev"></a></p>
      <p>Earlier in the chapter you saw an implementation of method <span class="code">reverse</span>, named <span class="code">rev</span>, whose running time was quadratic in the length of the list to be reversed. Here is a different implementation of <span class="code">reverse</span> that has linear cost. The idea is to use a fold left operation based on the following scheme:</p> <pre>  <code class="vem">def</code>&nbsp;reverseLeft[T](xs:&nbsp;<code class="typename">List[T]</code>)&nbsp;=
  &nbsp;&nbsp;xs.foldLeft(<i>startvalue</i>)(<i>operation</i>)
</pre>
      <p>What remains is to fill in the <i>startvalue</i> and <i>operation</i> parts. In fact, you can try to deduce these parts from some simple examples. To deduce the correct value of <i>startvalue</i>, you can start with the smallest possible list, <span class="code">List()</span>, and calculate as follows:</p> <pre>  <code class="typename">List</code>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;<code class="rm">(by the properties of <code class="code">reverseLeft</code>)</code>
  <br>  reverseLeft(<code class="typename">List</code>())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;<code class="rm">(by the template for <code class="code">reverseLeft</code>)</code>
  <br>  <code class="typename">List</code>().foldLeft(<i>startvalue</i>)(<i>operation</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;<code class="rm">(by the definition of <code class="code">foldLeft</code>)</code>
  <br>  <i>startvalue</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</pre>
      <p>Hence, <i>startvalue</i> must be <span class="code">List()</span>. To deduce the second operand, you can pick the next smallest list as an example case. You know already that <i>startvalue</i> is <span class="code">List()</span>, so you can calculate as follows:</p> <pre>  <code class="typename">List</code>(x)
  &nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;<code class="rm">(by the properties of <code class="code">reverseLeft</code>)</code>
  <br>  reverseLeft(<code class="typename">List</code>(x))
  &nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;<code class="rm">(by the template for <code class="code">reverseLeft</code>, with</code> <code class="rm"><em>startvalue</em></code> <code class="rm"><code class="code">= List()</code>)</code>
  <br>  <code class="typename">List</code>(x).foldLeft(<code class="typename">List</code>())(<i>operation</i>)&nbsp;
  &nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;<code class="rm">(by the definition of <code class="code">foldLeft</code>)</code>
  <br>  <i>operation</i>(<code class="typename">List</code>(),&nbsp;x)
</pre>
      <p>Hence, <i>operation</i><span class="code">(List(),</span>&nbsp;<span class="code">x)</span> equals <span class="code">List(x)</span>, which can also be written as <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">List()</span>. This suggests taking as <i>operation</i> the <span class="code">::</span> operator with its operands exchanged. (This operation is sometimes called "snoc," in reference<a id="i3535215-1"></a> to <span class="code">::</span>, which is called cons.) We arrive then at the following implementation for <span class="code">reverseLeft</span>:</p> <pre>  <code class="vem">def</code>&nbsp;reverseLeft[T](xs:&nbsp;<code class="typename">List[T]</code>)&nbsp;=
  &nbsp;&nbsp;xs.foldLeft(<code class="typename">List[T]</code>())&nbsp;{&nbsp;(ys,&nbsp;y)&nbsp;=&gt;&nbsp;y&nbsp;::&nbsp;ys&nbsp;}
</pre>
      <p>Again, the type annotation in <span class="code">List[T]()</span> is needed to make the type inferencer work. If you analyze the complexity of <span class="code">reverseLeft</span>, you'll find that it applies a constant-time operation ("snoc") <i>n</i> times, where <i>n</i> is the length of the argument list. Thus, the complexity of <span class="code">reverseLeft</span> is linear.</p>
      <h4>Sorting lists: <span class="code">sortWith</span></h4>
      <p>The operation <span class="code">xs</span>&nbsp;<span class="code">sortWith</span>&nbsp;<span class="code">before</span>, where "xs" is a list and "<span class="code">before</span>" is a function that can be used to compare two elements, sorts the elements of list <span class="code">xs</span>.<a id="i866528360-1"></a><a id="i-1539355216-1"></a> The expression <span class="code">x</span>&nbsp;<span class="code">before</span>&nbsp;<span class="code">y</span> should return <span class="code">true</span> if <span class="code">x</span> should come before <span class="code">y</span> in the intended ordering for the sort. For instance:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;-<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">6</code>)&nbsp;sortWith&nbsp;(_&nbsp;&lt;&nbsp;_)
  <code class="output">res51:&nbsp;List[Int]&nbsp;=&nbsp;List(-3,&nbsp;1,&nbsp;2,&nbsp;4,&nbsp;6)</code>
  <br>  scala&gt;&nbsp;words&nbsp;sortWith&nbsp;(_.length&nbsp;&gt;&nbsp;_.length)
  <code class="output">res52:&nbsp;List[String]&nbsp;=&nbsp;List(quick,&nbsp;brown,&nbsp;the,&nbsp;fox)</code>
</pre>
      <p>Note that <span class="code">sortWith</span> performs a merge sort similar to the <span class="code">msort</span> algorithm shown in the last section. But <span class="code">sortWith</span> is a method of class <span class="code">List</span>, whereas <span class="code">msort</span> is defined outside lists.</p>
      <h3>16.8 Methods of the <span class="code">List</span> object</h3>
      <p>So far, all operations you have seen in this chapter are implemented as methods of class <span class="code">List</span>, so you invoke them on individual list objects. There are also a number of methods in the globally accessible object <span class="code">scala.List</span>, which is the companion object of class <span class="code">List</span>. Some of these operations are factory methods that create lists. Others are operations that work on lists of some specific shape. Both kinds of methods will be presented in this section.</p>
      <h4>Creating lists from their elements: <span class="code">List.apply</span></h4>
      <p>You've already seen on several occasions list literals such as <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>. There's nothing special about their syntax. A literal like <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span><a id="i19484993-2"></a><a id="i1305057997-2"></a> is simply the application of the object <span class="code">List</span> to the elements <span class="code">1</span>, <span class="code">2</span>, <span class="code">3</span>. That is, it is equivalent to <span class="code">List.apply(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>:</p> <pre>  scala&gt;&nbsp;List.apply(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res53:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
</pre>
      <h4>Creating a range of numbers: <span class="code">List.range</span></h4>
      <p>The <span class="code">range</span> method, which you saw briefly earlier in the discussion of <span class="code">map</span> and <span class="code">flatmap</span>, creates a list consisting of a range of numbers. Its simplest form is <span class="code">List.range(from,</span>&nbsp;<span class="code">until)</span>,<a id="i648409480-1"></a><a id="i1320308892-2"></a> which creates a list of all numbers starting at <span class="code">from</span> and going up to <span class="code">until</span> minus one. So the end value, <span class="code">until</span>, does not form part of the range.</p>
      <p>There's also a version of <span class="code">range</span> that takes a <span class="code">step</span> value as third parameter. This operation will yield list elements that are <span class="code">step</span> values apart, starting at <span class="code">from</span>. The <span class="code">step</span> can be positive or negative:</p> <pre>  scala&gt;&nbsp;List.range(<code class="literal">1</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">res54:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4)</code>
  <br>  scala&gt;&nbsp;List.range(<code class="literal">1</code>,&nbsp;<code class="literal">9</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">res55:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;3,&nbsp;5,&nbsp;7)</code>
  <br>  scala&gt;&nbsp;List.range(<code class="literal">9</code>,&nbsp;<code class="literal">1</code>,&nbsp;-<code class="literal">3</code>)
  <code class="output">res56:&nbsp;List[Int]&nbsp;=&nbsp;List(9,&nbsp;6,&nbsp;3)</code>
</pre>
      <h4>Creating uniform lists: <span class="code">List.fill</span></h4>
      <p>The <span class="code">fill</span><a id="i-2061749081-1"></a><a id="i-1204685244-1"></a> method creates a list consisting of zero or more copies of the same element. It takes two parameters: the length of the list to be created, and the element to be repeated. Each parameter is given in a separate list:</p> <pre>  scala&gt;&nbsp;List.fill(<code class="literal">5</code>)(<code class="quotedstring">'a'</code>)
  <code class="output">res57:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;a,&nbsp;a,&nbsp;a,&nbsp;a)</code>
  <br>  scala&gt;&nbsp;List.fill(<code class="literal">3</code>)(<code class="quotedstring">"hello"</code>)
  <code class="output">res58:&nbsp;List[String]&nbsp;=&nbsp;List(hello,&nbsp;hello,&nbsp;hello)</code>
</pre>
      <p>If <span class="code">fill</span> is given more than two arguments, then it will make multi-dimensional lists. That is, it will make lists of lists, lists of lists of lists, <i>etc.</i> The additional arguments go in the first argument list.</p> <pre>  scala&gt;&nbsp;List.fill(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)(<code class="quotedstring">'b'</code>)
  <code class="output">res59:&nbsp;List[List[Char]]&nbsp;=&nbsp;List(List(b,&nbsp;b,&nbsp;b),&nbsp;List(b,&nbsp;b,&nbsp;b))</code>
</pre>
      <h4>Tabulating a function: <span class="code">List.tabulate</span></h4>
      <p>The <span class="code">tabulate</span><a id="i-1627924214-1"></a><a id="i-1127956889-1"></a> method creates a list whose elements are computed according to a supplied function. Its arguments are just like those of <span class="code">List.fill</span>: the first argument list gives the dimensions of the list to create, and the second describes the elements of the list. The only difference is that instead of the elements being fixed, they are computed from a function:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;squares&nbsp;=&nbsp;List.tabulate(<code class="literal">5</code>)(n&nbsp;=&gt;&nbsp;n&nbsp;*&nbsp;n)
  <code class="output">squares:&nbsp;List[Int]&nbsp;=&nbsp;List(0,&nbsp;1,&nbsp;4,&nbsp;9,&nbsp;16)</code>
  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;multiplication&nbsp;=&nbsp;List.tabulate(<code class="literal">5</code>,<code class="literal">5</code>)(_&nbsp;*&nbsp;_)
  <code class="output">multiplication:&nbsp;List[List[Int]]&nbsp;=&nbsp;List(List(0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0),&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;List(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4),&nbsp;List(0,&nbsp;2,&nbsp;4,&nbsp;6,&nbsp;8),</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;List(0,&nbsp;3,&nbsp;6,&nbsp;9,&nbsp;12),&nbsp;List(0,&nbsp;4,&nbsp;8,&nbsp;12,&nbsp;16))</code>
</pre>
      <h4>Concatenating multiple lists: <span class="code">List.concat</span></h4>
      <p>The <span class="code">concat</span><a id="i-214121608-1"></a><a id="i1858358165-1"></a> method concatenates a number of element lists. The lists to be concatenated are supplied as direct arguments to <span class="code">concat</span>:</p> <pre>  scala&gt;&nbsp;List.concat(<code class="typename">List</code>(<code class="quotedstring">'a'</code>,&nbsp;<code class="quotedstring">'b'</code>),&nbsp;<code class="typename">List</code>(<code class="quotedstring">'c'</code>))
  <code class="output">res60:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c)</code>
  <br>  scala&gt;&nbsp;List.concat(<code class="typename">List</code>(),&nbsp;<code class="typename">List</code>(<code class="quotedstring">'b'</code>),&nbsp;<code class="typename">List</code>(<code class="quotedstring">'c'</code>))
  <code class="output">res61:&nbsp;List[Char]&nbsp;=&nbsp;List(b,&nbsp;c)</code>
  <br>  scala&gt;&nbsp;List.concat()
  <code class="output">res62:&nbsp;List[Nothing]&nbsp;=&nbsp;List()</code>
</pre>
      <h3 id="sec-lists-zipped">16.9 Processing multiple lists together</h3>
      <p>You already know the <span class="code">zip</span> method on lists, which creates a list of pairs from two lists, and allows you to operate on the two lists at once:</p> <pre>  scala&gt;&nbsp;(<code class="typename">List</code>(<code class="literal">10</code>,&nbsp;<code class="literal">20</code>)&nbsp;zip&nbsp;<code class="typename">List</code>(<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)).
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;y&nbsp;}
  <code class="output">res63:&nbsp;List[Int]&nbsp;=&nbsp;List(30,&nbsp;80)</code>
</pre>
      <p>The <span class="code">map</span> method for two zipped lists maps pairs of elements rather than individual elements. One pair is for the first element of each list, another pair is for the second element of each list, and so on—as many pairs as the lists are long. Notice that the third element of the second list is discarded. The <span class="code">zip</span> method zips up only as many elements as appear in all the lists together. Any extra elements on the end are discarded.</p>
      <p>One drawback of operating on multiple lists via the <span class="code">zip</span> method is that it creates an intermediate list (after the <span class="code">zip</span> method is called) that is eventually discarded (when the <span class="code">map</span> method is called). Creating this intermediate list can have an important cost if the lists have a lot of elements. Another drawback of this pattern is that the function taken by the <span class="code">map</span> method takes a tuple as parameter, making it impossible to use the placeholder syntax shown in <a href="#sec-placeholder-syntax">Section 8.5</a>.</p>
      <p>The <span class="code">lazyZip</span> method<a id="i-764279812-1"></a><a id="i1103200097-1"></a> solves these two issues. Its syntax is similar to <span class="code">zip</span>:</p> <pre>  scala&gt;&nbsp;(<code class="typename">List</code>(<code class="literal">10</code>,&nbsp;<code class="literal">20</code>)&nbsp;lazyZip&nbsp;<code class="typename">List</code>(<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)).map(_&nbsp;*&nbsp;_)
  <code class="output">res63:&nbsp;List[Int]&nbsp;=&nbsp;List(30,&nbsp;80)</code>
</pre>
      <p>The difference between <span class="code">lazyZip</span> and <span class="code">zip</span> is that <span class="code">lazyZip</span> does not immediately return a collection (hence the "lazy" prefix). Instead, it returns a value that provides methods (including <span class="code">map</span>) operating on the two lazily zipped lists. In the above example, you can see that the <span class="code">map</span> method takes as parameter a function that takes two parameters (as opposed to one pair), allowing the usage of the placeholder syntax.</p>
      <p>There are also lazy zip analogs to <span class="code">exists</span> and <span class="code">forall</span>. They are just like the single-list versions of those methods except they operate on elements from multiple lists instead of just one:</p> <pre>  scala&gt;&nbsp;(<code class="typename">List</code>(<code class="quotedstring">"abc"</code>,&nbsp;<code class="quotedstring">"de"</code>)&nbsp;lazyZip&nbsp;<code class="typename">List</code>(<code class="literal">3</code>,&nbsp;<code class="literal">2</code>)).
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall(_.length&nbsp;==&nbsp;_)
  <code class="output">res64:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  scala&gt;&nbsp;(<code class="typename">List</code>(<code class="quotedstring">"abc"</code>,&nbsp;<code class="quotedstring">"de"</code>)&nbsp;lazyZip&nbsp;<code class="typename">List</code>(<code class="literal">3</code>,&nbsp;<code class="literal">2</code>)).
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists(_.length&nbsp;!=&nbsp;_)
  <code class="output">res65:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <div class="pointofinterest">
        <h3>The fast track</h3>
        <p>In the next (and final) section of this chapter, we provide insight into Scala's type inference algorithm. If you're not interested in such details right now, you can skip the entire section and go straight to the conclusion <a href="#sec-list-conclusion">here</a>.</p>
      </div>
      <h3 id="sec-understanding-scalas-type-inference-algorithm">16.10 Understanding Scala's type inference algorithm</h3>
      <p>One difference<a id="i2062825537-1"></a><a id="i2147374841-1"></a> between the previous uses of <span class="code">sortWith</span> and <span class="code">msort</span> concerns the admissible syntactic forms of the comparison function.</p>
      <p>Compare:</p> <pre>  scala&gt;&nbsp;msort((x:&nbsp;<code class="typename">Char</code>,&nbsp;y:&nbsp;<code class="typename">Char</code>)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;y)(abcde)
  <code class="output">res66:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</code>
</pre>
      <p>with:</p> <pre>  scala&gt;&nbsp;abcde&nbsp;sortWith&nbsp;(_&nbsp;&gt;&nbsp;_)
  <code class="output">res67:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</code>
</pre>
      <p>The two expressions are equivalent, but the first uses a longer form of comparison function with named parameters and explicit types. The second uses the concise form, <span class="code">(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span>, where named parameters are replaced by underscores. Of course, you could also use the first, longer form of comparison with <span class="code">sortWith</span>.</p>
      <p>However, the short form cannot be used with <span class="code">msort</span>.</p> <pre>  scala&gt;&nbsp;msort(_&nbsp;&gt;&nbsp;_)(abcde)
  <code class="output">&lt;console&gt;:12:&nbsp;error:&nbsp;missing&nbsp;parameter&nbsp;type&nbsp;for&nbsp;expanded&nbsp;</code>
  <code class="output">function&nbsp;((x$1,&nbsp;x$2)&nbsp;=&gt;&nbsp;x$1.$greater(x$2))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msort(_&nbsp;&gt;&nbsp;_)(abcde)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>To understand why, you need to know some details of Scala's type inference algorithm. Type inference in Scala is flow based. In a method application <span class="code">m(args)</span>, the inferencer first checks whether the method <span class="code">m</span> has a known type. If it does, that type is used to infer the expected type of the arguments. For instance, in <span class="code">abcde.sortWith(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span>, the type of <span class="code">abcde</span> is <span class="code">List[Char]</span>. Hence, <span class="code">sortWith</span> is known to be a method that takes an argument of type <span class="code">(Char,</span>&nbsp;<span class="code">Char)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span> and produces a result of type <span class="code">List[Char]</span>. Since the parameter types of the function arguments are known, they need not be written explicitly. With what it knows about <span class="code">sortWith</span>, the inferencer can deduce that <span class="code">(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span> should expand to <span class="code">((x:</span>&nbsp;<span class="code">Char,</span>&nbsp;<span class="code">y:</span>&nbsp;<span class="code">Char)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">y)</span> where <span class="code">x</span> and <span class="code">y</span> are some arbitrary fresh names.</p>
      <p>Now consider the second case, <span class="code">msort(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)(abcde)</span>. The type of <span class="code">msort</span> is a curried, polymorphic method type that takes an argument of type <span class="code">(T,</span>&nbsp;<span class="code">T)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span> to a function from <span class="code">List[T]</span> to <span class="code">List[T]</span> <span style="font-style:italic">where <span class="code">T</span> is some as-yet unknown type</span>. The <span class="code">msort</span> method needs to be instantiated with a type parameter before it can be applied to its arguments.</p>
      <p>Because the precise instance type of <span class="code">msort</span> in the application is not yet known, it cannot be used to infer the type of its first argument. The type inferencer changes its strategy in this case; it first type checks method arguments to determine the proper instance type of the method. However, when tasked to type check the short-hand function literal, <span class="code">(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span>, it fails because it has no information about the types of the implicit function parameters that are indicated by underscores.</p>
      <p>One way to resolve the problem is to pass an explicit type parameter to <span class="code">msort</span>, as in:</p> <pre>  scala&gt;&nbsp;msort[<code class="typename">Char</code>](_&nbsp;&gt;&nbsp;_)(abcde)
  <code class="output">res68:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</code>
</pre>
      <p>Because the correct instance type of <span class="code">msort</span> is now known, it can be used to infer the type of the arguments. Another possible solution is to rewrite the <span class="code">msort</span> method so that its parameters are swapped:</p> <pre>  <code class="vem">def</code>&nbsp;msortSwapped[T](xs:&nbsp;<code class="typename">List[T]</code>)(less:
  &nbsp;&nbsp;&nbsp;&nbsp;(T,&nbsp;T)&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;same&nbsp;implementation&nbsp;as&nbsp;msort,</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;but&nbsp;with&nbsp;arguments&nbsp;swapped</code>
  }
</pre>
      <p>Now type inference would succeed:</p> <pre>  scala&gt;&nbsp;msortSwapped(abcde)(_&nbsp;&gt;&nbsp;_)
  <code class="output">res69:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</code>
</pre>
      <p>What has happened is that the inferencer used the known type of the first parameter <span class="code">abcde</span> to determine the type parameter of <span class="code">msortSwapped</span>. Once the precise type of <span class="code">msortSwapped</span> was known, it could be used in turn to infer the type of the second parameter, <span class="code">(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span>.</p>
      <p>Generally, when tasked to infer the type parameters of a polymorphic method, the type inferencer consults the types of all value arguments in the first parameter list but no arguments beyond that. Since <span class="code">msortSwapped</span> is a curried method with two parameter lists, the second argument (<i>i.e.</i>, the function value) did not need to be consulted to determine the type parameter of the method.</p>
      <p>This inference scheme suggests the following library design principle: When designing a polymorphic method that takes some non-function arguments and a function argument, place the function argument last in a curried parameter list on its own<a id="i-1510488017-1"></a>. That way, the method's correct instance type can be inferred from the non-function arguments, and that type can in turn be used to type check the function argument. The net effect is that users of the method will be able to give less type information and write function literals in more compact ways.</p>
      <p>Now to the more complicated case of a <span style="font-style:italic">fold</span> operation. Why is there the need for an explicit type parameter in an expression like the body of the <span class="code">flattenRight</span> method shown <a href="#exa-flatten-right-body">here</a>?</p> <pre>  xss.foldRight(<code class="typename">List[T]</code>())(_&nbsp;:::&nbsp;_)
</pre>
      <p>The type of the <span class="code">foldRight</span> method is polymorphic in two type variables. Given an expression:</p> <pre>  xs.foldRight(z)(op)
</pre>
      <p>The type of <span class="code">xs</span> must be a list of some arbitrary type <span class="code">A</span>, say <span class="code">xs:</span>&nbsp;<span class="code">List[A]</span>. The start value <span class="code">z</span> can be of some other type <span class="code">B</span>. The operation <span class="code">op</span> must then take two arguments of type <span class="code">A</span> and <span class="code">B</span>, and return a result of type <span class="code">B</span>, <i>i.e.</i>, <span class="code">op:</span>&nbsp;<span class="code">(A,</span>&nbsp;<span class="code">B)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">B</span>. Because the type of <span class="code">z</span> is not related to the type of the list <span class="code">xs</span>, type inference has no context information for <span class="code">z</span>.</p>
      <p>Now consider the expression in the erroneous version of <span class="code">flattenRight</span>, also shown <a href="#exa-flatten-right-body">here</a>:</p> <pre>  xss.foldRight(<code class="typename">List</code>())(_&nbsp;:::&nbsp;_)&nbsp;&nbsp;<code class="comment">//&nbsp;this&nbsp;won't&nbsp;compile</code>
</pre>
      <p>The start value <span class="code">z</span> in this fold is an empty list, <span class="code">List()</span>, so without additional type information its type is inferred to be a <span class="code">List[Nothing]</span>. Hence, the inferencer will infer that the <span class="code">B</span> type of the fold is <span class="code">List[Nothing]</span>. Therefore, the operation <span class="code">(_</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">_)</span> of the fold is expected to be of the following type:</p> <pre>  (<code class="typename">List[T]</code>,&nbsp;<code class="typename">List[Nothing]</code>)&nbsp;=&gt;&nbsp;<code class="typename">List[Nothing]</code>
</pre>
      <p>This is indeed a possible type for the operation in that fold but it is not a very useful one! It says that the operation always takes an empty list as second argument and always produces an empty list as result.</p>
      <p>In other words, the type inference settled too early on a type for <span class="code">List()</span>; it should have waited until it had seen the type of the operation <span class="code">op</span>. So the (otherwise very useful) rule to only consider the first argument section in a curried method application for determining the method's type is at the root of the problem here. On the other hand, even if that rule were relaxed, the inferencer still could not come up with a type for <span class="code">op</span> because its parameter types are not given. Hence, there is a Catch-22 situation that can only be resolved by an explicit type annotation from the programmer.</p>
      <p>This example highlights some limitations of the local, flow-based type inference scheme of Scala. It is not present in the more global Hindley-Milner style of type inference used in functional languages, such as ML or Haskell.<a id="i281902151-1"></a><a id="i-402843137-1"></a> However, Scala's local type inference deals much more gracefully with object-oriented subtyping than the Hindley-Milner style does. Fortunately, the limitations show up only in some corner cases, and are usually easily fixed by adding an explicit type annotation.</p>
      <p>Adding type annotations<a id="i-250763219-1"></a><a id="i-2128117477-1"></a> is also a useful debugging technique when you get confused by type error messages related to polymorphic methods. If you are unsure what caused a particular type error, just add some type arguments or other type annotations, which you think are correct. Then you should be able to quickly see where the real problem is.</p>
      <h3 id="sec-list-conclusion">16.11 Conclusion</h3>
      <p>Now you have seen many ways to work with lists. You have seen the basic operations like <span class="code">head</span> and <span class="code">tail</span>, the first-order operations like <span class="code">reverse</span>, the higher-order operations like <span class="code">map</span>, and the utility methods in the <span class="code">List</span> object. Along the way, you learned a bit about how Scala's type inference works.</p>
      <p>Lists are a real work horse in Scala, so you will benefit from knowing how to use them. For that reason, this chapter has delved deeply into how to use lists. Lists are just one kind of collection that Scala supports, however. The next chapter is broad, rather than deep, and shows you how to use a variety of Scala's collection types.</p>
      <hr>
      <h4>Footnotes for Chapter 16:</h4>
      <p><a id="footnotemain16-1"></a>[1] For a graphical depiction of the structure of a <span class="code">List</span>, see <a href="#fig-more-fruit">Figure 22.2</a> <a href="#fig-more-fruit">here</a>.</p>
      <p><a id="footnotemain16-2"></a>[2] <a href="#chap-type-parameterization">Chapter 19</a> gives more details on covariance and other kinds of variance.</p>
      <p><a id="footnotemain16-3"></a>[3] Type parameters will be explained in more detail in <a href="#chap-type-parameterization">Chapter 19</a>.</p>
      <p><a id="footnotemain16-4"></a>[4] The <span class="code">???</span> method, which throws <span class="code">scala.NotImplementedError</span> and has result type <span class="code">Nothing</span>, can be used as a temporary implementation during development.</p>
      <p><a id="footnotemain16-5"></a>[5] As mentioned in <a href="#sec-impl-above-beside-tostring">Section 10.12</a>, the term <em>pair</em> is an informal name for <span class="code">Tuple2</span>.</p>
      <p><a id="footnotemain16-6"></a>[6] This is class <span class="code">scala.StringBuilder</span>, not <span class="code">java.lang.StringBuilder</span>.</p>
      <p><a id="footnotemain16-7"></a>[7] By <em>higher-order operators</em>, we mean higher-order functions used in operator notation. As mentioned in <a href="#sec-reducing-code-dup">Section 9.1</a>, a function is "higher-order" if it takes one or more other functions as parameters.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-working-with-other-collections">Chapter 17</a></h2>
      <h1>Working with Other Collections</h1>
      <p>Scala has a rich collection library. This chapter gives you a tour of the most commonly used collection types and operations, showing just the parts you will use most frequently. <a href="#chap-collections-in-depth">Chapter 24</a> will provide a more comprehensive tour of what's available, and <a href="#chap-the-architecture-of-scala-collections">Chapter 25</a> will show how Scala's composition constructs are used to provide such a rich API. <a id="i1853891989-1"></a></p>
      <h3 id="sec-sequences">17.1 Sequences</h3>
      <p>Sequence types let you work with groups of data lined up in order. Because the elements are ordered, you can ask for the first element, second element, 103rd element, and so on. In this section, we'll give you a quick tour of the most important sequences.</p>
      <h4>Lists</h4>
      <p>Perhaps the most important sequence type to know about is class <span class="code">List</span>,<a id="i882498454-2"></a> the immutable linked-list described in detail in the previous chapter. Lists support fast addition and removal of items to the beginning of the list, but they do not provide fast access to arbitrary indexes because the <a id="i-394736131-1"></a> implementation must iterate through the list linearly.</p>
      <p>This combination of features might sound odd, but they hit a sweet spot that works well for many algorithms. The fast addition and removal of initial elements means that pattern matching works well, as described in <a href="#chap-case-classes-and-pattern-matching">Chapter 15</a>. The immutability of lists helps you develop correct, efficient algorithms because you never need to make copies of a list.</p>
      <p>Here's a short example showing how to initialize a list, and access its head and tail:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;colors&nbsp;=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"red"</code>,&nbsp;<code class="quotedstring">"blue"</code>,&nbsp;<code class="quotedstring">"green"</code>)
  <code class="output">colors:&nbsp;List[String]&nbsp;=&nbsp;List(red,&nbsp;blue,&nbsp;green)</code>
  <br>  scala&gt;&nbsp;colors.head
  <code class="output">res0:&nbsp;String&nbsp;=&nbsp;red</code>
  <br>  scala&gt;&nbsp;colors.tail
  <code class="output">res1:&nbsp;List[String]&nbsp;=&nbsp;List(blue,&nbsp;green)</code>
</pre>
      <p>For a refresher on lists, see <a href="#step8">Step 8</a> in <a href="#chap-next-steps-in-scala">Chapter 3</a>. You can find details on using lists in <a href="#chap-working-with-lists">Chapter 16</a>. Lists will also be discussed in <a href="#chap-implementing-lists">Chapter 22</a>, which provides insight into how lists are implemented in Scala.</p>
      <h4>Arrays</h4>
      <p>Arrays allow you to hold a sequence of elements and efficiently access an element at an arbitrary position,<a id="i341425106-2"></a> either to get or update the element, with a zero-based index.<a id="i-1409164998-2"></a><a id="i916713681-1"></a> Here's how you create an array whose size you know, but for which you don't yet know the element values:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fiveInts&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[Int]</code>(<code class="literal">5</code>)
  <code class="output">fiveInts:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</code>
</pre>
      <p>Here's how you initialize an array when you do know the element values:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fiveToOne&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="literal">5</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">1</code>)
  <code class="output">fiveToOne:&nbsp;Array[Int]&nbsp;=&nbsp;Array(5,&nbsp;4,&nbsp;3,&nbsp;2,&nbsp;1)</code>
</pre>
      <p>As mentioned previously, arrays are accessed in Scala by placing an index in parentheses, not square brackets as in Java. Here's an example of both accessing and updating an array element:</p> <pre>  scala&gt;&nbsp;fiveInts(<code class="literal">0</code>)&nbsp;=&nbsp;fiveToOne(<code class="literal">4</code>)
  <br>  scala&gt;&nbsp;fiveInts
  <code class="output">res3:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</code>
</pre>
      <p>Scala arrays are represented in the same way as Java arrays. So, you can seamlessly use existing Java methods that return arrays.<a href="#footnotemain17-1">[1]</a></p>
      <p>You have seen arrays in action many times in previous chapters. The basics are in <a href="#step7">Step 7</a> in <a href="#chap-next-steps-in-scala">Chapter 3</a>. Several examples of iterating through the elements of an array with a <span class="code">for</span> expression are shown in <a href="#sec-for-expressions">Section 7.3</a>. Arrays also figure prominently in the two-dimensional layout library of <a href="#chap-composition-and-inheritance">Chapter 10</a>.</p>
      <h4>List buffers</h4>
      <p><a id="sec-collections-listbuf"></a></p>
      <p>Class <span class="code">List</span> provides fast access to the head of the list, but not the end. Thus, when you need to build a list by appending to the end, consider building the list backwards by prepending elements to the front. Then when you're done, call <span class="code">reverse</span> to get the elements in the order you need.</p>
      <p>Another alternative, which avoids the <span class="code">reverse</span> operation, is to use a <span class="code">ListBuffer</span>.<a id="i-1815843466-2"></a> A <span class="code">ListBuffer</span> is a mutable object (contained in package <span class="code">scala.collection.mutable</span>), which can<a id="i-737429794-1"></a> help you build lists more efficiently when you need to append. <span class="code">ListBuffer</span> provides constant time append and prepend operations. You append elements with the <span class="code">+=</span> operator,<a id="i714754650-1"></a> and prepend them with the <span class="code">+=:</span> operator.<a id="i35509127-1"></a><a href="#footnotemain17-2">[2]</a> When you're done building, you can obtain a <span class="code">List</span> by invoking <span class="code">toList</span><a id="i-330065859-1"></a> on the <span class="code">ListBuffer</span>. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable.ListBuffer
  <code class="output">import&nbsp;scala.collection.mutable.ListBuffer</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ListBuffer[Int]</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">buf:&nbsp;scala.collection.mutable.ListBuffer[Int]&nbsp;=&nbsp;ListBuffer()</code>
  <br>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">1</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res4:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1)</code>
  <br>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res5:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1,&nbsp;2)</code>
  <br>  scala&gt;&nbsp;buf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res6:&nbsp;scala.collection.mutable.ListBuffer[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;ListBuffer(1,&nbsp;2)</code>
  <br>  scala&gt;&nbsp;<code class="literal">3</code>&nbsp;+=:&nbsp;buf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res7:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(3,&nbsp;1,&nbsp;2)</code>
  <br>  scala&gt;&nbsp;buf.toList
  <code class="output">res8:&nbsp;List[Int]&nbsp;=&nbsp;List(3,&nbsp;1,&nbsp;2)</code>
</pre>
      <p>Another reason to use <span class="code">ListBuffer</span> instead of <span class="code">List</span> is to prevent the potential for stack overflow.<a id="i-981382311-1"></a> If you can build a list in the desired order by prepending, but the recursive algorithm that would be required is not tail recursive, you can use a <span class="code">for</span> expression or <span class="code">while</span> loop and a <span class="code">ListBuffer</span> instead. You'll see <span class="code">ListBuffer</span> being used in this way in <a href="#sec-the-listbuffer-class">Section 22.2</a>.</p>
      <h4>Array buffers</h4>
      <p><a id="sec-collections-arraybuf"></a></p>
      <p>An <span class="code">ArrayBuffer</span> is like an array, except that you can additionally add and remove elements from the beginning and end of the sequence<a id="i1906553817-1"></a>. All <span class="code">Array</span> operations are available, though they are a little slower due to a layer of wrapping in the implementation. The new addition and removal operations are constant time on average, but occasionally require linear time due to the implementation needing to allocate a new array to hold the buffer's contents.</p>
      <p>To use an <span class="code">ArrayBuffer</span>, you must first import it from the mutable collections package:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable.ArrayBuffer
  <code class="output">import&nbsp;scala.collection.mutable.ArrayBuffer</code>
</pre>
      <p>When you create an <span class="code">ArrayBuffer</span>, you must specify a type parameter, but you don't need to specify a length. The <span class="code">ArrayBuffer</span> will adjust the allocated space automatically as needed:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrayBuffer[Int]</code>()
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;</code>
  <code class="output">ArrayBuffer()</code>
</pre>
      <p>You can append to an <span class="code">ArrayBuffer</span> using the <span class="code">+=</span> method:<a id="i-69907863-1"></a></p> <pre>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">12</code>
  <code class="output">res9:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(12)</code>
  <br>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">15</code>
  <code class="output">res10:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(12,&nbsp;15)</code>
  <br>  scala&gt;&nbsp;buf
  <code class="output">res11:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;ArrayBuffer(12,&nbsp;15)</code>
</pre>
      <p>All the normal array methods are available. For example, you can ask an <span class="code">ArrayBuffer</span> its length or you can retrieve an element by its index:</p> <pre>  scala&gt;&nbsp;buf.length
  <code class="output">res12:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;buf(<code class="literal">0</code>)
  <code class="output">res13:&nbsp;Int&nbsp;=&nbsp;12</code>
</pre>
      <h4>Strings (via <span class="code">StringOps</span>)</h4>
      <p>One other sequence to be aware of is <span class="code">StringOps</span>, which implements many sequence methods. Because <span class="code">Predef</span> has<a id="i1341725017-1"></a> an implicit conversion from <span class="code">String</span> to <span class="code">StringOps</span><a id="i-1007334645-1"></a>, you can treat any string like a sequence. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;hasUpperCase(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;s.exists(_.isUpper)
  <code class="output">hasUpperCase:&nbsp;(s:&nbsp;String)Boolean</code>
  <br>  scala&gt;&nbsp;hasUpperCase(<code class="quotedstring">"Robert&nbsp;Frost"</code>)
  <code class="output">res14:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;hasUpperCase(<code class="quotedstring">"e&nbsp;e&nbsp;cummings"</code>)
  <code class="output">res15:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>In this example, the <span class="code">exists</span><a id="i556038843-1"></a> method is invoked on the string named <span class="code">s</span> in the <span class="code">hasUpperCase</span> method body. Because no method named "<span class="code">exists</span>" is declared in class <span class="code">String</span> itself, the Scala compiler will implicitly convert <span class="code">s</span> to <span class="code">StringOps</span>, which has the method. The <span class="code">exists</span> method treats the string as a sequence of characters, and will return true if any of the characters are upper case.<a href="#footnotemain17-3">[3]</a></p>
      <h3 id="sec-sets-and-maps">17.2 Sets and maps</h3>
      <p>You have already seen the basics of sets and maps in previous chapters, starting<a id="i3526737-2"></a><a id="i3344023-2"></a> with <a href="#step10">Step 10</a> in <a href="#chap-next-steps-in-scala">Chapter 3</a>. In this section, we'll offer more insight into their use and show you a few more examples.</p>
      <p>As mentioned previously, the Scala collections library offers both mutable and immutable versions of sets and maps. The hierarchy for sets is shown in <a href="#fig-set-hierarchy">Figure 3.2</a> <a href="#fig-set-hierarchy">here</a>, and the hierarchy for maps is shown in <a href="#fig-map-hierarchy">Figure 3.3</a> <a href="#fig-map-hierarchy">here</a>. As these diagrams show, the simple names <span class="code">Set</span> and <span class="code">Map</span> are used by three traits each, residing in different packages.</p>
      <p>By default when you write "<span class="code">Set</span>" or "<span class="code">Map</span>" you get an immutable object. If you want the mutable variant, you need to do an explicit import. Scala gives you easier access to the immutable variants, as a gentle encouragement to prefer them over their mutable counterparts. The easy access is provided via the <span class="code">Predef</span> object, which is implicitly imported into every Scala source file. <a href="#lst-predef-set-map">Listing 17.1</a> shows the relevant definitions: <a id="lst-predef-set-map"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Predef</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Map[A,&nbsp;+B]</code>&nbsp;=&nbsp;<code class="typename">collection.immutable.Map[A,&nbsp;B]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Set[A]</code>&nbsp;=&nbsp;<code class="typename">collection.immutable.Set[A]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Map</code>&nbsp;=&nbsp;<code class="typename">collection.immutable.Map</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Set</code>&nbsp;=&nbsp;<code class="typename">collection.immutable.Set</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;...</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 17.1 - Default map and set definitions in <span class="code">Predef</span>.</h5>
      <p>The "<span class="code">type</span>" keyword<a id="i-1569140754-1"></a> is used in <span class="code">Predef</span> to define <span class="code">Set</span> and <span class="code">Map</span> as aliases for the longer fully qualified names of the immutable set and map traits.<a href="#footnotemain17-4">[4]</a> The <span class="code">val</span>s named <span class="code">Set</span> and <span class="code">Map</span> are initialized to refer to the singleton objects for the immutable <span class="code">Set</span> and <span class="code">Map</span>. So <span class="code">Map</span> is the same as <span class="code">Predef.Map</span>, which is defined to be the same as <span class="code">scala.collection.immutable.Map</span>. This holds both for the <span class="code">Map</span> type and <span class="code">Map</span> object.</p>
      <p>If you want to use both mutable and immutable sets or maps in the same source file, one approach is to import the name of the package that contains the mutable variants:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
</pre>
      <p>You can continue to refer to the immutable set as <span class="code">Set</span>, as before, but can now refer to the mutable set as <span class="code">mutable.Set</span>. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;mutaSet&nbsp;=&nbsp;<code class="typename">mutable.Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">mutaSet:&nbsp;scala.collection.mutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3)</code>
</pre>
      <h4>Using sets</h4>
      <p>The key characteristic of sets is that they will ensure that at most one of each object, as determined by <span class="code">==</span><a id="i1401108821-1"></a>, will be contained in the set at any one time. As an example, we'll use a set to count the number of different words in a string.</p>
      <p>The <span class="code">split</span> method on <span class="code">String</span> can separate a string into words<a id="i-456038910-1"></a>, if you specify spaces and punctuation as word separators. The regular expression "<span class="code">[</span>&nbsp;<span class="code">!,.]+</span>" will suffice: It indicates the string should be split at each place that one or more space and/or punctuation characters exist.</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;text&nbsp;=&nbsp;<code class="quotedstring">"See&nbsp;Spot&nbsp;run.&nbsp;Run,&nbsp;Spot.&nbsp;Run!"</code>
  <code class="output">text:&nbsp;String&nbsp;=&nbsp;See&nbsp;Spot&nbsp;run.&nbsp;Run,&nbsp;Spot.&nbsp;Run!</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;wordsArray&nbsp;=&nbsp;text.split(<code class="quotedstring">"[&nbsp;!,.]+"</code>)&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">wordsArray:&nbsp;Array[String]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Array(See,&nbsp;Spot,&nbsp;run,&nbsp;Run,&nbsp;Spot,&nbsp;Run)</code>
</pre>
      <p>To count the distinct words, you can convert them to the same case and then add them to a set. Because sets exclude duplicates, each distinct word will appear exactly one time in the set.</p>
      <p>First, you can create an empty set using the <span class="code">empty</span> method provided on the <span class="code">Set</span> companion objects:<a id="i1582603163-1"></a><a id="i1868251958-2"></a></p> <pre>  scala&gt;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;words&nbsp;=&nbsp;mutable.Set.empty[<code class="typename">String</code>]
  <code class="output">words:&nbsp;scala.collection.mutable.Set[String]&nbsp;=&nbsp;Set()</code>
</pre>
      <p>Then, just iterate through the words with a <span class="code">for</span> expression, convert each word to lower case, and add it to the mutable set with the <span class="code">+=</span> operator:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(word&nbsp;&lt;-&nbsp;wordsArray)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words&nbsp;+=&nbsp;word.toLowerCase
  <br>  scala&gt;&nbsp;words
  <code class="output">res17:&nbsp;scala.collection.mutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(see,&nbsp;run,&nbsp;spot)</code>
</pre>
      <p>Thus, the text contained exactly three distinct words: spot, run, and see. The most commonly used methods on both mutable and immutable sets are shown in <a href="#tab-set-operations">Table 17.1</a>.</p>
      <p><a id="tab-set-operations"></a></p>
      <h5>Common operations for sets<a id="i51742212-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span class="code">val</span>&nbsp;<span class="code">nums</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">Set(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> </td>
            <td> Creates an immutable set (<span class="code">nums.toString</span> returns <span class="code">Set(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>) </td>
          </tr>
          <tr>
            <td> <span class="code">nums</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">5</span> </td>
            <td> Adds an element to an immutable set (returns <span class="code">Set(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3,</span>&nbsp;<span class="code">5)</span>)<a id="i58065198-2"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">3</span> </td>
            <td> Removes an element from an immutable set (returns <span class="code">Set(1,</span>&nbsp;<span class="code">2)</span>)<a id="i1951955033-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">List(5,</span>&nbsp;<span class="code">6)</span> </td>
            <td> Adds multiple elements (returns <span class="code">Set(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3,</span>&nbsp;<span class="code">5,</span>&nbsp;<span class="code">6)</span>)<a id="i758428245-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums</span>&nbsp;<span class="code">--</span>&nbsp;<span class="code">List(1,</span>&nbsp;<span class="code">2)</span> </td>
            <td> Removes multiple elements from an immutable set (returns <span class="code">Set(3)</span>)<a id="i-1311479633-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums</span>&nbsp;<span class="code">&amp;</span>&nbsp;<span class="code">Set(1,</span>&nbsp;<span class="code">3,</span>&nbsp;<span class="code">5,</span>&nbsp;<span class="code">7)</span> </td>
            <td> Takes the intersection of two sets (returns <span class="code">Set(1,</span>&nbsp;<span class="code">3)</span>)<a id="i617863161-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums.size</span> </td>
            <td> Returns the size of the set (returns <span class="code">3</span>)<a id="i-217240950-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums.contains(3)</span> </td>
            <td> Checks for inclusion (returns <span class="code">true</span>)<a id="i1685795628-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">import</span>&nbsp;<span class="code">scala.collection.mutable</span> </td>
            <td> Makes the mutable collections easy to access </td>
          </tr>
          <tr>
            <td> <span class="code">val</span>&nbsp;<span class="code">words</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span><br> <span class="code">mutable.Set.empty[String]</span> </td>
            <td> Creates an empty, mutable set (<span class="code">words.toString</span> returns <span class="code">Set()</span>)<a id="i1582603163-2"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">words</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">"the"</span> </td>
            <td> Adds an element (<span class="code">words.toString</span> returns <span class="code">Set(the)</span>)<a id="i1314992430-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">words</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">"the"</span> </td>
            <td> Removes an element, if it exists (<span class="code">words.toString</span> returns <span class="code">Set()</span>)<a id="i1816671796-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">words</span>&nbsp;<span class="code">++=</span>&nbsp;<span class="code">List("do",</span>&nbsp;<span class="code">"re",</span>&nbsp;<span class="code">"mi")</span> </td>
            <td> Adds multiple elements (<span class="code">words.toString</span> returns <span class="code">Set(do,</span>&nbsp;<span class="code">re,</span>&nbsp;<span class="code">mi)</span>)<a id="i-1693046362-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">words</span>&nbsp;<span class="code">--=</span>&nbsp;<span class="code">List("do",</span>&nbsp;<span class="code">"re")</span> </td>
            <td> Removes multiple elements (<span class="code">words.toString</span> returns <span class="code">Set(mi)</span>)<a id="i-610143062-1"></a> </td>
          </tr>
          <tr class="bottomline">
            <td> <span class="code">words.clear</span> </td>
            <td> Removes all elements (<span class="code">words.toString</span> returns <span class="code">Set()</span>)<a id="i-914291699-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <h4>Using maps</h4>
      <p>Maps let you associate a value with each element of a set. Using a map looks similar to using an array, except instead of indexing with integers counting from 0, you can use any kind of key<a id="i3344023-3"></a>. If you import the <span class="code">mutable</span> package name, you can create an empty mutable map like this:<a id="i-1094653291-1"></a><a id="i-809004496-2"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;mutable.Map.empty[<code class="typename">String</code>,&nbsp;<code class="typename">Int</code>]
  <code class="output">map:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=&nbsp;Map()</code>
</pre>
      <p>Note that when you create a map, you must specify two types. The first type is for the <em>keys</em> of the map, the second for the <em>values</em>. In this case, the keys are strings and the values are integers. Setting entries in a map looks similar to setting entries in an array:<a id="i648989597-1"></a></p> <pre>  scala&gt;&nbsp;map(<code class="quotedstring">"hello"</code>)&nbsp;=&nbsp;<code class="literal">1</code>
  <br>  scala&gt;&nbsp;map(<code class="quotedstring">"there"</code>)&nbsp;=&nbsp;<code class="literal">2</code>
  <br>  scala&gt;&nbsp;map
  <code class="output">res20:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(hello&nbsp;-&gt;&nbsp;1,&nbsp;there&nbsp;-&gt;&nbsp;2)</code>
</pre>
      <p>Likewise, reading a map is similar to reading an array:</p> <pre>  scala&gt;&nbsp;map(<code class="quotedstring">"hello"</code>)
  <code class="output">res21:&nbsp;Int&nbsp;=&nbsp;1</code>
</pre>
      <p>Putting it all together, here is a method that counts the number of times each word occurs in a string:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;countWords(text:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;counts&nbsp;=&nbsp;mutable.Map.empty[<code class="typename">String</code>,&nbsp;<code class="typename">Int</code>]
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(rawWord&nbsp;&lt;-&nbsp;text.split(<code class="quotedstring">"[&nbsp;,!.]+"</code>))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;word&nbsp;=&nbsp;rawWord.toLowerCase
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;oldCount&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(counts.contains(word))&nbsp;counts(word)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts&nbsp;+=&nbsp;(word&nbsp;-&gt;&nbsp;(oldCount&nbsp;+&nbsp;<code class="literal">1</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">countWords:&nbsp;(text:&nbsp;</code>
  <code class="output">String)scala.collection.mutable.Map[String,Int]</code>
  <br>  scala&gt;&nbsp;countWords(<code class="quotedstring">"See&nbsp;Spot&nbsp;run!&nbsp;Run,&nbsp;Spot.&nbsp;Run!"</code>)
  <code class="output">res22:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(spot&nbsp;-&gt;&nbsp;2,&nbsp;see&nbsp;-&gt;&nbsp;1,&nbsp;run&nbsp;-&gt;&nbsp;3)</code>
</pre>
      <p>The way this code works is that a mutable map, named <span class="code">counts</span>, maps each word to the number of times it occurs in the text. For each word in the text, the word's old count is looked up, that count is incremented by one, and the new count is saved back into <span class="code">counts</span>. Note the use of <span class="code">contains</span> to check whether a word has been seen yet or not. If <span class="code">counts.contains(word)</span> is not true, then the word has not yet been seen and zero is used for the count.</p>
      <p>Many of the most commonly used methods on both mutable and immutable maps are shown in <a href="#tab-map-operations">Table 17.2</a>.</p>
      <p><a id="tab-map-operations"></a></p>
      <h5>Common operations for maps<a id="i-498146178-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span class="code">val</span>&nbsp;<span class="code">nums</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">Map("i"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1,</span>&nbsp;<span class="code">"ii"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">2)</span> </td>
            <td> Creates an immutable map (<span class="code">nums.toString</span> returns <span class="code">Map(i</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1,</span>&nbsp;<span class="code">ii</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">2)</span>) </td>
          </tr>
          <tr>
            <td> <span class="code">nums</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(<span class="quotedstring">"vi"</span></span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code"><span class="literal">6</span>)</span> </td>
            <td> Adds an entry to an immutable map (returns <span class="code">Map(i</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1,</span> <span class="code">ii</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">vi</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">6)</span>)<a id="i57882484-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code"><span class="quotedstring">"ii"</span></span> </td>
            <td> Removes an entry from an immutable map (returns <span class="code">Map(i</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1)</span>)<a id="i1951772319-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code"><span class="typename">List</span>(<span class="quotedstring">"iii"</span></span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code"><span class="literal">3</span>,</span>&nbsp;<span class="code"><span class="quotedstring">"v"</span></span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code"><span class="literal">5</span>)</span> </td>
            <td> Adds multiple entries (returns <span class="code">Map(i</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1,</span> <span class="code">ii</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">iii</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">3,</span>&nbsp;<span class="code">v</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">5)</span>)<a id="i-2098881509-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums</span>&nbsp;<span class="code">--</span>&nbsp;<span class="code"><span class="typename">List</span>(<span class="quotedstring">"i"</span>,</span>&nbsp;<span class="code"><span class="quotedstring">"ii"</span>)</span> </td>
            <td> Removes multiple entries from an immutable map (returns <span class="code">Map()</span>)<a id="i-1311662347-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums.size</span> </td>
            <td> Returns the size of the map (returns <span class="code">2</span>) </td>
          </tr>
          <tr>
            <td> <span class="code">nums.contains(<span class="quotedstring">"ii"</span>)</span> </td>
            <td> Checks for inclusion (returns <span class="code">true</span>)<a id="i-1171514126-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums(<span class="quotedstring">"ii"</span>)</span> </td>
            <td> Retrieves the value at a specified key (returns <span class="code">2</span>)<a id="i648989597-2"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums.keys</span> </td>
            <td> Returns the keys (returns an <span class="code">Iterable</span> over the strings <span class="code">"i"</span> and <span class="code">"ii"</span>)<a id="i1213467709-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums.keySet</span> </td>
            <td> Returns the keys as a set (returns <span class="code">Set(i,</span>&nbsp;<span class="code">ii)</span>)<a id="i891405326-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums.values</span> </td>
            <td> Returns the values (returns an <span class="code">Iterable</span> over the integers <span class="code">1</span> and <span class="code">2</span>)<a id="i-546077233-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">nums.isEmpty</span> </td>
            <td> Indicates whether the map is empty (returns false)<a id="i-576053426-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">import</span>&nbsp;<span class="code">scala.collection.mutable</span> </td>
            <td> Makes the mutable collections easy to access </td>
          </tr>
          <tr>
            <td> <span class="code">val</span>&nbsp;<span class="code">words</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code"></span> <br> <span class="code">mutable.Map.empty[<span class="typename">String</span>,</span>&nbsp;<span class="code"><span class="typename">Int</span>]</span> </td>
            <td> Creates an empty, mutable map<a id="i-1094653291-2"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">words</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(<span class="quotedstring">"one"</span></span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code"><span class="literal">1</span>)</span> </td>
            <td> Adds a map entry from <span class="code">"one"</span> to <span class="code">1</span> (<span class="code">words.toString</span> returns <span class="code">Map(one</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1)</span>)<a id="i1314809716-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">words</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code"><span class="quotedstring">"one"</span></span> </td>
            <td> Removes a map entry, if it exists (<span class="code">words.toString</span> returns <span class="code">Map()</span>)<a id="i1816489082-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">words</span>&nbsp;<span class="code">++=</span>&nbsp;<span class="code"><span class="typename">List</span>(<span class="quotedstring">"one"</span></span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code"><span class="literal">1</span>,</span>&nbsp;<span class="code"></span><br> <span class="code"><span class="quotedstring">"two"</span></span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code"><span class="literal">2</span>,</span>&nbsp;<span class="code"><span class="quotedstring">"three"</span></span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code"><span class="literal">3</span>)</span> </td>
            <td> Adds multiple map entries (<span class="code">words.toString</span> returns <span class="code">Map(one</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1,</span> <span class="code">two</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">three</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">3)</span>)<a id="i-1693229076-1"></a> </td>
          </tr>
          <tr class="bottomline">
            <td> <span class="code">words</span>&nbsp;<span class="code">--=</span>&nbsp;<span class="code"><span class="typename">List</span>(<span class="quotedstring">"one"</span>,</span>&nbsp;<span class="code"><span class="quotedstring">"two"</span>)</span> </td>
            <td> Removes multiple objects (<span class="code">words.toString</span> returns <span class="code">Map(three</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">3)</span>)<a id="i-610325776-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <h4>Default sets and maps</h4>
      <p>For most uses, the implementations of mutable and immutable sets and maps provided by<a id="i1372944617-1"></a><a id="i1372761903-1"></a> the <span class="code">Set()</span>, <span class="code">scala.collection.mutable.Map()</span>, <i>etc.</i>, factories will likely be sufficient. The implementations provided by these factories use a fast lookup algorithm, usually involving a hash table, so they can quickly decide whether or not an object is in the collection.</p>
      <p>The <span class="code">scala.collection.mutable.Set()</span> factory method, for example, returns a <span class="code">scala.collection.mutable.HashSet</span>, which uses a hash table internally. Similarly, the <span class="code">scala.collection.mutable.Map()</span> factory returns a <span class="code">scala.collection.mutable.HashMap</span>.</p>
      <p>The story for immutable sets and maps is a bit more involved. The class returned by the <span class="code">scala.collection.immutable.Set()</span> factory method, for example, depends on how many elements you pass to it, as shown in <a href="#tab-default-sets">Table 17.3</a>. For sets with fewer than five elements, a special class devoted exclusively to sets of each particular size is used to maximize performance. Once you request a set that has five or more elements in it, however, the factory method will return an implementation that uses hash tries.<a id="i-794402297-1"></a></p>
      <p>Similarly, the <span class="code">scala.collection.immutable.Map()</span> factory method will return a different class depending on how many key-value pairs you pass to it, as shown in <a href="#tab-default-maps">Table 17.4</a>. As with sets, for immutable maps with fewer than five elements, a special class devoted exclusively to maps of each particular size is used to maximize performance. Once a map has five or more key-value pairs in it, however, an immutable <span class="code">HashMap</span> is used.</p>
      <p>The default immutable implementation classes shown in <a href="#tab-default-sets">Tables 17.3</a> <a href="#tab-default-maps">and 17.4</a> work together to give you maximum performance. For example, if you add an element to an <span class="code">EmptySet</span>, it will return a <span class="code">Set1</span>. If you add an element to that <span class="code">Set1</span>, it will return a <span class="code">Set2</span>. If you then remove an element from the <span class="code">Set2</span>, you'll get another <span class="code">Set1</span>.</p>
      <p><a id="tab-default-sets"></a></p>
      <h5>Table 17.3 - Default immutable set implementations</h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> <span style="font-size:medium"><span style="font-weight:bold">Number of elements</span></span> </td>
              <td> <span style="font-size:medium"><span style="font-weight:bold">Implementation</span></span> </td>
            </tr>
            <tr class="topline ">
              <td> 0 </td>
              <td> <span class="code">scala.collection.immutable.EmptySet</span> </td>
            </tr>
            <tr>
              <td> 1 </td>
              <td> <span class="code">scala.collection.immutable.Set1</span> </td>
            </tr>
            <tr>
              <td> 2 </td>
              <td> <span class="code">scala.collection.immutable.Set2</span> </td>
            </tr>
            <tr>
              <td> 3 </td>
              <td> <span class="code">scala.collection.immutable.Set3</span> </td>
            </tr>
            <tr>
              <td> 4 </td>
              <td> <span class="code">scala.collection.immutable.Set4</span> </td>
            </tr>
            <tr>
              <td> 5 or more </td>
              <td> <span class="code">scala.collection.immutable.HashSet</span> </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p><a id="tab-default-maps"></a></p>
      <h5>Table 17.4 - Default immutable map implementations</h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> <span style="font-size:medium"><span style="font-weight:bold">Number of elements</span></span> </td>
              <td> <span style="font-size:medium"><span style="font-weight:bold">Implementation</span></span> </td>
            </tr>
            <tr class="topline ">
              <td> 0 </td>
              <td> <span class="code">scala.collection.immutable.EmptyMap</span> </td>
            </tr>
            <tr>
              <td> 1 </td>
              <td> <span class="code">scala.collection.immutable.Map1</span> </td>
            </tr>
            <tr>
              <td> 2 </td>
              <td> <span class="code">scala.collection.immutable.Map2</span> </td>
            </tr>
            <tr>
              <td> 3 </td>
              <td> <span class="code">scala.collection.immutable.Map3</span> </td>
            </tr>
            <tr>
              <td> 4 </td>
              <td> <span class="code">scala.collection.immutable.Map4</span> </td>
            </tr>
            <tr>
              <td> 5 or more </td>
              <td> <span class="code">scala.collection.immutable.HashMap</span> </td>
            </tr>
          </tbody>
        </table>
      </div>
      <h4>Sorted sets and maps</h4>
      <p>On occasion you may need a set or map whose iterator returns elements in a particular order. For this purpose, the Scala collections library provides traits <span class="code">SortedSet</span><a id="i849148531-1"></a> and <span class="code">SortedMap</span>.<a id="i1172619245-1"></a> These traits are implemented by classes <span class="code">TreeSet</span><a id="i300430876-1"></a> and <span class="code">TreeMap</span>,<a id="i623901590-1"></a> which use a red-black tree to keep elements (in the case of <span class="code">TreeSet</span>) or keys (in the case of <span class="code">TreeMap</span>) in order. The order is determined by the <span class="code">Ordering</span><a id="i1791314146-1"></a> trait, an implicit instance of which must be defined for the element type of the set, or key type of the map. These classes come both in immutable and mutable variants. Here are some <span class="code">TreeSet</span> examples:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.immutable.TreeSet
  <code class="output">import&nbsp;scala.collection.immutable.TreeSet</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;ts&nbsp;=&nbsp;<code class="typename">TreeSet</code>(<code class="literal">9</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">1</code>,&nbsp;<code class="literal">8</code>,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">7</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">6</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">ts:&nbsp;scala.collection.immutable.TreeSet[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;TreeSet(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;cs&nbsp;=&nbsp;<code class="typename">TreeSet</code>(<code class="quotedstring">'f'</code>,&nbsp;<code class="quotedstring">'u'</code>,&nbsp;<code class="quotedstring">'n'</code>)
  <code class="output">cs:&nbsp;scala.collection.immutable.TreeSet[Char]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;TreeSet(f,&nbsp;n,&nbsp;u)</code>
</pre>
      <p>And here are a few <span class="code">TreeMap</span> examples:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.immutable.TreeMap
  <code class="output">import&nbsp;scala.collection.immutable.TreeMap</code>
  <br>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;tm&nbsp;=&nbsp;<code class="typename">TreeMap</code>(<code class="literal">3</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'x'</code>,&nbsp;<code class="literal">4</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'x'</code>)
  <code class="output">tm:&nbsp;scala.collection.immutable.TreeMap[Int,Char]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(1&nbsp;-&gt;&nbsp;x,&nbsp;3&nbsp;-&gt;&nbsp;x,&nbsp;4&nbsp;-&gt;&nbsp;x)</code>
  <br>  scala&gt;&nbsp;tm&nbsp;+=&nbsp;(<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">'x'</code>)
  <br>  scala&gt;&nbsp;tm
  <code class="output">res30:&nbsp;scala.collection.immutable.TreeMap[Int,Char]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(1&nbsp;-&gt;&nbsp;x,&nbsp;2&nbsp;-&gt;&nbsp;x,&nbsp;3&nbsp;-&gt;&nbsp;x,&nbsp;4&nbsp;-&gt;&nbsp;x)</code>
</pre>
      <h3>17.3 Selecting mutable versus immutable collections</h3>
      <p>For some problems, mutable collections work better, while for others, immutable collections work better.<a id="i1445844177-1"></a> When in doubt, it is better to start with an immutable collection and change it later, if you need to, because immutable collections can be easier to reason about than mutable ones.</p>
      <p>Also, it can be worthwhile to go the opposite way sometimes. If you find some code that uses mutable collections becoming complicated and hard to reason about, consider whether it would help to change some of the collections to immutable alternatives<a id="i650543080-1"></a>. In particular, if you find yourself worrying about making copies of mutable collections in just the right places, or thinking a lot about who "owns" or "contains" a mutable collection, consider switching some of the collections to their immutable counterparts.</p>
      <p>Besides being potentially easier to reason about, immutable collections can usually be stored more compactly than mutable ones if the number of elements stored in the collection is small. For instance an empty mutable map in its default representation of <span class="code">HashMap</span> takes up about 80 bytes, and about 16 more are added for each entry that's added to it. An empty immutable <span class="code">Map</span> is a single object that's shared between all references, so referring to it essentially costs just a single pointer field.</p>
      <p>What's more, the Scala collections library currently stores immutable maps and sets with up to four entries in a single object, which typically takes up between 16 and 40 bytes, depending on the number of entries stored in the collection.<a href="#footnotemain17-5">[5]</a> So for small maps and sets, the immutable versions are much more compact than the mutable ones. Given that many collections are small, switching them to be immutable can bring important space savings and performance advantages.</p>
      <p>To make it easier to switch from immutable to mutable collections, and vice versa, Scala provides some syntactic sugar. Even though immutable sets and maps do not support a true <span class="code">+=</span> method, Scala gives a useful alternate interpretation to <span class="code">+=</span>. Whenever you write <span class="code">a</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">b</span>, and <span class="code">a</span> does not support a method named <span class="code">+=</span>, Scala will try interpreting it as <span class="code">a</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b</span>.</p>
      <p>For example, immutable sets do not support a <span class="code">+=</span> operator:<a id="i1301665902-2"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;people&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"Nancy"</code>,&nbsp;<code class="quotedstring">"Jane"</code>)
  <code class="output">people:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(Nancy,&nbsp;Jane)</code>
  <br>  scala&gt;&nbsp;people&nbsp;+=&nbsp;<code class="quotedstring">"Bob"</code>
  <code class="output">&lt;console&gt;:14:&nbsp;error:&nbsp;value&nbsp;+=&nbsp;is&nbsp;not&nbsp;a&nbsp;member&nbsp;of&nbsp;</code>
  <code class="output">scala.collection.immutable.Set[String]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;people&nbsp;+=&nbsp;"Bob"</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>However, if you declare <span class="code">people</span> as a <span class="code">var</span>, instead of a <span class="code">val</span>, then the collection can be "updated" with a <span class="code">+=</span> operation, even though it is immutable. First, a new collection will be created, and then <span class="code">people</span> will be reassigned to refer to the new collection:</p> <pre>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;people&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"Nancy"</code>,&nbsp;<code class="quotedstring">"Jane"</code>)
  <code class="output">people:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(Nancy,&nbsp;Jane)</code>
  <br>  scala&gt;&nbsp;people&nbsp;+=&nbsp;<code class="quotedstring">"Bob"</code>
  <br>  scala&gt;&nbsp;people
  <code class="output">res34:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(Nancy,&nbsp;Jane,&nbsp;Bob)</code>
</pre>
      <p>After this series of statements, the <span class="code">people</span> variable refers to a new immutable set, which contains the added string, <span class="code">"Bob"</span>. The same idea applies to any method ending in <span class="code">=</span>, not just the <span class="code">+=</span> method. Here's the same syntax used with the <span class="code">-=</span> operator, which removes an element from a set, and the <span class="code">++=</span> operator, which adds a collection of elements to a set:</p> <pre>  scala&gt;&nbsp;people&nbsp;-=&nbsp;<code class="quotedstring">"Jane"</code>
  <br>  scala&gt;&nbsp;people&nbsp;++=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"Tom"</code>,&nbsp;<code class="quotedstring">"Harry"</code>)
  <br>  scala&gt;&nbsp;people
  <code class="output">res37:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(Nancy,&nbsp;Bob,&nbsp;Tom,&nbsp;Harry)</code>
</pre>
      <p>To see how this is useful, consider again the following <span class="code">Map</span> example from <a href="#sec-a-language-that-grows-on-you">Section 1.1</a>:</p> <pre>  <code class="vem">var</code>&nbsp;capital&nbsp;=&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"US"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Washington"</code>,&nbsp;<code class="quotedstring">"France"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Paris"</code>)
  capital&nbsp;+=&nbsp;(<code class="quotedstring">"Japan"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Tokyo"</code>)
  println(capital(<code class="quotedstring">"France"</code>))&nbsp;
</pre>
      <p>This code uses immutable collections. If you want to try using mutable collections instead, all that is necessary is to import the mutable version of <span class="code">Map</span>, thus overriding the default import of the immutable <span class="code">Map</span>:</p> <pre>  <code class="vem">import</code>&nbsp;scala.collection.mutable.Map&nbsp;&nbsp;<code class="comment">//&nbsp;only&nbsp;change&nbsp;needed!</code>
  <code class="vem">var</code>&nbsp;capital&nbsp;=&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"US"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Washington"</code>,&nbsp;<code class="quotedstring">"France"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Paris"</code>)
  capital&nbsp;+=&nbsp;(<code class="quotedstring">"Japan"</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"Tokyo"</code>)
  println(capital(<code class="quotedstring">"France"</code>))&nbsp;
</pre>
      <p>Not all examples are quite that easy to convert, but the special treatment of methods ending in an equals sign will often reduce the amount of code that needs changing.</p>
      <p>By the way, this syntactic treatment works on any kind of value, not just collections. For example, here it is being used on floating-point numbers:</p> <pre>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;roughlyPi&nbsp;=&nbsp;<code class="literal">3.0</code>
  <code class="output">roughlyPi:&nbsp;Double&nbsp;=&nbsp;3.0</code>
  <br>  scala&gt;&nbsp;roughlyPi&nbsp;+=&nbsp;<code class="literal">0.1</code>
  <br>  scala&gt;&nbsp;roughlyPi&nbsp;+=&nbsp;<code class="literal">0.04</code>
  <br>  scala&gt;&nbsp;roughlyPi
  <code class="output">res40:&nbsp;Double&nbsp;=&nbsp;3.14</code>
</pre>
      <p>The effect of this expansion is similar to Java's assignment operators (<span class="code">+=</span>, <span class="code">-=</span>, <span class="code">*=</span>, <i>etc.</i>), but it is more general because every operator ending in <span class="code">=</span> can be converted.</p>
      <h3>17.4 Initializing collections</h3>
      <p>As you've seen previously, the most common way to create and initialize a collection is to pass the initial elements to a factory method on the companion object of your chosen collection. You just place the elements in parentheses after the companion object name, and the Scala compiler will transform that to an invocation of an <span class="code">apply</span> method on that companion object:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res41:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;<code class="typename">Set</code>(<code class="quotedstring">'a'</code>,&nbsp;<code class="quotedstring">'b'</code>,&nbsp;<code class="quotedstring">'c'</code>)
  <code class="output">res42:&nbsp;scala.collection.immutable.Set[Char]&nbsp;=&nbsp;Set(a,&nbsp;b,&nbsp;c)</code>
  <br>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
  <br>
  scala&gt;&nbsp;<code class="typename">mutable.Map</code>(<code class="quotedstring">"hi"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>,&nbsp;<code class="quotedstring">"there"</code>&nbsp;-&gt;&nbsp;<code class="literal">5</code>)
  <code class="output">res43:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(hi&nbsp;-&gt;&nbsp;2,&nbsp;there&nbsp;-&gt;&nbsp;5)</code>
  <br>  scala&gt;&nbsp;<code class="typename">Array</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>,&nbsp;<code class="literal">3.0</code>)
  <code class="output">res44:&nbsp;Array[Double]&nbsp;=&nbsp;Array(1.0,&nbsp;2.0,&nbsp;3.0)</code>
</pre>
      <p>Although most often you can let the Scala compiler infer the element type of a collection from the elements passed to its factory method, sometimes you may want to create a collection but specify a different type from the one the compiler would choose. This is especially an issue with mutable collections. Here's an example:<a id="i-677980410-2"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stuff&nbsp;=&nbsp;<code class="typename">mutable.Set</code>(<code class="literal">42</code>)
  <code class="output">stuff:&nbsp;scala.collection.mutable.Set[Int]&nbsp;=&nbsp;Set(42)</code>
  <br>  scala&gt;&nbsp;stuff&nbsp;+=&nbsp;<code class="quotedstring">"abracadabra"</code>
  <code class="output">&lt;console&gt;:16:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;String("abracadabra")</code>
  <code class="output">&nbsp;required:&nbsp;Int</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stuff&nbsp;+=&nbsp;"abracadabra"</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>The problem here is that <span class="code">stuff</span> was given an element type of <span class="code">Int</span>. If you want it to have an element type of <span class="code">Any</span>, you need to say so explicitly by putting the element type in square brackets, like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stuff&nbsp;=&nbsp;<code class="typename">mutable.Set[Any]</code>(<code class="literal">42</code>)
  <code class="output">stuff:&nbsp;scala.collection.mutable.Set[Any]&nbsp;=&nbsp;Set(42)</code>
</pre>
      <p>Another special situation is if you want to initialize a collection with another collection. For example, imagine you have a list, but you want a <span class="code">TreeSet</span> containing the elements in the list. Here's the list:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;colors&nbsp;=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"blue"</code>,&nbsp;<code class="quotedstring">"yellow"</code>,&nbsp;<code class="quotedstring">"red"</code>,&nbsp;<code class="quotedstring">"green"</code>)
  <code class="output">colors:&nbsp;List[String]&nbsp;=&nbsp;List(blue,&nbsp;yellow,&nbsp;red,&nbsp;green)</code>
</pre>
      <p>You cannot pass the <span class="code">colors</span> list to the factory method for <span class="code">TreeSet</span>:<a id="i-1802169132-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.immutable.TreeSet
  <code class="output">import&nbsp;scala.collection.immutable.TreeSet</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;treeSet&nbsp;=&nbsp;<code class="typename">TreeSet</code>(colors)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">&lt;console&gt;:16:&nbsp;error:&nbsp;No&nbsp;implicit&nbsp;Ordering&nbsp;defined&nbsp;for&nbsp;</code>
  <code class="output">List[String].</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;treeSet&nbsp;=&nbsp;TreeSet(colors)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>Instead, you'll need to convert the list to a <span class="code">TreeSet</span> with the <span class="code">to</span> method:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;treeSet&nbsp;=&nbsp;colors&nbsp;to&nbsp;<code class="typename">TreeSet</code>
  <code class="output">treeSet:&nbsp;scala.collection.immutable.TreeSet[String]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;TreeSet(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</code>
</pre>
      <p>The <span class="code">to</span> method<a id="i1004785832-1"></a> takes as parameter a companion object of a collection. You can use it to convert any collection to another.</p>
      <h4>Converting to array or list</h4>
      <p>In addition to the generic <span class="code">to</span> method for converting a collection to another arbitary collection, you can also use more specific methods to convert to the most common Scala collection types. As you've seen previously, to initialize a new list with another collection, simply invoke <span class="code">toList</span><a id="i-1723195748-2"></a> on that collection<a id="i1406547745-1"></a><a id="i-218379511-1"></a><a id="i595962916-1"></a>:</p> <pre>  scala&gt;&nbsp;treeSet.toList
  <code class="output">res50:&nbsp;List[String]&nbsp;=&nbsp;List(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</code>
</pre>
      <p>Or, if you need an array, invoke <span class="code">toArray</span>:</p> <pre>  scala&gt;&nbsp;treeSet.toArray
  <code class="output">res51:&nbsp;Array[String]&nbsp;=&nbsp;Array(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</code>
</pre>
      <p>Note that although the original <span class="code">colors</span> list was not sorted, the elements in the list produced by invoking <span class="code">toList</span> on the <span class="code">TreeSet</span> are in alphabetical order. When you invoke <span class="code">toList</span> or <span class="code">toArray</span> on a collection, the order of the elements in the resulting list or array will be the same as the order of elements produced by an iterator on that collection. Because a <span class="code">TreeSet[String]</span>'s iterator will produce strings in alphabetical order, those strings will appear in alphabetical order in the list resulting from invoking <span class="code">toList</span> on that <span class="code">TreeSet</span>.</p>
      <p>The difference between "<span class="code">xs</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">List</span>" and "<span class="code">xs.toList</span>" is that the implementation of <span class="code">toList</span> may be overridden by the concrete collection type of <span class="code">xs</span> to provide a more efficient way to convert its elements to a list than the default implementation, which copies all the elements of the collection. For instance, the <span class="code">ListBuffer</span> collection does override its <span class="code">toList</span> method with an implementation that runs in constant time and space.</p>
      <p>Keep in mind, however, that conversion to lists or arrays usually requires copying all of the elements of the collection, and thus may be slow for large collections. Sometimes you need to do it, though, due to an existing API. Further, many collections only have a few elements anyway, in which case there is only a small speed penalty.</p>
      <h4>Converting between mutable and immutable sets and maps</h4>
      <p>Another situation that arises occasionally is the need to<a id="i-1962569096-1"></a> convert a mutable set or map to an immutable one, or <i>vice versa</i>. To accomplish this, you can use the <span class="code">to</span> method shown on the previous page. Here's how you'd convert the immutable <span class="code">TreeSet</span> from the previous example to a mutable set, and back again to an immutable one:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
  <br>  scala&gt;&nbsp;treeSet
  <code class="output">res52:&nbsp;scala.collection.immutable.TreeSet[String]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;TreeSet(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;mutaSet&nbsp;=&nbsp;treeSet&nbsp;to&nbsp;<code class="typename">mutable.Set</code>
  <code class="output">mutaSet:&nbsp;scala.collection.mutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(red,&nbsp;blue,&nbsp;green,&nbsp;yellow)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;immutaSet&nbsp;=&nbsp;mutaSet&nbsp;to&nbsp;<code class="typename">Set</code>
  <code class="output">immutaSet:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Set(red,&nbsp;blue,&nbsp;green,&nbsp;yellow)</code>
</pre>
      <p>You can use the same technique to convert between mutable and immutable maps:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;muta&nbsp;=&nbsp;<code class="typename">mutable.Map</code>(<code class="quotedstring">"i"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"ii"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)
  <code class="output">muta:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(ii&nbsp;-&gt;&nbsp;2,i&nbsp;-&gt;&nbsp;1)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;immu&nbsp;=&nbsp;muta&nbsp;to&nbsp;<code class="typename">Map</code>
  <code class="output">immu:&nbsp;scala.collection.immutable.Map[String,Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Map(ii&nbsp;-&gt;&nbsp;2,&nbsp;i&nbsp;-&gt;&nbsp;1)</code>
</pre>
      <h3>17.5 Tuples</h3>
      <p>As described in <a href="#step9">Step 9</a> in <a href="#chap-next-steps-in-scala">Chapter 3</a>, a tuple combines a fixed<a id="i-862490197-1"></a> number of items together so that they can be passed around as a whole. Unlike an array or list, a tuple can hold objects with different types. Here is an example of a tuple holding an integer, a string, and the console:</p> <pre>  (<code class="literal">1</code>,&nbsp;<code class="quotedstring">"hello"</code>,&nbsp;<code class="typename">Console</code>)
</pre>
      <p>Tuples save you the tedium of defining simplistic data-heavy classes. Even though defining a class is already easy, it does require a certain minimum effort, which sometimes serves no purpose. Tuples save you the effort of choosing a name for the class, choosing a scope to define the class in, and choosing names for the members of the class. If your class simply holds an integer and a string, there is no clarity added by defining a class named <span class="code">AnIntegerAndAString</span>.</p>
      <p>Because tuples can combine objects of different types, tuples do not inherit from <span class="code">Iterable</span>. If you find yourself wanting to group exactly one integer and exactly one string, then you want a tuple, not a <span class="code">List</span> or <span class="code">Array</span>.</p>
      <p>A common application of tuples is returning multiple values from a method.<a id="i651595778-2"></a><a id="i2120520132-2"></a> For example, here is a method that finds the longest word in a collection and also returns its index:<a id="i-1690228669-3"></a></p> <pre>  <code class="vem">def</code>&nbsp;longestWord(words:&nbsp;<code class="typename">Array[String]</code>):&nbsp;(<code class="typename">String</code>,&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;word&nbsp;=&nbsp;words(<code class="literal">0</code>)
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;idx&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;until&nbsp;words.length)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(words(i).length&nbsp;&gt;&nbsp;word.length)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word&nbsp;=&nbsp;words(i)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;i
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;(word,&nbsp;idx)
  }
</pre>
      <p>Here is an example use of the method:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;longest&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longestWord(<code class="quotedstring">"The&nbsp;quick&nbsp;brown&nbsp;fox"</code>.split(<code class="quotedstring">"&nbsp;"</code>))
  <code class="output">longest:&nbsp;(String,&nbsp;Int)&nbsp;=&nbsp;(quick,1)</code>
</pre>
      <p>The <span class="code">longestWord</span> function here computes two items: <span class="code">word</span>, the longest word in the array, and <span class="code">idx</span>, the index of that word. To keep things simple, the function assumes there is at least one word in the list, and it breaks ties by choosing the word that comes earlier in the list. Once the function has chosen which word and index to return, it returns both of them together using the tuple syntax <span class="code">(word,</span>&nbsp;<span class="code">idx)</span>.</p>
      <p>To access elements of a tuple, you can use method <span class="code">_1</span> to access the first element, <span class="code">_2</span> to access the second, and so on:</p> <pre>  scala&gt;&nbsp;longest._1
  <code class="output">res53:&nbsp;String&nbsp;=&nbsp;quick</code>
  <br>  scala&gt;&nbsp;longest._2
  <code class="output">res54:&nbsp;Int&nbsp;=&nbsp;1</code>
</pre>
      <p>Additionally, you can assign each element of the tuple to its own<a id="i-467993090-2"></a> variable,<a href="#footnotemain17-6">[6]</a> like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;(word,&nbsp;idx)&nbsp;=&nbsp;longest
  <code class="output">word:&nbsp;String&nbsp;=&nbsp;quick</code>
  <code class="output">idx:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;word
  <code class="output">res55:&nbsp;String&nbsp;=&nbsp;quick</code>
</pre>
      <p>By the way, if you leave off the parentheses you get a different result:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;word,&nbsp;idx&nbsp;=&nbsp;longest
  <code class="output">word:&nbsp;(String,&nbsp;Int)&nbsp;=&nbsp;(quick,1)</code>
  <code class="output">idx:&nbsp;(String,&nbsp;Int)&nbsp;=&nbsp;(quick,1)</code>
</pre>
      <p>This syntax gives <a href="#g-181260432"><em>multiple definitions</em></a> of the same expression.<a id="i1286114796-1"></a><a id="i664504196-1"></a> Each variable is initialized with its own evaluation of the expression on the right-hand side. That the expression evaluates to a tuple in this case does not matter. Both variables are initialized to the tuple in its entirety. See <a href="#chap-mutable-objects">Chapter 18</a> for some examples where multiple definitions are convenient.</p>
      <p>As a note of warning, tuples are almost too easy to use. Tuples are<a id="i-726189942-1"></a><a id="i-516778869-1"></a> great when you combine data that has no meaning beyond "an A and a B." However, whenever the combination has some meaning, or you want to add some methods to the combination, it is better to go ahead and create a class. For example, do not use a 3-tuple for the combination of a month, a day, and a year. Make a <span class="code">Date</span> class. It makes your intentions explicit, which both clears up the code for human readers and gives the compiler and language opportunities to help you catch mistakes.</p>
      <h3>17.6 Conclusion</h3>
      <p>This chapter has given an overview of the Scala collections library and the most important classes and traits in it. With this foundation you should be able to work effectively with Scala collections, and know where to look in Scaladoc when you need more information. For more detailed information about Scala collections, look ahead to <a href="#chap-collections-in-depth">Chapter 24</a> and <a href="#chap-the-architecture-of-scala-collections">Chapter 25</a>. For now, in the next chapter, we'll turn our attention from the Scala library back to the language and discuss Scala's support for mutable objects.</p>
      <hr>
      <h4>Footnotes for Chapter 17:</h4>
      <p><a id="footnotemain17-1"></a>[1] The difference in variance of Scala's and Java's arrays—<i>i.e.</i>, whether <span class="code">Array[String]</span> is a subtype of <span class="code">Array[AnyRef]</span>—will be discussed in <a href="#sec-first-arrays">Section 19.3</a>.</p>
      <p><a id="footnotemain17-2"></a>[2] The <span class="code">+=</span> and <span class="code">+=:</span> operators are aliases for <span class="code">append</span> and <span class="code">prepend</span>, respectively.</p>
      <p><a id="footnotemain17-3"></a>[3] The code given <a href="#subsec-scala-is-high-level">here</a> of <a href="#chap-a-scalable-language">Chapter 1</a> presents a similar example.</p>
      <p><a id="footnotemain17-4"></a>[4] The <span class="code">type</span> keyword will be explained in more detail in <a href="#sec-abstract-types">Section 20.6</a>.</p>
      <p><a id="footnotemain17-5"></a>[5] The "single object" is an instance of <span class="code">Set1</span> through <span class="code">Set4</span>, or <span class="code">Map1</span> through <span class="code">Map4</span>, as shown in <a href="#tab-default-sets">Tables 17.3</a> <a href="#tab-default-maps">and 17.4</a>.</p>
      <p><a id="footnotemain17-6"></a>[6] This syntax is actually a special case of <em>pattern matching</em>, as described in detail in <a href="#sec-patterns-everywhere">Section 15.7</a>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-mutable-objects">Chapter 18</a></h2>
      <h1>Mutable Objects</h1>
      <p>In previous chapters, we put the spotlight on functional (immutable) objects. We did so because the idea of objects without any mutable state deserves to be better known.<a id="i-1391607683-1"></a> However, it is also perfectly possible to define objects with mutable state in Scala. Such mutable objects often come up naturally when you want to model objects in the real world that change over time.<a id="i-166063424-1"></a></p>
      <p>This chapter explains what mutable objects are and what Scala provides in terms of syntax to express them. We will also introduce a larger case study on discrete event simulation, which involves mutable objects, as well as building an internal DSL for defining digital circuits to simulate.</p>
      <h3>18.1 What makes an object mutable?</h3>
      <p>You can observe the principal difference between a purely functional object and a mutable one even without looking at the object's implementation. When you invoke a method or dereference a field on some purely functional object, you will always get the same result.</p>
      <p>For instance, given a list of characters:</p> <pre>  <code class="vem">val</code>&nbsp;cs&nbsp;=&nbsp;<code class="typename">List</code>(<code class="quotedstring">'a'</code>,&nbsp;<code class="quotedstring">'b'</code>,&nbsp;<code class="quotedstring">'c'</code>)
</pre>
      <p>an application of <span class="code">cs.head</span> will always return <span class="code">'a'</span>. This is the case even if there is an arbitrary number of operations on the list <span class="code">cs</span> between the point where it is defined and the point where the access <span class="code">cs.head</span> is made.</p>
      <p>For a mutable object, on the other hand, the result of a method call or field access may depend on what operations were previously performed on the object. A good example of a mutable object is a bank account. <a href="#lst-bank-account">Listing 18.1</a> shows a simplified implementation of bank accounts: <a id="lst-bank-account"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">BankAccount</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;bal:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="literal">0</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;balance:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;bal
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;deposit(amount:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(amount&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bal&nbsp;+=&nbsp;amount
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;withdraw(amount:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(amount&nbsp;&gt;&nbsp;bal)&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bal&nbsp;-=&nbsp;amount
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}&nbsp;
</pre>
      <h5>Listing 18.1 - A mutable bank account class.</h5>
      <p>The <span class="code">BankAccount</span> class defines a private variable, <span class="code">bal</span>, and three public methods: <span class="code">balance</span> returns the current balance; <span class="code">deposit</span> adds a given <span class="code">amount</span> to <span class="code">bal</span>; and <span class="code">withdraw</span> tries to subtract a given <span class="code">amount</span> from <span class="code">bal</span> while assuring that the remaining balance won't be negative. The return value of <span class="code">withdraw</span> is a <span class="code">Boolean</span> indicating whether the requested funds were successfully withdrawn.</p>
      <p>Even if you know nothing about the inner workings of the <span class="code">BankAccount</span> class, you can still tell that <span class="code">BankAccount</span>s are mutable objects:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;account&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BankAccount</code>
  <code class="output">account:&nbsp;BankAccount&nbsp;=&nbsp;BankAccount@d504137</code>
  <br>  scala&gt;&nbsp;account&nbsp;deposit&nbsp;<code class="literal">100</code>
  <br>  scala&gt;&nbsp;account&nbsp;withdraw&nbsp;<code class="literal">80</code>
  <code class="output">res1:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;&nbsp;account&nbsp;withdraw&nbsp;<code class="literal">80</code>
  <code class="output">res2:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>Note that the two final withdrawals in the previous interaction returned different results. The first withdraw operation returned <span class="code">true</span> because the bank account contained sufficient funds to allow the withdrawal. The second operation, although the same as the first one, returned <span class="code">false</span> because the balance of the account had been reduced so that it no longer covered the requested funds. So, clearly, bank accounts have mutable state, because the same operation can return different results at different times.</p>
      <p>You might think that the mutability of <span class="code">BankAccount</span> is immediately apparent because it contains a <span class="code">var</span> definition<a id="i176085891-1"></a>. Mutation and <span class="code">var</span>s usually go hand in hand, but things are not always so clear cut. For instance, a class might be mutable without defining or inheriting any <span class="code">var</span>s because it forwards method calls to other objects that have mutable state. The reverse is also possible: A class might contain <span class="code">var</span>s and still be purely functional. An example would be a class that caches the result of an expensive operation in a field for optimization purposes. To pick an example, assume the following unoptimized class <span class="code">Keyed</span> with an expensive operation <span class="code">computeKey</span>:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Keyed</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;computeKey:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;...&nbsp;<code class="comment">//&nbsp;this&nbsp;will&nbsp;take&nbsp;some&nbsp;time</code>
  &nbsp;&nbsp;...
  }
</pre>
      <p>Provided that <span class="code">computeKey</span> neither reads nor writes any <span class="code">var</span>s, you can make <span class="code">Keyed</span> more efficient by adding a cache:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">MemoKeyed</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Keyed</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;keyCache:&nbsp;<code class="typename">Option[Int]</code>&nbsp;=&nbsp;<code class="typename">None</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;computeKey:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(!keyCache.isDefined)&nbsp;keyCache&nbsp;=&nbsp;<code class="typename">Some</code>(<code class="vem">super</code>.computeKey)
  &nbsp;&nbsp;&nbsp;&nbsp;keyCache.get
  &nbsp;&nbsp;}
  }
</pre>
      <p>Using <span class="code">MemoKeyed</span> instead of <span class="code">Keyed</span> can speed things up because the second time the result of the <span class="code">computeKey</span> operation is requested, the value stored in the <span class="code">keyCache</span> field can be returned instead of running <span class="code">computeKey</span> once again. But except for this speed gain, the behavior of class <span class="code">Keyed</span> and <span class="code">MemoKeyed</span> is exactly the same. Consequently, if <span class="code">Keyed</span> is purely functional, then so is <span class="code">MemoKeyed</span>, even though it contains a reassignable variable.</p>
      <h3 id="sec-properties">18.2 Reassignable variables and properties</h3>
      <p>You can perform two fundamental operations on a reassignable<a id="i-926053069-2"></a> variable<a id="i717358687-1"></a>: get its value or set it to a new value. In libraries such as JavaBeans, these operations are often encapsulated in separate getter<a id="i-1969580643-1"></a> and setter<a id="i553650449-1"></a> methods,<a id="i696953561-1"></a> which need to be defined explicitly.</p>
      <p>In Scala, every <span class="code">var</span> that is a non-private member of some object implicitly defines a getter and a setter method with it. These getters and setters are named differently from the Java convention, however. The getter of a <span class="code">var</span> <span class="code">x</span> is just named "<span class="code">x</span>", while its setter is named "<span class="code">x_=</span>"<a id="i-1901486033-1"></a>.</p>
      <p>For example, if it appears in a class, the <span class="code">var</span> definition:</p> <pre>  <code class="vem">var</code>&nbsp;hour&nbsp;=&nbsp;<code class="literal">12</code>
</pre>
      <p>generates a getter, "<span class="code">hour</span>", and setter, "<span class="code">hour_=</span>", in addition to a reassignable field. The field is always marked <span class="code">private[this]</span>, which means it can be accessed only from the object that contains it. The getter and setter, on the other hand, get the same visibility as the original <span class="code">var</span>. If the <span class="code">var</span> definition is public, so are its getter and setter. If it is <span class="code">protected</span>, they are also <span class="code">protected</span>, and so on.</p>
      <p>For instance, consider the class <span class="code">Time</span> shown in <a href="#lst-class-with-public-vars">Listing 18.2</a>, which defines two public <span class="code">var</span>s named <span class="code">hour</span> and <span class="code">minute</span>:</p>
      <p><a id="lst-class-with-public-vars"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Time</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;hour&nbsp;=&nbsp;<code class="literal">12</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;minute&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 18.2 - A class with public <span class="code">var</span>s.</h5>
      <p>This implementation is exactly equivalent to the class definition shown in <a href="#lst-public-var-expansion">Listing 18.3</a>. In the definitions shown in <a href="#lst-public-var-expansion">Listing 18.3</a>, the names of the local fields <span class="code">h</span> and <span class="code">m</span> are arbitrarily chosen so as not to clash with any names already in use.</p>
      <p><a id="lst-public-var-expansion"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Time</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;h&nbsp;=&nbsp;<code class="literal">12</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;m&nbsp;=&nbsp;<code class="literal">0</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;hour:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;h
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;hour_=(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{&nbsp;h&nbsp;=&nbsp;x&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;minute:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;m
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;minute_=(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{&nbsp;m&nbsp;=&nbsp;x&nbsp;}
  &nbsp;&nbsp;}&nbsp;
</pre>
      <h5>Listing 18.3 - How public <span class="code">var</span>s are expanded into getter and setter methods.</h5>
      <p>An interesting aspect about this expansion of <span class="code">var</span>s into getters and setters is that you can also choose to define a getter and a setter directly, instead of defining a <span class="code">var</span>. By defining these access methods directly you can interpret the operations of variable access and variable assignment as you like. For instance, the variant of class <span class="code">Time</span> shown in <a href="#lst-hand-written-get-set">Listing 18.4</a> contains requirements that catch all assignments to <span class="code">hour</span> and <span class="code">minute</span> with illegal values.</p>
      <p><a id="lst-hand-written-get-set"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Time</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;h&nbsp;=&nbsp;<code class="literal">12</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;m&nbsp;=&nbsp;<code class="literal">0</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;hour:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;h
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;hour_=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(<code class="literal">0</code>&nbsp;&lt;=&nbsp;x&nbsp;&amp;&amp;&nbsp;x&nbsp;&lt;&nbsp;<code class="literal">24</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;=&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;minute&nbsp;=&nbsp;m
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;minute_=&nbsp;(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(<code class="literal">0</code>&nbsp;&lt;=&nbsp;x&nbsp;&amp;&amp;&nbsp;x&nbsp;&lt;&nbsp;<code class="literal">60</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}&nbsp;
</pre>
      <h5>Listing 18.4 - Defining getter and setter methods directly.</h5>
      <p>Some languages have a special syntactic construct for these variable-like quantities that are not plain variables in that their getter or setter can be redefined. For instance, C# has properties, which fulfill this role. In effect, Scala's convention of always interpreting a variable as a pair of setter and getter methods gives you the same capabilities as C# properties without requiring special syntax<a id="i1153498175-1"></a>.</p>
      <p>Properties can serve many different purposes. In the example shown in <a href="#lst-hand-written-get-set">Listing 18.4</a>, the setters enforced an invariant, thus protecting the variable from being assigned illegal values. You could also use a property to log all accesses to getters or setters of a variable. Or you could integrate variables with events, for instance by notifying some subscriber methods each time a variable is modified (you'll see examples of this in <a href="#chap-the-scells-spreadsheet">Chapter 35</a>).</p>
      <p>It's also possible, and sometimes useful, to define a getter and a setter without an associated field. For example, <a href="#lst-class-thermometer">Listing 18.5</a> shows a <span class="code">Thermometer</span> class, which encapsulates a temperature variable that can be read and updated. Temperatures can be expressed in Celsius or Fahrenheit degrees. This class allows you to get and set the temperature in either measure.</p>
      <p><a id="lst-class-thermometer"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Thermometer</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;celsius:&nbsp;<code class="typename">Float</code>&nbsp;=&nbsp;_
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fahrenheit&nbsp;=&nbsp;celsius&nbsp;*&nbsp;<code class="literal">9</code>&nbsp;/&nbsp;<code class="literal">5</code>&nbsp;+&nbsp;<code class="literal">32</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fahrenheit_=&nbsp;(f:&nbsp;<code class="typename">Float</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;celsius&nbsp;=&nbsp;(f&nbsp;-&nbsp;<code class="literal">32</code>)&nbsp;*&nbsp;<code class="literal">5</code>&nbsp;/&nbsp;<code class="literal">9</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"${fahrenheit}F/${celsius}C"</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 18.5 - Defining a getter and setter without an associated field.</h5>
      <p>The first line in the body of this class defines a <span class="code">var</span>, <span class="code">celsius</span>, which will contain the temperature in degrees Celsius. The <span class="code">celsius</span> variable is initially set to a default value by specifying `<span class="code">_</span>' as the "initializing value" of the variable. More precisely, an initializer<a id="i969211487-1"></a><a id="i769452465-1"></a><a id="i1897052361-1"></a><a id="i1853080782-1"></a><a id="i-388295396-1"></a> "<span class="code">=</span>&nbsp;<span class="code">_</span>" of a field assigns a zero value to that field. The zero value depends on the field's type. It is <span class="code">0</span> for numeric types, <span class="code">false</span> for booleans, and <span class="code">null</span> for reference types. This is the same as if the same variable was defined in Java without an initializer.</p>
      <p>Note that you cannot simply leave off the "<span class="code">=</span>&nbsp;<span class="code">_</span>" initializer in Scala. If you had written:</p> <pre>  <code class="vem">var</code>&nbsp;celsius:&nbsp;<code class="typename">Float</code>
</pre>
      <p>this would declare an abstract variable, not an uninitialized one.<a href="#footnotemain18-1">[1]</a></p>
      <p>The <span class="code">celsius</span> variable definition is followed by a getter, "<span class="code">fahrenheit</span>", and a setter, "<span class="code">fahrenheit_=</span>", which access the same temperature, but in degrees Fahrenheit. There is no separate field that contains the current temperature value in Fahrenheit. Instead the getter and setter methods for Fahrenheit values automatically convert from and to degrees Celsius, respectively. Here's an example of interacting with a <span class="code">Thermometer</span> object:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;t&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Thermometer</code>
  <code class="output">t:&nbsp;Thermometer&nbsp;=&nbsp;32.0F/0.0C</code>
  <br>  scala&gt;&nbsp;t.celsius&nbsp;=&nbsp;<code class="literal">100</code>
  <code class="output">mutated&nbsp;t.celsius</code>
  <br>  scala&gt;&nbsp;t
  <code class="output">res3:&nbsp;Thermometer&nbsp;=&nbsp;212.0F/100.0C</code>
  <br>  scala&gt;&nbsp;t.fahrenheit&nbsp;=&nbsp;-<code class="literal">40</code>
  <code class="output">mutated&nbsp;t.fahrenheit</code>
  <br>  scala&gt;&nbsp;t
  <code class="output">res4:&nbsp;Thermometer&nbsp;=&nbsp;-40.0F/-40.0C</code>
</pre>
      <h3>18.3 Case study: Discrete event simulation</h3>
      <p>The rest of this chapter shows by way of an extended example how mutable objects can be combined with first-class function values in interesting ways. You'll see the design and implementation of a simulator for digital circuits. This task is broken down into several subproblems, each of which is interesting individually.</p>
      <p>First, you'll see a little language for digital circuits. The definition of this language will highlight a general method for embedding domain-specific languages (DSL) in a host language like Scala.<a id="i-1851490486-1"></a> Second, we'll present a simple but general framework for discrete event simulation. Its main task will be to keep track of actions that are performed in simulated time. Finally, we'll show how discrete simulation programs can be structured and built. The idea of such simulations is to model physical objects by simulated objects, and use the simulation framework to model physical time.</p>
      <p>The example is taken from the classic textbook <em>Structure and Interpretation of Computer Programs</em> by Abelson and Sussman <a href="#abelson-sussman-structure">[Abe96]</a>.<a id="i-72492243-1"></a><a id="i471924076-1"></a><a id="i-1712702061-1"></a> What's different here is that the implementation language is Scala instead of Scheme, and that the various aspects of the example are structured into four software layers: one for the simulation framework, another for the basic circuit simulation package, a third for a library of user-defined circuits, and the last layer for each simulated circuit itself. Each layer is expressed as a class, and more specific layers inherit from more general ones.</p>
      <div class="pointofinterest">
        <h3>The fast track</h3>
        <p>Understanding the discrete event simulation example presented in this chapter will take some time. If you feel you want to get on with learning more Scala instead, it's safe to skip ahead to the next chapter.</p>
      </div>
      <div class="figure">
        <a id="fig-gates"></a>
        <p><img src="basicgates160.png" alt="images/basicgates160.png"></p>
      </div>
      <h5> Figure 18.1 - Basic gates.</h5>
      <h3 id="sec-language-circuits">18.4 A language for digital circuits</h3>
      <p>We'll start with a "little language" to describe digital circuits. A digital circuit is built from <span style="font-style:italic">wires</span> and <span style="font-style:italic">function boxes</span>. Wires carry <span style="font-style:italic">signals</span>, which are transformed by function boxes. Signals are represented by booleans: <span class="code">true</span> for signal-on and <span class="code">false</span> for signal-off.</p>
      <p><a href="#fig-gates">Figure 18.1</a> shows three basic function boxes (or <span style="font-style:italic">gates</span>):</p>
      <ul>
        <li>An <em>inverter</em>, which negates its signal. </li>
        <li>An <em>and-gate</em>, which sets its output to the conjunction of its inputs. </li>
        <li>An <em>or-gate</em>, which sets its output to the disjunction of its inputs. </li>
      </ul>
      <p>These gates are sufficient to build all other function boxes. Gates have <span style="font-style:italic">delays</span>, so an output of a gate will change only some time after its inputs change.</p>
      <p>We'll describe the elements of a digital circuit by the following set of Scala classes and functions. First, there is a class <span class="code">Wire</span> for wires. We can construct wires like this:</p> <pre>  <code class="vem">val</code>&nbsp;a&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Wire</code>
  <code class="vem">val</code>&nbsp;b&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Wire</code>
  <code class="vem">val</code>&nbsp;c&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Wire</code>
</pre>
      <p>or, equivalent but shorter, like this:</p> <pre>  <code class="vem">val</code>&nbsp;a,&nbsp;b,&nbsp;c&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Wire</code>
</pre>
      <p>Second, there are three procedures which "make" the basic gates we need:</p> <pre>  <code class="vem">def</code>&nbsp;inverter(input:&nbsp;<code class="typename">Wire</code>,&nbsp;output:&nbsp;<code class="typename">Wire</code>)
  <code class="vem">def</code>&nbsp;andGate(a1:&nbsp;<code class="typename">Wire</code>,&nbsp;a2:&nbsp;<code class="typename">Wire</code>,&nbsp;output:&nbsp;<code class="typename">Wire</code>)
  <code class="vem">def</code>&nbsp;orGate(o1:&nbsp;<code class="typename">Wire</code>,&nbsp;o2:&nbsp;<code class="typename">Wire</code>,&nbsp;output:&nbsp;<code class="typename">Wire</code>)
</pre>
      <p>What's unusual, given the functional emphasis of Scala, is that these procedures construct the gates as a side effect, instead of returning the constructed gates as a result. For instance, an invocation of <span class="code">inverter(a,</span>&nbsp;<span class="code">b)</span> places an inverter between the wires <span class="code">a</span> and <span class="code">b</span>. It turns out that this side-effecting construction makes it easier to construct complicated circuits gradually. Also, although methods most often have verb names, these have noun names that indicate which gate they are making. This reflects the declarative nature of the DSL: it should describe a circuit, not the actions of making one.</p>
      <p>More complicated function boxes can be built from the basic gates. For instance, the method shown in <a href="#lst-half-adder">Listing 18.6</a> constructs a half-adder. The <span class="code">halfAdder</span> method takes two inputs, <span class="code">a</span> and <span class="code">b</span>, and produces a sum, <span class="code">s</span>, defined by "<span class="code">s</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">(a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b)</span>&nbsp;<span class="code"><span class="texttt">%</span></span>&nbsp;<span class="code">2</span>" and a carry, <span class="code">c</span>, defined by "<span class="code">c</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">(a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b)</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">2</span>". A diagram of the half-adder is shown in <a href="#fig-half-adder">Figure 18.2</a>.</p>
      <p><a id="lst-half-adder"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;halfAdder(a:&nbsp;<code class="typename">Wire</code>,&nbsp;b:&nbsp;<code class="typename">Wire</code>,&nbsp;s:&nbsp;<code class="typename">Wire</code>,&nbsp;c:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;d,&nbsp;e&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Wire</code>
  &nbsp;&nbsp;&nbsp;&nbsp;orGate(a,&nbsp;b,&nbsp;d)
  &nbsp;&nbsp;&nbsp;&nbsp;andGate(a,&nbsp;b,&nbsp;c)
  &nbsp;&nbsp;&nbsp;&nbsp;inverter(c,&nbsp;e)
  &nbsp;&nbsp;&nbsp;&nbsp;andGate(d,&nbsp;e,&nbsp;s)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 18.6 - The <span class="code">halfAdder</span> method.</h5>
      <div class="figure">
        <a id="fig-half-adder"></a>
        <p><img src="halfadder160.png" alt="images/halfadder160.png"></p>
      </div>
      <h5> Figure 18.2 - A half-adder circuit.</h5>
      <p>Note that <span class="code">halfAdder</span> is a parameterized function box just like the three methods that construct the primitive gates. You can use the <span class="code">halfAdder</span> method to construct more complicated circuits. For instance, <a href="#lst-full-adder">Listing 18.7</a> defines a full, one-bit adder, shown in <a href="#fig-full-adder">Figure 18.3</a>, which takes two inputs, <span class="code">a</span> and <span class="code">b</span>, as well as a carry-in, <span class="code">cin</span>, and which produces a sum output defined by "<span class="code">sum</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">(a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">cin)</span>&nbsp;<span class="code"><span class="texttt">%</span></span>&nbsp;<span class="code">2</span>" and a carry-out output defined by "<span class="code">cout</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">(a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">cin)</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">2</span>".</p>
      <p><a id="lst-full-adder"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;fullAdder(a:&nbsp;<code class="typename">Wire</code>,&nbsp;b:&nbsp;<code class="typename">Wire</code>,&nbsp;cin:&nbsp;<code class="typename">Wire</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum:&nbsp;<code class="typename">Wire</code>,&nbsp;cout:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;s,&nbsp;c1,&nbsp;c2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Wire</code>
  &nbsp;&nbsp;&nbsp;&nbsp;halfAdder(a,&nbsp;cin,&nbsp;s,&nbsp;c1)
  &nbsp;&nbsp;&nbsp;&nbsp;halfAdder(b,&nbsp;s,&nbsp;sum,&nbsp;c2)
  &nbsp;&nbsp;&nbsp;&nbsp;orGate(c1,&nbsp;c2,&nbsp;cout)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 18.7 - The <span class="code">fullAdder</span> method.</h5>
      <p>Class <span class="code">Wire</span> and functions <span class="code">inverter</span>, <span class="code">andGate</span>, and <span class="code">orGate</span> represent a little language with which users can define digital circuits. It's a good example of an <em>internal</em> DSL, a domain-specific language defined as a library in a host language instead of being implemented on its own.</p>
      <div class="figure">
        <a id="fig-full-adder"></a>
        <p><img src="fulladder160.png" alt="images/fulladder160.png"></p>
      </div>
      <h5> Figure 18.3 - A full-adder circuit.</h5>
      <p>The implementation of the circuit DSL still needs to be worked out. Since the purpose of defining a circuit in the DSL is simulating the circuit, it makes sense to base the DSL implementation on a general API for discrete event simulation. The next two sections will present first the simulation API and then the implementation of the circuit DSL on top of it.</p>
      <h3>18.5 The <span class="code">Simulation</span> API</h3>
      <p>The simulation API is shown in <a href="#lst-simulation">Listing 18.8</a>. It consists of class <span class="code">Simulation</span> in package <span class="code">org.stairwaybook.simulation</span>. Concrete simulation libraries inherit this class and augment it with domain-specific functionality. The elements of the <span class="code">Simulation</span> class are presented in this section.</p>
      <p><a id="lst-simulation"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Simulation</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Action</code>&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">WorkItem</code>(time:&nbsp;<code class="typename">Int</code>,&nbsp;action:&nbsp;<code class="typename">Action</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;curtime&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;currentTime:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;curtime
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;agenda:&nbsp;<code class="typename">List[WorkItem]</code>&nbsp;=&nbsp;<code class="typename">List</code>()
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;insert(ag:&nbsp;<code class="typename">List[WorkItem]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item:&nbsp;<code class="typename">WorkItem</code>):&nbsp;<code class="typename">List[WorkItem]</code>&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(ag.isEmpty&nbsp;||&nbsp;item.time&nbsp;&lt;&nbsp;ag.head.time)&nbsp;item&nbsp;::&nbsp;ag
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;ag.head&nbsp;::&nbsp;insert(ag.tail,&nbsp;item)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;afterDelay(delay:&nbsp;<code class="typename">Int</code>)(block:&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;item&nbsp;=&nbsp;<code class="typename">WorkItem</code>(currentTime&nbsp;+&nbsp;delay,&nbsp;()&nbsp;=&gt;&nbsp;block)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;agenda&nbsp;=&nbsp;insert(agenda,&nbsp;item)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;next()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(agenda:&nbsp;@unchecked)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;item&nbsp;::&nbsp;rest&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;agenda&nbsp;=&nbsp;rest&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curtime&nbsp;=&nbsp;item.time
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item.action()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;run()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<code class="literal">0</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"***&nbsp;simulation&nbsp;started,&nbsp;time&nbsp;=&nbsp;"</code>&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentTime&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;***"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(!agenda.isEmpty)&nbsp;next()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 18.8 - The <span class="code">Simulation</span> class.</h5>
      <p>A discrete event simulation performs user-defined <span style="font-style:italic">actions</span> at specified <em>times</em>. The actions, which are defined by concrete simulation subclasses, all share a common type:</p> <pre>  <code class="vem">type</code>&nbsp;<code class="typename">Action</code>&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>
</pre>
      <p>This statement defines <span class="code">Action</span> to be an alias of the type of procedure that takes an empty parameter list and returns <span class="code">Unit</span>. <span class="code">Action</span> is a <em>type member</em> of class <span class="code">Simulation</span>. You can think of it as a more readable name for type <span class="code">()</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Unit</span>. Type members will be described in detail in <a href="#sec-abstract-types">Section 20.6</a>.</p>
      <p>The time at which an action is performed is simulated time; it has nothing to do with the actual "wall clock" time. Simulated times are represented simply as integers. The current simulated time is kept in a private variable:</p> <pre>  <code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;curtime:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="literal">0</code>
</pre>
      <p>The variable has a public accessor method, which retrieves the current time:</p> <pre>  <code class="vem">def</code>&nbsp;currentTime:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;curtime
</pre>
      <p>This combination of private variable with public accessor is used to make sure that the current time cannot be modified outside the <span class="code">Simulation</span> class. After all, you don't usually want your simulation objects to manipulate the current time, except possibly if your simulation models time travel.</p>
      <p>An action that needs to be executed at a specified time is called a <span style="font-style:italic">work item</span>. Work items are implemented by the following class:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">WorkItem</code>(time:&nbsp;<code class="typename">Int</code>,&nbsp;action:&nbsp;<code class="typename">Action</code>)
</pre>
      <p>We made the <span class="code">WorkItem</span> class a case class because of the syntactic conveniences this entails: You can use the factory method, <span class="code">WorkItem</span>, to create instances of the class, and you get accessors for the constructor parameters <span class="code">time</span> and <span class="code">action</span> for free. Note also that class <span class="code">WorkItem</span> is nested inside class <span class="code">Simulation</span>. Nested classes in Scala are treated similarly to Java. <a href="#sec-path-dependent-types">Section 20.7</a> will give more details.</p>
      <p>The <span class="code">Simulation</span> class keeps an <span style="font-style:italic">agenda</span> of all remaining work items that have not yet been executed. The work items are sorted by the simulated time at which they have to be run:</p> <pre>  <code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;agenda:&nbsp;<code class="typename">List[WorkItem]</code>&nbsp;=&nbsp;<code class="typename">List</code>()
</pre>
      <p>The <span class="code">agenda</span> list will be kept in the proper sorted order by the <span class="code">insert</span> method, which updates it. You can see <span class="code">insert</span> being called from <span class="code">afterDelay</span>, which is the only way to add a work item to the agenda:</p> <pre>  <code class="vem">def</code>&nbsp;afterDelay(delay:&nbsp;<code class="typename">Int</code>)(block:&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;item&nbsp;=&nbsp;<code class="typename">WorkItem</code>(currentTime&nbsp;+&nbsp;delay,&nbsp;()&nbsp;=&gt;&nbsp;block)
  &nbsp;&nbsp;agenda&nbsp;=&nbsp;insert(agenda,&nbsp;item)
  }
</pre>
      <p>As the name implies, this method inserts an action (given by <span class="code">block</span>) into the agenda so that it is scheduled for execution <span class="code">delay</span> time units after the current simulation time. For instance, the following invocation would create a new work item to be executed at the simulated time, <span class="code">currentTime</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">delay</span>:</p> <pre>  afterDelay(delay)&nbsp;{&nbsp;count&nbsp;+=&nbsp;<code class="literal">1</code>&nbsp;}
</pre>
      <p>The code to be executed is contained in the method's second argument. The formal parameter for this argument has type "<span class="code">=&gt;</span>&nbsp;<span class="code">Unit</span>" (<i>i.e.</i>, it is a computation of type <span class="code">Unit</span> which is passed by name). Recall that by-name parameters<a id="i-1931276111-2"></a><a id="i-2031769303-2"></a> are not evaluated when passed to a method. So in the call above, <span class="code">count</span> would be incremented only when the simulation framework calls the action stored in the work item. Note that <span class="code">afterDelay</span> is a curried function. It's a good example of the principle set forward in <a href="#sec-by-name-parameters">Section 9.5</a> that currying can be used to make method calls look more like built-in syntax. The created work item still needs to be inserted into the agenda. This is done by the <span class="code">insert</span> method, which maintains the invariant that the agenda is time-sorted:</p> <pre>  <code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;insert(ag:&nbsp;<code class="typename">List[WorkItem]</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;item:&nbsp;<code class="typename">WorkItem</code>):&nbsp;<code class="typename">List[WorkItem]</code>&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(ag.isEmpty&nbsp;||&nbsp;item.time&nbsp;&lt;&nbsp;ag.head.time)&nbsp;item&nbsp;::&nbsp;ag
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;ag.head&nbsp;::&nbsp;insert(ag.tail,&nbsp;item)
  }
</pre>
      <p>The core of the <span class="code">Simulation</span> class is defined by the <span class="code">run</span> method:</p> <pre>  <code class="vem">def</code>&nbsp;run()&nbsp;=&nbsp;{
  &nbsp;&nbsp;afterDelay(<code class="literal">0</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"***&nbsp;simulation&nbsp;started,&nbsp;time&nbsp;=&nbsp;"</code>&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentTime&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;***"</code>)
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(!agenda.isEmpty)&nbsp;next()
  }
</pre>
      <p>This method repeatedly takes the first item in the agenda, removes it from the agenda and executes it. It does this until there are no more items left in the agenda to execute. Each step is performed by calling the <span class="code">next</span> method, which is defined as follows:</p> <pre>  <code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;next()&nbsp;=&nbsp;{
  &nbsp;&nbsp;(agenda:&nbsp;@unchecked)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;item&nbsp;::&nbsp;rest&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;agenda&nbsp;=&nbsp;rest&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curtime&nbsp;=&nbsp;item.time
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item.action()
  &nbsp;&nbsp;}
  }
</pre>
      <p>The <span class="code">next</span> method decomposes the current agenda with a pattern match into a front item, <span class="code">item</span>, and a remaining list of work items, <span class="code">rest</span>. It removes the front item from the current agenda, sets the simulated time <span class="code">curtime</span> to the work item's time, and executes the work item's action.<a id="i1154860961-1"></a></p>
      <p>Note that <span class="code">next</span> can be called only if the agenda is non-empty. There's no case for an empty list, so you would get a <span class="code">MatchError</span> exception if you tried to run <span class="code">next</span> on an empty agenda.</p>
      <p>In fact, the Scala compiler would normally warn you that you missed one of the possible patterns for a list:<a id="i-160448460-2"></a></p> <pre>  <code class="output">Simulator.scala:19:&nbsp;warning:&nbsp;match&nbsp;is&nbsp;not&nbsp;exhaustive!</code>
  <code class="output">missing&nbsp;combination&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nil</code>
  <code class="output"></code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;agenda&nbsp;match&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">one&nbsp;warning&nbsp;found</code>
</pre>
      <p>In this case, the missing case is not a problem because you know that <span class="code">next</span> is called only on a non-empty agenda. Therefore, you might want to disable the warning. You saw in <a href="#sec-sealed-classes">Section 15.5</a> that this can be done by adding an <span class="code">@unchecked</span><a id="i-2035290207-2"></a><a id="i-815574504-2"></a> annotation to the selector expression of the pattern match. That's why the <span class="code">Simulation</span> code uses "<span class="code">(agenda:</span> <span class="code">@unchecked)</span> <span class="code">match</span>", not "<span class="code">agenda</span>&nbsp;<span class="code">match</span>". That's it. This might look like surprisingly little code for a simulation framework. You might wonder how this framework could possibly support interesting simulations, if all it does is execute a list of work items? In fact the power of the simulation framework comes from the fact that actions stored in work items can themselves install further work items into the agenda when they are executed. That makes it possible to have long-running simulations evolve from simple beginnings.</p>
      <h3>18.6 Circuit Simulation</h3>
      <p>The next step is to use the simulation framework to implement the domain-specific language for circuits shown in <a href="#sec-language-circuits">Section 18.4</a>. Recall that the circuit DSL consists of a class for wires and methods that create and-gates, or-gates, and inverters. These are all contained in a <span class="code">BasicCircuitSimulation</span> class, which extends the simulation framework. This class is shown in <a href="#lst-top-basic-circuit-simulation">Listings 18.9</a> <a href="#lst-bottom-basic-circuit-simulation">and 18.10</a>.</p>
      <p><a id="lst-top-basic-circuit-simulation"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.simulation
  <br>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">BasicCircuitSimulation</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Simulation</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="typename">InverterDelay</code>:&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="typename">AndGateDelay</code>:&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="typename">OrGateDelay</code>:&nbsp;<code class="typename">Int</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Wire</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;sigVal&nbsp;=&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;actions:&nbsp;<code class="typename">List[Action]</code>&nbsp;=&nbsp;<code class="typename">List</code>()
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;getSignal&nbsp;=&nbsp;sigVal
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;setSignal(s:&nbsp;<code class="typename">Boolean</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s&nbsp;!=&nbsp;sigVal)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigVal&nbsp;=&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;foreach&nbsp;(_&nbsp;())&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;addAction(a:&nbsp;<code class="typename">Action</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;=&nbsp;a&nbsp;::&nbsp;actions
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;inverter(input:&nbsp;<code class="typename">Wire</code>,&nbsp;output:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;invertAction()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;inputSig&nbsp;=&nbsp;input.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<code class="typename">InverterDelay</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;!inputSig&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input&nbsp;addAction&nbsp;invertAction
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;continued&nbsp;in&nbsp;Listing&nbsp;18.10...</code>
</pre>
      <h5>Listing 18.9 - The first half of the <span class="code">BasicCircuitSimulation</span> class.</h5>
      <p><a id="lst-bottom-basic-circuit-simulation"></a></p> <pre>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;...continued&nbsp;from&nbsp;Listing&nbsp;18.9</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;andGate(a1:&nbsp;<code class="typename">Wire</code>,&nbsp;a2:&nbsp;<code class="typename">Wire</code>,&nbsp;output:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;andAction()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;a1Sig&nbsp;=&nbsp;a1.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;a2Sig&nbsp;=&nbsp;a2.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<code class="typename">AndGateDelay</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;(a1Sig&nbsp;&amp;&nbsp;a2Sig)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;addAction&nbsp;andAction
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a2&nbsp;addAction&nbsp;andAction
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;orGate(o1:&nbsp;<code class="typename">Wire</code>,&nbsp;o2:&nbsp;<code class="typename">Wire</code>,&nbsp;output:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;orAction()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;o1Sig&nbsp;=&nbsp;o1.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;o2Sig&nbsp;=&nbsp;o2.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<code class="typename">OrGateDelay</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;(o1Sig&nbsp;|&nbsp;o2Sig)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o1&nbsp;addAction&nbsp;orAction
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o2&nbsp;addAction&nbsp;orAction
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;probe(name:&nbsp;<code class="typename">String</code>,&nbsp;wire:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;probeAction()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;currentTime&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"&nbsp;new-value&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;wire.getSignal)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wire&nbsp;addAction&nbsp;probeAction
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 18.10 - The second half of the <span class="code">BasicCircuitSimulation</span> class.</h5>
      <p>Class <span class="code">BasicCircuitSimulation</span> declares three abstract methods that represent the delays of the basic gates: <span class="code">InverterDelay</span>, <span class="code">AndGateDelay</span>, and <span class="code">OrGateDelay</span>. The actual delays are not known at the level of this class because they depend on the technology of circuits that are simulated. That's why the delays are left abstract in class <span class="code">BasicCircuitSimulation</span>, so that their concrete definition is delegated to a subclass.<a href="#footnotemain18-2">[2]</a> The implementation of class <span class="code">BasicCircuitSimulation</span>'s other members is described next.</p>
      <h4>The <span class="code">Wire</span> class</h4>
      <p>A wire needs to support three basic actions:</p>
      <ul>
        <li><b></b> <span class="code">getSignal:</span>&nbsp;<span class="code">Boolean</span>: returns the current signal on the wire. </li>
        <li><b></b> <span class="code">setSignal(sig:</span>&nbsp;<span class="code">Boolean)</span>: sets the wire's signal to <span class="code">sig</span>. </li>
        <li><b></b> <span class="code">addAction(p:</span>&nbsp;<span class="code">Action)</span>: attaches the specified procedure <span class="code">p</span> to the <span style="font-style:italic">actions</span> of the wire. The idea is that all action procedures attached to some wire will be executed every time the signal of the wire changes. Typically actions are added to a wire by components connected to the wire. An attached action is executed once at the time it is added to a wire, and after that, every time the signal of the wire changes. </li>
      </ul>
      <p>Here is the implementation of the <span class="code">Wire</span> class:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Wire</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;sigVal&nbsp;=&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;actions:&nbsp;<code class="typename">List[Action]</code>&nbsp;=&nbsp;<code class="typename">List</code>()
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;getSignal&nbsp;=&nbsp;sigVal
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;setSignal(s:&nbsp;<code class="typename">Boolean</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s&nbsp;!=&nbsp;sigVal)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigVal&nbsp;=&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;foreach&nbsp;(_&nbsp;())&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;addAction(a:&nbsp;<code class="typename">Action</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;=&nbsp;a&nbsp;::&nbsp;actions
  &nbsp;&nbsp;&nbsp;&nbsp;a()
  &nbsp;&nbsp;}
  }
</pre>
      <p>Two private variables make up the state of a wire. The variable <span class="code">sigVal</span> represents the current signal, and the variable <span class="code">actions</span> represents the action procedures currently attached to the wire. The only interesting method implementation is the one for <span class="code">setSignal</span>: When the signal of a wire changes, the new value is stored in the variable <span class="code">sigVal</span>. Furthermore, all actions attached to a wire are executed. Note the shorthand syntax for doing this: "<span class="code">actions</span>&nbsp;<span class="code">foreach</span>&nbsp;<span class="code">(_</span>&nbsp;<span class="code">())</span>" applies the function, "<span class="code">_</span>&nbsp;<span class="code">()</span>", to each element in the <span class="code">actions</span> list. As described in <a href="#sec-placeholder-syntax">Section 8.5</a>, the function "<span class="code">_</span>&nbsp;<span class="code">()</span>" is a shorthand for "<span class="code">f</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">f</span>&nbsp;<span class="code">()</span>"—<i>i.e.</i>, it takes a function (we'll call it <span class="code">f</span>) and applies it to the empty parameter list.</p>
      <h4>The <span class="code">inverter</span> method</h4>
      <p>The only effect of creating an inverter is that an action is installed on its input wire. This action is invoked once at the time the action is installed, and thereafter every time the signal on the input changes. The effect of the action is that the value of the inverter's output value is set (via <span class="code">setSignal</span>) to the inverse of its input value. Since inverter gates have delays, this change should take effect only <span class="code">InverterDelay</span> units of simulated time after the input value has changed and the action was executed. This suggests the following implementation:</p> <pre>  <code class="vem">def</code>&nbsp;inverter(input:&nbsp;<code class="typename">Wire</code>,&nbsp;output:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;invertAction()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;inputSig&nbsp;=&nbsp;input.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<code class="typename">InverterDelay</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;!inputSig&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;input&nbsp;addAction&nbsp;invertAction
  }
</pre>
      <p>The effect of the <span class="code">inverter</span> method is to add <span class="code">invertAction</span> to the <span class="code">input</span> wire. This action, when invoked, gets the input signal and installs another action that inverts the <span class="code">output</span> signal into the simulation agenda. This other action is to be executed after <span class="code">InverterDelay</span> units of simulated time. Note how the method uses the <span class="code">afterDelay</span> method of the simulation framework to create a new work item that's going to be executed in the future.</p>
      <h4>The <span class="code">andGate</span> and <span class="code">orGate</span> methods</h4>
      <p>The implementation of and-gates is analogous to the implementation of inverters. The purpose of an and-gate is to output the conjunction of its input signals. This should happen at <span class="code">AndGateDelay</span> simulated time units after any one of its two inputs changes. Hence, the following implementation:</p> <pre>  <code class="vem">def</code>&nbsp;andGate(a1:&nbsp;<code class="typename">Wire</code>,&nbsp;a2:&nbsp;<code class="typename">Wire</code>,&nbsp;output:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;andAction()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;a1Sig&nbsp;=&nbsp;a1.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;a2Sig&nbsp;=&nbsp;a2.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<code class="typename">AndGateDelay</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;(a1Sig&nbsp;&amp;&nbsp;a2Sig)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;a1&nbsp;addAction&nbsp;andAction
  &nbsp;&nbsp;a2&nbsp;addAction&nbsp;andAction
  }
</pre>
      <p>The effect of the <span class="code">andGate</span> method is to add <span class="code">andAction</span> to both of its input wires <span class="code">a1</span> and <span class="code">a2</span>. This action, when invoked, gets both input signals and installs another action that sets the <span class="code">output</span> signal to the conjunction of both input signals. This other action is to be executed after <span class="code">AndGateDelay</span> units of simulated time. Note that the output has to be recomputed if either of the input wires changes. That's why the same <span class="code">andAction</span> is installed on each of the two input wires <span class="code">a1</span> and <span class="code">a2</span>. The <span class="code">orGate</span> method is implemented similarly, except it performs a logical-or instead of a logical-and.</p>
      <h4>Simulation output</h4>
      <p>To run the simulator, you need a way to inspect changes of signals on wires. To accomplish this, you can simulate the action of putting a probe on a wire:</p> <pre>  <code class="vem">def</code>&nbsp;probe(name:&nbsp;<code class="typename">String</code>,&nbsp;wire:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;probeAction()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;currentTime&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"&nbsp;new-value&nbsp;=&nbsp;"</code>&nbsp;+&nbsp;wire.getSignal)
  &nbsp;&nbsp;}
  &nbsp;&nbsp;wire&nbsp;addAction&nbsp;probeAction
  }
</pre>
      <p>The effect of the <span class="code">probe</span> procedure is to install a <span class="code">probeAction</span> on a given wire. As usual, the installed action is executed every time the wire's signal changes. In this case it simply prints the name of the wire (which is passed as first parameter to <span class="code">probe</span>), as well as the current simulated time and the wire's new value.</p>
      <h4>Running the simulator</h4>
      <p>After all these preparations, it's time to see the simulator in action. To define a concrete simulation, you need to inherit from a simulation framework class. To see something interesting, we'll create an abstract simulation class that extends <span class="code">BasicCircuitSimulation</span> and contains method definitions for half-adders and full-adders as they were presented earlier in this chapter in <a href="#lst-half-adder">Listings 18.6</a> <a href="#lst-full-adder">and 18.7</a>, respectively. This class, which we'll call <span class="code">CircuitSimulation</span>, is shown in <a href="#lst-circuit-simulation">Listing 18.11</a>.</p>
      <p><a id="lst-circuit-simulation"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.simulation
  <br>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">CircuitSimulation</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">BasicCircuitSimulation</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;halfAdder(a:&nbsp;<code class="typename">Wire</code>,&nbsp;b:&nbsp;<code class="typename">Wire</code>,&nbsp;s:&nbsp;<code class="typename">Wire</code>,&nbsp;c:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;d,&nbsp;e&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Wire</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orGate(a,&nbsp;b,&nbsp;d)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;andGate(a,&nbsp;b,&nbsp;c)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inverter(c,&nbsp;e)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;andGate(d,&nbsp;e,&nbsp;s)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fullAdder(a:&nbsp;<code class="typename">Wire</code>,&nbsp;b:&nbsp;<code class="typename">Wire</code>,&nbsp;cin:&nbsp;<code class="typename">Wire</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum:&nbsp;<code class="typename">Wire</code>,&nbsp;cout:&nbsp;<code class="typename">Wire</code>)&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;s,&nbsp;c1,&nbsp;c2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Wire</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;halfAdder(a,&nbsp;cin,&nbsp;s,&nbsp;c1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;halfAdder(b,&nbsp;s,&nbsp;sum,&nbsp;c2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orGate(c1,&nbsp;c2,&nbsp;cout)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 18.11 - The <span class="code">CircuitSimulation</span> class.</h5>
      <p>A concrete circuit simulation will be an object that inherits from class <span class="code">CircuitSimulation</span>. The object still needs to fix the gate delays according to the circuit implementation technology that's simulated. Finally, you will also need to define the concrete circuit that's going to be simulated.</p>
      <p>You can do these steps interactively in the Scala interpreter:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;org.stairwaybook.simulation._
  <code class="output">import&nbsp;org.stairwaybook.simulation._</code>
</pre>
      <p>First, the gate delays. Define an object (call it <span class="code">MySimulation</span>) that provides some numbers:</p> <pre>  scala&gt;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">MySimulation</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">CircuitSimulation</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="typename">InverterDelay</code>&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="typename">AndGateDelay</code>&nbsp;=&nbsp;<code class="literal">3</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="typename">OrGateDelay</code>&nbsp;=&nbsp;<code class="literal">5</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">defined&nbsp;module&nbsp;MySimulation</code>
</pre>
      <p>Because you are going to access the members of the <span class="code">MySimulation</span> object repeatedly, an import of the object keeps the subsequent code shorter:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;MySimulation._
  <code class="output">import&nbsp;MySimulation._</code>
</pre>
      <p>Next, the circuit. Define four wires, and place probes on two of them:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;input1,&nbsp;input2,&nbsp;sum,&nbsp;carry&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Wire</code>
  <code class="output">input1:&nbsp;MySimulation.Wire&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;BasicCircuitSimulation$Wire@111089b</code>
  <code class="output">input2:&nbsp;MySimulation.Wire&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;BasicCircuitSimulation$Wire@14c352e</code>
  <code class="output">sum:&nbsp;MySimulation.Wire&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;BasicCircuitSimulation$Wire@37a04c</code>
  <code class="output">carry:&nbsp;MySimulation.Wire&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;BasicCircuitSimulation$Wire@1fd10fa</code>
  <br>  scala&gt;&nbsp;probe(<code class="quotedstring">"sum"</code>,&nbsp;sum)
  <code class="output">sum&nbsp;0&nbsp;new-value&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;probe(<code class="quotedstring">"carry"</code>,&nbsp;carry)
  <code class="output">carry&nbsp;0&nbsp;new-value&nbsp;=&nbsp;false</code>
</pre>
      <p>Note that the probes immediately print an output. This is because every action installed on a wire is executed a first time when the action is installed.</p>
      <p>Now define a half-adder connecting the wires:</p> <pre>  scala&gt;&nbsp;halfAdder(input1,&nbsp;input2,&nbsp;sum,&nbsp;carry)
</pre>
      <p>Finally, set the signals, one after another, on the two input wires to <span class="code">true</span> and run the simulation:</p> <pre>  scala&gt;&nbsp;input1&nbsp;setSignal&nbsp;<code class="vem">true</code>
  <br>  scala&gt;&nbsp;run()
  <code class="output">***&nbsp;simulation&nbsp;started,&nbsp;time&nbsp;=&nbsp;0&nbsp;***</code>
  <code class="output">sum&nbsp;8&nbsp;new-value&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;input2&nbsp;setSignal&nbsp;<code class="vem">true</code>
  <br>  scala&gt;&nbsp;run()
  <code class="output">***&nbsp;simulation&nbsp;started,&nbsp;time&nbsp;=&nbsp;8&nbsp;***</code>
  <code class="output">carry&nbsp;11&nbsp;new-value&nbsp;=&nbsp;true</code>
  <code class="output">sum&nbsp;15&nbsp;new-value&nbsp;=&nbsp;false</code>
</pre>
      <h3>18.7 Conclusion</h3>
      <p>This chapter brought together two techniques that seem disparate at first: mutable state and higher-order functions. Mutable state was used to simulate physical entities whose state changes over time. Higher-order functions were used in the simulation framework to execute actions at specified points in simulated time. They were also used in the circuit simulations as <span style="font-style:italic">triggers</span> that associate actions with state changes. Along the way, you saw a simple way to define a domain-specific language as a library. That's probably enough for one chapter!</p>
      <p>If you feel like staying a bit longer, you might want to try more simulation examples. You can combine half-adders and full-adders to create larger circuits, or design new circuits from the basic gates defined so far and simulate them. In the next chapter, you'll learn about type parameterization in Scala, and see another example in which a combination of functional and imperative approaches yields a good solution.</p>
      <hr>
      <h4>Footnotes for Chapter 18:</h4>
      <p><a id="footnotemain18-1"></a>[1] Abstract variables will be explained in <a href="#chap-abstract-members">Chapter 20</a>.</p>
      <p><a id="footnotemain18-2"></a>[2] The names of these "delay" methods start with a capital letter because they represent constants. They are methods so they can be overridden in subclasses. You'll find out how to do the same thing with <span class="code">val</span>s in <a href="#sec-abstract-vals">Section 20.3</a>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-type-parameterization">Chapter 19</a></h2>
      <h1>Type Parameterization</h1>
      <p>In this chapter, we'll explain the details of type parameterization in Scala.<a id="i-1818778992-1"></a> Along the way we'll demonstrate some of the techniques for information hiding introduced in <a href="#chap-packages-and-imports">Chapter 13</a> by using a concrete example: the design of a class for purely functional queues. We're presenting type parameterization and information hiding together, because information hiding can be used to obtain more general type parameterization variance annotations.</p>
      <p>Type parameterization allows you to write generic classes and traits<a id="i-1986667706-1"></a><a id="i1515783126-1"></a><a id="i1083106947-1"></a><a id="i1530367874-1"></a>. For example, sets are generic and take a type parameter: they are defined as <span class="code">Set[T]</span><a id="i-906912898-1"></a>. As a result, any particular set instance might be a <span class="code">Set[String]</span>, a <span class="code">Set[Int]</span>, <i>etc.</i>, but it must be a set of <em>something</em>. Unlike Java, which allows raw types,<a id="i414933374-1"></a><a id="i1163979645-1"></a> Scala requires that you specify type parameters. Variance defines inheritance relationships of parameterized types, such as whether a <span class="code">Set[String]</span>, for example, is a subtype of <span class="code">Set[AnyRef]</span>.</p>
      <p>The chapter contains three parts. The first part develops a data structure for purely functional queues. The second part develops techniques to hide internal representation details of this structure. The final part explains variance of type parameters and how it interacts with information hiding.</p>
      <h3>19.1 Functional queues</h3>
      <p>A functional queue is a data structure with three operations:</p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> <span class="code">head</span> </td>
            <td> returns the first element of the queue </td>
          </tr>
          <tr>
            <td> <span class="code">tail</span> </td>
            <td> returns a queue without its first element </td>
          </tr>
          <tr>
            <td> <span class="code">enqueue</span> </td>
            <td> returns a new queue with a given element </td>
          </tr>
          <tr>
            <td> </td>
            <td> appended at the end </td>
          </tr>
        </tbody>
      </table>
      <p>Unlike a mutable queue, a functional queue does not change its contents when an element is appended. Instead, a new queue is returned that contains the element. The goal of this chapter will be to create a class, which we'll name <span class="code">Queue</span>, that works like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;<code class="typename">Queue</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">q:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;q1&nbsp;=&nbsp;q&nbsp;enqueue&nbsp;<code class="literal">4</code>
  <code class="output">q1:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3,&nbsp;4)</code>
  <br>  scala&gt;&nbsp;q
  <code class="output">res0:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3)</code>
</pre>
      <p>If <span class="code">Queue</span> were a mutable implementation, the <span class="code">enqueue</span> operation in the second input line above would affect the contents of <span class="code">q</span>; in fact both the result, <span class="code">q1</span>, and the original queue, <span class="code">q</span>, would contain the sequence <span class="code">1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3,</span>&nbsp;<span class="code">4</span> after the operation. But for a functional queue, the appended value shows up only in the result, <span class="code">q1</span>, not in the queue, <span class="code">q</span>, being operated on.</p>
      <p>Purely functional queues also have some similarity with lists. Both are so called <span style="font-style:italic">fully persistent</span> data structures<a id="i-1691614745-1"></a>, where old versions remain available even after extensions or modifications. Both support <span class="code">head</span> and <span class="code">tail</span> operations. But where a list is usually extended at the front, using a <span class="code">::</span> operation, a queue is extended at the end, using <span class="code">enqueue</span>.</p>
      <p>How can this be implemented efficiently? Ideally, a functional (immutable) queue should not have a fundamentally higher overhead than an imperative (mutable) one. That is, all three operations, <span class="code">head</span>, <span class="code">tail</span>, and <span class="code">enqueue</span>, should operate in constant time.</p>
      <p>One simple approach to implement a functional queue would be to use a list as representation type. Then <span class="code">head</span> and <span class="code">tail</span> would just translate into the same operations on the list, whereas <span class="code">enqueue</span> would be concatenation.</p>
      <p>This would give the following implementation:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">SlowAppendQueue[T]</code>(elems:&nbsp;<code class="typename">List[T]</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;Not&nbsp;efficient</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;elems.head
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowAppendQueue</code>(elems.tail)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowAppendQueue</code>(elems&nbsp;:::&nbsp;<code class="typename">List</code>(x))
  }
</pre>
      <p>The problem with this implementation is in the <span class="code">enqueue</span> operation. It takes time proportional to the number of elements stored in the queue. If you want constant time append, you could also try to reverse the order of the elements in the representation list, so that the last element that's appended comes first in the list. This would lead to the following implementation:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">SlowHeadQueue[T]</code>(smele:&nbsp;<code class="typename">List[T]</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;Not&nbsp;efficient</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;smele&nbsp;is&nbsp;elems&nbsp;reversed</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;smele.last
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowHeadQueue</code>(smele.init)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SlowHeadQueue</code>(x&nbsp;::&nbsp;smele)
  }
</pre>
      <p>Now <span class="code">enqueue</span> is constant time, but <span class="code">head</span> and <span class="code">tail</span> are not. They now take time proportional to the number of elements stored in the queue.</p>
      <p>Looking at these two examples, it does not seem easy to come up with an implementation that's constant time for all three operations. In fact, it looks doubtful that this is even possible! However, by combining the two operations you can get very close. The idea is to represent a queue by two lists, called <span class="code">leading</span> and <span class="code">trailing</span>. The <span class="code">leading</span> list contains elements towards the front, whereas the <span class="code">trailing</span> list contains elements towards the back of the queue in reversed order. The contents of the whole queue are at each instant equal to "<span class="code">leading</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">trailing.reverse</span>".</p>
      <p>Now, to append an element, you just cons it to the <span class="code">trailing</span> list using the <span class="code">::</span> operator,<a id="i1411857630-3"></a> so <span class="code">enqueue</span> is constant time. This means that, when an initially empty queue is constructed from successive <span class="code">enqueue</span> operations, the <span class="code">trailing</span> list will grow whereas the <span class="code">leading</span> list will stay empty. Then, before the first <span class="code">head</span> or <span class="code">tail</span> operation is performed on an empty <span class="code">leading</span> list, the whole <span class="code">trailing</span> list is copied to <span class="code">leading</span>, reversing the order of the elements. This is done in an operation called <span class="code">mirror</span>. <a href="#lst-simple-functional-queues">Listing 19.1</a> shows an implementation of queues that uses this approach.</p>
      <p><a id="lst-simple-functional-queues"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>&nbsp;
  &nbsp;&nbsp;)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;mirror&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(leading.isEmpty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(trailing.reverse,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;mirror.leading.head
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;mirror&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(q.leading.tail,&nbsp;q.trailing)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 19.1 - A basic functional queue.</h5>
      <p>What is the complexity of this implementation of queues? The <span class="code">mirror</span> operation might take time proportional to the number of queue elements, but only if list <span class="code">leading</span> is empty. It returns directly if <span class="code">leading</span> is non-empty. Because <span class="code">head</span> and <span class="code">tail</span> call <span class="code">mirror</span>, their complexity might be linear in the size of the queue, too. However, the longer the queue gets, the less often <span class="code">mirror</span> is called.</p>
      <p>Indeed, assume a queue of length <i>n</i> with an empty <span class="code">leading</span> list. Then <span class="code">mirror</span> has to reverse-copy a list of length <i>n</i>. However, the next time <span class="code">mirror</span> will have to do any work is once the <span class="code">leading</span> list is empty again, which will be the case after <i>n</i> <span class="code">tail</span> operations. This means you can "charge" each of these <i>n</i> <span class="code">tail</span> operations with one <i>n</i>'th of the complexity of <span class="code">mirror</span>, which means a constant amount of work. Assuming that <span class="code">head</span>, <span class="code">tail</span>, and <span class="code">enqueue</span> operations appear with about the same frequency, the <span style="font-style:italic">amortized</span> complexity is hence constant for each operation. So functional queues are asymptotically just as efficient as mutable ones.</p>
      <p>Now, there are some caveats that need to be attached to this argument. First, the discussion was only about asymptotic behavior; the constant factors might well be somewhat different. Second, the argument rested on the fact that <span class="code">head</span>, <span class="code">tail</span> and <span class="code">enqueue</span> are called with about the same frequency. If <span class="code">head</span> is called much more often than the other two operations, the argument is not valid, as each call to <span class="code">head</span> might involve a costly re-organization of the list with <span class="code">mirror</span>. The second caveat can be avoided; it is possible to design functional queues so that in a sequence of successive <span class="code">head</span> operations only the first one might require a re-organization. You will find out at the end of this chapter how this is done.</p>
      <h3>19.2 Information hiding</h3>
      <p>The implementation of <span class="code">Queue</span> shown in <a href="#lst-simple-functional-queues">Listing 19.1</a> is now quite good with regards to<a id="i374717171-2"></a> efficiency. You might object, though, that this efficiency is paid for by exposing a needlessly detailed implementation. The <span class="code">Queue</span> constructor, which is globally accessible, takes two lists as parameters, where one is reversed—hardly an intuitive representation of a queue. What's needed is a way to hide this constructor from client code. In this section, we'll show you some ways to accomplish this in Scala.</p>
      <h4>Private constructors and factory methods</h4>
      <p>In Java, you can hide a constructor by making it <span class="code">private</span>. In Scala, the primary constructor does not have an explicit definition;<a id="i2093291082-1"></a><a id="i-1528003040-1"></a> it is defined implicitly by the class parameters and body. Nevertheless, it is still possible to hide the primary constructor by adding a <span class="code">private</span> modifier in front of the class parameter list<a id="i1958480308-1"></a>, as shown in <a href="#lst-private-constructor">Listing 19.2</a>:</p>
      <p><a id="lst-private-constructor"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[T]</code>&nbsp;<code class="vem">private</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>
  &nbsp;&nbsp;)&nbsp;
</pre>
      <h5>Listing 19.2 - Hiding a primary constructor by making it private.</h5>
      <p>The <span class="code">private</span> modifier between the class name and its parameters indicates that the constructor of <span class="code">Queue</span> is private: it can be accessed only from within the class itself and its companion object<a id="i-861331495-1"></a>. The class name <span class="code">Queue</span> is still public, so you can use it as a type, but you cannot call its constructor:<a id="i-1604722710-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>),&nbsp;<code class="typename">List</code>(<code class="literal">3</code>))
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;constructor&nbsp;Queue&nbsp;in&nbsp;class&nbsp;Queue&nbsp;cannot&nbsp;be&nbsp;</code>
  <code class="output">accessed&nbsp;in&nbsp;object&nbsp;$iw</code>
</pre>
      <p>Now that the primary constructor of class <span class="code">Queue</span> can no longer be called from client code, there needs to be some other way to create new queues. One possibility is to add an auxiliary constructor, like this:</p> <pre>  <code class="vem">def</code>&nbsp;<code class="vem">this</code>()&nbsp;=&nbsp;<code class="vem">this</code>(<code class="typename">Nil</code>,&nbsp;<code class="typename">Nil</code>)&nbsp;
</pre>
      <p>The auxiliary constructor shown in the previous example builds an empty queue. As a refinement, the auxiliary constructor could take a list of initial queue elements:</p> <pre>  <code class="vem">def</code>&nbsp;<code class="vem">this</code>(elems:&nbsp;T*)&nbsp;=&nbsp;<code class="vem">this</code>(elems.toList,&nbsp;<code class="typename">Nil</code>)
</pre>
      <p>Recall that <span class="code">T*</span> is the notation for repeated parameters, as described in <a href="#sec-fancy-parameters">Section 8.8</a>.</p>
      <p>Another possibility is to add a factory method that builds a queue from such a sequence of initial elements. A neat way to do this is to define an object <span class="code">Queue</span> that has the same name as the class being defined and contains an <span class="code">apply</span> method, as shown in <a href="#lst-apply-factory">Listing 19.3</a>:</p>
      <p><a id="lst-apply-factory"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Queue</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;constructs&nbsp;a&nbsp;queue&nbsp;with&nbsp;initial&nbsp;elements&nbsp;`xs'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](xs:&nbsp;T*)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue[T]</code>(xs.toList,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 19.3 - An <span class="code">apply</span> factory method in a companion object.</h5>
      <p>By placing this object in the same source file as class <span class="code">Queue</span>, you make the object a companion object of the class. You saw in <a href="#sec-access-modifiers">Section 13.5</a> that a companion object has the same access rights as its class. Because of this, the <span class="code">apply</span> method in object <span class="code">Queue</span> can create a new <span class="code">Queue</span> object, even though the constructor of class <span class="code">Queue</span> is private.</p>
      <p>Note that, because the factory method is called <span class="code">apply</span>, clients can create queues with an expression such as <span class="code">Queue(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>. This expression expands to <span class="code">Queue.apply(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> since <span class="code">Queue</span> is an object instead of a function. As a result, <span class="code">Queue</span> looks to clients as if it was a globally defined factory method. In reality, Scala has no globally visible methods; every method must be contained in an object or a class. However, using methods named <span class="code">apply</span> inside global objects, you can support usage patterns that look like invocations of global methods.</p>
      <p><a id="lst-type-abstract-functional-queues"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Queue[T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;T
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">Queue[T]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T):&nbsp;<code class="typename">Queue[T]</code>
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Queue</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](xs:&nbsp;T*):&nbsp;<code class="typename">Queue[T]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl[T]</code>(xs.toList,&nbsp;<code class="typename">Nil</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">QueueImpl[T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Queue[T]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;mirror&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(leading.isEmpty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl</code>(trailing.reverse,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;T&nbsp;=&nbsp;mirror.leading.head
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">QueueImpl[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;mirror
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl</code>(q.leading.tail,&nbsp;q.trailing)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">QueueImpl</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 19.4 - Type abstraction for functional queues.</h5>
      <h4>An alternative: private classes</h4>
      <p>Private constructors and private members are one way to hide the initialization and representation of a class.<a id="i848757295-1"></a> Another more radical way is to hide the class itself and only export a trait that reveals the public interface of the class. The code in <a href="#lst-type-abstract-functional-queues">Listing 19.4</a> implements this design. There's a trait <span class="code">Queue</span>, which declares the methods <span class="code">head</span>, <span class="code">tail</span>, and <span class="code">enqueue</span>. All three methods are implemented in a subclass <span class="code">QueueImpl</span>, which is itself a <span class="code">private</span> inner class of object<a id="i-1543098108-1"></a> <span class="code">Queue</span>. This exposes to clients the same information as before, but using a different technique. Instead of hiding individual constructors and methods, this version hides the whole implementation class.</p>
      <h3 id="sec-first-arrays">19.3 Variance annotations</h3>
      <p><span class="code">Queue</span>, as defined in <a href="#lst-type-abstract-functional-queues">Listing 19.4</a>, is a trait, but<a id="i1555746715-1"></a><a id="i935521398-1"></a> not a type. <span class="code">Queue</span> is not a type because it takes a type parameter.</p>
      <p>As a result, you cannot create variables of type <span class="code">Queue</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;doesNotCompile(q:&nbsp;<code class="typename">Queue</code>)&nbsp;=&nbsp;{}
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;class&nbsp;Queue&nbsp;takes&nbsp;type&nbsp;parameters</code>
</pre>
      <p>Instead, trait <span class="code">Queue</span> enables you to specify <em>parameterized</em> types, such as <span class="code">Queue[String]</span>, <span class="code">Queue[Int]</span>, or <span class="code">Queue[AnyRef]</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;doesCompile(q:&nbsp;<code class="typename">Queue[AnyRef]</code>)&nbsp;=&nbsp;{}
  <code class="output">doesCompile:&nbsp;(q:&nbsp;Queue[AnyRef])Unit</code>
</pre>
      <p>Thus, <span class="code">Queue</span> is a trait and <span class="code">Queue[String]</span> is a type. <span class="code">Queue</span> is also called a <em>type constructor</em><a id="i1905256393-1"></a> because you can construct a type with it by specifying a type parameter. (This is analogous to constructing an object instance with a plain-old constructor by specifying a value parameter.) The type constructor <span class="code">Queue</span> "generates" a family of types, which includes <span class="code">Queue[Int]</span>, <span class="code">Queue[String]</span>, and <span class="code">Queue[AnyRef]</span>.</p>
      <p>You can also say that <span class="code">Queue</span> is a <em>generic</em> trait.<a id="i1530367874-2"></a><a id="i-1356826384-1"></a> (Classes and traits that take type parameters are "generic," but the types they generate are "parameterized," not generic.) The term "generic" means that you are defining many specific types with one generically written class or trait. For example, trait <span class="code">Queue</span> in <a href="#lst-type-abstract-functional-queues">Listing 19.4</a> defines a generic queue. <span class="code">Queue[Int]</span> and <span class="code">Queue[String]</span>, <i>etc.</i>, would be the specific queues.</p>
      <p>The combination of type parameters and subtyping poses some interesting questions.<a id="i-1780437500-1"></a> For example, are there any special subtyping relationships between members of the family of types generated by <span class="code">Queue[T]</span>? More specifically, should a <span class="code">Queue[String]</span> be considered a subtype of <span class="code">Queue[AnyRef]</span>? Or more generally, if <span class="code">S</span> is a subtype of type <span class="code">T</span>, then should <span class="code">Queue[S]</span> be considered a subtype of <span class="code">Queue[T]</span>? If so, you could say that trait <span class="code">Queue</span> is <a href="#g1865839257"><em>covariant</em></a> (or "flexible") in its type parameter <span class="code">T</span><a id="i2006441693-1"></a>. Or, since it just has one type parameter, you could say simply that <span class="code">Queue</span>s are covariant. Covariant <span class="code">Queue</span>s would mean, for example, that you could pass a <span class="code">Queue[String]</span> to the <span class="code">doesCompile</span> method shown previously, which takes a value parameter of type <span class="code">Queue[AnyRef]</span>.</p>
      <p>Intuitively, all this seems OK, since a queue of <span class="code">String</span>s looks like a special case of a queue of <span class="code">AnyRef</span>s. In Scala, however, generic types have by default <a href="#g-233237224"><em>nonvariant</em></a> (or "rigid") subtyping<a id="i1359580222-1"></a>. That is, with <span class="code">Queue</span> defined as in <a href="#lst-type-abstract-functional-queues">Listing 19.4</a>, queues with different element types would never be in a subtype relationship. A <span class="code">Queue[String]</span> would not be usable as a <span class="code">Queue[AnyRef]</span>. However, you can demand covariant (flexible) subtyping of queues by changing the first line of the definition of class <span class="code">Queue</span> like this:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;{&nbsp;...&nbsp;}
</pre>
      <p>Prefixing a formal type parameter with a <span class="code">+</span> indicates that subtyping is covariant (flexible) in that parameter<a id="i-1315578930-1"></a>. By adding this single character, you are telling Scala that you want <span class="code">Queue[String]</span>, for example, to be considered a subtype of <span class="code">Queue[AnyRef]</span>. The compiler will check that <span class="code">Queue</span> is defined in a way that this subtyping is sound.</p>
      <p>Besides <span class="code">+</span>, there is also a prefix <span class="code">-</span>, which indicates <a href="#g-1356412796"><em>contravariant</em></a> subtyping<a id="i973833207-1"></a><a id="i900875858-1"></a>. If <span class="code">Queue</span> were defined like this:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">Queue[-T]</code>&nbsp;{&nbsp;...&nbsp;}&nbsp;
</pre>
      <p>then if <span class="code">T</span> is a subtype of type <span class="code">S</span>, this would imply that <span class="code">Queue[S]</span> is a subtype of <span class="code">Queue[T]</span> (which in the case of queues would be rather surprising!). Whether a type parameter is covariant, contravariant, or nonvariant is called the parameter's <a href="#g-1249575311"><em>variance</em></a><a id="i-1249575311-1"></a>. The <span class="code">+</span> and <span class="code">-</span> symbols you can place next to type parameters are called <em>variance annotations</em>.<a id="i1554444807-1"></a></p>
      <p>In a purely functional world, many types are naturally covariant (flexible). However, the situation changes once you introduce mutable data. To find out why, consider the simple type of one-element cells that can be read or written, shown in <a href="#lst-nonvariant-cell">Listing 19.5</a>. <a id="lst-nonvariant-cell"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell[T]</code>(init:&nbsp;T)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;current&nbsp;=&nbsp;init
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;get&nbsp;=&nbsp;current
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;set(x:&nbsp;T)&nbsp;=&nbsp;{&nbsp;current&nbsp;=&nbsp;x&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 19.5 - A nonvariant (rigid) <span class="code">Cell</span> class.</h5>
      <p>The <span class="code">Cell</span> type of <a href="#lst-nonvariant-cell">Listing 19.5</a> is declared nonvariant (rigid). For the sake of argument, assume for a moment that <span class="code">Cell</span> was declared covariant instead—<i>i.e.</i>, it was declared <span class="code">class</span>&nbsp;<span class="code">Cell[+T]</span>—and that this passed the Scala compiler. (It doesn't, and we'll explain why shortly.) Then you could construct the following problematic statement sequence:</p> <pre>  <code class="vem">val</code>&nbsp;c1&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cell[String]</code>(<code class="quotedstring">"abc"</code>)
  <code class="vem">val</code>&nbsp;c2:&nbsp;<code class="typename">Cell[Any]</code>&nbsp;=&nbsp;c1
  c2.set(<code class="literal">1</code>)
  <code class="vem">val</code>&nbsp;s:&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;c1.get&nbsp;
</pre>
      <p>Seen by itself, each of these four lines looks OK. The first line creates a cell of strings and stores it in a <span class="code">val</span> named <span class="code">c1</span>. The second line defines a new <span class="code">val</span>, <span class="code">c2</span>, of type <span class="code">Cell[Any]</span>, which initialized with <span class="code">c1</span>. This is OK since <span class="code">Cell</span>s are assumed to be covariant. The third line sets the value of cell <span class="code">c2</span> to 1. This is also OK because the assigned value <span class="code">1</span> is an instance of <span class="code">c2</span>'s element type <span class="code">Any</span>. Finally, the last line assigns the element value of <span class="code">c1</span> into a string. Nothing strange here, as both the sides are of the same type. But taken together, these four lines end up assigning the integer <span class="code">1</span> to the string <span class="code">s</span>. This is clearly a violation of type soundness.</p>
      <p>Which operation is to blame for the runtime fault? It must be the second one, which uses covariant subtyping. The other statements are too simple and fundamental. Thus, a <span class="code">Cell</span> of <span class="code">String</span> is <span style="font-style:italic">not</span> also a <span class="code">Cell</span> of <span class="code">Any</span>, because there are things you can do with a <span class="code">Cell</span> of <span class="code">Any</span> that you cannot do with a <span class="code">Cell</span> of <span class="code">String</span>. You cannot use <span class="code">set</span> with an <span class="code">Int</span> argument on a <span class="code">Cell</span> of <span class="code">String</span>, for example.</p>
      <p>In fact, were you to pass the covariant version of <span class="code">Cell</span> to the Scala compiler, you would get a compile-time error:<a id="i-1072664655-1"></a></p> <pre>  <code class="output">Cell.scala:7:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;T&nbsp;of&nbsp;value&nbsp;x</code>
  <code class="output">&nbsp;&nbsp;&nbsp;def&nbsp;set(x:&nbsp;T)&nbsp;=&nbsp;current&nbsp;=&nbsp;x</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <h4>Variance and arrays</h4>
      <p>It's interesting to compare this behavior with arrays in Java. In principle, arrays are just like cells except that they can have more than one element. Nevertheless, arrays are treated as covariant in Java.</p>
      <p>You can try an example analogous to the cell interaction described here with Java arrays:</p> <pre>  //&nbsp;this&nbsp;is&nbsp;Java
  String[]&nbsp;a1&nbsp;=&nbsp;{&nbsp;"abc"&nbsp;};
  Object[]&nbsp;a2&nbsp;=&nbsp;a1;
  a2[0]&nbsp;=&nbsp;new&nbsp;Integer(17);
  String&nbsp;s&nbsp;=&nbsp;a1[0];
</pre>
      <p>If you try out this example, you will find that it compiles. But executing the program will cause an <span class="code">ArrayStore</span> exception to be thrown when <span class="code">a2[0]</span> is assigned to an <span class="code">Integer</span>:</p> <pre>  <code class="output">Exception&nbsp;in&nbsp;thread&nbsp;"main"&nbsp;java.lang.ArrayStoreException:&nbsp;</code>
  <code class="output">java.lang.Integer</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;JavaArrays.main(JavaArrays.java:8)</code>
</pre>
      <p>What happens here is that Java stores the element type of the array at runtime. Then, every time an array element is updated, the new element value is checked against the stored type. If it is not an instance of that type, an <span class="code">ArrayStore</span> exception is thrown.<a id="i1807481219-1"></a></p>
      <p>You might ask why Java adopted this design, which seems both unsafe and expensive. When asked this question, James Gosling,<a id="i1512661551-1"></a> the principal inventor of the Java language, answered that they wanted to have a simple means to treat arrays generically. For instance, they wanted to be able to write a method to sort all elements of an array, using a signature like the following that takes an array of <span class="code">Object</span>:</p> <pre>  void&nbsp;sort(<code class="typename">Object[]</code>&nbsp;a,&nbsp;<code class="typename">Comparator</code>&nbsp;cmp)&nbsp;{&nbsp;...&nbsp;}
</pre>
      <p>Covariance of arrays was needed so that arrays of arbitrary reference types could be passed to this <span class="code">sort</span> method. Of course, with the arrival of Java generics, such a <span class="code">sort</span> method can now be written with a type parameter, so the covariance of arrays is no longer necessary<a id="i1590614948-1"></a>. For compatibility reasons, though, it has persisted in Java to this day.</p>
      <p>Scala tries to be purer than Java in not treating arrays as covariant. Here's what you get if you translate the first two lines of the array example to Scala:<a id="i-677980410-3"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a1&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="quotedstring">"abc"</code>)
  <code class="output">a1:&nbsp;Array[String]&nbsp;=&nbsp;Array(abc)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a2:&nbsp;<code class="typename">Array[Any]</code>&nbsp;=&nbsp;a1
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Array[String]</code>
  <code class="output">&nbsp;&nbsp;required:&nbsp;Array[Any]</code>
  <code class="output">&nbsp;Note:&nbsp;String&nbsp;&lt;:&nbsp;Any,&nbsp;but&nbsp;class&nbsp;Array&nbsp;is&nbsp;invariant&nbsp;in&nbsp;type&nbsp;T.</code>
  <code class="output"></code>
</pre>
      <p>What happened here is that Scala treats arrays as nonvariant (rigid), so an <span class="code">Array[String]</span> is not considered to conform to an <span class="code">Array[Any]</span>. However, sometimes it is necessary to interact with legacy methods in Java that use an <span class="code">Object</span> array as a means to emulate a generic array. For instance, you might want to call a <span class="code">sort</span> method like the one described previously with an array of <span class="code">String</span>s as argument. To make this possible, Scala lets you cast an array of <span class="code">T</span>s to an array of any supertype of <span class="code">T</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a2:&nbsp;<code class="typename">Array[Object]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1.asInstanceOf[<code class="typename">Array[Object]</code>]
  <code class="output">a2:&nbsp;Array[Object]&nbsp;=&nbsp;Array(abc)</code>
</pre>
      <p>The cast is always legal at compile-time, and it will always succeed at run-time because the JVM's underlying run-time model treats arrays as covariant, just as Java the language does. But you might get <span class="code">ArrayStore</span> exceptions afterwards, again just as you would in Java.</p>
      <h3>19.4 Checking variance annotations</h3>
      <p>Now that you have seen some examples where variance is unsound, you<a id="i-245097893-1"></a> may be wondering which kind of class definitions need to be rejected and which can be accepted. So far, all violations of type soundness involved some reassignable field or array element. The purely functional implementation of queues, on the other hand, looks like a good candidate for covariance. However, the following example shows that you can "engineer" an unsound situation even if there is no reassignable field.</p>
      <p>To set up the example, assume that queues as defined in <a href="#lst-type-abstract-functional-queues">Listing 19.4</a> are covariant. Then, create a subclass of queues that specializes the element type to <span class="code">Int</span> and overrides the <span class="code">enqueue</span> method:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">StrangeIntQueue</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Queue[Int]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(math.sqrt(x))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">super</code>.enqueue(x)
  &nbsp;&nbsp;}
  }
</pre>
      <p>The <span class="code">enqueue</span> method in <span class="code">StrangeIntQueue</span> prints out the square root of its (integer) argument before doing the append proper.</p>
      <p>Now, you can write a counterexample in two lines:</p> <pre>  <code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Queue[Any]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">StrangeIntQueue</code>
  x.enqueue(<code class="quotedstring">"abc"</code>)
</pre>
      <p>The first of these two lines is valid because <span class="code">StrangeIntQueue</span> is a subclass of <span class="code">Queue[Int]</span> and, assuming covariance of queues, <span class="code">Queue[Int]</span> is a subtype of <span class="code">Queue[Any]</span>. The second line is valid because you can append a <span class="code">String</span> to a <span class="code">Queue[Any]</span>. However, taken together, these two lines have the effect of applying a square root method to a string, which makes no sense.</p>
      <p>Clearly it's not just mutable fields that make covariant types unsound. The problem is more general. It turns out that as soon as a generic parameter type appears as the type of a method parameter, the containing class or trait may not be covariant in that type parameter.</p>
      <p>For queues, the <span class="code">enqueue</span> method violates this condition:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;...
  }
</pre>
      <p>Running a modified queue class like the one above through a Scala compiler would yield:<a id="i-1072664655-2"></a></p> <pre>  <code class="output">Queues.scala:11:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;T&nbsp;of&nbsp;value&nbsp;x</code>
  <code class="output">&nbsp;&nbsp;def&nbsp;enqueue(x:&nbsp;T)&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>Reassignable fields are a special case of the rule that disallows type parameters annotated with <span class="code">+</span> from being used as method parameter types. As mentioned in <a href="#sec-properties">Section 18.2</a>, a reassignable field, "<span class="code">var</span>&nbsp;<span class="code">x:</span>&nbsp;<span class="code">T</span>", is treated in Scala as a getter method, "<span class="code">def</span>&nbsp;<span class="code">x:</span>&nbsp;<span class="code">T</span>", and a setter method, "<span class="code">def</span>&nbsp;<span class="code">x_=(y:</span>&nbsp;<span class="code">T)</span>"<a id="i-1969580643-2"></a>. As you can see, the setter method has a parameter of the field's type <span class="code">T</span>. So that type may not be covariant.</p>
      <div class="pointofinterest">
        <h3>The fast track</h3>
        <p>In the rest of this section, we'll describe the mechanism by which the Scala compiler checks variance annotations. If you're not interested in such detail right now, you can safely skip to <a href="#sec-lower-bounds">Section 19.5</a>. The most important thing to understand is that the Scala compiler will check any variance annotations you place on type parameters. For example, if you try to declare a type parameter to be covariant (by adding a <span class="code">+</span>), but that could lead to potential runtime errors, your program won't compile.</p>
      </div>
      <p>To verify correctness of variance annotations, the Scala compiler classifies all positions in a class or trait body as <em>positive</em>, <em>negative</em>, or <em>neutral</em>. A "position" is any location in the class or trait (but from now on we'll just write "class") body where a type parameter may be used. For example, every method value parameter is a position because a method value parameter has a type. Therefore a type parameter could appear in that position.</p>
      <p>The compiler checks each use of each of the class's type parameters. Type parameters annotated with <span class="code">+</span> may only be used in positive positions, while type parameters annotated with <span class="code">-</span> may only be used in negative positions. A type parameter with no variance annotation may be used in any position, and is, therefore, the only kind of type parameter that can be used in neutral positions of the class body.</p>
      <p>To classify the positions, the compiler starts from the declaration of a type parameter and then moves inward through deeper nesting levels. Positions at the top level of the declaring class are classified as positive. By default, positions at deeper nesting levels are classified the same as that at enclosing levels, but there are a handful of exceptions where the classification changes. Method value parameter positions are classified to the <em>flipped</em> classification relative to positions outside the method, where the flip of a positive classification is negative, the flip of a negative classification is positive, and the flip of a neutral classification is still neutral.</p>
      <p>Besides method value parameter positions, the current classification is also flipped at the type parameters of methods. A classification is sometimes flipped at the type argument position of a type, such as the <span class="code">Arg</span> in <span class="code">C[Arg]</span>, depending on the variance of the corresponding type parameter. If <span class="code">C</span>'s type parameter is annotated with a <span class="code">+</span> then the classification stays the same. If <span class="code">C</span>'s type parameter is annotated with a <span class="code">-</span>, then the current classification is flipped. If <span class="code">C</span>'s type parameter has no variance annotation then the current classification is changed to neutral.</p>
      <p>As a somewhat contrived example, consider the following class definition, where several positions are annotated with their classifications, <span class="code"><sup>+</sup></span> (for positive) or <span class="code"><sup>-</sup></span> (for negative):</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cat[-T,&nbsp;+U]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;meow[W<sup>-</sup>](volume:&nbsp;T<sup>-</sup>,&nbsp;listener:&nbsp;<code class="typename">Cat[U<sup>+</sup>,&nbsp;T<sup>-</sup>]</code><sup>-</sup>)
  &nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">Cat[Cat[U<sup>+</sup>,&nbsp;T<sup>-</sup>]<sup>-</sup>,&nbsp;U<sup>+</sup>]</code><sup>+</sup>
  }
</pre>
      <p>The positions of the type parameter, <span class="code">W</span>, and the two value parameters, <span class="code">volume</span> and <span class="code">listener</span>, are all negative. Looking at the result type of <span class="code">meow</span>, the position of the first <span class="code">Cat[U,</span>&nbsp;<span class="code">T]</span> argument is negative because <span class="code">Cat</span>'s first type parameter, <span class="code">T</span>, is annotated with a <span class="code">-</span>. The type <span class="code">U</span> inside this argument is again in positive position (two flips), whereas the type <span class="code">T</span> inside that argument is still in negative position.</p>
      <p>You see from this discussion that it's quite hard to keep track of variance positions. That's why it's a welcome relief that the Scala compiler does this job for you.</p>
      <p>Once the classifications are computed, the compiler checks that each type parameter is only used in positions that are classified appropriately. In this case, <span class="code">T</span> is only used in negative positions, and <span class="code">U</span> is only used in positive positions. So class <span class="code">Cat</span> is type correct.</p>
      <h3 id="sec-lower-bounds">19.5 Lower bounds</h3>
      <p>Back to the <span class="code">Queue</span> class. You saw that the previous definition of <span class="code">Queue[T]</span> shown in <a href="#lst-type-abstract-functional-queues">Listing 19.4</a> cannot be made covariant in <span class="code">T</span> because <span class="code">T</span> appears as a type of a parameter of the <span class="code">enqueue</span> method, and that's a negative position.</p>
      <p>Fortunately, there's a way to get unstuck: you can generalize <span class="code">enqueue</span> by making it polymorphic (<i>i.e.</i>, giving the <span class="code">enqueue</span> method itself a type parameter) and using a <em>lower bound</em> for its type parameter.<a id="i1770535476-1"></a><a id="i1742340276-1"></a> <a href="#lst-lower-bound">Listing 19.6</a> shows a new formulation of <span class="code">Queue</span> that implements this idea.</p>
      <p><a id="lst-lower-bound"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;(<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>&nbsp;)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue[U&nbsp;&gt;:&nbsp;T](x:&nbsp;U)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue[U]</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)&nbsp;<code class="comment">//&nbsp;...</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 19.6 - A type parameter with a lower bound.</h5>
      <p>The new definition gives <span class="code">enqueue</span> a type parameter <span class="code">U</span>, and with the syntax, "<span class="code">U</span>&nbsp;<span class="code">&gt;:</span>&nbsp;<span class="code">T</span>", defines <span class="code">T</span> as the lower bound for <span class="code">U</span>. As a result,<a id="i1800766244-1"></a> <span class="code">U</span> is required to be a supertype of <span class="code">T</span>.<a href="#footnotemain19-1">[1]</a> The parameter to <span class="code">enqueue</span> is now of type <span class="code">U</span> instead of type <span class="code">T</span>, and the return value of the method is now <span class="code">Queue[U]</span> instead of <span class="code">Queue[T]</span>.</p>
      <p>For example, suppose there is a class <span class="code">Fruit</span> with two subclasses, <span class="code">Apple</span> and <span class="code">Orange</span>. With the new definition of class <span class="code">Queue</span>, it is possible to append an <span class="code">Orange</span> to a <span class="code">Queue[Apple]</span>. The result will be a <span class="code">Queue[Fruit]</span>.</p>
      <p>This revised definition of <span class="code">enqueue</span> is type correct. Intuitively, if <span class="code">T</span> is a more specific type than expected (for example, <span class="code">Apple</span> instead of <span class="code">Fruit</span>), a call to <span class="code">enqueue</span> will still work because <span class="code">U</span> (<span class="code">Fruit</span>) will still be a supertype of <span class="code">T</span> (<span class="code">Apple</span>).<a href="#footnotemain19-2">[2]</a></p>
      <p>The new definition of <span class="code">enqueue</span> is arguably better than the old, because it is more general. Unlike the old version, the new definition allows you to append an arbitrary supertype <span class="code">U</span> of the queue element type <span class="code">T</span>. The result is then a <span class="code">Queue[U]</span>. Together with queue covariance, this gives the right kind of flexibility for modeling queues of different element types in a natural way.</p>
      <p>This shows that variance annotations and lower bounds play well together. They are a good example of <span style="font-style:italic">type-driven design</span>, where the types of an interface guide its detailed design and implementation<a id="i819829841-1"></a>. In the case of queues, it's likely you would not have thought of the refined implementation of <span class="code">enqueue</span> with a lower bound. But you might have decided to make queues covariant, in which case, the compiler would have pointed out the variance error for <span class="code">enqueue</span>. Correcting the variance error by adding a lower bound makes <span class="code">enqueue</span> more general and queues as a whole more usable.</p>
      <p>This observation is also the main reason that Scala prefers declaration-site variance over use-site variance as it is found in Java's wildcards.<a id="i358663587-1"></a><a id="i1971613366-1"></a><a id="i-364469185-1"></a> With use-site variance, you are on your own designing a class. It will be the clients of the class that need to put in the wildcards, and if they get it wrong, some important instance methods will no longer be applicable. Variance being a tricky business, users usually get it wrong, and they come away thinking that wildcards and generics are overly complicated. With definition-side variance, you express your intent to the compiler, and the compiler will double check that the methods you want available will indeed be available.</p>
      <h3>19.6 Contravariance</h3>
      <p>So far in this chapter, all examples you've seen were either covariant or nonvariant. But there are also cases where contravariance is natural.<a id="i900875858-2"></a> For instance, consider the trait of output channels shown in <a href="#lst-contravariant-output-channel">Listing 19.7</a>: <a id="lst-contravariant-output-channel"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">OutputChannel[-T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;write(x:&nbsp;T):&nbsp;<code class="typename">Unit</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 19.7 - A contravariant output channel.</h5>
      <p>Here, <span class="code">OutputChannel</span> is defined to be contravariant in <span class="code">T</span>. So an output channel of <span class="code">AnyRef</span>s, say, is a subtype of an output channel of <span class="code">String</span>s. Although it may seem non-intuitive, it actually makes sense. To see why, consider what you can do with an <span class="code">OutputChannel[String]</span>. The only supported operation is writing a <span class="code">String</span> to it. The same operation can also be done on an <span class="code">OutputChannel[AnyRef]</span>. So it is safe to substitute an <span class="code">OutputChannel[AnyRef]</span> for an <span class="code">OutputChannel[String]</span>. By contrast, it would not be safe to substitute an <span class="code">OutputChannel[String]</span> where an <span class="code">OutputChannel[AnyRef]</span> is required. After all, you can send any object to an <span class="code">OutputChannel[AnyRef]</span>, whereas an <span class="code">OutputChannel[String]</span> requires that the written values are all strings.</p>
      <p>This reasoning points to a general principle in type system design: It is safe to assume that a type <span class="code">T</span> is a subtype of a type <span class="code">U</span> if you can substitute a value of type <span class="code">T</span> wherever a value of type <span class="code">U</span> is required. This is called the <span style="font-style:italic">Liskov Substitution Principle</span><a id="i1033900893-1"></a>. The principle holds if <span class="code">T</span> supports the same operations as <span class="code">U</span>, and all of <span class="code">T</span>'s operations require less and provide more than the corresponding operations in <span class="code">U</span>. In the case of output channels, an <span class="code">OutputChannel[AnyRef]</span> can be a subtype of an <span class="code">OutputChannel[String]</span> because the two support the same <span class="code">write</span> operation, and this operation requires less in <span class="code">OutputChannel[AnyRef]</span> than in <span class="code">OutputChannel[String]</span>. "Less" means the argument is only required to be an <span class="code">AnyRef</span> in the first case, whereas it is required to be a <span class="code">String</span> in the second case.</p>
      <p>Sometimes covariance and contravariance are mixed in the same type. A prominent example is Scala's function traits. For instance, whenever you write the function type <span class="code">A</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">B</span>, Scala expands this to <span class="code">Function1[A,</span>&nbsp;<span class="code">B]</span>. The definition of <span class="code">Function1</span> in the standard library uses both covariance and contravariance: the <span class="code">Function1</span> trait is contravariant in the function argument type <span class="code">S</span> and covariant in the result type <span class="code">T</span>,<a id="i-921885027-1"></a><a id="i-1806331359-1"></a> as shown in <a href="#lst-function-variance">Listing 19.8</a>. This satisfies the Liskov Substitution Principle because arguments are something that's required, whereas results are something that's provided.</p>
      <p><a id="lst-function-variance"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Function1[-S,&nbsp;+T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(x:&nbsp;S):&nbsp;T
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 19.8 - Covariance and contravariance of <span class="code">Function1</span>s.</h5>
      <p>As an example, consider the application shown in <a href="#lst-parrot-contravariance">Listing 19.9</a>. Here, class <span class="code">Publication</span> contains one parametric field, <span class="code">title</span>, of type <span class="code">String</span>. Class <span class="code">Book</span> extends <span class="code">Publication</span> and forwards its string <span class="code">title</span> parameter to the constructor of its superclass. The <span class="code">Library</span> singleton object defines a set of books and a method <span class="code">printBookList</span>, which takes a function, named <span class="code">info</span>, of type <span class="code">Book</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">AnyRef</span>. In other words, the type of the lone parameter to <span class="code">printBookList</span> is a function that takes one <span class="code">Book</span> argument and returns an <span class="code">AnyRef</span>. The <span class="code">Customer</span> application defines a method, <span class="code">getTitle</span>, which takes a <span class="code">Publication</span> as its lone parameter and returns a <span class="code">String</span>, the title of the passed <span class="code">Publication</span>.</p>
      <p><a id="lst-parrot-contravariance"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Publication</code>(<code class="vem">val</code>&nbsp;title:&nbsp;<code class="typename">String</code>)
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Book</code>(title:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Publication</code>(title)
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Library</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;books:&nbsp;<code class="typename">Set[Book]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Set</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Book</code>(<code class="quotedstring">"Programming&nbsp;in&nbsp;Scala"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Book</code>(<code class="quotedstring">"Walden"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;printBookList(info:&nbsp;<code class="typename">Book</code>&nbsp;=&gt;&nbsp;<code class="typename">AnyRef</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(book&nbsp;&lt;-&nbsp;books)&nbsp;println(info(book))
  &nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Customer</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">App</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;getTitle(p:&nbsp;<code class="typename">Publication</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;p.title
  &nbsp;&nbsp;&nbsp;Library.printBookList(getTitle)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 19.9 - Demonstration of function type parameter variance.</h5>
      <p>Now take a look at the last line in <span class="code">Customer</span>. This line invokes <span class="code">Library</span>'s <span class="code">printBookList</span> method and passes <span class="code">getTitle</span>, wrapped in a function value:</p> <pre>  Library.printBookList(getTitle)
</pre>
      <p>This line of code type checks even though <span class="code">String</span>, the function's result type, is a subtype of <span class="code">AnyRef</span>, the result type of <span class="code">printBookList</span>'s <span class="code">info</span> parameter. This code passes the compiler because function result types are declared to be covariant (the <span class="code">+T</span> in <a href="#lst-function-variance">Listing 19.8</a>). If you look inside the body of <span class="code">printBookList</span>, you can get a glimpse of why this makes sense.</p>
      <p>The <span class="code">printBookList</span> method iterates through its book list and invokes the passed function on each book. It passes the <span class="code">AnyRef</span> result returned by <span class="code">info</span> to <span class="code">println</span>, which invokes <span class="code">toString</span> on it and prints the result. This activity will work with <span class="code">String</span> as well as any other subclass of <span class="code">AnyRef</span>, which is what covariance of function result types means.</p>
      <p>Now consider the parameter type of the function being passed to the <span class="code">printBookList</span> method. Although the <span class="code">info</span> function's parameter type is declared as <span class="code">Book</span>, the <span class="code">getTitle</span> we're passing in takes a <span class="code">Publication</span>, a <em>supertype</em> of <span class="code">Book</span><a id="i-331888331-1"></a>. The reason this works is that since <span class="code">printBookList</span>'s parameter type is <span class="code">Book</span>, the body of the <span class="code">printBookList</span> method will only be allowed to pass a <span class="code">Book</span> into the function. And because <span class="code">getTitle</span>'s parameter type is <span class="code">Publication</span>, the body of that function will only be able to access on its parameter, <span class="code">p</span>, members that are declared in class <span class="code">Publication</span>. Because any method declared in <span class="code">Publication</span> is also available on its subclass <span class="code">Book</span>, everything should work, which is what contravariance of function parameter types means. You can see all this graphically in <a href="#fig-contravariance">Figure 19.1</a>.</p>
      <p>The code in <a href="#lst-parrot-contravariance">Listing 19.9</a> compiles because <span class="code">Publication</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">String</span> is a subtype of <span class="code">Book</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">AnyRef</span>, as shown in the center of the <a href="#fig-contravariance">Figure 19.1</a>. Because the result type of a <span class="code">Function1</span> is defined as covariant, the inheritance relationship of the two result types, shown at the right of the diagram, is in the same direction as that of the two functions shown in the center. By contrast, because the parameter type of a <span class="code">Function1</span> is defined as contravariant, the inheritance relationship of the two parameter types, shown at the left of the diagram, is in the opposite direction as that of the two functions.</p>
      <div class="figure">
        <a id="fig-contravariance"></a>
        <p><img src="variance160.png" alt="images/variance160.png"></p>
      </div>
      <h5> Figure 19.1 - Covariance and contravariance in function type parameters.</h5>
      <p><a id="lst-optimized-functional-queues"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Queue[+T]</code>&nbsp;<code class="vem">private</code>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;leading:&nbsp;<code class="typename">List[T]</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[<code class="vem">this</code>]&nbsp;<code class="vem">var</code>&nbsp;trailing:&nbsp;<code class="typename">List[T]</code>
  &nbsp;&nbsp;)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;mirror()&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(leading.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(!trailing.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading&nbsp;=&nbsp;trailing.head&nbsp;::&nbsp;leading
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trailing&nbsp;=&nbsp;trailing.tail
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;T&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirror()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading.head&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">Queue[T]</code>&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirror()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue</code>(leading.tail,&nbsp;trailing)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;enqueue[U&nbsp;&gt;:&nbsp;T](x:&nbsp;U)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Queue[U]</code>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;}</pre>
      <h5>Listing 19.10 - An optimized functional queue.</h5>
      <h3 id="variance-object-local">19.7 Object private data</h3>
      <p>The <span class="code">Queue</span> class seen so far has a problem in that the <span class="code">mirror</span> operation will repeatedly copy the <span class="code">trailing</span> into the <span class="code">leading</span> list if <span class="code">head</span> is called several times in a row on a list where <span class="code">leading</span> is empty. The wasteful copying could be avoided by adding some judicious side effects. <a href="#lst-optimized-functional-queues">Listing 19.10</a> presents a new implementation of <span class="code">Queue</span>, which performs at most one <span class="code">trailing</span> to <span class="code">leading</span> adjustment for any sequence of <span class="code">head</span> operations.</p>
      <p>What's different with respect to the previous version is that now <span class="code">leading</span> and <span class="code">trailing</span> are reassignable variables, and <span class="code">mirror</span> performs the reverse copy from <span class="code">trailing</span> to <span class="code">leading</span> as a side effect on the current queue instead of returning a new queue. This side effect is purely internal to the implementation of the <span class="code">Queue</span> operation; since <span class="code">leading</span> and <span class="code">trailing</span> are private variables, the effect is not visible to clients of <span class="code">Queue</span>. So by the terminology established in <a href="#chap-mutable-objects">Chapter 18</a>, the new version of <span class="code">Queue</span> still defines purely functional objects, in spite of the fact that they now contain reassignable fields.</p>
      <p>You might wonder whether this code passes the Scala type checker. After all, queues now contain two reassignable fields of the covariant parameter type <span class="code">T</span>. Is this not a violation of the variance rules? It would be indeed, except for the detail that <span class="code">leading</span> and <span class="code">trailing</span> have a <span class="code">private[this]</span> modifier, and are thus declared to be object private.</p>
      <p>As mentioned in <a href="#sec-access-modifiers">Section 13.5</a>, object private members can be accessed only from within the object in which they are defined. It turns out that accesses to variables from the same object in which they are defined do not cause problems with variance. The intuitive explanation is that, in order to construct a case where variance would lead to type errors, you need to have a reference to a containing object that has a statically weaker type than the type the object was defined with. For accesses to object private values, however, this is impossible.</p>
      <p>Scala's variance checking rules contain a special case for object private definitions.<a id="i-245097893-2"></a> Such definitions are omitted when it is checked that a type parameter with either a <span class="code">+</span> or <span class="code">-</span> annotation occurs only in positions that have the same variance classification. Therefore, the code in <a href="#lst-optimized-functional-queues">Listing 19.10</a> compiles without error. On the other hand, if you had left out the <span class="code">[this]</span> qualifiers from the two <span class="code">private</span> modifiers, you would see two type errors:<a id="i-517711887-1"></a></p> <pre>  <code class="output">Queues.scala:1:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in&nbsp;</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;List[T]&nbsp;of&nbsp;parameter&nbsp;of</code>
  <code class="output">setter&nbsp;leading_=</code>
  <code class="output">class&nbsp;Queue[+T]&nbsp;private&nbsp;(private&nbsp;var&nbsp;leading:&nbsp;List[T],</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">Queues.scala:1:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in&nbsp;</code>
  <code class="output">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;List[T]&nbsp;of&nbsp;parameter&nbsp;of</code>
  <code class="output">setter&nbsp;trailing_=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;var&nbsp;trailing:&nbsp;List[T])&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <h3 id="sec-upper-bounds">19.8 Upper bounds</h3>
      <p>In <a href="#lst-merge-sort-function">Listing 16.1</a> <a href="#lst-merge-sort-function">here</a>, we showed a merge sort function for lists that took a comparison function as a first argument and a list to sort as a second, curried argument.<a id="i-1812239373-1"></a><a id="i1036774557-1"></a> Another way you might want to organize such a sort function is by requiring the type of the list to mix in the <span class="code">Ordered</span> trait. As mentioned in <a href="#sec-the-ordered-trait">Section 12.4</a>, by mixing <span class="code">Ordered</span> into a class and implementing <span class="code">Ordered</span>'s one abstract method, <span class="code">compare</span>, you<a id="i1970675952-2"></a><a id="i2068605051-2"></a> enable clients to compare instances of that class with <span class="code">&lt;</span>, <span class="code">&gt;</span>, <span class="code">&lt;=</span>, and <span class="code">&gt;=</span>. For example, <a href="#lst-ordered-person">Listing 19.11</a> shows <span class="code">Ordered</span> being mixed into a <span class="code">Person</span> class.</p>
      <p>As a result, you can compare two people like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;robert&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Robert"</code>,&nbsp;<code class="quotedstring">"Jones"</code>)
  <code class="output">robert:&nbsp;Person&nbsp;=&nbsp;Robert&nbsp;Jones</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sally&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Sally"</code>,&nbsp;<code class="quotedstring">"Smith"</code>)
  <code class="output">sally:&nbsp;Person&nbsp;=&nbsp;Sally&nbsp;Smith</code>
  <br>  scala&gt;&nbsp;robert&nbsp;&lt;&nbsp;sally
  <code class="output">res0:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p><a id="lst-ordered-person"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Person</code>(<code class="vem">val</code>&nbsp;firstName:&nbsp;<code class="typename">String</code>,&nbsp;<code class="vem">val</code>&nbsp;lastName:&nbsp;<code class="typename">String</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Ordered[Person]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;compare(that:&nbsp;<code class="typename">Person</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;lastNameComparison&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName.compareToIgnoreCase(that.lastName)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(lastNameComparison&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastNameComparison
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName.compareToIgnoreCase(that.firstName)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;firstName&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;lastName
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 19.11 - A <span class="code">Person</span> class that mixes in the <span class="code">Ordered</span> trait.</h5>
      <p><a id="lst-upper-bound-sort"></a></p> <pre>  <code class="vem">def</code>&nbsp;orderedMergeSort[T&nbsp;&lt;:&nbsp;<code class="typename">Ordered[T]</code>](xs:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;merge(xs:&nbsp;<code class="typename">List[T]</code>,&nbsp;ys:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">List[T]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(xs,&nbsp;ys)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(<code class="typename">Nil</code>,&nbsp;_)&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(_,&nbsp;<code class="typename">Nil</code>)&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(x&nbsp;::&nbsp;xs1,&nbsp;y&nbsp;::&nbsp;ys1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(x&nbsp;&lt;&nbsp;y)&nbsp;x&nbsp;::&nbsp;merge(xs1,&nbsp;ys)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;y&nbsp;::&nbsp;merge(xs,&nbsp;ys1)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;n&nbsp;=&nbsp;xs.length&nbsp;/&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;xs
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;(ys,&nbsp;zs)&nbsp;=&nbsp;xs&nbsp;splitAt&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;merge(orderedMergeSort(ys),&nbsp;orderedMergeSort(zs))
  &nbsp;&nbsp;}
  }
</pre>
      <h5>Listing 19.12 - A merge sort function with an upper bound.</h5>
      <p>To require that the type of the list passed to your new sort function mixes in <span class="code">Ordered</span>, you need to<a id="i1850759422-1"></a> use an <em>upper bound</em>. An upper bound is specified similar to a lower bound, except instead of the <span class="code">&gt;:</span> symbol used for lower bounds, you use a <span class="code">&lt;:</span> symbol, as shown in <a href="#lst-upper-bound-sort">Listing 19.12</a>.</p>
      <p>With the "<span class="code">T</span>&nbsp;<span class="code">&lt;:</span>&nbsp;<span class="code">Ordered[T]</span>" syntax, you indicate that the type parameter, <span class="code">T</span>, has an upper bound, <span class="code">Ordered[T]</span>. This means that the element type of the list passed to <span class="code">orderedMergeSort</span> must be a subtype of <span class="code">Ordered</span>. Thus, you could pass a <span class="code">List[Person]</span> to <span class="code">orderedMergeSort</span> because <span class="code">Person</span> mixes in <span class="code">Ordered</span>.</p>
      <p>For example, consider this list:<a id="i1588987823-1"></a><a id="i-604737946-1"></a><a id="i717131072-1"></a><a id="i438821039-2"></a><a id="i2020741259-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;people&nbsp;=&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Larry"</code>,&nbsp;<code class="quotedstring">"Wall"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Anders"</code>,&nbsp;<code class="quotedstring">"Hejlsberg"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Guido"</code>,&nbsp;<code class="quotedstring">"van&nbsp;Rossum"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Alan"</code>,&nbsp;<code class="quotedstring">"Kay"</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Yukihiro"</code>,&nbsp;<code class="quotedstring">"Matsumoto"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <code class="output">people:&nbsp;List[Person]&nbsp;=&nbsp;List(Larry&nbsp;Wall,&nbsp;Anders&nbsp;Hejlsberg,</code>
  <code class="output">&nbsp;&nbsp;Guido&nbsp;van&nbsp;Rossum,&nbsp;Alan&nbsp;Kay,&nbsp;Yukihiro&nbsp;Matsumoto)</code>
</pre>
      <p>Because the element type of this list, <span class="code">Person</span>, mixes in (and is therefore a subtype of) <span class="code">Ordered[People]</span>, you can pass the list to <span class="code">orderedMergeSort</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sortedPeople&nbsp;=&nbsp;orderedMergeSort(people)
  <code class="output">sortedPeople:&nbsp;List[Person]&nbsp;=&nbsp;List(Anders&nbsp;Hejlsberg,&nbsp;Alan&nbsp;Kay,</code>
  <code class="output">&nbsp;&nbsp;Yukihiro&nbsp;Matsumoto,&nbsp;Guido&nbsp;van&nbsp;Rossum,&nbsp;Larry&nbsp;Wall)</code>
</pre>
      <p>Now, although the sort function shown in <a href="#lst-upper-bound-sort">Listing 19.12</a> serves as a useful illustration of upper bounds, it isn't actually the most general way in Scala to design a sort function that takes advantage of the <span class="code">Ordered</span> trait.</p>
      <p>For example, you couldn't use the <span class="code">orderedMergeSort</span> function to sort a list of integers, because class <span class="code">Int</span> is not a subtype of <span class="code">Ordered[Int]</span>:<a id="i-1803074733-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;wontCompile&nbsp;=&nbsp;orderedMergeSort(<code class="typename">List</code>(<code class="literal">3</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">1</code>))
  <code class="output">&lt;console&gt;:5:&nbsp;error:&nbsp;inferred&nbsp;type&nbsp;arguments&nbsp;[Int]&nbsp;do</code>
  <code class="output">&nbsp;&nbsp;&nbsp;not&nbsp;conform&nbsp;to&nbsp;method&nbsp;orderedMergeSort's&nbsp;type</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameter&nbsp;bounds&nbsp;[T&nbsp;&lt;:&nbsp;Ordered[T]]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;wontCompile&nbsp;=&nbsp;orderedMergeSort(List(3,&nbsp;2,&nbsp;1))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>In <a href="#sec-context-bounds">Section 21.6</a>, we'll show you how to use <em>implicit parameters</em> and <em>context bounds</em> to achieve a more general solution.<a id="i-568821387-1"></a><a id="i-956942778-1"></a></p>
      <h3>19.9 Conclusion</h3>
      <p>In this chapter you saw several techniques for information hiding: private constructors, factory methods, type abstraction, and object private members. You also learned how to specify data type variance and what it implies for class implementation. Finally, you saw two techniques which help in obtaining flexible variance annotations: lower bounds for method type parameters and <span class="code">private[this]</span> annotations for local fields and methods.</p>
      <hr>
      <h4>Footnotes for Chapter 19:</h4>
      <p><a id="footnotemain19-1"></a>[1] Supertype and subtype relationships are reflexive, which means a type is both a supertype and a subtype of itself. Even though <span class="code">T</span> is a lower bound for <span class="code">U</span>, you could still pass in a <span class="code">T</span> to <span class="code">enqueue</span>.</p>
      <p><a id="footnotemain19-2"></a>[2] Technically, what happens is a flip occurs for lower bounds. The type parameter <span class="code">U</span> is in a negative position (1 flip), while the lower bound (<span class="code">&gt;:</span>&nbsp;<span class="code">T</span>) is in a positive position (2 flips).</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-abstract-members">Chapter 20</a></h2>
      <h1>Abstract Members</h1>
      <p>A member of a class or trait is <span style="font-style:italic">abstract</span> if the member does not have a complete definition in the class.<a id="i785070065-1"></a><a id="i184187235-1"></a> Abstract members are intended to be implemented in subclasses of the class in which they are declared. This idea is found in many object-oriented languages. For instance, Java lets you declare abstract methods. Scala also lets you declare such methods, as you saw in <a href="#sec-abstract-classes">Section 10.2</a>. But Scala goes beyond that and implements the idea in its full generality: Besides methods, you can declare abstract fields and even abstract types as members of classes and traits.</p>
      <p>In this chapter we'll describe all four kinds of abstract member: <span class="code">val</span>s, <span class="code">var</span>s, methods, and types. Along the way we'll discuss pre-initialized fields, lazy <span class="code">val</span>s, path-dependent types, and enumerations.</p>
      <h3>20.1 A quick tour of abstract members</h3>
      <p>The following trait declares one of each kind of abstract member: an abstract type (<span class="code">T</span>), method (<span class="code">transform</span>), <span class="code">val</span> (<span class="code">initial</span>), and <span class="code">var</span> (<span class="code">current</span>):<a id="i-1463644999-1"></a></p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">Abstract</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;T
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;transform(x:&nbsp;T):&nbsp;T
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;initial:&nbsp;T
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;current:&nbsp;T
  }
</pre>
      <p>A concrete implementation of <span class="code">Abstract</span> needs to fill in definitions for each of its abstract members. Here is an example implementation that provides these definitions:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Concrete</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Abstract</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;T&nbsp;=&nbsp;<code class="typename">String</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;transform(x:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;x&nbsp;+&nbsp;x
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;initial&nbsp;=&nbsp;<code class="quotedstring">"hi"</code>
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;current&nbsp;=&nbsp;initial
  }
</pre>
      <p>The implementation gives a concrete meaning to the type name <span class="code">T</span> by defining it as an alias of type <span class="code">String</span>.<a id="i1803174454-1"></a><a id="i22781976-1"></a> The <span class="code">transform</span> operation concatenates a given string with itself, and the <span class="code">initial</span> and <span class="code">current</span> values are both set to <span class="code">"hi"</span>.</p>
      <p>This example gives you a rough first idea of what kinds of abstract members exist in Scala. The remainder of the chapter will present the details and explain what the new forms of abstract members, as well as type members in general, are good for.</p>
      <h3>20.2 Type members</h3>
      <p>As you can see from the example in the previous section, the term <em>abstract type</em> in Scala means a type<a id="i1886198323-1"></a> declared (with the "<span class="code">type</span>" keyword) to be a member of a class or trait, without specifying a definition.<a id="i475521275-1"></a><a id="i-1569140754-2"></a> Classes themselves may be abstract, and traits are by definition abstract, but neither of these are what are referred to as <em>abstract types</em> in Scala. An abstract type in Scala is always a member of some class or trait, such as type <span class="code">T</span> in trait <span class="code">Abstract</span>.</p>
      <p>You can think of a non-abstract (or "concrete") type member, such as type <span class="code">T</span> in class <span class="code">Concrete</span>, as a way to define a new name, or <em>alias</em>, for a type.<a id="i22781976-2"></a><a id="i1803174454-2"></a> In class <span class="code">Concrete</span>, for example, the type <span class="code">String</span> is given the alias <span class="code">T</span>. As a result, anywhere <span class="code">T</span> appears in the definition of class <span class="code">Concrete</span>, it means <span class="code">String</span>. This includes the parameter and result types of <span class="code">transform</span>, <span class="code">initial</span>, and <span class="code">current</span>, which mention <span class="code">T</span> when they are declared in supertrait <span class="code">Abstract</span>. Thus, when class <span class="code">Concrete</span> implements these methods, those <span class="code">T</span>s are interpreted to mean <span class="code">String</span>.</p>
      <p>One reason to use a type member is to define a short, descriptive alias<a id="i22781976-3"></a><a id="i1803174454-3"></a> for a type whose real name is more verbose, or less obvious in meaning, than the alias. Such type members can help clarify the code of a class or trait. The other main use of type members is to declare abstract types that must be defined in subclasses. This use, which was demonstrated in the previous section, will be described in detail later in this chapter.</p>
      <h3 id="sec-abstract-vals">20.3 Abstract <span class="code">val</span>s</h3>
      <p>An abstract <span class="code">val</span> declaration has a form like:</p> <pre>  <code class="vem">val</code>&nbsp;initial:&nbsp;<code class="typename">String</code>
</pre>
      <p>It gives a name and type for a <span class="code">val</span>, but not its value.<a id="i1727592746-1"></a> This value has to be provided by a concrete <span class="code">val</span> definition in a subclass. For instance, class <span class="code">Concrete</span> implemented the <span class="code">val</span> using:</p> <pre>  <code class="vem">val</code>&nbsp;initial&nbsp;=&nbsp;<code class="quotedstring">"hi"</code>
</pre>
      <p>You use an abstract <span class="code">val</span> declaration in a class when you do not know the correct value in the class, but you do know that the variable will have an unchangeable value in each instance of the class.</p>
      <p>An abstract <span class="code">val</span> declaration resembles an abstract parameterless<a id="i1692897037-1"></a><a id="i748048051-1"></a><a id="i84167179-1"></a> method declaration such as:</p> <pre>  <code class="vem">def</code>&nbsp;initial:&nbsp;<code class="typename">String</code>
</pre>
      <p>Client code would refer to both the <span class="code">val</span> and the method in exactly the same way (<i>i.e.</i>, <span class="code">obj.initial</span>). However, if <span class="code">initial</span> is an abstract <span class="code">val</span>, the client is guaranteed that <span class="code">obj.initial</span> will yield the same value every time it is referenced. If <span class="code">initial</span> were an abstract method, that guarantee would not hold because, in that case, <span class="code">initial</span> could be implemented by a concrete method that returns a different value every time it's called.</p>
      <p>In other words, an abstract <span class="code">val</span> constrains its legal implementation: Any implementation must be a <span class="code">val</span> definition; it may not be a <span class="code">var</span> or a <span class="code">def</span>. Abstract method declarations, on the other hand, may be implemented by both concrete method definitions and concrete <span class="code">val</span> definitions. Given the abstract class <span class="code">Fruit</span> shown in <a href="#lst-bad-apple">Listing 20.1</a>, class <span class="code">Apple</span> would be a legal subclass implementation, but class <span class="code">BadApple</span> would not. <a id="lst-bad-apple"></a></p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Fruit</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;v:&nbsp;<code class="typename">String</code>&nbsp;<code class="comment">//&nbsp;`v'&nbsp;for&nbsp;value</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;m:&nbsp;<code class="typename">String</code>&nbsp;<code class="comment">//&nbsp;`m'&nbsp;for&nbsp;method</code>
  }
  <br>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Apple</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;v:&nbsp;<code class="typename">String</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;m:&nbsp;<code class="typename">String</code>&nbsp;<code class="comment">//&nbsp;OK&nbsp;to&nbsp;override&nbsp;a&nbsp;`def'&nbsp;with&nbsp;a&nbsp;`val'</code>
  }
  <br>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">BadApple</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;v:&nbsp;<code class="typename">String</code>&nbsp;<code class="comment">//&nbsp;ERROR:&nbsp;cannot&nbsp;override&nbsp;a&nbsp;`val'&nbsp;with&nbsp;a&nbsp;`def'</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;m:&nbsp;<code class="typename">String</code>
  }
</pre>
      <h5>Listing 20.1 - Overriding abstract <span class="code">val</span>s and parameterless methods.</h5>
      <h3>20.4 Abstract <span class="code">var</span>s</h3>
      <p>Like an abstract <span class="code">val</span>, an abstract <span class="code">var</span> declares just a name and a type, but not an initial value<a id="i-464180816-1"></a>. For instance, <a href="#lst-abstract-vars">Listing 20.2</a> shows a trait <span class="code">AbstractTime</span>, which declares two abstract variables named <span class="code">hour</span> and <span class="code">minute</span>:</p>
      <p><a id="lst-abstract-vars"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">AbstractTime</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;hour:&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;minute:&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.2 - Declaring abstract <span class="code">var</span>s.</h5>
      <p>What is the meaning of abstract <span class="code">var</span>s like <span class="code">hour</span> and <span class="code">minute</span>? You saw in <a href="#sec-properties">Section 18.2</a> that <span class="code">var</span>s declared as members of classes come equipped with getter and setter methods<a id="i553650449-2"></a><a id="i-1969580643-3"></a>. This holds for abstract <span class="code">var</span>s as well. If you declare an abstract <span class="code">var</span> named <span class="code">hour</span>, for example, you implicitly declare an abstract getter method, <span class="code">hour</span>, and an abstract setter method, <span class="code">hour_=</span>. There's no reassignable field to be defined—that will come in subclasses that define the concrete implementation of the abstract <span class="code">var</span>. For instance, the definition of <span class="code">AbstractTime</span> shown in <a href="#lst-abstract-vars">Listing 20.2</a> is exactly equivalent to the definition shown in <a href="#lst-abstract-vars-expanded">Listing 20.3</a>. <a id="lst-abstract-vars-expanded"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">AbstractTime</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;hour:&nbsp;<code class="typename">Int</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;getter&nbsp;for&nbsp;`hour'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;hour_=(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Unit</code>&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;setter&nbsp;for&nbsp;`hour'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;minute:&nbsp;<code class="typename">Int</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;getter&nbsp;for&nbsp;`minute'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;minute_=(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Unit</code>&nbsp;<code class="comment">//&nbsp;setter&nbsp;for&nbsp;`minute'</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.3 - How abstract <span class="code">var</span>s are expanded into getters and setters.</h5>
      <h3 id="sec-val-init">20.5 Initializing abstract <span class="code">val</span>s</h3>
      <p>Abstract <span class="code">val</span>s sometimes play a role analogous to superclass parameters: they let you provide details in a subclass that are missing in a superclass. This is particularly important for traits, because traits don't have a constructor to which you could pass<a id="i-1985442764-1"></a><a id="i-280981118-1"></a> parameters. So the usual notion of parameterizing a trait works via abstract <span class="code">val</span>s that are implemented in subclasses.<a id="i1371895904-1"></a><a id="i-1767979071-1"></a></p>
      <p>As an example, consider a reformulation of class <span class="code">Rational</span> from <a href="#chap-functional-objects">Chapter 6</a>, as shown in <a href="#lst-overloaded-methods">Listing 6.5</a> <a href="#lst-overloaded-methods">here</a>, as a trait:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">RationalTrait</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg:&nbsp;<code class="typename">Int</code>&nbsp;
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg:&nbsp;<code class="typename">Int</code>&nbsp;
  }&nbsp;
</pre>
      <p>The <span class="code">Rational</span> class from <a href="#chap-functional-objects">Chapter 6</a> had two parameters: <span class="code">n</span> for the numerator of the rational number, and <span class="code">d</span> for the denominator. The <span class="code">RationalTrait</span> trait given here defines instead two abstract <span class="code">val</span>s: <span class="code">numerArg</span> and <span class="code">denomArg</span>. To instantiate a concrete instance of that trait, you need to implement the abstract <span class="code">val</span> definitions. Here's an example:</p> <pre>  <code class="vem">new</code>&nbsp;<code class="typename">RationalTrait</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg&nbsp;=&nbsp;<code class="literal">2</code>
  }
</pre>
      <p>Here the keyword <span class="code">new</span> appears in front of a trait name, <span class="code">RationalTrait</span>, which is followed by a class body in curly braces. This expression yields an instance of an <a href="#g-113939451"><em>anonymous class</em></a> that mixes in the trait and is defined by the body<a id="i-2121626765-1"></a><a id="i-899295719-1"></a>. This particular anonymous class instantiation has an effect analogous to the instance creation <span class="code">new</span>&nbsp;<span class="code">Rational(1,</span>&nbsp;<span class="code">2)</span>.</p>
      <p>The analogy is not perfect, however. There's a subtle difference concerning the order in which expressions are initialized. When you write:</p> <pre>  <code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(expr1,&nbsp;expr2)
</pre>
      <p>the two expressions, <span class="code">expr1</span> and <span class="code">expr2</span>, are evaluated before class <span class="code">Rational</span> is initialized, so the values of <span class="code">expr1</span> and <span class="code">expr2</span> are available for the initialization of class <span class="code">Rational</span>.</p>
      <p>For traits, the situation is the opposite. When you write:</p> <pre>  <code class="vem">new</code>&nbsp;<code class="typename">RationalTrait</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg&nbsp;=&nbsp;expr1
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg&nbsp;=&nbsp;expr2
  }
</pre>
      <p>the expressions, <span class="code">expr1</span> and <span class="code">expr2</span>, are evaluated as part of the initialization of the anonymous class, but the anonymous class is initialized <em>after</em> the <span class="code">RationalTrait</span>. So the values of <span class="code">numerArg</span> and <span class="code">denomArg</span> are not available during the initialization of <span class="code">RationalTrait</span> (more precisely, a selection of either value would yield the default value for type <span class="code">Int</span>, 0). For the definition of <span class="code">RationalTrait</span> given previously, this is not a problem, because the trait's initialization does not make use of values <span class="code">numerArg</span> or <span class="code">denomArg</span>. However, it becomes a problem in the variant of <span class="code">RationalTrait</span> shown in <a href="#lst-rational-trait">Listing 20.4</a>, which defines normalized numerators and denominators.</p>
      <p><a id="lst-rational-trait"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">RationalTrait</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg:&nbsp;<code class="typename">Int</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg:&nbsp;<code class="typename">Int</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;require(denomArg&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;gcd(numerArg,&nbsp;denomArg)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;numerArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;denomArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$numer/$denom"</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.4 - A trait that uses its abstract <span class="code">val</span>s.</h5>
      <p>If you try to instantiate this trait with some numerator and denominator expressions that are not simple literals, you'll get an exception:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="literal">2</code>
  <code class="output">x:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">RationalTrait</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">java.lang.IllegalArgumentException:&nbsp;requirement&nbsp;failed</code>
  <code class="output">&nbsp;&nbsp;at&nbsp;scala.Predef$.require(Predef.scala:280)</code>
  <code class="output">&nbsp;&nbsp;at&nbsp;RationalTrait.$init$(&lt;console&gt;:4)</code>
  <code class="output">&nbsp;&nbsp;...&nbsp;28&nbsp;elided</code>
</pre>
      <p>The exception in this example was thrown because <span class="code">denomArg</span> still had its default value of 0 when class <span class="code">RationalTrait</span> was initialized, which caused the <span class="code">require</span> invocation to fail.</p>
      <p>This example demonstrates that initialization order is not the same for class parameters and abstract fields.<a id="i-1695985614-1"></a><a id="i-17530359-1"></a><a id="i-1356458045-1"></a> A class parameter argument is evaluated <span style="font-style:italic">before</span> it is passed to the class constructor (unless the parameter is by-name). An implementing <span class="code">val</span> definition in a subclass, by contrast, is evaluated only <span style="font-style:italic">after</span> the superclass has been initialized.</p>
      <p>Now that you understand why abstract <span class="code">val</span>s behave differently from parameters, it would be good to know what can be done about this. Is it possible to define a <span class="code">RationalTrait</span> that can be initialized robustly, without fearing errors due to uninitialized fields? In fact, Scala offers two alternative solutions to this problem, <span style="font-style:italic"> pre-initialized fields</span> and <span style="font-style:italic">lazy <span class="code">val</span>s</span>. They are presented in the remainder of this section.</p>
      <h4>Pre-initialized fields</h4>
      <p>The first solution, pre-initialized fields, lets you initialize a field of a subclass before the superclass is called.<a id="i-1387085847-1"></a><a id="i483675481-1"></a> To do this, simply place the field definition in braces before the superclass constructor call. As an example, <a href="#lst-pre-init-anon-class">Listing 20.5</a> shows another attempt to create an instance of <span class="code">RationalTrait</span>. As you see from this example, the initialization section comes before the mention of the supertrait <span class="code">RationalTrait</span>. Both are separated by a <span class="code">with</span>.</p>
      <p><a id="lst-pre-init-anon-class"></a></p> <pre>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">new</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;*&nbsp;x&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">RationalTrait</code>
  <code class="output">&nbsp;&nbsp;res1:&nbsp;RationalTrait&nbsp;=&nbsp;1/2</code>
</pre>
      <h5>Listing 20.5 - Pre-initialized fields in an anonymous class expression.</h5>
      <p>Pre-initialized fields are not restricted to anonymous classes; they can also be used in objects or named subclasses. Two examples are shown in <a href="#lst-pre-init-fields-object">Listings 20.6</a> <a href="#lst-pre-init-fields-class">and 20.7</a>. As you can see from these examples, the pre-initialization section comes in each case after the <span class="code">extends</span> keyword of the defined object or class. Class <span class="code">RationalClass</span>, shown in <a href="#lst-pre-init-fields-class">Listing 20.7</a>, exemplifies a general schema of how class parameters can be made available for the initialization of a supertrait.</p>
      <p><a id="lst-pre-init-fields-object"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;twoThirds&nbsp;<code class="vem">extends</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg&nbsp;=&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg&nbsp;=&nbsp;<code class="literal">3</code>
  &nbsp;&nbsp;}&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">RationalTrait</code>
</pre>
      <h5>Listing 20.6 - Pre-initialized fields in an object definition.</h5>
      <p><a id="lst-pre-init-fields-class"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">RationalClass</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg&nbsp;=&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg&nbsp;=&nbsp;d
  &nbsp;&nbsp;}&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">RationalTrait</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">RationalClass</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">RationalClass</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.7 - Pre-initialized fields in a class definition.</h5>
      <p>Because pre-initialized fields are initialized before the superclass constructor is called, their initializers cannot refer to the object that's being constructed. Consequently, if such an initializer refers to <span class="code">this</span>, the reference goes to the object containing the class or object that's being constructed, not the constructed object itself.</p>
      <p>Here's an example:<a id="i988779894-2"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg&nbsp;=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg&nbsp;=&nbsp;<code class="vem">this</code>.numerArg&nbsp;*&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">RationalTrait</code>
  <code class="output">On&nbsp;line&nbsp;3:&nbsp;error:&nbsp;value&nbsp;numerArg&nbsp;is&nbsp;not&nbsp;a&nbsp;member&nbsp;of&nbsp;object&nbsp;</code>
  <code class="output">$iw</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;denomArg&nbsp;=&nbsp;this.numerArg&nbsp;*&nbsp;2</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>The example did not compile because the reference <span class="code">this.numerArg</span> was looking for a <span class="code">numerArg</span> field in the object containing the <span class="code">new</span> (which in this case was the synthetic object named <span class="code">$iw</span>, into which the interpreter puts user input lines). Once more, pre-initialized fields behave in this respect like class constructor arguments.</p>
      <h4>Lazy <span class="code">val</span>s</h4>
      <p>You can use pre-initialized fields to simulate precisely the initialization behavior of class constructor arguments. Sometimes, however, you might prefer to let the system itself sort out how things should be initialized. This can be achieved by making your <span class="code">val</span> definitions <em>lazy</em>. If you prefix a <span class="code">val</span> definition with a <span class="code">lazy</span><a id="i1386009102-1"></a> modifier, the initializing expression on the right-hand side will only be evaluated the first time the <span class="code">val</span> is used.</p>
      <p>For an example, define an object <span class="code">Demo</span> with a <span class="code">val</span> as follows:</p> <pre>  scala&gt;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Demo</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"initializing&nbsp;x"</code>);&nbsp;<code class="quotedstring">"done"</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">defined&nbsp;object&nbsp;Demo</code>
</pre>
      <p>Now, first refer to <span class="code">Demo</span>, then to <span class="code">Demo.x</span>:</p> <pre>  scala&gt;&nbsp;<code class="typename">Demo</code>
  <code class="output">initializing&nbsp;x</code>
  <code class="output">res3:&nbsp;Demo.type&nbsp;=&nbsp;Demo$@2129a843</code>
  <br>  scala&gt;&nbsp;Demo.x
  <code class="output">res4:&nbsp;String&nbsp;=&nbsp;done</code>
</pre>
      <p>As you can see, the moment you use <span class="code">Demo</span>, its <span class="code">x</span> field becomes initialized. The initialization of <span class="code">x</span> forms part of the initialization of <span class="code">Demo</span>. The situation changes, however, if you define the <span class="code">x</span> field to be <span class="code">lazy</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Demo</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">lazy</code>&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;{&nbsp;println(<code class="quotedstring">"initializing&nbsp;x"</code>);&nbsp;<code class="quotedstring">"done"</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">defined&nbsp;object&nbsp;Demo</code>
  <br>  scala&gt;&nbsp;<code class="typename">Demo</code>
  <code class="output">res5:&nbsp;Demo.type&nbsp;=&nbsp;Demo$@1a18e68a</code>
  <br>  scala&gt;&nbsp;Demo.x
  <code class="output">initializing&nbsp;x</code>
  <code class="output">res6:&nbsp;String&nbsp;=&nbsp;done</code>
</pre>
      <p>Now, initializing <span class="code">Demo</span> does not involve initializing <span class="code">x</span>. The initialization of <span class="code">x</span> will be deferred until the first time <span class="code">x</span> is used. This is similar to the situation where <span class="code">x</span> is defined as a parameterless method, using a <span class="code">def</span>. However, unlike a <span class="code">def</span>, a lazy <span class="code">val</span> is never evaluated more than once<a id="i-861970308-1"></a><a id="i3314548-1"></a>. In fact, after the first evaluation of a lazy <span class="code">val</span> the result of the evaluation is stored, to be reused when the same <span class="code">val</span> is used subsequently.</p>
      <p>Looking at this example, it seems that objects like <span class="code">Demo</span> themselves behave like lazy <span class="code">val</span>s, in that they are also initialized on demand, the first time they are used. This is correct. In fact an object definition can be seen as a shorthand for the definition of a lazy <span class="code">val</span> with an anonymous class that describes the object's contents.</p>
      <p>Using lazy <span class="code">val</span>s, you could reformulate <span class="code">RationalTrait</span> as shown in <a href="#lst-init-trait-lazy-vals">Listing 20.8</a>. In the new trait definition, all concrete fields are defined <span class="code">lazy</span>. Another change with respect to the previous definition of <span class="code">RationalTrait</span>, shown in <a href="#lst-rational-trait">Listing 20.4</a>, is that the <span class="code">require</span> clause was moved from the body of the trait to the initializer of the private field, <span class="code">g</span>, which computes the greatest common divisor of <span class="code">numerArg</span> and <span class="code">denomArg</span>. With these changes, there's nothing that remains to be done when <span class="code">LazyRationalTrait</span> is initialized; all initialization code is now part of the right-hand side of a lazy <span class="code">val</span>. Thus, it is safe to initialize the abstract fields of <span class="code">LazyRationalTrait</span> after the class is defined.</p>
      <p><a id="lst-init-trait-lazy-vals"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">LazyRationalTrait</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg:&nbsp;<code class="typename">Int</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg:&nbsp;<code class="typename">Int</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">lazy</code>&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;numerArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">lazy</code>&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;denomArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$numer/$denom"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">lazy</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(denomArg&nbsp;!=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcd(numerArg,&nbsp;denomArg)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.8 - Initializing a trait with lazy <span class="code">val</span>s.</h5>
      <p>Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;<code class="literal">2</code>
  <code class="output">x:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">LazyRationalTrait</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numerArg&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denomArg&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">res7:&nbsp;LazyRationalTrait&nbsp;=&nbsp;1/2</code>
</pre>
      <p>No pre-initialization is needed. It's instructive to trace the sequence of initializations that lead to the string <span class="code">1/2</span> to be printed in the code above:</p>
      <ol>
        <li> A fresh instance of <span class="code">LazyRationalTrait</span> gets created and the initialization code of <span class="code">LazyRationalTrait</span> is run. This initialization code is empty; none of the fields of <span class="code">LazyRationalTrait</span> is initialized yet. </li>
        <li> Next, the primary constructor of the anonymous subclass defined by the <span class="code">new</span> expression is executed. This involves the initialization of <span class="code">numerArg</span> with <span class="code">2</span> and <span class="code">denomArg</span> with <span class="code">4</span>. </li>
        <li> Next, the <span class="code">toString</span> method is invoked on the constructed object by the interpreter, so that the resulting value can be printed. </li>
        <li> Next, the <span class="code">numer</span> field is accessed for the first time by the <span class="code">toString</span> method in trait <span class="code">LazyRationalTrait</span>, so its initializer is evaluated. </li>
        <li> The initializer of <span class="code">numer</span> accesses the private field, <span class="code">g</span>, so <span class="code">g</span> is evaluated next. This evaluation accesses <span class="code">numerArg</span> and <span class="code">denomArg</span>, which were defined in Step 2. </li>
        <li> Next, the <span class="code">toString</span> method accesses the value of <span class="code">denom</span>, which causes <span class="code">denom</span>'s evaluation. The evaluation of <span class="code">denom</span> accesses the values of <span class="code">denomArg</span> and <span class="code">g</span>. The initializer of the <span class="code">g</span> field is not re-evaluated, because it was already evaluated in Step 5. </li>
        <li> Finally, the result string <span class="code">"1/2"</span> is constructed and printed. </li>
      </ol>
      <p>Note that the definition of <span class="code">g</span> comes textually after the definitions of <span class="code">numer</span> and <span class="code">denom</span> in class <span class="code">LazyRationalTrait</span>. Nevertheless, because all three values are lazy, <span class="code">g</span> gets initialized before the initialization of <span class="code">numer</span> and <span class="code">denom</span> is completed.</p>
      <p>This shows an important property of lazy <span class="code">val</span>s: The textual order of their definitions does not matter because values get initialized on demand. Thus, lazy vals can free you as a programmer from having to think hard how to arrange <span class="code">val</span> definitions to ensure that everything is defined when it is needed.</p>
      <p>However, this advantage holds only as long as the initialization of lazy <span class="code">val</span>s neither produces side effects nor depends on them. In the presence of side effects, initialization order starts to matter. And then it can be quite difficult to trace in what order initialization code is run, as the previous example has demonstrated. So lazy <span class="code">val</span>s are an ideal complement to functional objects, where the order of initializations does not matter, as long as everything gets initialized eventually<a id="i-1860042908-1"></a>. They are less well suited for code that's predominantly imperative.</p>
      <div class="aside">
        <h3>Lazy functional languages</h3>
        <p>Scala is by no means the first language to have exploited the perfect match of lazy definitions and functional code. In fact, there is a category of "lazy functional programming languages" in which <span style="font-style:italic"> every</span> value and parameter is initialized lazily<a id="i-748662080-1"></a>. The best known member of this class of languages is Haskell <a href="#haskell98">[SPJ02]</a><a id="i-156161824-1"></a>.</p>
      </div>
      <h3 id="sec-abstract-types">20.6 Abstract <span class="code">type</span>s</h3>
      <p>In the beginning of this chapter, you saw, "<span class="code">type</span>&nbsp;<span class="code">T</span>", an abstract type declaration<a id="i-332843517-1"></a><a id="i669006587-1"></a>. The rest of this chapter discusses what such an abstract type declaration means and what it's good for. Like all other abstract declarations, an abstract type declaration is a placeholder for something that will be defined concretely in subclasses. In this case, it is a type that will be defined further down the class hierarchy. So <span class="code">T</span> above refers to a type that is as yet unknown at the point where it is declared. Different subclasses can provide different realizations of <span class="code">T</span>.</p>
      <p>Here is a well-known example where abstract types show up naturally. Suppose you are given the task of modeling the eating habits of animals. You might start with a class <span class="code">Food</span> and a class <span class="code">Animal</span> with an <span class="code">eat</span> method:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Food</code>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Animal</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;eat(food:&nbsp;<code class="typename">Food</code>):&nbsp;<code class="typename">Unit</code>
  }
</pre>
      <p>You might then attempt to specialize these two classes to a class of <span class="code">Cow</span>s that eat <span class="code">Grass</span>:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Grass</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Cow</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;eat(food:&nbsp;<code class="typename">Grass</code>)&nbsp;=&nbsp;{}&nbsp;<code class="comment">//&nbsp;This&nbsp;won't&nbsp;compile</code>
  }
</pre>
      <p>However, if you tried to compile the new classes, you'd get the following compilation errors:<a id="i-1458364982-1"></a><a id="i934798591-2"></a></p> <pre>  <code class="output">BuggyAnimals.scala:7:&nbsp;error:&nbsp;class&nbsp;Cow&nbsp;needs&nbsp;to&nbsp;be</code>
  <code class="output">abstract,&nbsp;since&nbsp;method&nbsp;eat&nbsp;in&nbsp;class&nbsp;Animal&nbsp;of&nbsp;type</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Food)Unit&nbsp;is&nbsp;not&nbsp;defined</code>
  <code class="output">class&nbsp;Cow&nbsp;extends&nbsp;Animal&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">BuggyAnimals.scala:8:&nbsp;error:&nbsp;method&nbsp;eat&nbsp;overrides&nbsp;nothing</code>
  <code class="output">&nbsp;&nbsp;override&nbsp;def&nbsp;eat(food:&nbsp;Grass)&nbsp;=&nbsp;{}</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>What happened is that the <span class="code">eat</span> method in class <span class="code">Cow</span> did not override the <span class="code">eat</span> method in class <span class="code">Animal</span> because its parameter type is different: it's <span class="code">Grass</span> in class <span class="code">Cow</span> vs. <span class="code">Food</span> in class <span class="code">Animal</span>.</p>
      <p>Some people have argued that the type system is unnecessarily strict in refusing these classes. They have said that it should be OK to specialize a parameter of a method in a subclass. However, if the classes were allowed as written, you could get yourself in unsafe situations very quickly.</p>
      <p>For instance, the following script would pass the type checker:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Food</code>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Animal</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;eat(food:&nbsp;<code class="typename">Food</code>):&nbsp;<code class="typename">Unit</code>
  }
  <code class="vem">class</code>&nbsp;<code class="typename">Grass</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Cow</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;eat(food:&nbsp;<code class="typename">Grass</code>)&nbsp;=&nbsp;{}&nbsp;<code class="comment">//&nbsp;This&nbsp;won't&nbsp;compile,</code>
  }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;but&nbsp;if&nbsp;it&nbsp;did,...</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Fish</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>
  <code class="vem">val</code>&nbsp;bessy:&nbsp;<code class="typename">Animal</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cow</code>
  bessy&nbsp;eat&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">Fish</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;...you&nbsp;could&nbsp;feed&nbsp;fish&nbsp;to&nbsp;cows.</code>
</pre>
      <p>The program would compile if the restriction were eased, because <span class="code">Cow</span>s are <span class="code">Animal</span>s and <span class="code">Animal</span>s do have an <span class="code">eat</span> method that accepts any kind of <span class="code">Food</span>, including <span class="code">Fish</span>. But surely it would do a cow no good to eat a fish!</p>
      <p>What you need to do instead is apply some more precise modeling. <span class="code">Animal</span>s do eat <span class="code">Food</span>, but what kind of <span class="code">Food</span> each <span class="code">Animal</span> eats depends on the <span class="code">Animal</span>. This can be neatly expressed with an abstract type, as shown in <a href="#lst-suitablefood-abstract-type">Listing 20.9</a>:</p>
      <p><a id="lst-suitablefood-abstract-type"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Food</code>
  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Animal</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">SuitableFood</code>&nbsp;&lt;:&nbsp;<code class="typename">Food</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;eat(food:&nbsp;<code class="typename">SuitableFood</code>):&nbsp;<code class="typename">Unit</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.9 - Modeling suitable food with an abstract type.</h5>
      <p>With the new class definition, an <span class="code">Animal</span> can eat only food that's suitable. What food is suitable cannot be determined at the level of the <span class="code">Animal</span> class. That's why <span class="code">SuitableFood</span> is modeled as an abstract type. The type has an upper bound, <span class="code">Food</span>, which is expressed by the "<span class="code">&lt;:</span>&nbsp;<span class="code">Food</span>" clause. This means that any concrete instantiation of <span class="code">SuitableFood</span> (in a subclass of <span class="code">Animal</span>) must be a subclass of <span class="code">Food</span>. For example, you would not be able to instantiate <span class="code">SuitableFood</span> with class <span class="code">IOException</span>.</p>
      <p>With <span class="code">Animal</span> defined, you can now progress to cows, as shown in <a href="#lst-suitable-cow">Listing 20.10</a>. Class <span class="code">Cow</span> fixes its <span class="code">SuitableFood</span> to be <span class="code">Grass</span> and also defines a concrete <span class="code">eat</span> method for this kind of food.</p>
      <p><a id="lst-suitable-cow"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Grass</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cow</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">SuitableFood</code>&nbsp;=&nbsp;<code class="typename">Grass</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;eat(food:&nbsp;<code class="typename">Grass</code>)&nbsp;=&nbsp;{}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.10 - Implementing an abstract type in a subclass.</h5>
      <p>These new class definitions compile without errors. If you tried to run the "cows-that-eat-fish" counterexample with the new class definitions, you would get the following compiler error:<a id="i-677980410-4"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Fish</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>
  <code class="output">defined&nbsp;class&nbsp;Fish</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bessy:&nbsp;<code class="typename">Animal</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cow</code>
  <code class="output">bessy:&nbsp;Animal&nbsp;=&nbsp;Cow@4df50829</code>
  <br>  scala&gt;&nbsp;bessy&nbsp;eat&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">Fish</code>)
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output"></code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Fish</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required:&nbsp;bessy.SuitableFood</code>
</pre>
      <h3 id="sec-path-dependent-types">20.7 Path-dependent types</h3>
      <p>Have a look at the last error message again. What's interesting about it is the<a id="i419165808-1"></a><a id="i-2033041288-1"></a> type required by the <span class="code">eat</span> method: <span class="code">bessy.SuitableFood</span>. This type consists of an object reference, <span class="code">bessy</span>, followed by a type field, <span class="code">SuitableFood</span>, of the object. So this shows that objects in Scala can have types as members. The meaning of <span class="code">bessy.SuitableFood</span> is "the type <span class="code">SuitableFood</span> that is a member of the object referenced from <span class="code">bessy</span>" or, alternatively, the type of food that's suitable for <span class="code">bessy</span>.</p>
      <p>A type like <span class="code">bessy.SuitableFood</span> is called a <span style="font-style:italic">path-dependent type</span>. The word "path" here means a reference to an object. It could be a single name, such as <span class="code">bessy</span>, or a longer access path, such as <span class="code">farm.barn.bessy</span>, where each of <span class="code">farm</span>, <span class="code">barn</span>, and <span class="code">bessy</span> are variables (or singleton object names) that refer to objects.</p>
      <p>As the term "path-dependent type" implies, the type depends on the path; in general, different paths give rise to different types. For instance, say you defined classes <span class="code">DogFood</span> and <span class="code">Dog</span>, like this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">DogFood</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Dog</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Animal</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">SuitableFood</code>&nbsp;=&nbsp;<code class="typename">DogFood</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;eat(food:&nbsp;<code class="typename">DogFood</code>)&nbsp;=&nbsp;{}
  }
</pre>
      <p>If you attempted to feed a dog with food fit for a cow, your code would not compile:<a id="i-677980410-5"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bessy&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cow</code>
  <code class="output">bessy:&nbsp;Cow&nbsp;=&nbsp;Cow@6740b169</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;lassie&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Dog</code>
  <code class="output">lassie:&nbsp;Dog&nbsp;=&nbsp;Dog@31419d4a</code>
  <br>  scala&gt;&nbsp;lassie&nbsp;eat&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">bessy.SuitableFood</code>)
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output"></code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Grass</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required:&nbsp;DogFood</code>
</pre>
      <p>The problem here is that the type of the <span class="code">SuitableFood</span> object passed to the <span class="code">eat</span> method, <span class="code">bessy.SuitableFood</span>, is incompatible with the parameter type of <span class="code">eat</span>, <span class="code">lassie.SuitableFood</span>.</p>
      <p>The case would be different for two <span class="code">Dog</span>s. Because <span class="code">Dog</span>'s <span class="code">SuitableFood</span> type is defined to be an alias for class <span class="code">DogFood</span>, the <span class="code">SuitableFood</span> types of two <span class="code">Dog</span>s are in fact the same. As a result, the <span class="code">Dog</span> instance named <span class="code">lassie</span> could actually eat the suitable food of a different <span class="code">Dog</span> instance (which we'll name <span class="code">bootsie</span>):</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bootsie&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Dog</code>
  <code class="output">bootsie:&nbsp;Dog&nbsp;=&nbsp;Dog@2740c1e</code>
  <br>  scala&gt;&nbsp;lassie&nbsp;eat&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">bootsie.SuitableFood</code>)
</pre>
      <p>A path-dependent type resembles the syntax for an inner class type in Java<a id="i1051202392-1"></a>, but there is a crucial difference: a path-dependent type names an outer <span style="font-style:italic">object</span>, whereas an inner class type names an outer <span style="font-style:italic">class</span>. Java-style inner class types can also be expressed in Scala, but they are written differently. Consider these two classes, <span class="code">Outer</span> and <span class="code">Inner</span>:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Outer</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Inner</code>
  }
</pre>
      <p>In Scala, the inner class is addressed using the expression <span class="code">Outer#Inner</span> instead of Java's <span class="code">Outer.Inner</span>. The `<span class="code">.</span>' syntax is reserved for objects.<a id="i-1229370884-1"></a> For example, imagine you instantiate two objects of type <span class="code">Outer</span>, like this:</p> <pre>  <code class="vem">val</code>&nbsp;o1&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Outer</code>
  <code class="vem">val</code>&nbsp;o2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Outer</code>
</pre>
      <p>Here <span class="code">o1.Inner</span> and <span class="code">o2.Inner</span> are two path-dependent types<a id="i1286205047-1"></a><a id="i-1290990775-1"></a> (and they are different types). Both of these types conform to (are subtypes of) the more general type <span class="code">Outer#Inner</span>, which represents the <span class="code">Inner</span> class with an <em>arbitrary</em> outer object of type <span class="code">Outer</span>. By contrast, type <span class="code">o1.Inner</span> refers to the <span class="code">Inner</span> class with a <em>specific</em> outer object (the one referenced from <span class="code">o1</span>). Likewise, type <span class="code">o2.Inner</span> refers to the <span class="code">Inner</span> class with a different, specific outer object (the one referenced from <span class="code">o2</span>).</p>
      <p>In Scala, as in Java, inner class instances hold a reference to an enclosing outer class instance. This allows an inner class, for example, to access members of its outer class. Thus you can't instantiate an inner class without in some way specifying an outer class instance. One way to do this is to instantiate the inner class inside the body of the outer class. In this case, the current outer class instance (referenced from <span class="code">this</span>) will be used.</p>
      <p>Another way is to use a path-dependent type. For example, because the type, <span class="code">o1.Inner</span>, names a specific outer object, you can instantiate it:</p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">o1.Inner</code>
  <code class="output">res11:&nbsp;o1.Inner&nbsp;=&nbsp;Outer$Inner@2e13c72b</code>
</pre>
      <p>The resulting inner object will contain a reference to its outer object, the object referenced from <span class="code">o1</span>. By contrast, because the type <span class="code">Outer#Inner</span> does not name any specific instance of <span class="code">Outer</span>, you can't create an instance of it:<a id="i-480808313-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Outer</code>#<code class="typename">Inner</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;Outer&nbsp;is&nbsp;not&nbsp;a&nbsp;legal&nbsp;prefix&nbsp;for</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;constructor</code>
</pre>
      <h3 id="sec-refinement-types">20.8 Refinement types</h3>
      <p>When a class inherits from another, the first class is said to be a <em>nominal</em> subtype<a id="i1065377139-1"></a> of the other one. It's a <em>nominal</em> subtype because each type has a <em>name</em>, and the names are explicitly declared to have a subtyping relationship. Scala additionally supports <em>structural</em> subtyping,<a id="i1855899700-1"></a> where you get a subtyping relationship simply because two types have compatible members. To get structural subtyping in Scala, use Scala's <a href="#g1264110831"><em>refinement types</em></a>.<a id="i532730212-1"></a><a id="i-378070292-1"></a><a id="i1419394611-1"></a></p>
      <p>Nominal subtyping is usually more convenient, so you should try nominal types first with any new design. A name is a single short identifier and thus is more concise than an explicit listing of member types. Further, structural subtyping is often more flexible than you want. A widget can <span class="code">draw()</span>, and a Western cowboy can <span class="code">draw()</span>, but they aren't really substitutable. You'd typically prefer to get a compilation error if you tried to substitute a cowboy for a widget.</p>
      <p>Nonetheless, structural subtyping has its own advantages. One is that sometimes there really is no more to a type than its members. For example, suppose you want to define a <span class="code">Pasture</span> class that can contain animals that eat grass. One option would be to define a trait <span class="code">AnimalThatEatsGrass</span> and mix it into every class where it applies. It would be verbose, however. Class <span class="code">Cow</span> has already declared that it's an animal and that it eats grass, and now it would have to declare that it is also an animal-that-eats-grass.</p>
      <p>Instead of defining <span class="code">AnimalThatEatsGrass</span>, you can use a refinement type. Simply write the base type, <span class="code">Animal</span>, followed by a sequence of members listed in curly braces. The members in the curly braces further specify—or refine, if you will—the types of members from the base class.</p>
      <p>Here is how you write the type, "animal that eats grass":</p> <pre>  <code class="typename">Animal</code>&nbsp;{&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">SuitableFood</code>&nbsp;=&nbsp;<code class="typename">Grass</code>&nbsp;}
</pre>
      <p>Given this type, you can now write the pasture class like this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Pasture</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;animals:&nbsp;<code class="typename">List[Animal&nbsp;{&nbsp;type&nbsp;SuitableFood&nbsp;=&nbsp;Grass&nbsp;}]</code>&nbsp;=&nbsp;<code class="typename">Nil</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;...</code>
  }
</pre>
      <h3 id="sec-enums">20.9 Enumerations</h3>
      <p>An interesting application of path-dependent types is found in Scala's support for enumerations. Some other languages, including Java and C#, have enumerations as a built-in language construct to define new types. Scala does not need special syntax for enumerations<a id="i-469710704-1"></a><a id="i1297750808-1"></a>. Instead, there's a class in its standard library, <span class="code">scala.Enumeration</span><a id="i-1102794201-1"></a>.</p>
      <p>To create a new enumeration, you define an object that extends this class, as in the following example, which defines a new enumeration of <span class="code">Color</span>s:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Color</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Enumeration</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Red</code>&nbsp;=&nbsp;<code class="typename">Value</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Green</code>&nbsp;=&nbsp;<code class="typename">Value</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Blue</code>&nbsp;=&nbsp;<code class="typename">Value</code>
  }
</pre>
      <p>Scala lets you also shorten several successive <span class="code">val</span> or <span class="code">var</span> definitions with the same right-hand side. Equivalently to the above you could write:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Color</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Enumeration</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Red</code>,&nbsp;<code class="typename">Green</code>,&nbsp;<code class="typename">Blue</code>&nbsp;=&nbsp;<code class="typename">Value</code>
  }
</pre>
      <p>This object definition provides three values: <span class="code">Color.Red</span>, <span class="code">Color.Green</span>, and <span class="code">Color.Blue</span>. You could also import everything in <span class="code">Color</span> with:</p> <pre>  <code class="vem">import</code>&nbsp;Color._
</pre>
      <p>and then just use <span class="code">Red</span>, <span class="code">Green</span>, and <span class="code">Blue</span>. But what is the type of these values?</p>
      <p><span class="code">Enumeration</span> defines an inner class named <span class="code">Value</span>, and the same-named parameterless <span class="code">Value</span> method returns a fresh instance of that class.<a id="i-1232708119-1"></a> In other words, a value such as <span class="code">Color.Red</span> is of type <span class="code">Color.Value</span>; <span class="code">Color.Value</span> is the type of all enumeration values defined in object <span class="code">Color</span>. It's a path-dependent type, with <span class="code">Color</span> being the path and <span class="code">Value</span> being the dependent type. What's significant about this is that it is a completely new type, different from all other types.</p>
      <p>In particular, if you define another enumeration, such as:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Direction</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Enumeration</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">North</code>,&nbsp;<code class="typename">East</code>,&nbsp;<code class="typename">South</code>,&nbsp;<code class="typename">West</code>&nbsp;=&nbsp;<code class="typename">Value</code>
  }
</pre>
      <p>then <span class="code">Direction.Value</span> would be different from <span class="code">Color.Value</span> because the path parts of the two types differ.</p>
      <p>Scala's <span class="code">Enumeration</span> class also offers many other features found in the enumeration designs of other languages. You can associate names with enumeration values by using a different overloaded variant of the <span class="code">Value</span> method:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Direction</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Enumeration</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">North</code>&nbsp;=&nbsp;<code class="typename">Value</code>(<code class="quotedstring">"North"</code>)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">East</code>&nbsp;=&nbsp;<code class="typename">Value</code>(<code class="quotedstring">"East"</code>)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">South</code>&nbsp;=&nbsp;<code class="typename">Value</code>(<code class="quotedstring">"South"</code>)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">West</code>&nbsp;=&nbsp;<code class="typename">Value</code>(<code class="quotedstring">"West"</code>)
  }
</pre>
      <p>You can iterate over the values of an enumeration via the set returned by the enumeration's <span class="code">values</span> method:<a id="i-563805575-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(d&nbsp;&lt;-&nbsp;Direction.values)&nbsp;print(d&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>)
  <code class="output">North&nbsp;East&nbsp;South&nbsp;West&nbsp;</code>
</pre>
      <p>Values of an enumeration are numbered from <span class="code">0</span>, and you can find out the number of an enumeration value by its <span class="code">id</span> method:</p> <pre>  scala&gt;&nbsp;Direction.East.id
  <code class="output">res14:&nbsp;Int&nbsp;=&nbsp;1</code>
</pre>
      <p>It's also possible to go the other way, from a non-negative integer number to the value that has this number as <span class="code">id</span> in an enumeration:</p> <pre>  scala&gt;&nbsp;<code class="typename">Direction</code>(<code class="literal">1</code>)
  <code class="output">res15:&nbsp;Direction.Value&nbsp;=&nbsp;East</code>
</pre>
      <p>This should be enough to get you started with enumerations. You can find more information in the Scaladoc comments of class <span class="code">scala.Enumeration</span>.</p>
      <h3 id="sec-currencies">20.10 Case study: Currencies</h3>
      <p>The rest of this chapter presents a case study that explains how abstract types can be used in Scala. The task is to design a class <span class="code">Currency</span>. A typical instance of <span class="code">Currency</span> would represent an amount of money in dollars, euros, yen, or some other currency. It should be possible to do some arithmetic on currencies. For instance, you should be able to add two amounts of the same currency. Or you should be able to multiply a currency amount by a factor representing an interest rate.</p>
      <p>These thoughts lead to the following first design for a currency class:</p> <pre>  <code class="comment">//&nbsp;A&nbsp;first&nbsp;(faulty)&nbsp;design&nbsp;of&nbsp;the&nbsp;Currency&nbsp;class</code>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Currency</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;amount:&nbsp;<code class="typename">Long</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation:&nbsp;<code class="typename">String</code>&nbsp;
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$amount&nbsp;$designation"</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Currency</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(x:&nbsp;<code class="typename">Double</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;...
  }
</pre>
      <p>The <span class="code">amount</span> of a currency is the number of currency units it represents. This is a field of type <span class="code">Long</span> so that very large amounts of money, such as the market capitalization of Google or Apple, can be represented. It's left abstract here, waiting to be defined when a subclass talks about concrete amounts of money. The <span class="code">designation</span> of a currency is a string that identifies it. The <span class="code">toString</span> method of class <span class="code">Currency</span> indicates an amount and a designation. It would yield results such as:</p> <pre>  79&nbsp;USD
  11000&nbsp;Yen
  99&nbsp;Euro&nbsp;
</pre>
      <p>Finally, there are methods <span class="code">+</span> for adding currencies and <span class="code">*</span> for multiplying a currency with a floating-point number. You can create a concrete currency value by supplying concrete <span class="code">amount</span> and <span class="code">designation</span> values, like this:</p> <pre>  <code class="vem">new</code>&nbsp;<code class="typename">Currency</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;amount&nbsp;=&nbsp;<code class="literal">79L</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation&nbsp;=&nbsp;<code class="quotedstring">"USD"</code>
  }
</pre>
      <p>This design would be OK if all we wanted to model was a single currency, like only dollars or only euros. But it fails if we need to deal with several currencies. Assume that you model dollars and euros as two subclasses of class currency:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Dollar</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Currency</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation&nbsp;=&nbsp;<code class="quotedstring">"USD"</code>
  }
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Euro</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Currency</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation&nbsp;=&nbsp;<code class="quotedstring">"Euro"</code>
  }
</pre>
      <p>At first glance this looks reasonable. But it would let you add dollars to euros. The result of such an addition would be of type <span class="code">Currency</span>. But it would be a funny currency that was made up of a mix of euros and dollars. What you want instead is a more specialized version of the <span class="code">+</span> method. When implemented in class <span class="code">Dollar</span>, it should take <span class="code">Dollar</span> arguments and yield a <span class="code">Dollar</span> result; when implemented in class <span class="code">Euro</span>, it should take <span class="code">Euro</span> arguments and yield a <span class="code">Euro</span> result. So the type of the addition method would change depending on which class you are in. Nonetheless, you would like to write the addition method just once, not each time a new currency is defined.</p>
      <p>In Scala, there's a simple technique to deal with situations like this. If something is not known at the point where a class is defined, make it abstract in the class. This applies to both values and types. In the case of currencies, the exact argument and result type of the addition method are not known, so it is a good candidate for an abstract type.</p>
      <p>This would lead to the following sketch of class <span class="code">AbstractCurrency</span>:</p> <pre>  <code class="comment">//&nbsp;A&nbsp;second&nbsp;(still&nbsp;imperfect)&nbsp;design&nbsp;of&nbsp;the&nbsp;Currency&nbsp;class</code>
  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Currency</code>&nbsp;&lt;:&nbsp;<code class="typename">AbstractCurrency</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;amount:&nbsp;<code class="typename">Long</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation:&nbsp;<code class="typename">String</code>&nbsp;
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$amount&nbsp;$designation"</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Currency</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(x:&nbsp;<code class="typename">Double</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;...
  }
</pre>
      <p>The only differences from the previous situation are that the class is now called <span class="code">AbstractCurrency</span>, and that it contains an abstract type <span class="code">Currency</span>, which represents the real currency in question. Each concrete subclass of <span class="code">AbstractCurrency</span> would need to fix the <span class="code">Currency</span> type to refer to the concrete subclass itself, thereby "tying the knot."</p>
      <p>For instance, here is a new version of class <span class="code">Dollar</span>, which now extends class <span class="code">AbstractCurrency</span>:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Dollar</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;<code class="typename">Dollar</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation&nbsp;=&nbsp;<code class="quotedstring">"USD"</code>
  }
</pre>
      <p>This design is workable, but it is still not perfect. One problem is hidden by the ellipses that indicate the missing method definitions of <span class="code">+</span> and <span class="code">*</span> in class <span class="code">AbstractCurrency</span>. In particular, how should addition be implemented in this class? It's easy enough to calculate the correct amount of the new currency as <span class="code">this.amount</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">that.amount</span>, but how would you convert the amount into a currency of the right type?</p>
      <p>You might try something like:<a id="i-1457961297-1"></a></p> <pre>  <code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Currency</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Currency</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;amount&nbsp;=&nbsp;<code class="vem">this</code>.amount&nbsp;+&nbsp;that.amount
  }
</pre>
      <p>However, this would not compile:</p> <pre>  <code class="output">error:&nbsp;class&nbsp;type&nbsp;required</code>
  <code class="output">&nbsp;&nbsp;def&nbsp;+&nbsp;(that:&nbsp;Currency):&nbsp;Currency&nbsp;=&nbsp;new&nbsp;Currency&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>One of the restrictions of Scala's treatment of abstract types is that you can neither create an instance of an abstract type nor have an abstract type as a supertype of another class.<a href="#footnotemain20-1">[1]</a> So the compiler would refuse the example code here that attempted to instantiate <span class="code">Currency</span>.</p>
      <p>However, you can work around this restriction using a <span style="font-style:italic">factory method</span>. Instead of creating an instance of an abstract type directly, declare an abstract method that does it. Then, wherever the abstract type is fixed to be some concrete type, you also need to give a concrete implementation of the factory method.<a id="i-1125093732-2"></a> For class <span class="code">AbstractCurrency</span>, this would look as follows:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Currency</code>&nbsp;&lt;:&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;<code class="comment">//&nbsp;abstract&nbsp;type</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;make(amount:&nbsp;<code class="typename">Long</code>):&nbsp;<code class="typename">Currency</code>&nbsp;&nbsp;<code class="comment">//&nbsp;factory&nbsp;method</code>
  &nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;rest&nbsp;of&nbsp;class</code>
  }
</pre>
      <p>A design like this could be made to work, but it looks rather suspicious. Why place the factory method <span style="font-style:italic">inside</span> class <span class="code">AbstractCurrency</span>? This looks dubious for at least two reasons. First, if you have some amount of currency (say, one dollar), you also hold in your hand the ability to make more of the same currency, using code such as:</p> <pre>  myDollar.make(<code class="literal">100</code>)&nbsp;&nbsp;<code class="comment">//&nbsp;here&nbsp;are&nbsp;a&nbsp;hundred&nbsp;more!</code>
</pre>
      <p>In the age of color copying this might be a tempting scenario, but hopefully not one which you would be able to do for very long without being caught. The second problem with this code is that you can make more <span class="code">Currency</span> objects if you already have a reference to a <span class="code">Currency</span> object. But how do you get the first object of a given <span class="code">Currency</span>? You'd need another creation method, which does essentially the same job as <span class="code">make</span>. So you have a case of code duplication, which is a sure sign of a code smell.</p>
      <p>The solution, of course, is to move the abstract type and the factory method outside class <span class="code">AbstractCurrency</span>. You need to create another class that contains the <span class="code">AbstractCurrency</span> class, the <span class="code">Currency</span> type, and the <span class="code">make</span> factory method.</p>
      <p>We'll call this a <span class="code">CurrencyZone</span>:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">CurrencyZone</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Currency</code>&nbsp;&lt;:&nbsp;<code class="typename">AbstractCurrency</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;make(x:&nbsp;<code class="typename">Long</code>):&nbsp;<code class="typename">Currency</code>
  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;amount:&nbsp;<code class="typename">Long</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation:&nbsp;<code class="typename">String</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;s<code class="quotedstring">"$amount&nbsp;$designation"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Currency</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(<code class="vem">this</code>.amount&nbsp;+&nbsp;that.amount)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(x:&nbsp;<code class="typename">Double</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make((<code class="vem">this</code>.amount&nbsp;*&nbsp;x).toLong)
  &nbsp;&nbsp;}
  }
</pre>
      <p>An example concrete <span class="code">CurrencyZone</span> is the US, which could be defined as:</p> <pre>  <code class="vem">object</code>&nbsp;US&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">CurrencyZone</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Dollar</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation&nbsp;=&nbsp;<code class="quotedstring">"USD"</code>
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;<code class="typename">Dollar</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;make(x:&nbsp;<code class="typename">Long</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Dollar</code>&nbsp;{&nbsp;<code class="vem">val</code>&nbsp;amount&nbsp;=&nbsp;x&nbsp;}
  }
</pre>
      <p>Here, <span class="code">US</span> is an object that extends <span class="code">CurrencyZone</span>. It defines a class <span class="code">Dollar</span>, which is a subclass of <span class="code">AbstractCurrency</span>. So the type of money in this zone is <span class="code">US.Dollar</span>. The <span class="code">US</span> object also fixes the type <span class="code">Currency</span> to be an alias for <span class="code">Dollar</span>, and it gives an implementation of the <span class="code">make</span> factory method to return a dollar amount.</p>
      <p>This is a workable design. There are only a few refinements to be added. The first refinement concerns subunits. So far, every currency was measured in a single unit: dollars, euros, or yen. However, most currencies have subunits: For instance, in the US, it's dollars and cents. The most straightforward way to model cents is to have the <span class="code">amount</span> field in <span class="code">US.Currency</span> represent cents instead of dollars. To convert back to dollars, it's useful to introduce a field <span class="code">CurrencyUnit</span> into class <span class="code">CurrencyZone</span>, which contains the amount of one standard unit in that currency:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">CurrencyZone</code>&nbsp;{
  &nbsp;&nbsp;...&nbsp;
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">CurrencyUnit</code>:&nbsp;<code class="typename">Currency</code>&nbsp;
  }&nbsp;
</pre>
      <p>As shown in <a href="#lst-us-currency-zone">Listing 20.11</a>, The <span class="code">US</span> object could define the quantities <span class="code">Cent</span>, <span class="code">Dollar</span>, and <span class="code">CurrencyUnit</span>. This definition is just like the previous definition of the <span class="code">US</span> object, except that it adds three new fields. The field <span class="code">Cent</span> represents an amount of 1 <span class="code">US.Currency</span>. It's an object analogous to a one-cent coin. The field <span class="code">Dollar</span> represents an amount of 100 <span class="code">US.Currency</span>. So the <span class="code">US</span> object now defines the name <span class="code">Dollar</span> in two ways. The <span style="font-style:italic">type</span> <span class="code">Dollar</span> (defined by the abstract inner class named <span class="code">Dollar</span>) represents the generic name of the <span class="code">Currency</span> valid in the <span class="code">US</span> currency zone. By contrast, the <span style="font-style:italic">value</span> <span class="code">Dollar</span> (referenced from the <span class="code">val</span> field named <span class="code">Dollar</span>) represents a single US dollar, analogous to a one-dollar bill. The third field definition of <span class="code">CurrencyUnit</span> specifies that the standard currency unit in the <span class="code">US</span> zone is the <span class="code">Dollar</span> (<i>i.e.</i>, the value <span class="code">Dollar</span>, referenced from the field, not the type <span class="code">Dollar</span>).</p>
      <p>The <span class="code">toString</span> method in class <span class="code">Currency</span> also needs to be adapted to take subunits into account. For instance, the sum of ten dollars and twenty three cents should print as a decimal number: 10.23 USD. To achieve this, you could implement <span class="code">Currency</span>'s <span class="code">toString</span> method as follows:</p> <pre>  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;
  &nbsp;&nbsp;((amount.toDouble&nbsp;/&nbsp;CurrencyUnit.amount.toDouble)
  &nbsp;&nbsp;&nbsp;formatted&nbsp;(<code class="quotedstring">"<code class="texttt">%</code>."</code>&nbsp;+&nbsp;decimals(CurrencyUnit.amount)&nbsp;+&nbsp;<code class="quotedstring">"f"</code>)
  &nbsp;&nbsp;&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;designation)
</pre>
      <p>Here, <span class="code">formatted</span><a id="i-1143614518-1"></a> is a method that Scala makes available on several classes, including <span class="code">Double</span>.<a href="#footnotemain20-2">[2]</a> The <span class="code">formatted</span> method returns<a id="i1886523229-1"></a><a id="i1659928775-1"></a> the string that results from formatting the original string on which <span class="code">formatted</span> was invoked according to a format string passed as the <span class="code">formatted</span> method's right-hand operand. The syntax of format strings passed to <span class="code">formatted</span> is the same as that of Java's <span class="code">String.format</span> method.</p>
      <p><a id="lst-us-currency-zone"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;US&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">CurrencyZone</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Dollar</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation&nbsp;=&nbsp;<code class="quotedstring">"USD"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;<code class="typename">Dollar</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;make(cents:&nbsp;<code class="typename">Long</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Dollar</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;amount&nbsp;=&nbsp;cents
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Cent</code>&nbsp;=&nbsp;make(<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Dollar</code>&nbsp;=&nbsp;make(<code class="literal">100</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">CurrencyUnit</code>&nbsp;=&nbsp;<code class="typename">Dollar</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.11 - The US currency zone.</h5>
      <p>For instance, the format string <span class="code">%.2f</span> formats a number with two decimal digits. The format string used in the <span class="code">toString</span> shown previously is assembled by calling the <span class="code">decimals</span> method on <span class="code">CurrencyUnit.amount</span>. This method returns the number of decimal digits of a decimal power minus one. For instance, <span class="code">decimals(10)</span> is <span class="code">1</span>, <span class="code">decimals(100)</span> is <span class="code">2</span>, and so on. The <span class="code">decimals</span> method is implemented by a simple recursion:</p> <pre>  <code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;decimals(n:&nbsp;<code class="typename">Long</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;==&nbsp;<code class="literal">1</code>)&nbsp;<code class="literal">0</code>&nbsp;<code class="vem">else</code>&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;decimals(n&nbsp;/&nbsp;<code class="literal">10</code>)
</pre>
      <p><a href="#lst-europe-japan">Listing 20.12</a> shows some other currency zones. As another refinement, you can add a currency conversion feature to the model. First, you could write a <span class="code">Converter</span> object that contains applicable exchange rates between currencies, as shown in <a href="#lst-currency-converter">Listing 20.13</a>. Then, you could add a conversion method, <span class="code">from</span>, to class <span class="code">Currency</span>, which converts from a given source currency into the current <span class="code">Currency</span> object:</p> <pre>  <code class="vem">def</code>&nbsp;from(other:&nbsp;<code class="typename">CurrencyZone</code>#<code class="typename">AbstractCurrency</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;make(math.round(
  &nbsp;&nbsp;&nbsp;&nbsp;other.amount.toDouble&nbsp;*&nbsp;Converter.exchangeRate
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(other.designation)(<code class="vem">this</code>.designation)))
</pre>
      <p>The <span class="code">from</span> method takes an arbitrary currency as argument. This is expressed by its formal parameter type, <span class="code">CurrencyZone#AbstractCurrency</span>, which indicates that the argument passed as <span class="code">other</span> must be an <span class="code">AbstractCurrency</span> type in some arbitrary and unknown <span class="code">CurrencyZone</span>. It produces its result by multiplying the amount of the <span class="code">other</span> currency with the exchange rate between the other and the current currency.<a href="#footnotemain20-3">[3]</a></p>
      <p><a id="lst-europe-japan"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Europe</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">CurrencyZone</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Euro</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation&nbsp;=&nbsp;<code class="quotedstring">"EUR"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;<code class="typename">Euro</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;make(cents:&nbsp;<code class="typename">Long</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Euro</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;amount&nbsp;=&nbsp;cents
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Cent</code>&nbsp;=&nbsp;make(<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Euro</code>&nbsp;=&nbsp;make(<code class="literal">100</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">CurrencyUnit</code>&nbsp;=&nbsp;<code class="typename">Euro</code>
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Japan</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">CurrencyZone</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Yen</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation&nbsp;=&nbsp;<code class="quotedstring">"JPY"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;<code class="typename">Yen</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;make(yen:&nbsp;<code class="typename">Long</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Yen</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;amount&nbsp;=&nbsp;yen
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Yen</code>&nbsp;=&nbsp;make(<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">CurrencyUnit</code>&nbsp;=&nbsp;<code class="typename">Yen</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.12 - Currency zones for Europe and Japan.</h5>
      <p><a id="lst-currency-converter"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Converter</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;exchangeRate&nbsp;=&nbsp;<code class="typename">Map</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"USD"</code>&nbsp;-&gt;&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"USD"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.0</code>&nbsp;&nbsp;&nbsp;,&nbsp;<code class="quotedstring">"EUR"</code>&nbsp;-&gt;&nbsp;<code class="literal">0.7596</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"JPY"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.211</code>&nbsp;,&nbsp;<code class="quotedstring">"CHF"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.223</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"EUR"</code>&nbsp;-&gt;&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"USD"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.316</code>&nbsp;,&nbsp;<code class="quotedstring">"EUR"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.0</code>&nbsp;&nbsp;&nbsp;,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"JPY"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.594</code>&nbsp;,&nbsp;<code class="quotedstring">"CHF"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.623</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"JPY"</code>&nbsp;-&gt;&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"USD"</code>&nbsp;-&gt;&nbsp;<code class="literal">0.8257</code>,&nbsp;<code class="quotedstring">"EUR"</code>&nbsp;-&gt;&nbsp;<code class="literal">0.6272</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"JPY"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.0</code>&nbsp;&nbsp;&nbsp;,&nbsp;<code class="quotedstring">"CHF"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.018</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"CHF"</code>&nbsp;-&gt;&nbsp;<code class="typename">Map</code>(<code class="quotedstring">"USD"</code>&nbsp;-&gt;&nbsp;<code class="literal">0.8108</code>,&nbsp;<code class="quotedstring">"EUR"</code>&nbsp;-&gt;&nbsp;<code class="literal">0.6160</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"JPY"</code>&nbsp;-&gt;&nbsp;<code class="literal">0.982</code>&nbsp;,&nbsp;<code class="quotedstring">"CHF"</code>&nbsp;-&gt;&nbsp;<code class="literal">1.0</code>&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 20.13 - A converter object with an exchange rates map.</h5>
      <p><a id="lst-CurrencyZone"></a></p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">CurrencyZone</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Currency</code>&nbsp;&lt;:&nbsp;<code class="typename">AbstractCurrency</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;make(x:&nbsp;<code class="typename">Long</code>):&nbsp;<code class="typename">Currency</code>
  <br>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">AbstractCurrency</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;amount:&nbsp;<code class="typename">Long</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;designation:&nbsp;<code class="typename">String</code>&nbsp;
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Currency</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(<code class="vem">this</code>.amount&nbsp;+&nbsp;that.amount)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;*&nbsp;(x:&nbsp;<code class="typename">Double</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make((<code class="vem">this</code>.amount&nbsp;*&nbsp;x).toLong)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;-&nbsp;(that:&nbsp;<code class="typename">Currency</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(<code class="vem">this</code>.amount&nbsp;-&nbsp;that.amount)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;/&nbsp;(that:&nbsp;<code class="typename">Double</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make((<code class="vem">this</code>.amount&nbsp;/&nbsp;that).toLong)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;/&nbsp;(that:&nbsp;<code class="typename">Currency</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.amount.toDouble&nbsp;/&nbsp;that.amount
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;from(other:&nbsp;<code class="typename">CurrencyZone</code>#<code class="typename">AbstractCurrency</code>):&nbsp;<code class="typename">Currency</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(math.round(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.amount.toDouble&nbsp;*&nbsp;Converter.exchangeRate
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(other.designation)(<code class="vem">this</code>.designation)))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;decimals(n:&nbsp;<code class="typename">Long</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;==&nbsp;<code class="literal">1</code>)&nbsp;<code class="literal">0</code>&nbsp;<code class="vem">else</code>&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;decimals(n&nbsp;/&nbsp;<code class="literal">10</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((amount.toDouble&nbsp;/&nbsp;CurrencyUnit.amount.toDouble)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatted&nbsp;(<code class="quotedstring">"<code class="texttt">%</code>."</code>&nbsp;+&nbsp;decimals(CurrencyUnit.amount)&nbsp;+&nbsp;<code class="quotedstring">"f"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;"</code>&nbsp;+&nbsp;designation)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">CurrencyUnit</code>:&nbsp;<code class="typename">Currency</code>
  }
</pre>
      <h5>Listing 20.14 - The full code of class <span class="code">CurrencyZone</span>.</h5>
      <p>The final version of the <span class="code">CurrencyZone</span> class is shown in <a href="#lst-CurrencyZone">Listing 20.14</a>. You can test the class in the Scala command shell. We'll assume that the <span class="code">CurrencyZone</span> class and all concrete <span class="code">CurrencyZone</span> objects are defined in a package <span class="code">org.stairwaybook.currencies</span>. The first step is to import "<span class="code">org.stairwaybook.currencies._</span>" into the command shell. Then you can do some currency conversions:</p> <pre>  scala&gt;&nbsp;<code class="typename">Japan.Yen</code>&nbsp;from&nbsp;<code class="typename">US.Dollar</code>&nbsp;*&nbsp;<code class="literal">100</code>
  <code class="output">res16:&nbsp;Japan.Currency&nbsp;=&nbsp;12110&nbsp;JPY</code>
  <br>  scala&gt;&nbsp;<code class="typename">Europe.Euro</code>&nbsp;from&nbsp;res16
  <code class="output">res17:&nbsp;Europe.Currency&nbsp;=&nbsp;75.95&nbsp;EUR</code>
  <br>  scala&gt;&nbsp;<code class="typename">US.Dollar</code>&nbsp;from&nbsp;res17
  <code class="output">res18:&nbsp;US.Currency&nbsp;=&nbsp;99.95&nbsp;USD</code>
</pre>
      <p>The fact that we obtain almost the same amount after three conversions implies that these are some pretty good exchange rates! You can also add up values of the same currency:</p> <pre>  scala&gt;&nbsp;<code class="typename">US.Dollar</code>&nbsp;*&nbsp;<code class="literal">100</code>&nbsp;+&nbsp;res18
  <code class="output">res19:&nbsp;US.Currency&nbsp;=&nbsp;199.95&nbsp;USD</code>
</pre>
      <p>On the other hand, you cannot add amounts of different currencies:<a id="i-677980410-6"></a></p> <pre>  scala&gt;&nbsp;<code class="typename">US.Dollar</code>&nbsp;+&nbsp;<code class="typename">Europe.Euro</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Europe.Euro</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required:&nbsp;US.Currency</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(which&nbsp;expands&nbsp;to)&nbsp;&nbsp;US.Dollar</code>
</pre>
      <p>By preventing the addition of two values with different units (in this case, currencies), the type abstraction has done its job. It prevents us from performing calculations that are unsound. Failures to convert correctly between different units may seem like trivial bugs, but they have caused many serious systems faults. An example is the crash of the Mars Climate Orbiter spacecraft on September 23, 1999, which was caused because one engineering team used metric units while another used English units. If units had been coded in the same way as currencies are coded in this chapter, this error would have been detected by a simple compilation run. Instead, it caused the crash of the orbiter after a near ten-month voyage.</p>
      <h3>20.11 Conclusion</h3>
      <p>Scala offers systematic and very general support for object-oriented abstraction. It enables you to not only abstract over methods, but also over values, variables, and types. This chapter has shown how to take advantage of abstract members. They support a simple yet effective principle for systems structuring: when designing a class, make everything that is not yet known into an abstract member. The type system will then drive the development of your model, just as you saw with the currency case study. It does not matter whether the unknown is a type, method, variable or value. In Scala, all of these can be declared abstract.</p>
      <hr>
      <h4>Footnotes for Chapter 20:</h4>
      <p><a id="footnotemain20-1"></a>[1] There's some promising recent research on <span style="font-style:italic">virtual classes</span>,<a id="i439466001-1"></a><a id="i1629420471-1"></a> which would allow this, but virtual classes are not currently supported in Scala.</p>
      <p><a id="footnotemain20-2"></a>[2] Scala uses rich wrappers, described in <a href="#sec-rich-wrappers">Section 5.10</a>, to make <span class="code">formatted</span> available.</p>
      <p><a id="footnotemain20-3"></a>[3] By the way, in case you think you're getting a bad deal on Japanese yen, the exchange rates convert currencies based on their <span class="code">CurrencyZone</span> amounts. Thus, 1.211 is the exchange rate between US cents and Japanese yen.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-implicit-conversions-and-parameters">Chapter 21</a></h2>
      <h1>Implicit Conversions and Parameters</h1>
      <p>There's a fundamental difference between your own code and other people's libraries: You can change or extend your own code as you wish, but if you want to use someone else's libraries, you usually have to take them as they are. A number of constructs have sprung up in programming languages to alleviate this problem. Ruby<a id="i-1999895874-3"></a> has modules, and Smalltalk<a id="i-817657147-2"></a> lets packages add to each other's classes. These are very powerful but also dangerous, in that you can modify the behavior of a class for an entire application, some parts of which you might not know. C# 3.0 has static extension methods<a id="i1246302635-1"></a>, which are more local but also more restrictive, in that you can only add methods, not fields, to a class, and you can't make a class implement new interfaces.</p>
      <p>Scala's answer is implicit conversions and parameters.<a id="i-174456078-1"></a><a id="i-1068906551-2"></a> These can make existing libraries much more pleasant to deal with by letting you leave out tedious, obvious details that obscure the interesting parts of your code. Used tastefully, this results in code that is focused on the interesting, non-trivial parts of your program. This chapter shows you how implicits work, and it presents some of the most common ways they are used.</p>
      <h3 id="sec-implicit-conversions">21.1 Implicit conversions</h3>
      <p>Before delving into the details of implicit conversions, take a look at a typical example of their use. Implicit conversions are often helpful for working with two bodies of software that were developed without each other in mind. Each library has its own way to encode a concept that is essentially the same thing. Implicit conversions help by reducing the number of explicit conversions that are needed from one type to another.</p>
      <p>Java includes a library named Swing for implementing cross-platform user interfaces. One of the things Swing does is process events from the operating system, convert them to platform-independent event objects, and pass those events to parts of an application called event listeners.</p>
      <p>If Swing had been written with Scala in mind, event listeners would probably have been represented by a function type. Callers could then use the function literal syntax as a lightweight way to specify what should happen for a certain class of events. Since Java doesn't have function literals, Swing uses the next best thing, an inner class that implements a one-method interface. In the case of action listeners, the interface is <span class="code">ActionListener</span>.</p>
      <p>Without the use of implicit conversions, a Scala program that uses Swing must use inner classes just like in Java. Here's an example that creates a button and hooks up an action listener to it. The action listener is invoked whenever the button is pressed, at which point it prints the string <span class="code">"pressed!"</span>:</p> <pre>  <code class="vem">val</code>&nbsp;button&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">JButton</code>
  button.addActionListener(
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ActionListener</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;actionPerformed(event:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"pressed!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  )
</pre>
      <p>This code has a lot of information-free boilerplate. The fact that this listener is an <span class="code">ActionListener</span>, the fact that the callback method is named <span class="code">actionPerformed</span>, and the fact that the argument is an <span class="code">ActionEvent</span> are all implied for any argument to <span class="code">addActionListener</span>. The only new information here is the code to be performed, namely the call to <span class="code">println</span>. This new information is drowned out by the boilerplate. Someone reading this code will need to have an eagle's eye to pick through the noise and find the informative part.</p>
      <p>A more Scala-friendly version would take a function as an argument, greatly reducing the amount of boilerplate:</p> <pre>  button.addActionListener(&nbsp;<code class="comment">//&nbsp;Type&nbsp;mismatch!</code>
  &nbsp;&nbsp;(_:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"pressed!"</code>)
  )
</pre>
      <p>As written so far, this code doesn't work.<a href="#footnotemain21-1">[1]</a> The <span class="code">addActionListener</span> method wants an action listener but is getting a function. With implicit conversions, however, this code can be made to work.</p>
      <p>The first step is to write an implicit conversion between the two types. Here is an implicit conversion from functions to action listeners:</p> <pre>  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;function2ActionListener(f:&nbsp;<code class="typename">ActionEvent</code>&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ActionListener</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;actionPerformed(event:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&nbsp;f(event)
  &nbsp;&nbsp;}
</pre>
      <p>This is a one-argument method that takes a function and returns an action listener. Like any other one-argument method, it can be called directly and have its result passed on to another expression:</p> <pre>  button.addActionListener(
  &nbsp;&nbsp;function2ActionListener(
  &nbsp;&nbsp;&nbsp;&nbsp;(_:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"pressed!"</code>)
  &nbsp;&nbsp;)
  )
</pre>
      <p>This is already an improvement on the version with the inner class. Note how arbitrary amounts of boilerplate end up replaced by a function literal and a call to a method. It gets better, though, with implicit conversions. Because <span class="code">function2ActionListener</span> is marked as implicit, it can be left out and the compiler will insert it automatically. Here is the result:</p> <pre>  <code class="comment">//&nbsp;Now&nbsp;this&nbsp;works</code>
  button.addActionListener(
  &nbsp;&nbsp;(_:&nbsp;<code class="typename">ActionEvent</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"pressed!"</code>)
  )
</pre>
      <p>The way this code works is that the compiler first tries to compile it as is, but it sees a type error. Before giving up, it looks for an implicit conversion that can repair the problem. In this case, it finds <span class="code">function2ActionListener</span>. It tries that conversion method, sees that it works, and moves on. The compiler works hard here so that the developer can ignore one more fiddly detail. Action listener? Action event function? Either one will work—use the one that's more convenient.</p>
      <p>In this section, we illustrated some of the power of implicit conversions and how they let you dress up existing libraries. In the next sections, you'll learn the rules that determine when implicit conversions are tried and how they are found.</p>
      <h3 id="sec-rules-for-implicits">21.2 Rules for implicits</h3>
      <p>Implicit definitions are those that the compiler is allowed to insert into a program in order to fix any of its type errors. For example, if <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span> does not type check, then the compiler might change it to <span class="code">convert(x)</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span>, where <span class="code">convert</span> is some available implicit conversion. If <span class="code">convert</span> changes <span class="code">x</span> into something that has a <span class="code">+</span> method, then this change might fix a program so that it type checks and runs correctly. If <span class="code">convert</span> really is just a simple conversion function, then leaving it out of the source code can be a clarification.</p>
      <p>Implicit conversions are governed by the following general rules:</p>
      <p><b>Marking rule: Only definitions marked <span class="code">implicit</span> are available.</b> The <span class="code">implicit</span> keyword is used to mark which declarations the compiler may use as implicits. You can use it to mark any variable, function, or object definition. Here's an example of an implicit function definition:<a href="#footnotemain21-2">[2]</a></p> <pre>  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToString(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;x.toString
</pre>
      <p>The compiler will only change <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span> to <span class="code">convert(x)</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span> if <span class="code">convert</span> is marked as <span class="code">implicit</span>. This way, you avoid the confusion that would result if the compiler picked random functions that happen to be in scope and inserted them as "conversions." The compiler will only select among the definitions you have explicitly marked as implicit.</p>
      <p><b>Scope rule: An inserted implicit conversion must be in scope as a single identifier, or be associated with the source or target type of the conversion.</b> The Scala compiler will only consider implicit conversions that are in scope.<a id="i1011304421-1"></a> To make an implicit conversion available, therefore, you must in some way bring it into scope. Moreover, with one exception, the implicit conversion must be in scope <em>as a single identifier</em>. The compiler will not insert a conversion of the form <span class="code">someVariable.convert</span>. For example, it will not expand <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span> to <span class="code">someVariable.convert(x)</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span>. If you want to make <span class="code">someVariable.convert</span> available as an implicit, you would need to import it, which would make it available as a single identifier. Once imported, the compiler would be free to apply it as <span class="code">convert(x)</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span>. In fact, it is common for libraries to include a <span class="code">Preamble</span> object including a number of useful implicit conversions. Code that uses the library can then do a single "<span class="code">import</span>&nbsp;<span class="code">Preamble._</span>" to access the library's implicit conversions.</p>
      <p>There's one exception to the "single identifier" rule. The compiler will also look for implicit definitions in the companion object of the source or expected target types of the conversion<a id="i1755659460-1"></a>. For example, if you're attempting to pass a <span class="code">Dollar</span> object to a method that takes a <span class="code">Euro</span>, the source type is <span class="code">Dollar</span> and the target type is <span class="code">Euro</span>. You could, therefore, package an implicit conversion from <span class="code">Dollar</span> to <span class="code">Euro</span> in the companion object of either class, <span class="code">Dollar</span> or <span class="code">Euro</span>.</p>
      <p>Here's an example in which the implicit definition is placed in <span class="code">Dollar</span>'s companion object:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Dollar</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;dollarToEuro(x:&nbsp;<code class="typename">Dollar</code>):&nbsp;<code class="typename">Euro</code>&nbsp;=&nbsp;...
  }
  <code class="vem">class</code>&nbsp;<code class="typename">Dollar</code>&nbsp;{&nbsp;...&nbsp;}
</pre>
      <p>In this case, the conversion <span class="code">dollarToEuro</span> is said to be <span style="font-style:italic">associated</span> to the type <span class="code">Dollar</span>. The compiler will find such an associated conversion every time it needs to convert from an instance of type <span class="code">Dollar</span>. There's no need to import the conversion separately into your program.</p>
      <p>The Scope Rule helps with modular reasoning. When you read code in a file, the only things you need to consider from other files are those that are either imported or are explicitly referenced through a fully qualified name. This benefit is at least as important for implicits as for explicitly written code. If implicits took effect system-wide, then to understand a file you would have to know about every implicit introduced anywhere in the program!</p>
      <p><b>One-at-a-time rule: Only one implicit is inserted.</b> The compiler will never rewrite <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span> to <span class="code">convert1(convert2(x))</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span>. Doing so would cause compile times to increase dramatically on erroneous code, and it would increase the difference between what the programmer writes and what the program actually does. For sanity's sake, the compiler does not insert further implicit conversions when it is already in the middle of trying another implicit. However, it's possible to circumvent this restriction by having implicits take implicit parameters, which will be described later in this chapter<a id="i-568821387-2"></a>.</p>
      <p><b>Explicits-first rule: Whenever code type checks as it is written, no implicits are attempted.</b> The compiler will not change code that already works. A corollary of this rule is that you can always replace implicit identifiers by explicit ones, thus making the code longer but with less apparent ambiguity. You can trade between these choices on a case-by-case basis. Whenever you see code that seems repetitive and verbose, implicit conversions can help you decrease the tedium. Whenever code seems terse to the point of obscurity, you can insert conversions explicitly. The amount of implicits you leave the compiler to insert is ultimately a matter of style.</p>
      <h4>Naming an implicit conversion</h4>
      <p>Implicit conversions can have arbitrary names. The name of an implicit conversion matters only in two situations: If you want to write it explicitly in a method application and for determining which implicit conversions are available at any place in the program. To illustrate the second point, say you have an object with two implicit conversions:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">MyConversions</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;stringWrapper(s:&nbsp;<code class="typename">String</code>):
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">IndexedSeq[Char]</code>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToString(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;...
  }
</pre>
      <p>In your application, you want to make use of the <span class="code">stringWrapper</span> conversion, but you don't want integers to be converted automatically to strings by means of the <span class="code">intToString</span> conversion. You can achieve this by importing only one conversion, but not the other:</p> <pre>  <code class="vem">import</code>&nbsp;MyConversions.stringWrapper
  ...&nbsp;<code class="comment">//&nbsp;code&nbsp;making&nbsp;use&nbsp;of&nbsp;stringWrapper</code>
</pre>
      <p>In this example, it was important that the implicit conversions had names, because only that way could you selectively import one and not the other.</p>
      <h4>Where implicits are tried</h4>
      <p>There are three places implicits are used in the language: conversions to an expected type, conversions of the receiver of a selection, and implicit parameters. Implicit conversions to an expected type let you use one type in a context where a different type is expected. For example, you might have a <span class="code">String</span> and want to pass it to a method that requires an <span class="code">IndexedSeq[Char]</span>. Conversions of the receiver let you adapt the receiver of a method call (<i>i.e.</i>, the object on which a method is invoked), if the method is not applicable on the original type. An example is <span class="code">"abc".exists</span>, which is converted to <span class="code">stringWrapper("abc").exists</span> because the <span class="code">exists</span> method is not available on <span class="code">String</span>s but is available on <span class="code">IndexedSeq</span>s. Implicit parameters, on the other hand, are usually used to provide more information to the called function about what the caller wants. Implicit parameters are especially useful with generic functions, where the called function might otherwise know nothing at all about the type of one or more arguments. We will examine each of these three kinds of implicits in the next sections.</p>
      <h3>21.3 Implicit conversion to an expected type</h3>
      <p>Implicit conversion to an expected type is the first place the compiler will use implicits. The rule is simple. Whenever the compiler sees an X, but needs a Y, it will look for an implicit function that converts X to Y. For example, normally a double cannot be used as an integer because it loses precision:<a id="i-677980410-7"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;i:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="literal">3.5</code>
  <code class="output">&lt;console&gt;:7:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Double(3.5)</code>
  <code class="output">&nbsp;required:&nbsp;Int</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;i:&nbsp;Int&nbsp;=&nbsp;3.5</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>However, you can define an implicit conversion to smooth this over:</p> <pre>  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;doubleToInt(x:&nbsp;<code class="typename">Double</code>)&nbsp;=&nbsp;x.toInt
  <code class="output">doubleToInt:&nbsp;(x:&nbsp;Double)Int</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;i:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="literal">3.5</code>
  <code class="output">i:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <p>What happens here is that the compiler sees a <span class="code">Double</span>, specifically <span class="code">3.5</span>, in a context where it requires an <span class="code">Int</span>. So far, the compiler is looking at an ordinary type error. Before giving up, though, it searches for an implicit conversion from <span class="code">Double</span> to <span class="code">Int</span>. In this case, it finds one: <span class="code">doubleToInt</span>, because <span class="code">doubleToInt</span> is in scope as a single identifier. (Outside the interpreter, you might bring <span class="code">doubleToInt</span> into scope via an <span class="code">import</span> or possibly through inheritance.) The compiler then inserts a call to <span class="code">doubleToInt</span> automatically. Behind the scenes, the code becomes:</p> <pre>  <code class="vem">val</code>&nbsp;i:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;doubleToInt(<code class="literal">3.5</code>)
</pre>
      <p>This is literally an <em>implicit</em> conversion. You did not explicitly ask for conversion. Instead, you marked <span class="code">doubleToInt</span> as an available implicit conversion by bringing it into scope as a single identifier, and then the compiler automatically used it when it needed to convert from a <span class="code">Double</span> to an <span class="code">Int</span>.</p>
      <p>Converting <span class="code">Double</span>s to <span class="code">Int</span>s might raise some eyebrows because, it's a dubious idea to have something that causes a loss in precision happen invisibly. So this is not really a conversion we recommend. It makes much more sense to go the other way, from some more constrained type to a more general one. For instance, an <span class="code">Int</span> can be converted without loss of precision to a <span class="code">Double</span>, so an implicit conversion from <span class="code">Int</span> to <span class="code">Double</span> makes sense. In fact, that's exactly what happens. The <span class="code">scala.Predef</span> object, which is implicitly imported into every Scala program, defines implicit conversions that convert "smaller" numeric types to "larger" ones. For instance, you will find in <span class="code">Predef</span> the following conversion:</p> <pre>  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;int2double(x:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;x.toDouble
</pre>
      <p>That's why in Scala <span class="code">Int</span> values can be stored in variables of type <span class="code">Double</span>. There's no special rule in the type system for this; it's just an implicit conversion that gets applied.<a href="#footnotemain21-3">[3]</a></p>
      <h3>21.4 Converting the receiver</h3>
      <p>Implicit conversions also apply to the receiver of a method call, the object on which the method is invoked. This kind of implicit conversion has two main uses. First, receiver conversions allow smoother integration of a new class into an existing class hierarchy. And second, they support writing domain-specific languages (DSLs) within the language.<a id="i49254319-1"></a></p>
      <p>To see how it works, suppose you write down <span class="code">obj.doIt</span>, and <span class="code">obj</span> does not have a member named <span class="code">doIt</span>. The compiler will try to insert conversions before giving up. In this case, the conversion needs to apply to the receiver, <span class="code">obj</span>. The compiler will act as if the expected "type" of <span class="code">obj</span> was "has a member named <span class="code">doIt</span>." This "has a <span class="code">doIt</span>" type is not a normal Scala type, but it is there conceptually and is why the compiler will insert an implicit conversion in this case.</p>
      <h4>Interoperating with new types</h4>
      <p>As mentioned previously, one major use of receiver conversions is allowing smoother integration of new types with existing types. In particular, they allow you to enable client programmers to use instances of existing types as if they were instances of your new type. Take, for example, class <span class="code">Rational</span> shown in <a href="#lst-overloaded-methods">Listing 6.5</a> <a href="#lst-overloaded-methods">here</a>. Here's a snippet of that class again:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;...
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Rational</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;+&nbsp;(that:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Rational</code>&nbsp;=&nbsp;...
  }
</pre>
      <p>Class <span class="code">Rational</span> has two overloaded variants of the <span class="code">+</span> method, which take <span class="code">Rational</span>s and <span class="code">Int</span>s, respectively, as arguments. So you can either add two rational numbers or a rational number and an integer:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;oneHalf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">oneHalf:&nbsp;Rational&nbsp;=&nbsp;1/2</code>
  <br>  scala&gt;&nbsp;oneHalf&nbsp;+&nbsp;oneHalf
  <code class="output">res0:&nbsp;Rational&nbsp;=&nbsp;1/1</code>
  <br>  scala&gt;&nbsp;oneHalf&nbsp;+&nbsp;<code class="literal">1</code>
  <code class="output">res1:&nbsp;Rational&nbsp;=&nbsp;3/2</code>
</pre>
      <p>What about an expression like <span class="code">1</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">oneHalf</span>? This expression is tricky because the receiver, <span class="code">1</span>, does not have a suitable <span class="code">+</span> method. So the following gives an error:<a id="i1859455133-1"></a></p> <pre>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;oneHalf
  <code class="output">&lt;console&gt;:6:&nbsp;error:&nbsp;overloaded&nbsp;method&nbsp;value&nbsp;+&nbsp;with</code>
  <code class="output">alternatives&nbsp;(Double)Double&nbsp;&lt;and&gt;&nbsp;...&nbsp;cannot&nbsp;be&nbsp;applied</code>
  <code class="output">to&nbsp;(Rational)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+&nbsp;oneHalf</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>To allow this kind of mixed arithmetic, you need to define an implicit conversion from <span class="code">Int</span> to <span class="code">Rational</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToRational(x:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Rational</code>(x,&nbsp;<code class="literal">1</code>)
  <code class="output">intToRational:&nbsp;(x:&nbsp;Int)Rational</code>
</pre>
      <p>With the conversion in place, converting the receiver does the trick:</p> <pre>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;oneHalf
  <code class="output">res2:&nbsp;Rational&nbsp;=&nbsp;3/2</code>
</pre>
      <p>What happens behind the scenes here is that the Scala compiler first tries to type check the expression <span class="code">1</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">oneHalf</span> as it is. This fails because <span class="code">Int</span> has several <span class="code">+</span> methods, but none that takes a <span class="code">Rational</span> argument. Next, the compiler searches for an implicit conversion from <span class="code">Int</span> to another type that has a <span class="code">+</span> method which can be applied to a <span class="code">Rational</span>. It finds your conversion and applies it, which yields:</p> <pre>  intToRational(<code class="literal">1</code>)&nbsp;+&nbsp;oneHalf
</pre>
      <p>In this case, the compiler found the implicit conversion function because you entered its definition into the interpreter, which brought it into scope for the remainder of the interpreter session.</p>
      <h4>Simulating new syntax</h4>
      <p><a id="sec-simulating-new-syntax"></a></p>
      <p>The other major use of implicit conversions is to simulate adding new syntax. Recall that you can make a <span class="code">Map</span> using syntax like this:</p> <pre>  <code class="typename">Map</code>(<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"one"</code>,&nbsp;<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"two"</code>,&nbsp;<code class="literal">3</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"three"</code>)
</pre>
      <p>Have you wondered how the <span class="code">-&gt;</span> is supported?<a id="i483527409-1"></a> It's not syntax! Instead, <span class="code">-&gt;</span> is a method of the class <span class="code">ArrowAssoc</span>, a class defined inside the standard Scala preamble (<span class="code">scala.Predef</span>). The preamble also defines an implicit conversion from <span class="code">Any</span> to <span class="code">ArrowAssoc</span>. When you write <span class="code">1</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">"one"</span>, the compiler inserts a conversion from <span class="code">1</span> to <span class="code">ArrowAssoc</span> so that the <span class="code">-&gt;</span> method can be found. Here are the relevant definitions:</p> <pre>  <code class="vem">package</code>&nbsp;scala
  <code class="vem">object</code>&nbsp;<code class="typename">Predef</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ArrowAssoc[A]</code>(x:&nbsp;A)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;-&gt;&nbsp;[B](y:&nbsp;B):&nbsp;<code class="typename">Tuple2[A,&nbsp;B]</code>&nbsp;=&nbsp;<code class="typename">Tuple2</code>(x,&nbsp;y)
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;any2ArrowAssoc[A](x:&nbsp;A):&nbsp;<code class="typename">ArrowAssoc[A]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ArrowAssoc</code>(x)
  &nbsp;&nbsp;...
  }
</pre>
      <p>This "rich wrappers" pattern is common in libraries that provide syntax-like extensions to the language, so you should be ready to recognize the pattern when you see it.<a id="i807731316-2"></a><a id="i681737575-2"></a> Whenever you see someone calling methods that appear not to exist in the receiver class, they are probably using implicits. Similarly, if you see a class named <span class="code">RichSomething</span> (<i>e.g.</i>, <span class="code">RichInt</span> or <span class="code">RichBoolean</span>), that class is likely adding syntax-like methods to type <span class="code">Something</span>.</p>
      <p>You have already seen this rich wrappers pattern for the basic types described in <a href="#chap-basic-types-and-operations">Chapter 5</a>. As you can now see, these rich wrappers apply more widely, often letting you get by with an internal DSL defined as a library where programmers in other languages might feel the need to develop an external DSL.<a id="i367427817-1"></a></p>
      <h4>Implicit classes</h4>
      <p>Implicit classes<a id="i-1972624620-1"></a><a id="i-2080002837-1"></a><a id="i1275741881-1"></a> were added in Scala 2.10 to make it easier to write rich wrapper classes. An implicit class is a class that is preceded by the <span class="code">implicit</span> keyword. For any such class, the compiler generates an implicit conversion from the class's constructor parameter to the class itself. Such a conversion is just what you need if you plan to use the class for the rich wrappers pattern.</p>
      <p>For example, suppose you have a class named <span class="code">Rectangle</span> for representing the width and height of a rectangle on the screen:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rectangle</code>(width:&nbsp;<code class="typename">Int</code>,&nbsp;height:&nbsp;<code class="typename">Int</code>)
</pre>
      <p>If you use this class very frequently, you might want to use the rich wrappers pattern so you can more easily construct it. Here's one way to do so.</p> <pre>  <code class="vem">implicit</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">RectangleMaker</code>(width:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;x(height:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="typename">Rectangle</code>(width,&nbsp;height)
  }
</pre>
      <p>The above definition defines a <span class="code">RectangleMaker</span> class in the usual manner. In addition, it causes the following conversion to be automatically generated:</p> <pre>  <code class="comment">//&nbsp;Automatically&nbsp;generated</code>
  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;<code class="typename">RectangleMaker</code>(width:&nbsp;<code class="typename">Int</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">RectangleMaker</code>(width)
</pre>
      <p>As a result, you can create points by putting an <span class="code">x</span> in between two integers:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;myRectangle&nbsp;=&nbsp;<code class="literal">3</code>&nbsp;x&nbsp;<code class="literal">4</code>
  <code class="output">&nbsp;&nbsp;myRectangle:&nbsp;Rectangle&nbsp;=&nbsp;Rectangle(3,4)</code>
</pre>
      <p>This is how it works: Since type <span class="code">Int</span> has no method named <span class="code">x</span>, the compiler will look for an implicit conversion from <span class="code">Int</span> to something that does. It will find the generated <span class="code">RectangleMaker</span> conversion, and <span class="code">RectangleMaker</span> does have a method named <span class="code">x</span>. The compiler inserts a call to this conversion, after which the call to <span class="code">x</span> type checks and does what is desired.</p>
      <p>As a warning to the adventurous, it might be tempting to think that any class can have <span class="code">implicit</span> put in front of it. It's not so. An implicit class cannot be a case class, and its constructor must have exactly one parameter. Also, an implicit class must be located within some other object, class, or trait. In practice, so long as you use implicit classes as rich wrappers to add a few methods onto an existing class, these restrictions should not matter.</p>
      <h3>21.5 Implicit parameters</h3>
      <p>The remaining place the compiler inserts implicits is within argument lists.<a id="i-568821387-3"></a><a id="i-1127720187-1"></a> The compiler will sometimes replace <span class="code">someCall(a)</span> with <span class="code">someCall(a)(b)</span>, or <span class="code">new</span>&nbsp;<span class="code">SomeClass(a)</span> with <span class="code">new</span>&nbsp;<span class="code">SomeClass(a)(b)</span>, thereby adding a missing parameter list to complete a function call. It is the entire last curried parameter list that's supplied, not just the last parameter. For example, if <span class="code">someCall</span>'s missing last parameter list takes three parameters, the compiler might replace <span class="code">someCall(a)</span> with <span class="code">someCall(a)(b,</span>&nbsp;<span class="code">c,</span>&nbsp;<span class="code">d)</span>. For this usage, not only must the inserted identifiers, such as <span class="code">b</span>, <span class="code">c</span>, and <span class="code">d</span> in <span class="code">(b,</span>&nbsp;<span class="code">c,</span>&nbsp;<span class="code">d)</span>, be marked <span class="code">implicit</span> where they are defined, but also the last parameter list in <span class="code">someCall</span>'s or <span class="code">someClass</span>'s definition must be marked <span class="code">implicit</span>.</p>
      <p>Here's a simple example. Suppose you have a class <span class="code">PreferredPrompt</span>, which encapsulates a shell prompt string (such as, say <span class="code">"$</span>&nbsp;<span class="code">"</span> or <span class="code">"&gt;</span>&nbsp;<span class="code">"</span>) that is preferred by a user:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="vem">val</code>&nbsp;preference:&nbsp;<code class="typename">String</code>)
</pre>
      <p>Also, suppose you have a <span class="code">Greeter</span> object with a <span class="code">greet</span> method, which takes two parameter lists. The first parameter list takes a string user name, and the second parameter list takes a <span class="code">PreferredPrompt</span>:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Greeter</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;greet(name:&nbsp;<code class="typename">String</code>)(<code class="vem">implicit</code>&nbsp;prompt:&nbsp;<code class="typename">PreferredPrompt</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Welcome,&nbsp;"</code>&nbsp;+&nbsp;name&nbsp;+&nbsp;<code class="quotedstring">".&nbsp;The&nbsp;system&nbsp;is&nbsp;ready."</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;println(prompt.preference)
  &nbsp;&nbsp;}
  }
</pre>
      <p>The last parameter list is marked <span class="code">implicit</span>, which means it can be supplied implicitly. But you can still provide the <span class="code">prompt</span> explicitly, like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bobsPrompt&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="quotedstring">"relax&gt;&nbsp;"</code>)
  <code class="output">bobsPrompt:&nbsp;PreferredPrompt&nbsp;=&nbsp;PreferredPrompt@714d36d6</code>
  <br>  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Bob"</code>)(bobsPrompt)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">Welcome,&nbsp;Bob.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</code>
  <code class="output">relax&gt;&nbsp;</code>
</pre>
      <p>To let the compiler supply the parameter implicitly, you must first define a variable of the expected type, which in this case is <span class="code">PreferredPrompt</span>. You could do this, for example, in a preferences object:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">JoesPrefs</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">val</code>&nbsp;prompt&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="quotedstring">"Yes,&nbsp;master&gt;&nbsp;"</code>)
  }
</pre>
      <p>Note that the <span class="code">val</span> itself is marked implicit. If it wasn't, the compiler would not use it to supply the missing parameter list. It will also not use it if it isn't in scope as a single identifier, as shown in this example:<a id="i-1437022486-1"></a></p> <pre>  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)
  <code class="output">&lt;console&gt;:13:&nbsp;error:&nbsp;could&nbsp;not&nbsp;find&nbsp;implicit&nbsp;value&nbsp;for&nbsp;</code>
  <code class="output">parameter&nbsp;prompt:&nbsp;PreferredPrompt</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greeter.greet("Joe")</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>Once you bring it into scope via an import, however, it will be used to supply the missing parameter list:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;JoesPrefs._&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">import&nbsp;JoesPrefs._</code>
  <br>  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)
  <code class="output">Welcome,&nbsp;Joe.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</code>
  <code class="output">Yes,&nbsp;master&gt;&nbsp;</code>
</pre>
      <p>Note that the <span class="code">implicit</span> keyword applies to an entire parameter list, not to individual parameters. <a href="#lst-multiple-implicit-params">Listing 21.1</a> shows an example in which the last parameter list of <span class="code">Greeter</span>'s <span class="code">greet</span> method, which is again marked <span class="code">implicit</span>, has two parameters: <span class="code">prompt</span> (of type <span class="code">PreferredPrompt</span>) and <span class="code">drink</span> (of type <span class="code">PreferredDrink</span>).</p>
      <p>Singleton object <span class="code">JoesPrefs</span> declares two implicit <span class="code">val</span>s, <span class="code">prompt</span> of type <span class="code">PreferredPrompt</span> and <span class="code">drink</span> of type <span class="code">PreferredDrink</span>. As before, however, so long as these are not in scope as single identifiers, they won't be used to fill in a missing parameter list to <span class="code">greet</span>:<a id="i-1437022486-2"></a></p> <pre>  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)&nbsp;
  <code class="output">&lt;console&gt;:19:&nbsp;error:&nbsp;could&nbsp;not&nbsp;find&nbsp;implicit&nbsp;value&nbsp;for&nbsp;</code>
  <code class="output">parameter&nbsp;prompt:&nbsp;PreferredPrompt</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greeter.greet("Joe")</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>You can bring both implicit <span class="code">val</span>s into scope with an import:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;JoesPrefs._
  <code class="output">import&nbsp;JoesPrefs._</code>
</pre>
      <p>Because both <span class="code">prompt</span> and <span class="code">drink</span> are now in scope as single identifiers, you can use them to supply the last parameter list explicitly, like this:</p> <pre>  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)(prompt,&nbsp;drink)
  <code class="output">Welcome,&nbsp;Joe.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</code>
  <code class="output">But&nbsp;while&nbsp;you&nbsp;work,&nbsp;why&nbsp;not&nbsp;enjoy&nbsp;a&nbsp;cup&nbsp;of&nbsp;tea?</code>
  <code class="output">Yes,&nbsp;master&gt;&nbsp;</code>
</pre>
      <p>And because all the rules for implicit parameters are now met, you can alternatively let the Scala compiler supply <span class="code">prompt</span> and <span class="code">drink</span> for you by leaving off the last parameter list:</p> <pre>  scala&gt;&nbsp;Greeter.greet(<code class="quotedstring">"Joe"</code>)
  <code class="output">Welcome,&nbsp;Joe.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</code>
  <code class="output">But&nbsp;while&nbsp;you&nbsp;work,&nbsp;why&nbsp;not&nbsp;enjoy&nbsp;a&nbsp;cup&nbsp;of&nbsp;tea?</code>
  <code class="output">Yes,&nbsp;master&gt;&nbsp;</code>
</pre>
      <p><a id="lst-multiple-implicit-params"></a></p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="vem">val</code>&nbsp;preference:&nbsp;<code class="typename">String</code>)
  <code class="vem">class</code>&nbsp;<code class="typename">PreferredDrink</code>(<code class="vem">val</code>&nbsp;preference:&nbsp;<code class="typename">String</code>)
  <br>  <code class="vem">object</code>&nbsp;<code class="typename">Greeter</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;greet(name:&nbsp;<code class="typename">String</code>)(<code class="vem">implicit</code>&nbsp;prompt:&nbsp;<code class="typename">PreferredPrompt</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drink:&nbsp;<code class="typename">PreferredDrink</code>)&nbsp;=&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Welcome,&nbsp;"</code>&nbsp;+&nbsp;name&nbsp;+&nbsp;<code class="quotedstring">".&nbsp;The&nbsp;system&nbsp;is&nbsp;ready."</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">"But&nbsp;while&nbsp;you&nbsp;work,&nbsp;"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"why&nbsp;not&nbsp;enjoy&nbsp;a&nbsp;cup&nbsp;of&nbsp;"</code>&nbsp;+&nbsp;drink.preference&nbsp;+&nbsp;<code class="quotedstring">"?"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;println(prompt.preference)
  &nbsp;&nbsp;}
  }
  <br>  <code class="vem">object</code>&nbsp;<code class="typename">JoesPrefs</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">val</code>&nbsp;prompt&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredPrompt</code>(<code class="quotedstring">"Yes,&nbsp;master&gt;&nbsp;"</code>)
  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">val</code>&nbsp;drink&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredDrink</code>(<code class="quotedstring">"tea"</code>)
  }
</pre>
      <h5>Listing 21.1 - An implicit parameter list with multiple parameters.</h5>
      <p>One thing to note about the previous examples is that we didn't use <span class="code">String</span> as the type of <span class="code">prompt</span> or <span class="code">drink</span>, even though ultimately it was a <span class="code">String</span> that each of them provided through their <span class="code">preference</span> fields. Because the compiler selects implicit parameters by matching types of parameters against types of values in scope, implicit parameters usually have "rare" or "special" enough types that accidental matches are unlikely. For example, the types <span class="code">PreferredPrompt</span> and <span class="code">PreferredDrink</span> in <a href="#lst-multiple-implicit-params">Listing 21.1</a> were defined solely to serve as implicit parameter types. As a result, it is unlikely that implicit variables of these types will be in scope if they aren't intended to be used as implicit parameters to <span class="code">Greeter.greet</span>.</p>
      <p>Another thing to know about implicit parameters is that they are perhaps most often used to provide information about a type mentioned <em>explicitly</em> in an earlier parameter list, similar to the type classes of Haskell.</p>
      <p>As an example, consider the <span class="code">maxListOrdering</span> function shown in <a href="#lst-max-list-take-one">Listing 21.2</a>, which returns the maximum element of the passed list.</p>
      <p><a id="lst-max-list-take-one"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;maxListOrdering[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ordering:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxListOrdering(rest)(ordering)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(ordering.gt(x,&nbsp;maxRest))&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>
      <h5>Listing 21.2 - A function with an upper bound.</h5>
      <p>The signature of <span class="code">maxListOrdering</span> is similar to that of <span class="code">orderedMergeSort</span>, shown in <a href="#lst-upper-bound-sort">Listing 19.12</a> <a href="#lst-upper-bound-sort">here</a>: It takes a <span class="code">List[T]</span> as its argument, and now it takes an additional argument of type <span class="code">Ordering[T]</span>. This additional argument specifies which ordering to use when comparing elements of type <span class="code">T</span>. As such, this version can be used for types that don't have a built-in ordering. Additionally, this version can be used for types that <em>do</em> have a built-in ordering, but for which you occasionally want to use some other ordering.</p>
      <p>This version is more general, but it's also more cumbersome to use. Now a caller must specify an explicit ordering even if <span class="code">T</span> is something like <span class="code">String</span> or <span class="code">Int</span> that has an obvious default ordering. To make the new method more convenient, it helps to make the second argument implicit. This approach is shown in <a href="#lst-max-list-take-two">Listing 21.3</a>.</p>
      <p>The <span class="code">ordering</span> parameter in this example is used to describe the ordering of <span class="code">T</span>s. In the body of <span class="code">maxListImpParm</span>, this ordering is used in two places: a recursive call to <span class="code">maxListImpParm</span>, and an <span class="code">if</span> expression that checks whether the head of the list is larger than the maximum element of the rest of the list.</p>
      <p><a id="lst-max-list-take-two"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;maxListImpParm[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;ordering:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxListImpParm(rest)(ordering)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(ordering.gt(x,&nbsp;maxRest))&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>
      <h5>Listing 21.3 - A function with an implicit parameter.</h5>
      <p>The <span class="code">maxListImpParm</span> function is an example of an implicit parameter used to provide more information about a type mentioned explicitly in an earlier parameter list. To be specific, the implicit parameter <span class="code">ordering</span>, of type <span class="code">Ordering[T]</span>, provides more information about type <span class="code">T</span>—in this case, how to order <span class="code">T</span>s. Type <span class="code">T</span> is mentioned in <span class="code">List[T]</span>, the type of parameter <span class="code">elements</span>, which appears in the earlier parameter list. Because <span class="code">elements</span> must always be provided explicitly in any invocation of <span class="code">maxListImpParm</span>, the compiler will know <span class="code">T</span> at compile time and can therefore determine whether an implicit definition of type <span class="code">Ordering[T]</span> is available. If so, it can pass in the second parameter list, <span class="code">ordering</span>, implicitly.</p>
      <p>This pattern is so common that the standard Scala library provides implicit "ordering" methods for many common types. You could therefore use this <span class="code">maxListImpParm</span> method with a variety of types:</p> <pre>  scala&gt;&nbsp;maxListImpParm(<code class="typename">List</code>(<code class="literal">1</code>,<code class="literal">5</code>,<code class="literal">10</code>,<code class="literal">3</code>))
  <code class="output">res9:&nbsp;Int&nbsp;=&nbsp;10</code>
  <br>  scala&gt;&nbsp;maxListImpParm(<code class="typename">List</code>(<code class="literal">1.5</code>,&nbsp;<code class="literal">5.2</code>,&nbsp;<code class="literal">10.7</code>,&nbsp;<code class="literal">3.14159</code>))
  <code class="output">res10:&nbsp;Double&nbsp;=&nbsp;10.7</code>
  <br>  scala&gt;&nbsp;maxListImpParm(<code class="typename">List</code>(<code class="quotedstring">"one"</code>,&nbsp;<code class="quotedstring">"two"</code>,&nbsp;<code class="quotedstring">"three"</code>))
  <code class="output">res11:&nbsp;String&nbsp;=&nbsp;two</code>
</pre>
      <p>In the first case, the compiler inserted an <span class="code">ordering</span> for <span class="code">Int</span>s; in the second case, for <span class="code">Double</span>s; in the third case, for <span class="code">String</span>s.</p>
      <h4>A style rule for implicit parameters</h4>
      <p>As a style rule, it is best to use a custom named type in the types of implicit parameters. For example, the types of <span class="code">prompt</span> and <span class="code">drink</span> in the previous example was not <span class="code">String</span>, but <span class="code">PreferredPrompt</span> and <span class="code">PreferredDrink</span>, respectively. As a counterexample, consider that the <span class="code">maxListImpParm</span> function could just as well have been written with the following type signature:</p> <pre>  <code class="vem">def</code>&nbsp;maxListPoorStyle[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;orderer:&nbsp;(T,&nbsp;T)&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;T
</pre>
      <p>To use this version of the function, though, the caller would have to supply an <span class="code">orderer</span> parameter of type <span class="code">(T,</span>&nbsp;<span class="code">T)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span>. This is a fairly generic type that includes any function from two <span class="code">T</span>s to a <span class="code">Boolean</span>. It does not indicate anything at all about what the type is for; it could be an equality test, a less-than test, a greater-than test, or something else entirely.</p>
      <p>The actual code for <span class="code">maxListImpParm</span>, given in <a href="#lst-max-list-take-two">Listing 21.3</a>, shows better style. It uses an <span class="code">ordering</span> parameter of type <span class="code">Ordering[T]</span>. The word <span class="code">Ordering</span> in this type indicates exactly what the implicit parameter is used for: it is for ordering elements of <span class="code">T</span>. Because this <span class="code">ordering</span> type is more explicit, it's no trouble to add implicit providers for this type in the standard library. To contrast, imagine the chaos that would ensue if you added an implicit of type <span class="code">(T,</span>&nbsp;<span class="code">T)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span> in the standard library, and the compiler started sprinkling it around in people's code. You would end up with code that compiles and runs, but that does fairly arbitrary tests against pairs of items! Thus the style rule: Use at least one role-determining name within the type of an implicit parameter.</p>
      <h3 id="sec-context-bounds">21.6 Context bounds</h3>
      <p>The previous example showed an opportunity to use an implicit but did not. Note that when you use <span class="code">implicit</span> on a parameter, not only will the compiler try to <em>supply</em> that parameter with an implicit value, but the compiler will also <em>use</em> that parameter as an available implicit in the body of the method! Thus, the first use of <span class="code">ordering</span> within the body of the method can be left out.</p>
      <p><a id="lst-max-list-take-three"></a></p> <pre>  <code class="vem">def</code>&nbsp;maxList[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;ordering:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=
  <br>  &nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxList(rest)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;(ordering)&nbsp;is&nbsp;implicit</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(ordering.gt(x,&nbsp;maxRest))&nbsp;x&nbsp;&nbsp;<code class="comment">//&nbsp;this&nbsp;ordering&nbsp;is</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;still&nbsp;explicit</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 21.4 - A function that uses an implicit parameter internally.</h5>
      <p>When the compiler examines the code in <a href="#lst-max-list-take-three">Listing 21.4</a>, it will see that the types do not match up. The expression <span class="code">maxList(rest)</span> only supplies one parameter list, but <span class="code">maxList</span> requires two. Since the second parameter list is implicit, the compiler does not give up type checking immediately. Instead, it looks for an implicit parameter of the appropriate type, in this case <span class="code">Ordering[T]</span>. In this case, it finds one and rewrites the call to <span class="code">maxList(rest)(ordering)</span>, after which the code type checks.</p>
      <p>There is also a way to eliminate the second use of <span class="code">ordering</span>. It involves the following method defined in the standard library:</p> <pre>  <code class="vem">def</code>&nbsp;implicitly[T](<code class="vem">implicit</code>&nbsp;t:&nbsp;T)&nbsp;=&nbsp;t
</pre>
      <p>The effect of calling <span class="code">implicitly[Foo]</span> is that the compiler will look for an implicit definition of type <span class="code">Foo</span>. It will then call the <span class="code">implicitly</span> method with that object, which in turn returns the object right back. Thus you can write <span class="code">implicitly[Foo]</span> whenever you want to find an implicit object of type <span class="code">Foo</span> in the current scope. For example, <a href="#lst-max-list-take-three-b">Listing 21.5</a> shows a use of <span class="code">implicitly[Ordering[T]]</span> to retrieve the <span class="code">ordering</span> parameter by its type.</p>
      <p>Look closely at this last version of <span class="code">maxList</span>. There is not a single mention of the <span class="code">ordering</span> parameter in the text of the method. The second parameter could just as well be named "<span class="code">comparator</span>":</p> <pre>  <code class="vem">def</code>&nbsp;maxList[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;comparator:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=&nbsp;<code class="comment">//&nbsp;same&nbsp;body...</code>
</pre>
      <p><a id="lst-max-list-take-three-b"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;maxList[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;ordering:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxList(rest)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(implicitly[<code class="typename">Ordering[T]</code>].gt(x,&nbsp;maxRest))&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>
      <h5>Listing 21.5 - A function that uses <span class="code">implicitly</span>.</h5>
      <p>For that matter, this version works as well:</p> <pre>  <code class="vem">def</code>&nbsp;maxList[T](elements:&nbsp;<code class="typename">List[T]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;iceCream:&nbsp;<code class="typename">Ordering[T]</code>):&nbsp;T&nbsp;=&nbsp;<code class="comment">//&nbsp;same&nbsp;body...</code>
</pre>
      <p>Because this pattern is common, Scala lets you leave out the name of this parameter and shorten the method header by using a <em>context bound</em>.<a id="i-956942778-2"></a> Using a context bound, you would write the signature of <span class="code">maxList</span> as shown in <a href="#lst-max-list-context-bound">Listing 21.6</a>. The syntax <span class="code">[T</span>&nbsp;<span class="code">:</span>&nbsp;<span class="code">Ordering]</span> is a context bound, and it does two things. First, it introduces a type parameter <span class="code">T</span> as normal. Second, it adds an implicit parameter of type <span class="code">Ordering[T]</span>. In previous versions of <span class="code">maxList</span>, that parameter was called <span class="code">ordering</span>, but when using a context bound you don't know what the parameter will be called. As shown earlier, you often don't need to know what the parameter is called.</p>
      <p>Intuitively, you can think of a context bound as saying something <em>about</em> a type parameter. When you write <span class="code">[T</span>&nbsp;<span class="code">&lt;:</span>&nbsp;<span class="code">Ordered[T]]</span> you are saying that a <span class="code">T</span> <em>is</em> an <span class="code">Ordered[T]</span>. To contrast, when you write <span class="code">[T</span>&nbsp;<span class="code">:</span>&nbsp;<span class="code">Ordering]</span> you are not so much saying what <span class="code">T</span> is; rather, you are saying that there is some form of ordering associated with <span class="code">T</span>. Thus, a context bound is quite flexible. It allows you to use code that requires orderings—or any other property of a type—without having to change the definition of that type.</p>
      <p><a id="lst-max-list-context-bound"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;maxList[T&nbsp;:&nbsp;<code class="typename">Ordering</code>](elements:&nbsp;<code class="typename">List[T]</code>):&nbsp;T&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IllegalArgumentException</code>(<code class="quotedstring">"empty&nbsp;list!"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;maxRest&nbsp;=&nbsp;maxList(rest)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(implicitly[<code class="typename">Ordering[T]</code>].gt(x,&nbsp;maxRest))&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>
      <h5>Listing 21.6 - A function with a context bound.</h5>
      <h3 id="sec-when-multiple-conversions-apply">21.7 When multiple conversions apply</h3>
      <p>It can happen that multiple implicit conversions are in scope and each would work.<a id="i2142988268-1"></a> For the most part, Scala refuses to insert a conversion in such a case. Implicits work well when the conversion left out is completely obvious and pure boilerplate. If multiple conversions apply, then the choice isn't so obvious after all.</p>
      <p>Here's a simple example. There is a method that takes a sequence, a conversion that turns an integer into a range, and a conversion that turns an integer into a list of digits:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;printLength(seq:&nbsp;<code class="typename">Seq[Int]</code>)&nbsp;=&nbsp;println(seq.length)
  <code class="output">printLength:&nbsp;(seq:&nbsp;Seq[Int])Unit</code>
  <br>  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToRange(i:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;i
  <code class="output">intToRange:&nbsp;(i:&nbsp;</code>
  <code class="output">Int)scala.collection.immutable.Range.Inclusive</code>
  <br>  scala&gt;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;intToDigits(i:&nbsp;<code class="typename">Int</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.toString.toList.map(_.toInt)
  <code class="output">intToDigits:&nbsp;(i:&nbsp;Int)List[Int]</code>
  <br>  scala&gt;&nbsp;printLength(<code class="literal">12</code>)
  <code class="output">&lt;console&gt;:26:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Int(12)</code>
  <code class="output">&nbsp;required:&nbsp;Seq[Int]</code>
  <code class="output">Note&nbsp;that&nbsp;implicit&nbsp;conversions&nbsp;are&nbsp;not&nbsp;applicable&nbsp;because&nbsp;</code>
  <code class="output">they&nbsp;are&nbsp;ambiguous:</code>
  <code class="output">&nbsp;both&nbsp;method&nbsp;intToRange&nbsp;of&nbsp;type&nbsp;(i:&nbsp;</code>
  <code class="output">Int)scala.collection.immutable.Range.Inclusive</code>
  <code class="output">&nbsp;and&nbsp;method&nbsp;intToDigits&nbsp;of&nbsp;type&nbsp;(i:&nbsp;Int)List[Int]</code>
  <code class="output">&nbsp;are&nbsp;possible&nbsp;conversion&nbsp;functions&nbsp;from&nbsp;Int(12)&nbsp;to&nbsp;Seq[Int]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printLength(12)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>The ambiguity here is real. Converting an integer to a sequence of digits is completely different from converting it to a range. In this case, the programmer should specify which one is intended and be explicit. Up through Scala 2.7, that was the end of the story. Whenever multiple implicit conversions applied, the compiler refused to choose between them. The situation was just as with method overloading. If you try to call <span class="code">foo(null)</span> and there are two different <span class="code">foo</span> overloads that accept <span class="code">null</span>, the compiler will refuse. It will say that the method call's target is ambiguous.</p>
      <p>Scala 2.8 loosened this rule. If one of the available conversions is strictly <em>more specific</em> than the others, then the compiler will choose the more specific one. The idea is that whenever there is a reason to believe a programmer would always choose one of the conversions over the others, don't require the programmer to write it explicitly. After all, method overloading has the same relaxation. Continuing the previous example, if one of the available <span class="code">foo</span> methods takes a <span class="code">String</span> while the other takes an <span class="code">Any</span>, then choose the <span class="code">String</span> version. It's clearly more specific.</p>
      <p>To be more precise, one implicit conversion is <em>more specific</em> than another if one of the following applies:</p>
      <ul>
        <li>The argument type of the former is a subtype of the latter's. </li>
        <li>Both conversions are methods, and the enclosing class of the former extends the enclosing class of the latter. </li>
      </ul>
      <p>The motivation to revisit this issue and revise the rule was to improve interoperation between Java collections, Scala collections, and strings.</p>
      <p>Here's a simple example:</p> <pre>  <code class="vem">val</code>&nbsp;cba&nbsp;=&nbsp;<code class="quotedstring">"abc"</code>.reverse
</pre>
      <p>What is the type inferred for <span class="code">cba</span>? Intuitively, the type should be <span class="code">String</span>. Reversing a string should yield another string, right? However, in Scala 2.7, what happened was that "abc" was converted to a Scala collection. Reversing a Scala collection yields a Scala collection, so the type of <span class="code">cba</span> would be a collection. There's also an implicit conversion back to a string, but that didn't patch up every problem. For example, in versions prior to Scala 2.8, <span class="code">"abc"</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">"abc".reverse.reverse</span> was false!</p>
      <p>With Scala 2.8, the type of <span class="code">cba</span> is <span class="code">String</span>. The old implicit conversion to a Scala collection (now named <span class="code">WrappedString</span>)<a id="i-260905957-1"></a><a id="i-61010514-1"></a> is retained. However, there is a more specific conversion supplied from <span class="code">String</span> to a new type called <span class="code">StringOps</span>.<a id="i1341725017-2"></a><a id="i-1007334645-2"></a> <span class="code">StringOps</span> has many methods such as <span class="code">reverse</span>, but instead of returning a collection, they return a <span class="code">String</span>. The conversion to <span class="code">StringOps</span> is defined directly in <span class="code">Predef</span>, whereas the conversion to a Scala collection is defined in a new class, <span class="code">LowPriorityImplicits</span>,<a id="i-486218258-1"></a> which is extended by <span class="code">Predef</span>. Whenever a choice exists between these two conversions, the compiler chooses the conversion to <span class="code">StringOps</span>, because it's defined in a subclass of the class where the other conversion is defined.</p>
      <h3>21.8 Debugging implicits</h3>
      <p>Implicits are a powerful feature in Scala, but one that's sometimes difficult to get right. This section contains a few tips for debugging implicits.</p>
      <p>Sometimes you might wonder why the compiler did not find an implicit conversion that you think should apply. In that case it helps to write the conversion out explicitly. If that also gives an error message, you then know why the compiler could not apply your implicit.</p>
      <p>For instance, assume that you mistakenly took <span class="code">wrapString</span> to be a conversion from <span class="code">String</span>s to <span class="code">List</span>s, instead of <span class="code">IndexedSeq</span>s. You would wonder why the following code does not work:<a id="i-677980410-8"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;chars:&nbsp;<code class="typename">List[Char]</code>&nbsp;=&nbsp;<code class="quotedstring">"xyz"</code>
  <code class="output">&lt;console&gt;:24:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;String("xyz")</code>
  <code class="output">&nbsp;required:&nbsp;List[Char]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;chars:&nbsp;List[Char]&nbsp;=&nbsp;"xyz"</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>Again, it helps to write the <span class="code">wrapString</span> conversion explicitly to find out what went wrong:<a id="i-677980410-9"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;chars:&nbsp;<code class="typename">List[Char]</code>&nbsp;=&nbsp;wrapString(<code class="quotedstring">"xyz"</code>)
  <code class="output">&lt;console&gt;:24:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;scala.collection.immutable.WrappedString</code>
  <code class="output">&nbsp;required:&nbsp;List[Char]</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;chars:&nbsp;List[Char]&nbsp;=&nbsp;wrapString("xyz")</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>With this, you have found the cause of the error: <span class="code">wrapString</span> has the wrong return type. On the other hand, it's also possible that inserting the conversion explicitly will make the error go away. In that case you know that one of the other rules (such as the Scope Rule) was preventing the implicit conversion from being applied.</p>
      <p>When you are debugging a program, it can sometimes help to see what implicit conversions the compiler is inserting. The <span class="code">-Xprint:typer</span> option to the compiler is useful for this. If you run <span class="code">scalac</span> with this option, the compiler will show you what your code looks like after all implicit conversions have been added by the type checker. An example is shown in <a href="#lst-example">Listing 21.7</a> and <a href="#lst-print-typer">Listing 21.8</a>. If you look at the last statement in each of these listings, you'll see that the second parameter list to <span class="code">enjoy</span>, which was left off in the code in <a href="#lst-example">Listing 21.7</a>, "<span class="code">enjoy("reader")</span>," was inserted by the compiler, as shown in <a href="#lst-print-typer">Listing 21.8</a>:</p> <pre>  <code class="output">Mocha.this.enjoy("reader")(Mocha.this.pref)</code>
</pre>
      <p>If you are brave, try <span class="code">scala</span>&nbsp;<span class="code">-Xprint:typer</span> to get an interactive shell that prints out the post-typing source code it uses internally. If you do so, be prepared to see an enormous amount of boilerplate surrounding the meat of your code.</p>
      <p><a id="lst-example"></a></p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Mocha</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">App</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">PreferredDrink</code>(<code class="vem">val</code>&nbsp;preference:&nbsp;<code class="typename">String</code>)
  <br>  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">val</code>&nbsp;pref&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PreferredDrink</code>(<code class="quotedstring">"mocha"</code>)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;enjoy(name:&nbsp;<code class="typename">String</code>)(<code class="vem">implicit</code>&nbsp;drink:&nbsp;<code class="typename">PreferredDrink</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">"Welcome,&nbsp;"</code>&nbsp;+&nbsp;name)
  &nbsp;&nbsp;&nbsp;&nbsp;print(<code class="quotedstring">".&nbsp;Enjoy&nbsp;a&nbsp;"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;print(drink.preference)
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"!"</code>)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;enjoy(<code class="quotedstring">"reader"</code>)
  }
</pre>
      <h5>Listing 21.7 - Sample code that uses an implicit parameter.</h5>
      <p><a id="lst-print-typer"></a></p> <pre>  $&nbsp;scalac&nbsp;-<code class="typename">Xprint</code>:typer&nbsp;mocha.scala
  <code class="output">[[syntax&nbsp;trees&nbsp;at&nbsp;end&nbsp;of&nbsp;typer]]<code class="comment"></code>
//&nbsp;Scala&nbsp;source:&nbsp;mocha.scala</code>
  <code class="output">package&nbsp;&lt;empty&gt;&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;final&nbsp;object&nbsp;Mocha&nbsp;extends&nbsp;java.lang.Object&nbsp;with&nbsp;Application</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;ScalaObject&nbsp;{</code>
  <br>  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment"></code>
//&nbsp;...</code>
  <br>  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;private[this]&nbsp;val&nbsp;pref:&nbsp;Mocha.PreferredDrink&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Mocha.this.PreferredDrink("mocha");</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;implicit&nbsp;&lt;stable&gt;&nbsp;&lt;accessor&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;pref:&nbsp;Mocha.PreferredDrink&nbsp;=&nbsp;Mocha.this.pref;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;enjoy(name:&nbsp;String)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(implicit&nbsp;drink:&nbsp;Mocha.PreferredDrink):&nbsp;Unit&nbsp;=&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.print("Welcome,&nbsp;".+(name));</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.print(".&nbsp;Enjoy&nbsp;a&nbsp;");</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.print(drink.preference);</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.println("!")</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;};</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Mocha.this.enjoy("reader")(Mocha.this.pref)</code>
  <code class="output">&nbsp;&nbsp;}</code>
  <code class="output">}</code>
</pre>
      <h5>Listing 21.8 - Sample code after type checking and insertion of implicits.</h5>
      <h3>21.9 Conclusion</h3>
      <p>Implicits are a powerful, code-condensing feature of Scala. This chapter has shown you Scala's rules about implicits and several common programming situations where you can profit from using implicits.</p>
      <p>As a word of warning, implicits can make code confusing if they are used too frequently. Thus, before adding a new implicit conversion, first ask whether you can achieve a similar effect through other means, such as inheritance, mixin composition, or method overloading. If all of these fail, however, and you feel like a lot of your code is still tedious and redundant, then implicits might just be able to help you out.</p>
      <hr>
      <h4>Footnotes for Chapter 21:</h4>
      <p><a id="footnotemain21-1"></a>[1] As will be explained in <a href="#sec-java-8-and-scala-212">Section 31.5</a>, it does work in Scala 2.12.<a id="i88737196-1"></a></p>
      <p><a id="footnotemain21-2"></a>[2] Variables and singleton objects marked implicit can be used as <em>implicit parameters</em>. This use case will be described later in this chapter.</p>
      <p><a id="footnotemain21-3"></a>[3] The Scala compiler backend will treat the conversion specially, however, translating it to a special "<span class="code">i2d</span>" bytecode. So the compiled image is the same as in Java.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-implementing-lists">Chapter 22</a></h2>
      <h1>Implementing Lists</h1>
      <p>Lists have been ubiquitous in this book. Class <span class="code">List</span> is probably the most commonly used structured data type in Scala. <a href="#chap-working-with-lists">Chapter 16</a> showed you how to use lists.<a id="i2054390305-1"></a> This chapter "opens up the covers" and explains a bit about how lists are implemented in Scala.</p>
      <p>Knowing the internal workings of the <span class="code">List</span> class is useful for several reasons. You gain a better idea of the relative efficiency of list operations, which will help you in writing fast and compact code using lists. You also gain a toolbox of techniques that you can apply in the design of your own libraries. Finally, the <span class="code">List</span> class is a sophisticated application of Scala's type system in general and its genericity concepts in particular. So studying class <span class="code">List</span> will deepen your knowledge in these areas.</p>
      <h3 id="sec-list-impl-principle">22.1 The <span class="code">List</span> class in principle</h3>
      <p>Lists are not "built-in" as a language construct in Scala; they are defined by an abstract class <span class="code">List</span> in the <span class="code">scala.collection.immutable</span> package, which comes with two subclasses for <span class="code">::</span><a id="i304418243-1"></a> and <span class="code">Nil</span>.<a id="i1899558990-3"></a> In this chapter we will present a quick tour through class <span class="code">List</span>. This section presents a somewhat simplified account of the class, compared to its real implementation in the Scala standard library, which is covered in <a href="#sec-list-impl-practice">Section 22.3</a>.</p> <pre>  <code class="vem">package</code>&nbsp;scala.collection.immutable
  <code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">List[+A]</code>&nbsp;{
</pre>
      <p><span class="code">List</span> is an abstract class, so you cannot define elements by calling the empty <span class="code">List</span> constructor. For instance the expression "<span class="code">new</span>&nbsp;<span class="code">List</span>" would be illegal. The class has a type parameter <span class="code">A</span>. The <span class="code">+</span> in front of this type parameter specifies that lists are covariant, as discussed in <a href="#chap-type-parameterization">Chapter 19</a><a id="i-588033271-1"></a>.</p>
      <div class="figure">
        <a id="fig-list-hierarchy"></a>
        <p><img src="listHierarchy85.png" alt="images/listHierarchy85.png"></p>
      </div>
      <h5> Figure 22.1 - Class hierarchy for Scala lists.<a id="i-490886053-1"></a><a id="i-322128956-1"></a><a id="i164593921-1"></a></h5>
      <p>Because of this property, you can assign a value of type <span class="code">List[Int]</span> to a variable of type <span class="code">List[Any]</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;xs&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">xs:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;ys:&nbsp;<code class="typename">List[Any]</code>&nbsp;=&nbsp;xs
  <code class="output">ys:&nbsp;List[Any]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
</pre>
      <p>All list operations can be defined in terms of three basic methods:</p> <pre>  <code class="vem">def</code>&nbsp;isEmpty:&nbsp;<code class="typename">Boolean</code>
  <code class="vem">def</code>&nbsp;head:&nbsp;A
  <code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">List[A]</code>
</pre>
      <p>These three methods are all abstract in class <span class="code">List</span><a id="i1657074897-3"></a><a id="i-735890706-3"></a><a id="i849842526-3"></a>. They are defined in the subobject <span class="code">Nil</span> and the subclass <span class="code">::</span>. The hierarchy for <span class="code">List</span> is shown in <a href="#fig-list-hierarchy">Figure 22.1</a>.</p>
      <h4>The <span class="code">Nil</span> object</h4>
      <p>The <span class="code">Nil</span> object defines an empty list.<a id="i1899558990-4"></a> Its definition is shown in <a href="#lst-nil-definition">Listing 22.1</a>. The <span class="code">Nil</span> object inherits from type <span class="code">List[Nothing]</span>. Because of covariance, this means that <span class="code">Nil</span> is compatible with every instance of the <span class="code">List</span> type.</p>
      <p><a id="lst-nil-definition"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Nil</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">List[Nothing]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;isEmpty&nbsp;=&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;head:&nbsp;<code class="typename">Nothing</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">NoSuchElementException</code>(<code class="quotedstring">"head&nbsp;of&nbsp;empty&nbsp;list"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">List[Nothing]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">NoSuchElementException</code>(<code class="quotedstring">"tail&nbsp;of&nbsp;empty&nbsp;list"</code>)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 22.1 - The definition of the <span class="code">Nil</span> singleton object.</h5>
      <p>The three abstract methods of class <span class="code">List</span> are implemented in the <span class="code">Nil</span> object in a straightforward way: The <span class="code">isEmpty</span> method returns <span class="code">true</span>, and the <span class="code">head</span> and <span class="code">tail</span> methods both throw an exception. Note that throwing an exception is not only reasonable, but practically the only possible thing to do for <span class="code">head</span>: Because <span class="code">Nil</span> is a <span class="code">List</span> of <span class="code">Nothing</span>, the result type of <span class="code">head</span> must be <span class="code">Nothing</span>. Since there is no value of this type, this means that <span class="code">head</span> cannot return a normal value. It has to return abnormally by throwing an exception.<a href="#footnotemain22-1">[1]</a></p>
      <h4>The <span class="code">::</span> class</h4>
      <p>Class <span class="code">::</span>, pronounced "cons" for "construct," represents non-empty lists.<a id="i55390901-3"></a><a id="i-1839436249-3"></a><a id="i1411857630-4"></a><a id="i1732245321-1"></a> It's named that way in order to support pattern matching with the infix <span class="code">::</span><a id="i1357014823-1"></a>. You have seen in <a href="#sec-list-patterns">Section 16.5</a> that every infix operation in a pattern is treated as a constructor application of the infix operator to its arguments. So the pattern <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span> is treated as <span class="code">::(x,</span>&nbsp;<span class="code">xs)</span> where <span class="code">::</span> is a case class.</p>
      <p>Here is the definition of the <span class="code">::</span> class:</p> <pre>  <code class="vem">final</code>&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;::[A](hd:&nbsp;A,&nbsp;tl:&nbsp;<code class="typename">List[A]</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">List[A]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;head&nbsp;=&nbsp;hd
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail&nbsp;=&nbsp;tl
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;isEmpty:&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;<code class="vem">false</code>
  }
</pre>
      <p>The implementation of the <span class="code">::</span> class is straightforward. It takes two parameters <span class="code">hd</span> and <span class="code">tl</span>, representing the head and the tail of the list to be constructed. The definitions of the <span class="code">head</span> and <span class="code">tail</span> method simply return the corresponding parameter. In fact, this pattern can be abbreviated by letting the parameters directly implement the <span class="code">head</span> and <span class="code">tail</span> methods of the superclass <span class="code">List</span>, as in the following equivalent but shorter definition of the <span class="code">::</span> class:</p> <pre>  <code class="vem">final</code>&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;::[A](head:&nbsp;A,&nbsp;tail:&nbsp;<code class="typename">List[A]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">List[A]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;isEmpty:&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;<code class="vem">false</code>
  }
</pre>
      <p>This works because every case class parameter is implicitly also a field of the class (it's like the parameter declaration was prefixed with <span class="code">val</span>).<a id="i1467639728-1"></a> Recall from <a href="#sec-abstract-vals">Section 20.3</a> that Scala allows you to implement an abstract parameterless method such as <span class="code">head</span> or <span class="code">tail</span> with a field.<a id="i748048051-2"></a><a id="i1692897037-2"></a><a id="i84167179-2"></a> So the code above directly uses the parameters <span class="code">head</span> and <span class="code">tail</span> as implementations of the abstract methods <span class="code">head</span> and <span class="code">tail</span> that were inherited from class <span class="code">List</span>.</p>
      <h4>Some more methods</h4>
      <p>All other <span class="code">List</span> methods can be written using the basic three. For instance:</p> <pre>  <code class="vem">def</code>&nbsp;length:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(isEmpty)&nbsp;<code class="literal">0</code>&nbsp;<code class="vem">else</code>&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;tail.length
</pre>
      <p>or:</p> <pre>  <code class="vem">def</code>&nbsp;drop(n:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">List[A]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(isEmpty)&nbsp;<code class="typename">Nil</code>
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;&lt;=&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;tail.drop(n&nbsp;-&nbsp;<code class="literal">1</code>)
</pre>
      <p>or:</p> <pre>  <code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;<code class="typename">List[B]</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(isEmpty)&nbsp;<code class="typename">Nil</code>
  &nbsp;&nbsp;<code class="vem">else</code>&nbsp;f(head)&nbsp;::&nbsp;tail.map(f)
</pre>
      <h4>List construction</h4>
      <p>The list construction methods <span class="code">::</span> and <span class="code">:::</span> are special. Because they end in a colon, they are bound to their right operand. That is, an operation such as <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span> is treated as the method call <span class="code">xs.::(x)</span>, not <span class="code">x.::(xs)</span>. In fact, <span class="code">x.::(xs)</span> would not make sense, as <span class="code">x</span> is of the list element type, which can be arbitrary, so we cannot assume that this type would have a <span class="code">::</span> method.</p>
      <p>For this reason, the <span class="code">::</span> method should take an element value and yield a new list. What is the required type of the element value? You might be tempted to say it should be the same as the list's element type, but in fact this is more restrictive than necessary.</p>
      <p>To see why, consider this class hierarchy:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Fruit</code>&nbsp;
  <code class="vem">class</code>&nbsp;<code class="typename">Apple</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Orange</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Fruit</code>
</pre>
      <p><a href="#lst-supertype-cons">Listing 22.2</a> shows what happens when you construct lists of fruit: <a id="lst-supertype-cons"></a></p> <pre>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">val</code>&nbsp;apples&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Apple</code>&nbsp;::&nbsp;<code class="typename">Nil</code>
  <code class="output">&nbsp;&nbsp;apples:&nbsp;List[Apple]&nbsp;=&nbsp;List(Apple@e885c6a)</code>
  <br>  &nbsp;&nbsp;scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fruits&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Orange</code>&nbsp;::&nbsp;apples
  <code class="output">&nbsp;&nbsp;fruits:&nbsp;List[Fruit]&nbsp;=&nbsp;List(Orange@3f51b349,&nbsp;Apple@e885c6a)</code>
</pre>
      <h5>Listing 22.2 - Prepending a supertype element to a subtype list.</h5>
      <p>The <span class="code">apples</span> value is treated as a <span class="code">List</span> of <span class="code">Apple</span>s, as expected. However, the definition of <span class="code">fruits</span> shows that it's still possible to add an element of a different type to that list. The element type of the resulting list is <span class="code">Fruit</span>, which is the most precise common supertype of the original list element type (<i>i.e.</i>, <span class="code">Apple</span>) and the type of the element to be added (<i>i.e.</i>, <span class="code">Orange</span>). This flexibility is obtained by defining the <span class="code">::</span> method (cons) as shown in <a href="#lst-cons-method-def">Listing 22.3</a>: <a id="lst-cons-method-def"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;::[B&nbsp;&gt;:&nbsp;A](x:&nbsp;B):&nbsp;<code class="typename">List[B]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;scala.::(x,&nbsp;<code class="vem">this</code>)
</pre>
      <h5>Listing 22.3 - The definition of method <span class="code">::</span> (cons) in class <span class="code">List</span>.</h5>
      <p>Note that the method is itself polymorphic—it takes a type parameter named <span class="code">B</span>. Furthermore, <span class="code">B</span> is constrained in <span class="code">[B</span>&nbsp;<span class="code">&gt;:</span>&nbsp;<span class="code">A]</span> to be a supertype of the list element type <span class="code">A</span>. The element to be added is required to be of type <span class="code">B</span> and the result is a <span class="code">List[B]</span>.</p>
      <p>With the formulation of <span class="code">::</span> shown in <a href="#lst-cons-method-def">Listing 22.3</a>, you can check how the definition of <span class="code">fruits</span> shown in <a href="#lst-supertype-cons">Listing 22.2</a> works out type-wise: In that definition, the type parameter <span class="code">B</span> of <span class="code">::</span> is instantiated to <span class="code">Fruit</span>. The lower-bound constraint of <span class="code">B</span> is satisfied because the list <span class="code">apples</span> has type <span class="code">List[Apple]</span> and <span class="code">Fruit</span> is a supertype of <span class="code">Apple</span>. The argument to the <span class="code">::</span> is <span class="code">new</span>&nbsp;<span class="code">Orange</span>, which conforms to type <span class="code">Fruit</span>. Therefore, the method application is type-correct with result type <span class="code">List[Fruit]</span>. <a href="#fig-more-fruit">Figure 22.2</a> illustrates the structure of the lists that result from executing the code shown in <a href="#lst-supertype-cons">Listing 22.2</a>.</p>
      <div class="figure">
        <a id="fig-more-fruit"></a>
        <p><img src="moreFruit160.png" alt="images/moreFruit160.png"></p>
      </div>
      <h5> Figure 22.2 - The structure of the Scala lists shown in <a href="#lst-supertype-cons">Listing 22.2</a>.<a id="i-1313439186-1"></a></h5>
      <p>In fact, the polymorphic definition of <span class="code">::</span> with the lower bound <span class="code">A</span> is not only convenient, it is also necessary to render the definition of class <span class="code">List</span> type-correct. This is because <span class="code">List</span>s are defined to be covariant<a id="i-1469695991-2"></a>.</p>
      <p>Assume for a moment that we had defined <span class="code">::</span> like this:</p> <pre>  <code class="comment">//&nbsp;A&nbsp;thought&nbsp;experiment&nbsp;(which&nbsp;wouldn't&nbsp;work)</code>
  <code class="vem">def</code>&nbsp;::(x:&nbsp;A):&nbsp;<code class="typename">List[A]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;scala.::(x,&nbsp;<code class="vem">this</code>)
</pre>
      <p>You saw in <a href="#chap-type-parameterization">Chapter 19</a> that method parameters count as contravariant positions, so the list element type <span class="code">A</span> is in contravariant position in the definition above. But then <span class="code">List</span> cannot be declared covariant in <span class="code">A</span>. The lower bound <span class="code">[B</span>&nbsp;<span class="code">&gt;:</span>&nbsp;<span class="code">A]</span> thus kills two birds with one stone: It removes a typing problem and leads to a <span class="code">::</span> method that's more flexible to use. The list concatenation method <span class="code">:::</span> is defined in a similar way to <span class="code">::</span>, as shown in <a href="#lst-concatenate-def">Listing 22.4</a>.</p>
      <p><a id="lst-concatenate-def"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;:::[B&nbsp;&gt;:&nbsp;A](prefix:&nbsp;<code class="typename">List[B]</code>):&nbsp;<code class="typename">List[B]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(prefix.isEmpty)&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;prefix.head&nbsp;::&nbsp;prefix.tail&nbsp;:::&nbsp;<code class="vem">this</code>
</pre>
      <h5>Listing 22.4 - The definition of method <span class="code">:::</span> in class <span class="code">List</span>.</h5>
      <p>Like cons, concatenation is polymorphic. The result type is "widened" as necessary to include the types of all list elements. Note again that the order of the arguments is swapped between an infix operation and an explicit method call. Because both <span class="code">:::</span> and <span class="code">::</span> end in a colon, they both bind to the right and are both right associative. For instance, the <span class="code">else</span> part of the definition of <span class="code">:::</span> shown in <a href="#lst-concatenate-def">Listing 22.4</a> contains infix operations of both <span class="code">::</span> and <span class="code">:::</span>.</p>
      <p>These infix operations can be expanded to equivalent method calls as follows:</p> <pre>  prefix.head&nbsp;::&nbsp;prefix.tail&nbsp;:::&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;<code class="rm">(because <code class="code">::</code> and <code class="code">:::</code> are right-associative)</code>
  <br>  prefix.head&nbsp;::&nbsp;(prefix.tail&nbsp;:::&nbsp;<code class="vem">this</code>)
  &nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;<code class="rm">(because <code class="code">::</code> binds to the right)</code>
  <br>  (prefix.tail&nbsp;:::&nbsp;<code class="vem">this</code>).::(prefix.head)
  &nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;<code class="rm">(because <code class="code">:::</code> binds to the right)</code>
  <br>  <code class="vem">this</code>.:::(prefix.tail).::(prefix.head)
</pre>
      <h3 id="sec-the-listbuffer-class">22.2 The <span class="code">ListBuffer</span> class</h3>
      <p>The typical access pattern for a list is recursive. For instance, to increment every element of a list without using <span class="code">map</span> you could write:</p> <pre>  <code class="vem">def</code>&nbsp;incAll(xs:&nbsp;<code class="typename">List[Int]</code>):&nbsp;<code class="typename">List[Int]</code>&nbsp;=&nbsp;xs&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>()&nbsp;=&gt;&nbsp;<code class="typename">List</code>()
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<code class="literal">1</code>&nbsp;::&nbsp;incAll(xs1)
  }
</pre>
      <p>One shortcoming of this program pattern is that it is not tail recursive<a id="i2133301138-2"></a>. Note that the recursive call to <span class="code">incAll</span> above occurs inside a <span class="code">::</span> operation. Therefore each recursive call requires a new stack frame.</p>
      <p>On today's virtual machines this means that you cannot<a id="i10962622-2"></a> apply <span class="code">incAll</span> to lists of much more than about 30,000 to 50,000 elements. This is a pity. How do you write a version of <span class="code">incAll</span> that can work on lists of arbitrary size (as much as heap-capacity allows)?</p>
      <p>One approach is to use a loop:</p> <pre>  <code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;<code class="comment">//&nbsp;??</code>
</pre>
      <p>But what should go in the loop body? Note that where <span class="code">incAll</span> constructs the list by prepending elements to the result of the recursive call, the loop needs to append new elements at the end of the result list. A very inefficient possibility is to use <span class="code">:::</span>, the list append operator:</p> <pre>  <code class="vem">var</code>&nbsp;result&nbsp;=&nbsp;<code class="typename">List[Int]</code>()&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;a&nbsp;very&nbsp;inefficient&nbsp;approach</code>
  <code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;result&nbsp;=&nbsp;result&nbsp;:::&nbsp;<code class="typename">List</code>(x&nbsp;+&nbsp;<code class="literal">1</code>)
  result
</pre>
      <p>This is terribly inefficient. Because <span class="code">:::</span> takes time proportional to the length of its first operand, the whole operation takes time proportional to the square of the length of the list. This is clearly unacceptable.</p>
      <p>A better alternative is to use a list buffer. List buffers let you<a id="i-737429794-2"></a> accumulate the elements of a list. To do this, you use an operation such as "<span class="code">buf</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">elem</span>", which appends the element <span class="code">elem</span> at the end of the list buffer <span class="code">buf</span>. Once you are done appending elements, you can turn the buffer into a list using the <span class="code">toList</span> operation.</p>
      <p><span class="code">ListBuffer</span> is a class in package <span class="code">scala.collection.mutable</span><a id="i-1815843466-3"></a>. To use the simple name only, you can import <span class="code">ListBuffer</span> from its package:</p> <pre>  <code class="vem">import</code>&nbsp;scala.collection.mutable.ListBuffer
</pre>
      <p>Using a list buffer, the body of <span class="code">incAll</span> can now be written as follows:</p> <pre>  <code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ListBuffer[Int]</code>
  <code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;buf&nbsp;+=&nbsp;x&nbsp;+&nbsp;<code class="literal">1</code>
  buf.toList
</pre>
      <p>This is a very efficient way to build lists. In fact, the list buffer implementation is organized so that both the append operation (<span class="code">+=</span>)<a id="i714754650-2"></a> and the <span class="code">toList</span> operation take (very short) constant time.<a id="i-1804214425-1"></a></p>
      <h3 id="sec-list-impl-practice">22.3 The <span class="code">List</span> class in practice</h3>
      <p>The implementations of list methods given in <a href="#sec-list-impl-principle">Section 22.1</a> are concise and clear, but suffer from the same stack overflow problem as the non-tail recursive implementation of <span class="code">incAll</span>. Therefore, most methods in the real implementation of class <span class="code">List</span> avoid recursion and use loops instead. For example, <a href="#lst-map-definition">Listing 22.5</a> shows an implementation of <span class="code">map</span> in class <span class="code">List</span> that is closer to the real implementation:</p>
      <p><a id="lst-map-definition"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;<code class="typename">List[B]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(<code class="vem">this</code>&nbsp;eq&nbsp;<code class="typename">Nil</code>)&nbsp;<code class="typename">Nil</code>&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;h&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;::[B](f(head),&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;t:&nbsp;::[B]&nbsp;=&nbsp;h
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;rest&nbsp;=&nbsp;tail
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">while</code>&nbsp;(rest&nbsp;ne&nbsp;<code class="typename">Nil</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;nx&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;::(f(rest.head),&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.next&nbsp;=&nbsp;nx
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;nx
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rest&nbsp;=&nbsp;rest.tail
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 22.5 - The definition of method <span class="code">map</span> in class <span class="code">List</span>.</h5>
      <p>This revised implementation traverses the list with a simple loop, which is highly efficient. A tail recursive implementation would be<a id="i-666165524-1"></a> similarly efficient, but a general recursive implementation would be slower.</p>
      <p>Note how the list is built "from left to right" (as opposed to using the usual "cons" operator that prepends an element to the left of a list) with:</p> <pre>  t.next&nbsp;=&nbsp;nx
</pre>
      <p>This line <span style="font-style:italic">mutates</span> the tail of the list. To understand how it works, take a second look at class <span class="code">::</span>, which constructs non-empty lists. In practice, this class does not quite correspond to its idealized definition given previously in <a href="#sec-list-impl-principle">Section 22.1</a>. The real definition is more like the one shown in <a href="#lst-class-doublecolon-definition">Listing 22.6</a>. As you can see, there's one peculiarity: the <span class="code">next</span> argument is a <span class="code">var</span>! This means that it is possible to modify the tail of a list after the list is constructed. However, because the variable <span class="code">next</span> has the modifier <span class="code">private[scala]</span>, it can be accessed only from within package <span class="code">scala</span>. Client code outside this package can neither read nor write <span class="code">next</span>.</p>
      <p><a id="lst-class-doublecolon-definition"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;::&nbsp;[A](<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;head:&nbsp;A,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>[scala]&nbsp;<code class="vem">var</code>&nbsp;next:&nbsp;<code class="typename">List[A]</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">List[A]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;isEmpty:&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;tail:&nbsp;<code class="typename">List[A]</code>&nbsp;=&nbsp;next
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 22.6 - The definition of the <span class="code">::</span> subclass of <span class="code">List</span>.</h5>
      <p>For example, since the <span class="code">ListBuffer</span> class is contained in a subpackage of package <span class="code">scala</span>, <span class="code">scala.collection.mutable</span>, <span class="code">ListBuffer</span> can access the <span class="code">next</span> field of a cons cell. In fact the elements of a list buffer are represented as a list and appending new elements involves a modification of the <span class="code">next</span> field of the last <span class="code">::</span> cell in that list. Thus, <span class="code">ListBuffer</span> is another efficient way to build a list from left to right. Here's the start of class <span class="code">ListBuffer</span>:</p> <pre>  <code class="vem">package</code>&nbsp;scala.collection.mutable
  <code class="vem">class</code>&nbsp;<code class="typename">ListBuffer[A]</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Buffer[A]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;first:&nbsp;<code class="typename">List[A]</code>&nbsp;=&nbsp;<code class="typename">Nil</code>
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;last0:&nbsp;::[A]&nbsp;=&nbsp;<code class="vem">null</code>
  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;aliased:&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;<code class="vem">false</code>
  <br>  &nbsp;&nbsp;...
</pre>
      <p>You see three private fields that characterize a <span class="code">ListBuffer</span>:</p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> <span class="code">first</span> </td>
            <td> points to the list of all elements stored in the buffer </td>
          </tr>
          <tr>
            <td> <span class="code">last0</span> </td>
            <td> points to the last <span class="code">::</span> cell in that list </td>
          </tr>
          <tr>
            <td> <span class="code">aliased</span> </td>
            <td> indicates whether the buffer has been turned into </td>
          </tr>
          <tr>
            <td> </td>
            <td> a list using a <span class="code">toList</span> operation </td>
          </tr>
        </tbody>
      </table>
      <p>The <span class="code">toList</span> operation is very simple:</p> <pre>  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toList:&nbsp;<code class="typename">List[A]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;aliased&nbsp;=&nbsp;nonEmpty
  &nbsp;&nbsp;first
  }
</pre>
      <p>It returns the list of elements referred to by <span class="code">first</span> and also sets <span class="code">aliased</span> to <span class="code">true</span> if that list is nonempty. So <span class="code">toList</span> is very efficient because it does not copy the list which is stored in a <span class="code">ListBuffer</span>. But what happens if the list is further extended after the <span class="code">toList</span> operation? Of course, once a list is returned from <span class="code">toList</span>, it must be immutable. However, appending to the <span class="code">last0</span> element will modify the list which is referred to by <span class="code">first</span>.</p>
      <p>To maintain the correctness of the list buffer operations, you need to work on a fresh list instead. This is achieved by the first line in the implementation of the <span class="code">addOne</span> operation:</p> <pre>  <code class="vem">def</code>&nbsp;addOne(elem:&nbsp;A):&nbsp;<code class="vem">this</code>.type&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(aliased)&nbsp;copyElems()
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;last1&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;::[A](elem,&nbsp;<code class="typename">Nil</code>)
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(first.isEmpty)&nbsp;first&nbsp;=&nbsp;last1&nbsp;<code class="vem">else</code>&nbsp;last0.next&nbsp;=&nbsp;last1
  &nbsp;&nbsp;last0&nbsp;=&nbsp;last1
  &nbsp;&nbsp;<code class="vem">this</code>
  }
</pre>
      <p>You see that <span class="code">addOne</span> copies the list pointed to by <span class="code">first</span> if <span class="code">aliased</span> is true. So, in the end, there is no free lunch. If you want to go from lists which can be extended at the end to immutable lists, there needs to be some copying. However, the implementation of <span class="code">ListBuffer</span> is such that copying is necessary only for list buffers that are further extended after they have been turned into lists. This case is quite rare in practice. Most use cases of list buffers add elements incrementally and then do one <span class="code">toList</span> operation at the end. In such cases, no copying is necessary.</p>
      <h3>22.4 Functional on the outside</h3>
      <p>In the previous section, we showed key elements of the implementation of Scala's<a id="i-381431720-1"></a><a id="i536175291-1"></a> <span class="code">List</span> and <span class="code">ListBuffer</span> classes. You saw that lists are purely functional on the "outside" but have an imperative implementation using list buffers on the "inside." This is a typical strategy in Scala programming—trying to combine purity with efficiency by carefully delimiting the effects of impure operations.<a id="i-1924040307-1"></a><a id="i982015373-1"></a></p>
      <p>But you might ask, Why insist on purity? Why not just open up the definition of lists, making the <span class="code">tail</span> field, and maybe also the <span class="code">head</span> field, mutable? The disadvantage of such an approach is that it would make programs much more fragile. Note that constructing lists with <span class="code">::</span> re-uses the tail of the constructed list.</p>
      <p>So when you write:</p> <pre>  <code class="vem">val</code>&nbsp;ys&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;::&nbsp;xs
  <code class="vem">val</code>&nbsp;zs&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;::&nbsp;xs
</pre>
      <p>the tails of lists <span class="code">ys</span> and <span class="code">zs</span> are shared; they point to the same data structure. This is essential for efficiency; if the list <span class="code">xs</span> was copied every time you added a new element onto it, this would be much slower. Because sharing is pervasive, changing list elements, if it were possible, would be quite dangerous. For instance, taking the code above, if you wanted to truncate list <span class="code">ys</span> to its first two elements by writing:</p> <pre>  ys.drop(<code class="literal">2</code>).tail&nbsp;=&nbsp;<code class="typename">Nil</code>&nbsp;&nbsp;<code class="comment">//&nbsp;can't&nbsp;do&nbsp;this&nbsp;in&nbsp;Scala!</code>
</pre>
      <p>you would also truncate lists <span class="code">zs</span> and <span class="code">xs</span> as a side effect.</p>
      <p>Clearly, it would be quite difficult to keep track of what gets changed. That's why Scala opts for pervasive sharing and no mutation for lists. The <span class="code">ListBuffer</span> class still allows you to build up lists imperatively and incrementally, if you wish. But since list buffers are not lists, the types keep mutable buffers and immutable lists separate.</p>
      <p>The design of Scala's <span class="code">List</span> and <span class="code">ListBuffer</span> is quite similar to what's done in Java's pair of classes <span class="code">String</span> and <span class="code">StringBuffer</span>. This is no coincidence. In both situations the designers wanted to maintain a pure immutable data structure but also provide an efficient way to construct this structure incrementally. For Java and Scala strings, <span class="code">StringBuffer</span>s (or, in Java 5, <span class="code">StringBuilder</span>s) provide a way to construct a string incrementally. For Scala's lists, you have a choice: You can either construct lists incrementally by adding elements to the beginning of a list using <span class="code">::</span>, or you use a list buffer for adding elements to the end. Which one is preferable depends on the situation. Usually, <span class="code">::</span> lends itself well to recursive algorithms in the divide-and-conquer style. List buffers are often used in a more traditional loop-based style.</p>
      <h3>22.5 Conclusion</h3>
      <p>In this chapter, you saw how lists are implemented in Scala. <span class="code">List</span> is one of the most heavily used data structures in Scala, and it has a refined implementation. <span class="code">List</span>'s two subclasses, <span class="code">Nil</span> and <span class="code">::</span>, are both case classes. Instead of recursing through this structure, however, many core list methods are implemented using a <span class="code">ListBuffer</span>. <span class="code">ListBuffer</span>, in turn, is carefully implemented so that it can efficiently build lists without allocating extraneous memory. It is functional on the outside, but uses mutation internally to speed up the common case where a buffer is discarded after <span class="code">toList</span> has been called. After studying all of this, you now know the list classes inside and out, and you might have learned an implementation trick or two.</p>
      <hr>
      <h4>Footnotes for Chapter 22:</h4>
      <p><a id="footnotemain22-1"></a>[1] To be precise, the types would also permit for <span class="code">head</span> to always go into an infinite loop instead of throwing an exception, but this is clearly not what's wanted.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-for-expressions-revisited">Chapter 23</a></h2>
      <h1>For Expressions Revisited</h1>
      <p><a href="#chap-working-with-lists">Chapter 16</a> demonstrated that higher-order functions, such as <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">filter</span>, provide powerful constructions for dealing with lists. But sometimes the level of abstraction required by these functions makes a program a bit hard to understand.</p>
      <p>Here's an example. Say you are given a list of persons, each defined as an instance of a class <span class="code">Person</span>. Class <span class="code">Person</span> has fields indicating the person's name, whether he or she is male, and his or her children.</p>
      <p>Here's the class definition:</p> <pre>  scala&gt;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Person</code>(name:&nbsp;<code class="typename">String</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMale:&nbsp;<code class="typename">Boolean</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children:&nbsp;<code class="typename">Person</code>*)
</pre>
      <p>Here's a list of some sample <span class="code">person</span>s:</p> <pre>  <code class="vem">val</code>&nbsp;lara&nbsp;=&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Lara"</code>,&nbsp;<code class="vem">false</code>)
  <code class="vem">val</code>&nbsp;bob&nbsp;=&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Bob"</code>,&nbsp;<code class="vem">true</code>)
  <code class="vem">val</code>&nbsp;julie&nbsp;=&nbsp;<code class="typename">Person</code>(<code class="quotedstring">"Julie"</code>,&nbsp;<code class="vem">false</code>,&nbsp;lara,&nbsp;bob)
  <code class="vem">val</code>&nbsp;persons&nbsp;=&nbsp;<code class="typename">List</code>(lara,&nbsp;bob,&nbsp;julie)
</pre>
      <p>Now, say you want to find out the names of all pairs of mothers and their children in that list. Using <span class="code">map</span>, <span class="code">flatMap</span> and <span class="code">filter</span>, you can formulate the following query:</p> <pre>  scala&gt;&nbsp;persons&nbsp;filter&nbsp;(p&nbsp;=&gt;&nbsp;!p.isMale)&nbsp;flatMap&nbsp;(p&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p.children&nbsp;map&nbsp;(c&nbsp;=&gt;&nbsp;(p.name,&nbsp;c.name))))
  <code class="output">res0:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</code>
</pre>
      <p>You could optimize this example a bit by using a <span class="code">withFilter</span> call instead of <span class="code">filter</span>. This would avoid the creation of an intermediate data structure for female persons:</p> <pre>  scala&gt;&nbsp;persons&nbsp;withFilter&nbsp;(p&nbsp;=&gt;&nbsp;!p.isMale)&nbsp;flatMap&nbsp;(p&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p.children&nbsp;map&nbsp;(c&nbsp;=&gt;&nbsp;(p.name,&nbsp;c.name))))
  <code class="output">res1:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</code>
</pre>
      <p>These queries do their job, but they are not exactly trivial to write or understand. Is there a simpler way? In fact, there is. Remember the <span class="code">for</span> expressions in <a href="#sec-for-expressions">Section 7.3</a><a id="i-207940604-3"></a>? Using a <span class="code">for</span> expression, the same example can be written as follows:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(p&nbsp;&lt;-&nbsp;persons;&nbsp;<code class="vem">if</code>&nbsp;!p.isMale;&nbsp;c&nbsp;&lt;-&nbsp;p.children)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;(p.name,&nbsp;c.name)
  <code class="output">res2:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</code>
</pre>
      <p>The result of this expression is exactly the same as the result of the previous expression. What's more, most readers of the code would likely find the <span class="code">for</span> expression much clearer than the previous query, which used the higher-order functions, <span class="code">map</span><a id="i-482121133-1"></a>, <span class="code">flatMap</span><a id="i-1499753963-1"></a>, and <span class="code">withFilter</span><a id="i582713813-1"></a>.</p>
      <p>However, the last two queries are not as dissimilar as it might seem. In fact, it turns out that the Scala compiler will translate the second query into the first one. More generally, all <span class="code">for</span> expressions that <span class="code">yield</span><a id="i-1534065145-1"></a> a result are translated by the compiler into combinations of invocations of the higher-order methods <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span>. All <span class="code">for</span> loops without <span class="code">yield</span> are translated into a smaller set of higher-order functions: just <span class="code">withFilter</span> and <span class="code">foreach</span><a id="i-493461951-1"></a>.</p>
      <p>In this chapter, you'll find out first about the precise rules of writing <span class="code">for</span> expressions. After that, you'll see how they can make combinatorial problems easier to solve. Finally, you'll learn how <span class="code">for</span> expressions are translated, and how as a result, <span class="code">for</span> expressions can help you "grow" the Scala language into new application domains.</p>
      <h3>23.1 For expressions</h3>
      <p>Generally, a <span class="code">for</span> expression is of the form:</p> <pre>  <code class="vem">for</code>&nbsp;(&nbsp;<code style="font-style:italic">seq</code>&nbsp;)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code>
</pre>
      <p>Here, <span style="font-style:italic">seq</span> is a sequence of <span style="font-style:italic">generators</span>, <span style="font-style:italic">definitions</span>, and <span style="font-style:italic">filters</span>, with semicolons between successive elements. An example is the <span class="code">for</span> expression:</p> <pre>  <code class="vem">for</code>&nbsp;(p&nbsp;&lt;-&nbsp;persons;&nbsp;n&nbsp;=&nbsp;p.name;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;startsWith&nbsp;<code class="quotedstring">"To"</code>))&nbsp;
  <code class="vem">yield</code>&nbsp;n
</pre>
      <p>This <span class="code">for</span> expression contains one generator, one definition, and one filter. As mentioned in <a href="#sec-for-expressions">Section 7.3</a> <a href="#exa-for-semicolon-explanation">here</a>, you can also enclose the sequence in braces instead of parentheses. Then the semicolons become optional:</p> <pre>  <code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;p&nbsp;&lt;-&nbsp;persons&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;a&nbsp;generator</code>
  &nbsp;&nbsp;n&nbsp;=&nbsp;p.name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;a&nbsp;definition</code>
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(n&nbsp;startsWith&nbsp;<code class="quotedstring">"To"</code>)&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;a&nbsp;filter</code>
  }&nbsp;<code class="vem">yield</code>&nbsp;n
</pre>
      <p>A <span style="font-style:italic">generator</span> is of the form:<a id="i1422302298-1"></a></p> <pre>  <code style="font-style:italic">pat</code>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code>
</pre>
      <p>The expression <span style="font-style:italic">expr</span> typically returns a list, even though you will see later that this can be generalized. The pattern <span style="font-style:italic">pat</span> gets matched one-by-one against all elements of that list.<a id="i-1272952554-2"></a><a id="i371386352-2"></a> If the match succeeds, the variables in the pattern get bound to the corresponding parts of the element, just the way it is described in <a href="#chap-case-classes-and-pattern-matching">Chapter 15</a>. But if the match fails, no <span class="code">MatchError</span> is thrown.<a id="i797126047-1"></a> Instead, the element is simply discarded from the iteration.</p>
      <p>In the most common case, the pattern <span style="font-style:italic">pat</span> is just a variable <span style="font-style:italic">x</span>, as in <span class="code"><span style="font-style:italic">x</span></span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code"><span style="font-style:italic">expr</span></span>. In that case, the variable <span style="font-style:italic">x</span> simply iterates over all elements returned by <span style="font-style:italic">expr</span>.</p>
      <p>A <span style="font-style:italic">definition</span> is of the form:</p> <pre>  <code style="font-style:italic">pat</code>&nbsp;=&nbsp;<code style="font-style:italic">expr</code>
</pre>
      <p>This definition binds the pattern <span style="font-style:italic">pat</span> to the value of <span style="font-style:italic">expr</span>, so it has the same effect as a <span class="code">val</span> definition:</p> <pre>  <code class="vem">val</code>&nbsp;<code style="font-style:italic">x</code>&nbsp;=&nbsp;<code style="font-style:italic">expr</code>
</pre>
      <p>The most common case is again where the pattern is a simple variable <span class="code">x</span> (<i>e.g.</i>, <span class="code"><span style="font-style:italic">x</span></span>&nbsp;<span class="code">=</span>&nbsp;<span class="code"><span style="font-style:italic">expr</span></span>). This defines <span style="font-style:italic">x</span> as a name for the value <span style="font-style:italic">expr</span>.</p>
      <p>A <span style="font-style:italic">filter</span> is of the form:</p> <pre>  <code class="vem">if</code>&nbsp;<code style="font-style:italic">expr</code>
</pre>
      <p>Here, <span style="font-style:italic">expr</span> is an expression of type <span class="code">Boolean</span>.<a id="i331566550-1"></a> The filter drops from the iteration all elements for which <span style="font-style:italic">expr</span> returns <span class="code">false</span>.</p>
      <p>Every <span class="code">for</span> expression starts with a generator. If there are several generators in a <span class="code">for</span> expression, later generators vary more rapidly than earlier ones. You can verify this easily with the following simple test:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>);&nbsp;y&nbsp;&lt;-&nbsp;<code class="typename">List</code>(<code class="quotedstring">"one"</code>,&nbsp;<code class="quotedstring">"two"</code>))&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;(x,&nbsp;y)
  <code class="output">res3:&nbsp;List[(Int,&nbsp;String)]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;List((1,one),&nbsp;(1,two),&nbsp;(2,one),&nbsp;(2,two))</code>
</pre>
      <h3>23.2 The n-queens problem</h3>
      <p>A particularly suitable application area of <span class="code">for</span> expressions are combinatorial puzzles. An example of such a puzzle is the 8-queens problem: Given a standard chess-board, place eight queens such that no queen is in check from any other (a queen can check another piece if they are on the same column, row, or diagonal). To find a solution to this problem, it's actually simpler to generalize it to chess-boards of arbitrary size. Hence, the problem is to place <i>N</i> queens on a chess-board of <i>N</i> <span style="font-family:sans-serif">x</span> <i>N</i> squares, where the size <i>N</i> is arbitrary. We'll start numbering cells at one, so the upper-left cell of an <i>N</i> <span style="font-family:sans-serif">x</span> <i>N</i> board has coordinate (1, 1) and the lower-right cell has coordinate (<i>N</i>, <i>N</i>).</p>
      <p>To solve the N-queens problem, note that you need to place a queen in each row. So you could place queens in successive rows, each time checking that a newly placed queen is not in check from any other queens that have already been placed. In the course of this search, it might happen that a queen that needs to be placed in row <i>k</i> would be in check in all fields of that row from queens in row 1 to <i>k</i>-1. In that case, you need to abort that part of the search in order to continue with a different configuration of queens in columns 1 to <i>k</i>-1.</p>
      <p>An imperative solution to this problem would place queens one by one, moving them around on the board. But it looks difficult to come up with a scheme that really tries all possibilities. A more functional approach represents a solution directly, as a value. A solution consists of a list of coordinates, one for each queen placed on the board. Note, however, that a full solution can not be found in a single step. It needs to be built up gradually, by occupying successive rows with queens.</p>
      <p>This suggests a recursive algorithm. Assume you have already generated all solutions of placing <i>k</i> queens on a board of size <i>N</i> <span style="font-family:sans-serif">x</span> <i>N</i>, where <i>k</i> is less than <i>N</i>. Each such solution can be presented by a list of length <i>k</i> of coordinates <span class="code">(row,</span>&nbsp;<span class="code">column)</span>, where both row and column numbers range from 1 to <i>N</i>. It's convenient to treat these partial solution lists as stacks, where the coordinates of the queen in row <i>k</i> come first in the list, followed by the coordinates of the queen in row <i>k</i>-1, and so on. The bottom of the stack is the coordinate of the queen placed in the first row of the board. All solutions together are represented as a list of lists, with one element for each solution.</p>
      <p>Now, to place the next queen in row <i>k</i>+1, generate all possible extensions of each previous solution by one more queen. This yields another list of solution lists, this time of length <i>k</i>+1. Continue the process until you have obtained all solutions of the size of the chess-board <i>N</i>.</p>
      <p>This algorithmic idea is embodied in function <span class="code">placeQueens</span> below:</p> <pre>  <code class="vem">def</code>&nbsp;queens(n:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">List[List[(Int,&nbsp;Int)]]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;placeQueens(k:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">List[List[(Int,&nbsp;Int)]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(k&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="typename">List</code>())
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queens&nbsp;&lt;-&nbsp;placeQueens(k&nbsp;-&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queen&nbsp;=&nbsp;(k,&nbsp;column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;isSafe(queen,&nbsp;queens)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">yield</code>&nbsp;queen&nbsp;::&nbsp;queens
  <br>  &nbsp;&nbsp;placeQueens(n)
  }
</pre>
      <p>The outer function <span class="code">queens</span> in the program above simply calls <span class="code">placeQueens</span> with the size of the board <span class="code">n</span> as its argument. The task of the function application <span class="code">placeQueens(k)</span> is to generate all partial solutions of length <span class="code">k</span> in a list. Every element of the list is one solution, represented by a list of length <span class="code">k</span>. So <span class="code">placeQueens</span> returns a list of lists.</p>
      <p>If the parameter <span class="code">k</span> to <span class="code">placeQueens</span> is <span class="code">0</span>, this means that it needs to generate all solutions of placing zero queens on zero rows. There is only one such solution: place no queen at all. This solution is represented by the empty list. So if <span class="code">k</span> is zero, <span class="code">placeQueens</span> returns <span class="code">List(List())</span>, a list consisting of a single element that is the empty list. Note that this is quite different from the empty list <span class="code">List()</span>. If <span class="code">placeQueens</span> returns <span class="code">List()</span>, this means <span style="font-style:italic">no solutions</span>, instead of a single solution consisting of no placed queens.</p>
      <p>In the other case, where <span class="code">k</span> is not zero, all the work of <span class="code">placeQueens</span> is done in a <span class="code">for</span> expression. The first generator of that <span class="code">for</span> expression iterates through all solutions of placing <span class="code">k</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1</span> queens on the board. The second generator iterates through all possible <span class="code">column</span>s on which the <span class="code">k</span>'th queen might be placed. The third part of the <span class="code">for</span> expression defines the newly considered <span class="code">queen</span> position to be the pair consisting of row <span class="code">k</span> and each produced <span class="code">column</span>. The fourth part of the <span class="code">for</span> expression is a filter which checks with <span class="code">isSafe</span> whether the new queen is safe from check by all previous queens (the definition of <span class="code">isSafe</span> will be discussed a bit later).</p>
      <p>If the new queen is not in check from any other queens, it can form part of a partial solution, so <span class="code">placeQueens</span> generates with <span class="code">queen</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">queens</span> a new solution. If the new queen is not safe from check, the filter returns <span class="code">false</span>, so no solution is generated.</p>
      <p>The only remaining bit is the <span class="code">isSafe</span> method, which is used to check whether a given <span class="code">queen</span> is in check from any other element in a list of <span class="code">queens</span>. Here is its definition:</p> <pre>  <code class="vem">def</code>&nbsp;isSafe(queen:&nbsp;(<code class="typename">Int</code>,&nbsp;<code class="typename">Int</code>),&nbsp;queens:&nbsp;<code class="typename">List[(Int,&nbsp;Int)]</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;queens&nbsp;forall&nbsp;(q&nbsp;=&gt;&nbsp;!inCheck(queen,&nbsp;q))
  <br>  <code class="vem">def</code>&nbsp;inCheck(q1:&nbsp;(<code class="typename">Int</code>,&nbsp;<code class="typename">Int</code>),&nbsp;q2:&nbsp;(<code class="typename">Int</code>,&nbsp;<code class="typename">Int</code>))&nbsp;=&nbsp;
  &nbsp;&nbsp;q1._1&nbsp;==&nbsp;q2._1&nbsp;||&nbsp;&nbsp;<code class="comment">//&nbsp;same&nbsp;row</code>
  &nbsp;&nbsp;q1._2&nbsp;==&nbsp;q2._2&nbsp;||&nbsp;&nbsp;<code class="comment">//&nbsp;same&nbsp;column</code>
  &nbsp;&nbsp;(q1._1&nbsp;-&nbsp;q2._1).abs&nbsp;==&nbsp;(q1._2&nbsp;-&nbsp;q2._2).abs&nbsp;<code class="comment">//&nbsp;on&nbsp;diagonal</code>
</pre>
      <p>The <span class="code">isSafe</span> method expresses that a <span class="code">queen</span> is safe with respect to some other <span class="code">queens</span> if it is not in check from any other queen. The <span class="code">inCheck</span> method expresses that queens <span class="code">q1</span> and <span class="code">q2</span> are mutually in check.</p>
      <p>It returns <span class="code">true</span> in one of three cases:</p>
      <ol>
        <li>If the two queens have the same row coordinate, </li>
        <li>If the two queens have the same column coordinate, </li>
        <li>If the two queens are on the same diagonal (<i>i.e.</i>, the difference between their rows and the difference between their columns are the same). </li>
      </ol>
      <p>The first case—that the two queens have the same row coordinate—cannot happen in the application because <span class="code">placeQueens</span> already takes care to place each queen in a different row. So you could remove the test without changing the functionality of the program.</p>
      <h3 id="sec-for-queries">23.3 Querying with <span class="code">for</span> expressions</h3>
      <p>The <span class="code">for</span> notation is essentially equivalent to common operations of database query languages<a id="i1851175608-1"></a>. For instance, say you are given a database named <span class="code">books</span>, represented as a list of books, where <span class="code">Book</span> is defined as follows:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Book</code>(title:&nbsp;<code class="typename">String</code>,&nbsp;authors:&nbsp;<code class="typename">String</code>*)
</pre>
      <p>Here is a small example database represented as an in-memory list:<a id="i471924076-2"></a><a id="i-1712702061-2"></a><a id="i1109104818-1"></a><a id="i-601321358-1"></a><a id="i134333723-1"></a><a id="i875843663-1"></a><a id="i1916394333-2"></a><a id="i-1202190098-1"></a><a id="i1512661551-2"></a></p> <pre>  <code class="vem">val</code>&nbsp;books:&nbsp;<code class="typename">List[Book]</code>&nbsp;=
  &nbsp;&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Structure&nbsp;and&nbsp;Interpretation&nbsp;of&nbsp;Computer&nbsp;Programs"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Abelson,&nbsp;Harold"</code>,&nbsp;<code class="quotedstring">"Sussman,&nbsp;Gerald&nbsp;J."</code>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Principles&nbsp;of&nbsp;Compiler&nbsp;Design"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Aho,&nbsp;Alfred"</code>,&nbsp;<code class="quotedstring">"Ullman,&nbsp;Jeffrey"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Programming&nbsp;in&nbsp;Modula-2"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Wirth,&nbsp;Niklaus"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Elements&nbsp;of&nbsp;ML&nbsp;Programming"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Ullman,&nbsp;Jeffrey"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Book</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"The&nbsp;Java&nbsp;Language&nbsp;Specification"</code>,&nbsp;<code class="quotedstring">"Gosling,&nbsp;James"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Joy,&nbsp;Bill"</code>,&nbsp;<code class="quotedstring">"Steele,&nbsp;Guy"</code>,&nbsp;<code class="quotedstring">"Bracha,&nbsp;Gilad"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;)
</pre>
      <p>To find the titles of all books whose author's last name is "Gosling":</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(b&nbsp;&lt;-&nbsp;books;&nbsp;a&nbsp;&lt;-&nbsp;b.authors
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;a&nbsp;startsWith&nbsp;<code class="quotedstring">"Gosling"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;b.title
  <code class="output">res4:&nbsp;List[String]&nbsp;=&nbsp;List(The&nbsp;Java&nbsp;Language&nbsp;Specification)</code>
</pre>
      <p>Or to find the titles of all books that have the string "Program" in their title:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(b&nbsp;&lt;-&nbsp;books&nbsp;<code class="vem">if</code>&nbsp;(b.title&nbsp;indexOf&nbsp;<code class="quotedstring">"Program"</code>)&nbsp;&gt;=&nbsp;<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;b.title
  <code class="output">res5:&nbsp;List[String]&nbsp;=&nbsp;List(Structure&nbsp;and&nbsp;Interpretation&nbsp;of&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Computer&nbsp;Programs,&nbsp;Programming&nbsp;in&nbsp;Modula-2,&nbsp;Elements&nbsp;of&nbsp;ML&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Programming)</code>
</pre>
      <p>Or to find the names of all authors who have written at least two books in the database:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(b1&nbsp;&lt;-&nbsp;books;&nbsp;b2&nbsp;&lt;-&nbsp;books&nbsp;<code class="vem">if</code>&nbsp;b1&nbsp;!=&nbsp;b2;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;&lt;-&nbsp;b1.authors;&nbsp;a2&nbsp;&lt;-&nbsp;b2.authors&nbsp;<code class="vem">if</code>&nbsp;a1&nbsp;==&nbsp;a2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;a1
  <code class="output">res6:&nbsp;List[String]&nbsp;=&nbsp;List(Ullman,&nbsp;Jeffrey,&nbsp;Ullman,&nbsp;Jeffrey)</code>
</pre>
      <p>The last solution is still not perfect because authors will appear several times in the list of results. You still need to remove duplicate authors from result lists. This can be achieved with the following function:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;removeDuplicates[A](xs:&nbsp;<code class="typename">List[A]</code>):&nbsp;<code class="typename">List[A]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(xs.isEmpty)&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.head&nbsp;::&nbsp;removeDuplicates(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.tail&nbsp;filter&nbsp;(x&nbsp;=&gt;&nbsp;x&nbsp;!=&nbsp;xs.head)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">removeDuplicates:&nbsp;[A](xs:&nbsp;List[A])List[A]</code>
  <br>  scala&gt;&nbsp;removeDuplicates(res6)
  <code class="output">res7:&nbsp;List[String]&nbsp;=&nbsp;List(Ullman,&nbsp;Jeffrey)</code>
</pre>
      <p>It's worth noting that the last expression in method <span class="code">removeDuplicates</span> can be equivalently expressed using a <span class="code">for</span> expression:</p> <pre>  xs.head&nbsp;::&nbsp;removeDuplicates(
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs.tail&nbsp;<code class="vem">if</code>&nbsp;x&nbsp;!=&nbsp;xs.head)&nbsp;<code class="vem">yield</code>&nbsp;x
  )
</pre>
      <h3>23.4 Translation of <span class="code">for</span> expressions</h3>
      <p>Every <span class="code">for</span> expression can be expressed in terms of the three higher-order functions <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span>. This section describes the translation scheme, which is also used by the Scala compiler.</p>
      <h4>Translating <span class="code">for</span> expressions with one generator</h4>
      <p>First, assume you have a simple <span class="code">for</span> expression:</p> <pre>  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>
</pre>
      <p>where <i>x</i> is a variable. Such an expression is translated to:</p> <pre>  <code style="font-style:italic">expr</code><sub>1</sub>.map(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>)
</pre>
      <h4>Translating <span class="code">for</span> expressions starting with a generator and a filter</h4>
      <p>Now, consider <span class="code">for</span> expressions that combine a leading generator with some other elements. A <span class="code">for</span> expression of the form:</p> <pre>  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>&nbsp;<code class="vem">if</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>
      <p>is translated to:</p> <pre>  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>))&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>
      <p>This translation gives another <span class="code">for</span> expression that is shorter by one element than the original, because an <span class="code">if</span> element is transformed into an application of <span class="code">withFilter</span> on the first generator expression. The translation then continues with this second expression, so in the end you obtain:</p> <pre>  <code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>)&nbsp;map&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>)
</pre>
      <p>The same translation scheme also applies if there are further elements following the filter. If <span style="font-style:italic">seq</span> is an arbitrary sequence of generators, definitions, and filters, then:</p> <pre>  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>&nbsp;<code class="vem">if</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>
      <p>is translated to:</p> <pre>  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>
      <p>Then translation continues with the second expression, which is again shorter by one element than the original one.</p>
      <h4>Translating <span class="code">for</span> expressions starting with two generators</h4>
      <p>The next case handles <span class="code">for</span> expressions that start with two generators, as in:</p> <pre>  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>;&nbsp;<i>y</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>
      <p>Again, assume that <span style="font-style:italic">seq</span> is an arbitrary sequence of generators, definitions, and filters. In fact, <span style="font-style:italic">seq</span> might also be empty, and in that case there would not be a semicolon after <span class="code"><span style="font-style:italic">expr</span><sub>2</sub></span>. The translation scheme stays the same in each case. The <span class="code">for</span> expression above is translated to an application of <span class="code">flatMap</span>:</p> <pre>  <code style="font-style:italic">expr</code><sub>1</sub>.flatMap(<i>x</i>&nbsp;=&gt;&nbsp;<code class="vem">for</code>&nbsp;(<i>y</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>)
</pre>
      <p>This time, there is another <span class="code">for</span> expression in the function value passed to <span class="code">flatMap</span>. That <span class="code">for</span> expression (which is again simpler by one element than the original) is in turn translated with the same rules.</p>
      <p>The three translation schemes given so far are sufficient to translate all <span class="code">for</span> expressions that contain just generators and filters, and where generators bind only simple variables. Take, for instance, the query, "find all authors who have published at least two books," from <a href="#sec-for-queries">Section 23.3</a>:</p> <pre>  <code class="vem">for</code>&nbsp;(b1&nbsp;&lt;-&nbsp;books;&nbsp;b2&nbsp;&lt;-&nbsp;books&nbsp;<code class="vem">if</code>&nbsp;b1&nbsp;!=&nbsp;b2;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;&lt;-&nbsp;b1.authors;&nbsp;a2&nbsp;&lt;-&nbsp;b2.authors&nbsp;<code class="vem">if</code>&nbsp;a1&nbsp;==&nbsp;a2)
  <code class="vem">yield</code>&nbsp;a1
</pre>
      <p>This query translates to the following <span class="code">map</span>/<span class="code">flatMap</span>/<span class="code">filter</span> combination:</p> <pre>  books&nbsp;flatMap&nbsp;(b1&nbsp;=&gt;
  &nbsp;&nbsp;books&nbsp;withFilter&nbsp;(b2&nbsp;=&gt;&nbsp;b1&nbsp;!=&nbsp;b2)&nbsp;flatMap&nbsp;(b2&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;b1.authors&nbsp;flatMap&nbsp;(a1&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b2.authors&nbsp;withFilter&nbsp;(a2&nbsp;=&gt;&nbsp;a1&nbsp;==&nbsp;a2)&nbsp;map&nbsp;(a2&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1))))
</pre>
      <p>The translation scheme presented so far does not yet handle generators that bind whole patterns instead of simple variables. It also does not yet cover definitions. These two aspects will be explained in the next two sub-sections.</p>
      <h4>Translating patterns in generators</h4>
      <p>The translation scheme becomes more complicated if the left hand side of generator is a pattern, <span style="font-style:italic">pat</span>, other than a simple variable. The case where the <span class="code">for</span> expression binds a tuple of variables is still relatively easy to handle. In that case, almost the same scheme as for single variables applies.</p>
      <p>A <span class="code">for</span> expression of the form:</p> <pre>  <code class="vem">for</code>&nbsp;((<i>x</i><sub>1</sub>,&nbsp;...,&nbsp;<i>x</i><sub>n</sub>)&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>
</pre>
      <p>translates to:</p> <pre>  <code style="font-style:italic">expr</code><sub>1</sub>.map&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;(<i>x</i><sub>1</sub>,&nbsp;...,&nbsp;<i>x</i><sub>n</sub>)&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>&nbsp;}
</pre>
      <p>Things become a bit more involved if the left hand side of the generator is an arbitrary pattern <span style="font-style:italic">pat</span> instead of a single variable or a tuple.</p>
      <p>In this case:</p> <pre>  <code class="vem">for</code>&nbsp;(<code style="font-style:italic">pat</code>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>
</pre>
      <p>translates to:</p> <pre>  <code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code style="font-style:italic">pat</code>&nbsp;=&gt;&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  }&nbsp;map&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code style="font-style:italic">pat</code>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>
  }
</pre>
      <p>That is, the generated items are first filtered and only those that match <span style="font-style:italic">pat</span> are mapped. Therefore, it's guaranteed that a pattern-matching generator will never throw a <span class="code">MatchError</span>.<a id="i797126047-2"></a></p>
      <p>The scheme here only treated the case where the <span class="code">for</span> expression contains a single pattern-matching generator. Analogous rules apply if the <span class="code">for</span> expression contains other generators, filters or definitions. Because these additional rules don't add much new insight, they are omitted from discussion here. If you are interested, you can look them up in the <em>Scala Language Specification</em> <a href="#sls">[Ode11]</a>.</p>
      <h4>Translating definitions</h4>
      <p>The last missing situation is where a <span class="code">for</span> expression contains embedded definitions. Here's a typical case:</p> <pre>  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>;&nbsp;<i>y</i>&nbsp;=&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<code style="font-style:italic">seq</code>)&nbsp;<code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>
      <p>Assume again that <span style="font-style:italic">seq</span> is a (possibly empty) sequence of generators, definitions, and filters. This expression is translated to this one:</p> <pre>  <code class="vem">for</code>&nbsp;((<i>x</i>,&nbsp;<i>y</i>)&nbsp;&lt;-&nbsp;<code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code class="vem">yield</code>&nbsp;(<i>x</i>,&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>);&nbsp;<code style="font-style:italic">seq</code>)&nbsp;
  <code class="vem">yield</code>&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>
</pre>
      <p>So you see that <span class="code"><span style="font-style:italic">expr</span><sub>2</sub></span> is evaluated each time there is a new <i>x</i> value being generated. This re-evaluation is necessary because <span class="code"><span style="font-style:italic">expr</span><sub>2</sub></span> might refer to <i>x</i> and so needs to be re-evaluated for changing values of <i>x</i>. For you as a programmer, the conclusion is that it's probably not a good idea to have definitions embedded in <span class="code">for</span> expressions that do not refer to variables bound by some preceding generator, because re-evaluating such expressions would be wasteful. For instance, instead of:</p> <pre>  <code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">1000</code>;&nbsp;y&nbsp;=&nbsp;expensiveComputationNotInvolvingX)
  <code class="vem">yield</code>&nbsp;x&nbsp;*&nbsp;y
</pre>
      <p>it's usually better to write:</p> <pre>  <code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;expensiveComputationNotInvolvingX
  <code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">1000</code>)&nbsp;<code class="vem">yield</code>&nbsp;x&nbsp;*&nbsp;y
</pre>
      <h4>Translating <span class="code">for</span> loops</h4>
      <p>The previous subsections showed how <span class="code">for</span> expressions that contain a <span class="code">yield</span> are translated.<a id="i-382847944-1"></a> What about <span class="code">for</span> loops that simply perform a side effect without returning anything? Their translation is similar, but simpler than <span class="code">for</span> expressions. In principle, wherever the previous translation scheme used a <span class="code">map</span> or a <span class="code">flatMap</span> in the translation, the translation scheme for <span class="code">for</span> loops uses just a <span class="code">foreach</span>.</p>
      <p>For instance, the expression:</p> <pre>  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>)&nbsp;<code style="font-style:italic">body</code>
</pre>
      <p>translates to:</p> <pre>  <code style="font-style:italic">expr</code><sub>1</sub>&nbsp;foreach&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">body</code>)
</pre>
      <p>A larger example is the expression:</p> <pre>  <code class="vem">for</code>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>1</sub>;&nbsp;<code class="vem">if</code>&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>;&nbsp;<i>y</i>&nbsp;&lt;-&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>)&nbsp;<code style="font-style:italic">body</code>
</pre>
      <p>This expression translates to:</p> <pre>  <code style="font-style:italic">expr</code><sub>1</sub>&nbsp;withFilter&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">expr</code><sub>2</sub>)&nbsp;foreach&nbsp;(<i>x</i>&nbsp;=&gt;
  &nbsp;&nbsp;<code style="font-style:italic">expr</code><sub>3</sub>&nbsp;foreach&nbsp;(<i>y</i>&nbsp;=&gt;&nbsp;<code style="font-style:italic">body</code>))
</pre>
      <p>For example, the following expression sums up all elements of a matrix represented as a list of lists:</p> <pre>  <code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="vem">for</code>&nbsp;(xs&nbsp;&lt;-&nbsp;xss;&nbsp;x&nbsp;&lt;-&nbsp;xs)&nbsp;sum&nbsp;+=&nbsp;x
</pre>
      <p>This loop is translated into two nested <span class="code">foreach</span> applications:</p> <pre>  <code class="vem">var</code>&nbsp;sum&nbsp;=&nbsp;<code class="literal">0</code>
  xss&nbsp;foreach&nbsp;(xs&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;xs&nbsp;foreach&nbsp;(x&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;x))
</pre>
      <h3>23.5 Going the other way</h3>
      <p>The previous section showed that <span class="code">for</span> expressions can be translated into applications of the higher-order functions <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span>. In fact, you could equally go the other way: Every application of a <span class="code">map</span>, <span class="code">flatMap</span>, or <span class="code">filter</span> can be represented as a <span class="code">for</span> expression.</p>
      <p>Here are implementations of the three methods in terms of <span class="code">for</span> expressions. The methods are contained in an object <span class="code">Demo</span> to distinguish them from the standard operations on <span class="code">List</span>s. To be concrete, the three functions all take a <span class="code">List</span> as parameter, but the translation scheme would work just as well with other collection types:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Demo</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[A,&nbsp;B](xs:&nbsp;<code class="typename">List[A]</code>,&nbsp;f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;<code class="typename">List[B]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;<code class="vem">yield</code>&nbsp;f(x)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;flatMap[A,&nbsp;B](xs:&nbsp;<code class="typename">List[A]</code>,&nbsp;f:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">List[B]</code>):&nbsp;<code class="typename">List[B]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs;&nbsp;y&nbsp;&lt;-&nbsp;f(x))&nbsp;<code class="vem">yield</code>&nbsp;y
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;filter[A](xs:&nbsp;<code class="typename">List[A]</code>,&nbsp;p:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;<code class="typename">List[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(x&nbsp;&lt;-&nbsp;xs&nbsp;<code class="vem">if</code>&nbsp;p(x))&nbsp;<code class="vem">yield</code>&nbsp;x
  }
</pre>
      <p>Not surprisingly, the translation of the <span class="code">for</span> expression used in the body of <span class="code">Demo.map</span> will produce a call to <span class="code">map</span> in class <span class="code">List</span>. Similarly, <span class="code">Demo.flatMap</span> and <span class="code">Demo.filter</span> translate to <span class="code">flatMap</span> and <span class="code">withFilter</span> in class <span class="code">List</span>. So this little demonstration shows that <span class="code">for</span> expressions really are equivalent in their expressiveness to applications of the three functions <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span>.</p>
      <h3>23.6 Generalizing <span class="code">for</span></h3>
      <p>Because the translation of <span class="code">for</span> expressions only relies on the presence of methods <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span>, it is possible to apply the <span class="code">for</span> notation to a large class of data types.</p>
      <p>You have already seen <span class="code">for</span> expressions over lists and arrays. These are supported because lists, as well as arrays, define operations <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span>. Because they define a <span class="code">foreach</span> method as well, <span class="code">for</span> loops over these data types are also possible.</p>
      <p>Besides lists and arrays, there are many other types in the Scala standard library that support the same four methods and therefore allow <span class="code">for</span> expressions. Examples are ranges, iterators, streams, and all implementations of sets.<a id="i2076162232-1"></a> It's also perfectly possible for your own data types to support <span class="code">for</span> expressions by defining the necessary methods. To support the full range of <span class="code">for</span> expressions and <span class="code">for</span> loops, you need to define <span class="code">map</span>, <span class="code">flatMap</span>, <span class="code">withFilter</span>, and <span class="code">foreach</span> as methods of your data type. But it's also possible to define a subset of these methods, and thereby support a subset of all possible <span class="code">for</span> expressions or loops.</p>
      <p>Here are the precise rules:</p>
      <ul>
        <li> If your type defines just <span class="code">map</span>, it allows <span class="code">for</span> expressions consisting of a single generator. </li>
        <li> If it defines <span class="code">flatMap</span> as well as <span class="code">map</span>, it allows <span class="code">for</span> expressions consisting of several generators. </li>
        <li> If it defines <span class="code">foreach</span>, it allows <span class="code">for</span> loops (both with single and multiple generators). </li>
        <li> If it defines <span class="code">withFilter</span>, it allows for filter expressions starting with an <span class="code">if</span> in the <span class="code">for</span> expression. </li>
      </ul>
      <p>The translation of <span class="code">for</span> expressions happens before type checking.<a id="i-1430360982-1"></a><a id="i746576009-1"></a> This allows for maximum flexibility because the only requirement is that the result of expanding a <span class="code">for</span> expression type checks. Scala defines no typing rules for the <span class="code">for</span> expressions themselves, and does not require that methods <span class="code">map</span>, <span class="code">flatMap</span>, <span class="code">withFilter</span>, or <span class="code">foreach</span> have any particular type signatures.</p>
      <p>Nevertheless, there is a typical setup that captures the most common intention of the higher order methods to which <span class="code">for</span> expressions translate. Say you have a parameterized class, <span class="code">C</span>, which typically would stand for some sort of collection. Then it's quite natural to pick the following type signatures for <span class="code">map</span>, <span class="code">flatMap</span>, <span class="code">withFilter</span>, and <span class="code">foreach</span>:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;C[A]&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;C[B]
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;flatMap[B](f:&nbsp;A&nbsp;=&gt;&nbsp;C[B]):&nbsp;C[B]
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;withFilter(p:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;C[A]
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;foreach(b:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">Unit</code>):&nbsp;<code class="typename">Unit</code>
  }
</pre>
      <p>That is, the <span class="code">map</span> function takes a function from the collection's element type <span class="code">A</span> to some other type <span class="code">B</span>. It produces a new collection of the same kind <span class="code">C</span>, but with <span class="code">B</span> as the element type. The <span class="code">flatMap</span> method takes a function <span class="code">f</span> from <span class="code">A</span> to some <span class="code">C</span>-collection of <span class="code">B</span>s and produces a <span class="code">C</span>-collection of <span class="code">B</span>s. The <span class="code">withFilter</span> method takes a predicate function from the collection's element type <span class="code">A</span> to <span class="code">Boolean</span>. It produces a collection of the same type as the one on which it is invoked. Finally, the <span class="code">foreach</span> method takes a function from <span class="code">A</span> to <span class="code">Unit</span> and produces a <span class="code">Unit</span> result:</p>
      <p>In class <span class="code">C</span> above, the <span class="code">withFilter</span> method produces a new collection of the same class. That means that every invocation of <span class="code">withFilter</span> creates a new <span class="code">C</span> object, just the same as <span class="code">filter</span> would work. Now, in the translation of for expressions, any calls to <span class="code">withFilter</span> are always followed by calls to one of the other three methods. Therefore, the object created by <span class="code">withFilter</span> will be taken apart by one of the other methods immediately afterwards. If objects of class <span class="code">C</span> are large (think long sequences), you might want to avoid the creation of such an intermediate object. A standard technique is to let <span class="code">withFilter</span> return not a <span class="code">C</span> object but just a wrapper object that "remembers" that elements need to be filtered before being processed further.</p>
      <p>Concentrating on just the first three functions of class <span class="code">C</span>, the following facts are noteworthy. In functional programming, there's a general concept called a <span style="font-style:italic">monad</span>, which can explain a large number of types with computations, ranging from collections, to computations with state and I/O, backtracking computations, and transactions, to name a few.<a id="i-1068505564-1"></a> You can formulate functions <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span> on a monad, and, if you do, they end up having exactly the types given here.</p>
      <p>Furthermore, you can characterize every monad by <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span>, plus a "unit" constructor that produces a monad from an element value. In an object-oriented language, this "unit" constructor is simply an instance constructor or a factory method. Therefore, <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span> can be seen as an object-oriented version of the functional concept of monad. Because <span class="code">for</span> expressions are equivalent to applications of these three methods, they can be seen as syntax for monads.</p>
      <p>All this suggests that the concept of <span class="code">for</span> expression is more general than just iteration over a collection, and indeed it is. For instance, <span class="code">for</span> expressions also play an important role in asynchronous I/O, or as an alternative notation for optional values. Watch out in the Scala libraries for occurrences of <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">withFilter</span>—when they are present, <span class="code">for</span> expressions suggest themselves as a concise way of manipulating elements of the type.</p>
      <h3>23.7 Conclusion</h3>
      <p>In this chapter, you were given a peek under the hood of <span class="code">for</span> expressions and <span class="code">for</span> loops. You learned that they translate into applications of a standard set of higher-order methods. As a result, you saw that <span class="code">for</span> expressions are really much more general than mere iterations over collections, and that you can design your own classes to support them.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-collections-in-depth">Chapter 24</a></h2>
      <h1>Collections in Depth</h1>
      <p>Scala includes an elegant and powerful collection library. Even though the collections API is subtle at first glance, the changes it can provoke in your programming style can be profound. Quite often it's as if you work on a higher level with the basic building blocks of a program being whole collections instead of their elements. This new style of programming requires some adaptation. Fortunately, the adaptation is helped by several nice properties of Scala collections. They are easy to use, concise, safe, fast, and universal. <a id="i1077226165-1"></a></p>
      <ul>
        <li><b>Easy to use:</b> A small vocabulary of twenty to fifty methods is enough to solve most collection problems in a couple of operations. No need to wrap your head around complicated looping structures or recursions. Persistent collections and side-effect-free operations mean that you need not worry about accidentally corrupting existing collections with new data. Interference between iterators and collection updates is eliminated. </li>
        <li><b>Concise:</b> You can achieve with a single word what used to take one or several loops. You can express functional operations with lightweight syntax and combine operations effortlessly, so that the result feels like a custom algebra. </li>
        <li><b>Safe:</b> This one has to be experienced to sink in. The statically typed and functional nature of Scala's collections means that the overwhelming majority of errors you might make are caught at compile-time. The reason is that (1) the collection operations themselves are heavily used and therefore well tested. (2) the usages of the collection operation make inputs and output explicit as function parameters and results. (3) These explicit inputs and outputs are subject to static type checking. The bottom line is that the large majority of misuses will manifest themselves as type errors. It's not at all uncommon to have programs of several hundred lines run at first try. </li>
        <li><b>Fast:</b> Collection operations are tuned and optimized in the libraries. As a result, using collections is typically quite efficient. You might be able to do a little bit better with carefully hand-tuned data structures and operations, but you might also do a lot worse by making some suboptimal implementation decisions along the way. What's more, collections have been adapted to parallel<a id="i-1874383620-2"></a><a id="i-1964267956-2"></a> execution on multi-cores. Parallel collections support the same operations as sequential ones, so no new operations need to be learned and no code needs to be rewritten. You can turn a sequential collection into a parallel one simply by invoking the <span class="code">par</span> method. </li>
        <li><b>Universal:</b> Collections provide the same operations on any type where it makes sense to do so. So you can achieve a lot with a fairly small vocabulary of operations. For instance, a string is conceptually a sequence of characters. Consequently, in Scala collections, strings support all sequence operations. The same holds for arrays. </li>
      </ul>
      <p>This chapter describes in depth the APIs of the Scala collection classes from a user perspective. You've already seen a quick tour of the collections library, in <a href="#chap-working-with-other-collections">Chapter 17</a>. This chapter takes you on a more detailed tour, showing all the collection classes and all the methods they define, so it includes everything you need to know to use Scala collections. Looking ahead, <a href="#chap-the-architecture-of-scala-collections">Chapter 25</a> will concentrate on the architecture and extensibility aspects of the library, for people implementing new collection types.</p>
      <h3>24.1 Mutable and immutable collections</h3>
      <p>As is now familiar to you, Scala collections systematically distinguish between mutable and immutable collections. A mutable collection can be updated or extended in place. This means you can change, add, or remove elements of a collection as a side effect. Immutable collections, by contrast, never change. You still have operations that simulate additions, removals, or updates, but those operations will in each case return a new collection and leave the old collection unchanged.</p>
      <p>All collection classes are found in the package <span class="code">scala.collection</span> or one of its subpackages: <span class="code">mutable</span>, <span class="code">immutable</span>, and <span class="code">generic</span>. Most collection classes needed by client code exist in three variants, each of which has different characteristics with respect to mutability. The three variants are located in packages <span class="code">scala.collection</span>, <span class="code">scala.collection.immutable</span>, and <span class="code">scala.collection.mutable</span>.</p>
      <p>A collection in package <span class="code">scala.collection.immutable</span> is guaranteed to be immutable for everyone. Such a collection will never change after it is created. Therefore, you can rely on the fact that accessing the same collection value repeatedly at different points in time will always yield a collection with the same elements.</p>
      <p>A collection in package <span class="code">scala.collection.mutable</span> is known to have some operations that change the collection in place. These operations let you write code to mutate the collection yourself. However, you must be careful to understand and defend against any updates performed by other parts of the code base.</p>
      <p>A collection in package <span class="code">scala.collection</span> can be either mutable or immutable. For instance, <span class="code">scala.collection.IndexedSeq[T]</span> is a supertrait of both <span class="code">scala.collection.immutable.IndexedSeq[T]</span> and its mutable sibling <span class="code">scala.collection.mutable.IndexedSeq[T]</span>. Generally, the root collections in package <span class="code">scala.collection</span> support transformation operations affecting the whole collection, such as <span class="code">map</span> and <span class="code">filter</span>. The immutable collections in package <span class="code">scala.collection.immutable</span> typically add operations for adding and removing single values, and the mutable collections in package <span class="code">scala.collection.mutable</span> add some side-effecting modification operations to the root interface.</p>
      <p>Another difference between root collections and immutable collections is that clients of an immutable collection have a guarantee that nobody can mutate the collection, whereas clients of a root collection only know that they can't change the collection themselves. Even though the static type of such a collection provides no operations for modifying the collection, it might still be possible that the run-time type is a mutable collection that can be changed by other clients.</p>
      <p>By default, Scala always picks immutable collections. For instance, if you just write <span class="code">Set</span> without any prefix or without having imported anything, you get an immutable set, and if you write <span class="code">Iterable</span> you get an immutable iterable, because these are the default bindings imported from the <span class="code">scala</span> package. To get the mutable default versions, you need to write explicitly <span class="code">collection.mutable.Set</span>, or <span class="code">collection.mutable.Iterable</span>.</p>
      <p>The last package in the collection hierarchy is <span class="code">collection.generic</span>. This package contains building blocks for abstracting over concrete collections. Everyday users of the collection framework should need to refer to classes in <span class="code">generic</span> only in exceptional circumstances.</p>
      <p><a id="fig-coll-hierarchy"></a></p> <pre>  Iterable
      Seq
          IndexedSeq
              ArraySeq
              Vector
              ArrayDeque (mutable)
              Queue (mutable)
              Stack (mutable)
              Range
              NumericRange
          LinearSeq
              List
              LazyList
              Queue (immutable)
          Buffer
              ListBuffer
              ArrayBuffer
      Set
          SortedSet
              TreeSet
          HashSet (mutable)
          LinkedHashSet
          HashSet (immutable)
          BitSet
          EmptySet, Set1, Set2, Set3, Set4
      Map
          SortedMap
              TreeMap
          HashMap (mutable)
          LinkedHashMap (mutable)
          HashMap (immutable)
          VectorMap (immutable)
          EmptyMap, Map1, Map2, Map3, Map4
</pre>
      <h5>Collection hierarchy.</h5>
      <h3>24.2 Collections consistency</h3>
      <p>The most important collection classes are shown in <a href="#fig-coll-hierarchy">Figure 24.1</a>. There is quite a bit of commonality shared by all these classes. For instance, every kind of collection can be created by the same uniform syntax, writing the collection class name followed by its elements:</p> <pre>  <code class="typename">Iterable</code>(<code class="quotedstring">"x"</code>,&nbsp;<code class="quotedstring">"y"</code>,&nbsp;<code class="quotedstring">"z"</code>)
  <code class="typename">Map</code>(<code class="quotedstring">"x"</code>&nbsp;-&gt;&nbsp;<code class="literal">24</code>,&nbsp;<code class="quotedstring">"y"</code>&nbsp;-&gt;&nbsp;<code class="literal">25</code>,&nbsp;<code class="quotedstring">"z"</code>&nbsp;-&gt;&nbsp;<code class="literal">26</code>)
  <code class="typename">Set</code>(<code class="typename">Color.Red</code>,&nbsp;<code class="typename">Color.Green</code>,&nbsp;<code class="typename">Color.Blue</code>)
  <code class="typename">SortedSet</code>(<code class="quotedstring">"hello"</code>,&nbsp;<code class="quotedstring">"world"</code>)
  <code class="typename">Buffer</code>(x,&nbsp;y,&nbsp;z)
  <code class="typename">IndexedSeq</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)
  <code class="typename">LinearSeq</code>(a,&nbsp;b,&nbsp;c)
</pre>
      <p>The same principle also applies for specific collection implementations:</p> <pre>  <code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="typename">HashMap</code>(<code class="quotedstring">"x"</code>&nbsp;-&gt;&nbsp;<code class="literal">24</code>,&nbsp;<code class="quotedstring">"y"</code>&nbsp;-&gt;&nbsp;<code class="literal">25</code>,&nbsp;<code class="quotedstring">"z"</code>&nbsp;-&gt;&nbsp;<code class="literal">26</code>)
</pre>
      <p>The <span class="code">toString</span> methods for all collections produce output written as above, with a type name followed by the elements of the collection in parentheses. All collections support the API provided by <span class="code">Iterable</span>, but their methods all return their own class rather than the root class <span class="code">Iterable</span>. For instance, the <span class="code">map</span> method on <span class="code">List</span> has a return type of <span class="code">List</span>, whereas the <span class="code">map</span> method on <span class="code">Set</span> has a return type of <span class="code">Set</span>. Thus the static return type of these methods is fairly precise:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)
  <code class="output">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;3,&nbsp;4)</code>
  <br>  scala&gt;&nbsp;<code class="typename">Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res1:&nbsp;scala.collection.immutable.Set[Int]&nbsp;=&nbsp;Set(2,&nbsp;4,&nbsp;6)</code>
</pre>
      <p>Equality is also organized uniformly for all collection classes; more on this in <a href="#sec-coll-arch-eq">Section 24.12</a>.</p>
      <p>Most of the classes in <a href="#fig-coll-hierarchy">Figure 24.1</a> exist in three variants: root, mutable, and immutable. The only exception is the <span class="code">Buffer</span> trait, which only exists as a mutable collection.</p>
      <p>In the remainder of this chapter, we will review these classes one by one.</p>
      <h3>24.3 Trait <span class="code">Iterable</span></h3>
      <p>At the top of the collection hierarchy is trait <span class="code">Iterable[A]</span>, where <span class="code">A</span> is the type of the collection's elements. All methods in this trait are defined in terms of an abstract method, <span class="code">iterator</span>, which yields the collection's elements one by one.</p> <pre>  <code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[A]</code>&nbsp;
</pre>
      <p>Collection classes implementing <span class="code">Iterable</span> just need to define this single method; all other methods can be inherited from <span class="code">Iterable</span>.</p>
      <p><span class="code">Iterable</span> also defines many concrete methods, which are all listed in <a href="#tab-iterableops">Table 24.1</a> <a href="#tab-iterableops">here</a>. These methods fall into the following categories:</p>
      <ul>
        <li><b><span style="font-style:italic">Iteration operations</span></b> <span class="code">foreach</span>, <span class="code">grouped</span>, <span class="code">sliding</span>, which iterate through the elements of the collection in the order defined by its iterator. The <span class="code">grouped</span> and <span class="code">sliding</span> methods return iterators that, rather than returning single elements, return subsequences of elements of the original collection. The maximal size of these subsequences is given as an argument to these methods. The <span class="code">grouped</span> method chunks its elements into increments, whereas <span class="code">sliding</span> yields a sliding window over the elements. The difference between the two should become clear by looking at the following interpreter interaction: <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;xs&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>)
  <code class="output">xs:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;git&nbsp;=&nbsp;xs&nbsp;grouped&nbsp;<code class="literal">3</code>
  <code class="output">git:&nbsp;Iterator[List[Int]]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br>  scala&gt;&nbsp;git.next()
  <code class="output">res2:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;git.next()
  <code class="output">res3:&nbsp;List[Int]&nbsp;=&nbsp;List(4,&nbsp;5)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;sit&nbsp;=&nbsp;xs&nbsp;sliding&nbsp;<code class="literal">3</code>
  <code class="output">sit:&nbsp;Iterator[List[Int]]&nbsp;=&nbsp;non-empty&nbsp;iterator</code>
  <br>  scala&gt;&nbsp;sit.next()
  <code class="output">res4:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;sit.next()
  <code class="output">res5:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;3,&nbsp;4)</code>
  <br>  scala&gt;&nbsp;sit.next()
  <code class="output">res6:&nbsp;List[Int]&nbsp;=&nbsp;List(3,&nbsp;4,&nbsp;5)</code>
</pre> </li>
        <li><b><span style="font-style:italic">Addition</span></b> <span class="code">++</span> (alias, <span class="code">concat</span>), which appends two collections together, or appends all elements of an iterator to a collection. </li>
        <li><b><span style="font-style:italic">Map</span> <em>operations</em></b> <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">collect</span>, which produce a new collection by applying some function to collection elements. </li>
        <li><b><span style="font-style:italic">Conversions</span></b> <span class="code">toIndexedSeq</span>, <span class="code">toIterable</span>, <span class="code">toList</span>, <span class="code">toMap</span>, <span class="code">toSeq</span>, <span class="code">toSet</span>, and <span class="code">toVector</span>, which turn an <span class="code">Iterable</span> collection into an immutable collection. All these conversions return the receiver object if it already matches the demanded collection type. For instance, applying <span class="code">toList</span> to a list will yield the list itself. The <span class="code">toArray</span> and <span class="code">toBuffer</span> methods return a new mutable collection, even if the receiver object already matches. The <span class="code">to</span> method can be used to convert to any other collection.<a id="i595962916-2"></a> </li>
        <li><b><span style="font-style:italic">Copying operations</span></b> <span class="code">copyToArray</span>. As its name implies, this copies collection elements to an array. </li>
        <li><b><span style="font-style:italic">Size operations</span></b> <span class="code">isEmpty</span>, <span class="code">nonEmpty</span>, <span class="code">size</span>, <span class="code">knownSize</span>, <span class="code">sizeCompare</span>, and <span class="code">sizeIs</span>, which deal with a collection's size. Computing the number of elements of a collection can require a traversal in some cases, such as <span class="code">List</span>. In other cases the collection can have an infinite number of elements, for example, <span class="code">LazyList.from(0)</span>. The <span class="code">knownSize</span>, <span class="code">sizeCompare</span>, and <span class="code">sizeIs</span> methods give information about the number of elements while traversing as few of the elements as possible. </li>
        <li><b><span style="font-style:italic">Element retrieval operations</span></b> <span class="code">head</span>, <span class="code">last</span>, <span class="code">headOption</span>, <span class="code">lastOption</span>, and <span class="code">find</span>. These select the first or last element of a collection, or else the first element matching a condition. Note, however, that not all collections have a well-defined meaning of what "first" and "last" means. For instance, a hash set might store elements according to their hash keys, which might change from run to run. In that case, the "first" element of a hash set could also be different for different runs of a program. A collection is <span style="font-style:italic">ordered</span> if it always yields its elements in the same order. Most collections are ordered, but some (such as hash sets) are not—dropping the ordering provides a little bit of extra efficiency. Ordering is often essential to give reproducible tests and help in debugging. That's why Scala collections provide ordered alternatives for all collection types. For instance, the ordered alternative for <span class="code">HashSet</span> is <span class="code">LinkedHashSet</span>. </li>
        <li><b><span style="font-style:italic">Subcollection retrieval</span> <em>operations</em></b> <span class="code">takeWhile</span>, <span class="code">tail</span>, <span class="code">init</span>, <span class="code">slice</span>, <span class="code">take</span>, <span class="code">drop</span>, <span class="code">filter</span>, <span class="code">dropWhile</span>, <span class="code">filterNot</span>, and <span class="code">withFilter</span>. These all return some subcollection identified by an index range or a predicate. </li>
        <li><b><span style="font-style:italic">Subdivision</span> <em>operations</em></b> <span class="code">groupBy</span>, <span class="code">groupMap</span>, <span class="code">groupMapReduce</span>, <span class="code">splitAt</span>, <span class="code">span</span>, <span class="code">partition</span>, and <span class="code">partitionMap</span>, which split the elements of this collection into several subcollections. </li>
        <li><b><span style="font-style:italic">Element tests</span></b> <span class="code">exists</span>, <span class="code">forall</span>, and <span class="code">count</span>, which test collection elements with a given predicate. </li>
        <li><b><span style="font-style:italic">Folds</span></b> <span class="code">foldLeft</span>, <span class="code">foldRight</span>, <span class="code">reduceLeft</span>, <span class="code">reduceRight</span>, which apply a binary operation to successive elements. </li>
        <li><b><span style="font-style:italic">Specific folds</span></b> <span class="code">sum</span>, <span class="code">product</span>, <span class="code">min</span>, and <span class="code">max</span>, which work on collections of specific types (numeric or comparable). </li>
        <li><b><span style="font-style:italic">String operations</span></b> <span class="code">mkString</span> and <span class="code">addString</span>, which offer alternative ways of converting a collection to a string. </li>
        <li><b><span style="font-style:italic">View operation</span></b> A view is a collection that's evaluated lazily. You'll learn more about views in <a href="#sec-views">Section 24.13</a>. </li>
      </ul>
      <p><a id="tab-iterableops"></a></p>
      <h5>Operations in trait <span class="code">Iterable</span></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Abstract method:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.iterator</span> </td>
            <td> An iterator that yields every element in <span class="code">xs</span>. <a id="i1960545726-1"></a> <a id="i-2123398051-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Iteration:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">foreach</span>&nbsp;<span class="code">f</span> </td>
            <td> Executes function <span class="code">f</span> for every element of <span class="code">xs</span>. The invocation of <span class="code">f</span> is done for its side effect only; in fact any function result of <span class="code">f</span> is discarded by <span class="code">foreach</span>. <a id="i184430613-1"></a> <a id="i1432431739-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">grouped</span>&nbsp;<span class="code">size</span> </td>
            <td> An iterator that yields fixed-sized "chunks" of this collection. <a id="i1434663977-1"></a> <a id="i-1891423857-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">sliding</span>&nbsp;<span class="code">size</span> </td>
            <td> An iterator that yields a sliding fixed-sized window of elements in this collection. <a id="i-2085639431-1"></a> <a id="i-9143201-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Addition:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">ys</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">concat</span>&nbsp;<span class="code">ys</span>) </td>
            <td> A collection consisting of the elements of both <span class="code">xs</span> and <span class="code">ys</span>. <span class="code">ys</span> is an <span class="code">IterableOnce</span> collection, <i>i.e.</i>, either an <span class="code">Iterable</span> or an <span class="code">Iterator</span>. <a id="i-1810495967-1"></a> <a id="i850530942-1"></a> <a id="i340156760-1"></a> <a id="i-1517341511-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Maps:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">f</span> </td>
            <td> The collection obtained from applying the function <span class="code">f</span> to every element in <span class="code">xs</span>. <a id="i519692455-1"></a> <a id="i-379703283-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">flatMap</span>&nbsp;<span class="code">f</span> </td>
            <td> The collection obtained from applying the collection-valued function <span class="code">f</span> to every element in <span class="code">xs</span> and concatenating the results. <a id="i1033804009-1"></a> <a id="i1331272020-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">collect</span>&nbsp;<span class="code">f</span> </td>
            <td> The collection obtained from applying the partial function <span class="code">f</span> to every element in <span class="code">xs</span> for which it is defined and collecting the results. <a id="i1841780469-1"></a> <a id="i-1235408037-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Conversions:<!-- \hfill --> </span> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.toArray</span> </td>
            <td> Converts the collection to an array. <a id="i-1609624215-1"></a> <a id="i927732431-1"></a> <a id="i595962916-3"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.toList</span> </td>
            <td> Converts the collection to a list. <a id="i1203752644-1"></a> <a id="i1415719272-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.toIterable</span> </td>
            <td> Converts the collection to an iterable. <a id="i1067113496-1"></a> <a id="i-1857173444-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.toSeq</span> </td>
            <td> Converts the collection to a sequence. <a id="i-1379204817-1"></a> <a id="i184222293-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.toIndexedSeq</span> </td>
            <td> Converts the collection to an indexed sequence. <a id="i-1069759596-1"></a> <a id="i188072696-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.toSet</span> </td>
            <td> Converts the collection to a set. <a id="i1505637234-1"></a> <a id="i184222296-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.toMap</span> </td>
            <td> Converts a collection of key/value pairs to a map. <a id="i-1185515540-1"></a> <a id="i184216402-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">SortedSet</span> </td>
            <td> Generic conversion operation that takes a collection factory as parameter. <a id="i774377734-1"></a> <a id="i-427890262-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Copying:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.copyToArray(arr,</span>&nbsp;<span class="code">s,</span>&nbsp;<span class="code">len)</span> </td>
            <td> Copies at most <span class="code">len</span> elements to <span class="code">arr</span>, starting at index <span class="code">s</span>. The last two arguments are optional. <a id="i-913984797-1"></a> <a id="i-924181222-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Size info:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.isEmpty</span> </td>
            <td> Tests whether the collection is empty. <a id="i900893390-1"></a> <a id="i-126813068-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.nonEmpty</span> </td>
            <td> Tests whether the collection contains elements. <a id="i-1015678773-1"></a> <a id="i-1925374353-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.size</span> </td>
            <td> The number of elements in the collection. <a id="i-717658356-1"></a> <a id="i1114286960-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.knownSize</span> </td>
            <td> The number of elements if it can be computed in constant time, else <span class="code">-1</span>. <a id="i-622813393-1"></a> <a id="i2146533333-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">sizeCompare</span>&nbsp;<span class="code">ys</span> </td>
            <td> Returns a negative value if <span class="code">xs</span> is shorter than the <span class="code">ys</span> collection, a positive value if it is longer, and <span class="code">0</span> if they have the same size. Works even if the collection is infinite. <a id="i-1999564049-1"></a> <a id="i-1984795819-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.sizeIs</span>&nbsp;<span class="code">&lt;</span>&nbsp;<span class="code">42</span>, </td>
          </tr>
          <tr>
            <td> <span class="code">xs.sizeIs</span>&nbsp;<span class="code">!=</span>&nbsp;<span class="code">42</span>, <i>etc.</i> </td>
            <td> Compares the size of the collection with the given value while traversing as few elements as possible. <a id="i4578198-1"></a> <a id="i1382914234-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Element retrieval:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.head</span> </td>
            <td> The first element of the collection (or, some element, if no order is defined). <a id="i1792257067-1"></a> <a id="i1113954639-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.headOption</span> </td>
            <td> The first element of <span class="code">xs</span> in an option value, or <span class="code">None</span> if <span class="code">xs</span> is empty. <a id="i-872351616-1"></a> <a id="i-1672833372-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.last</span> </td>
            <td> The last element of the collection (or, some element, if no order is defined). <a id="i1275746657-1"></a> <a id="i1114070533-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.lastOption</span> </td>
            <td> The last element of <span class="code">xs</span> in an option value, or <span class="code">None</span> if <span class="code">xs</span> is empty. <a id="i726820150-1"></a> <a id="i-1198032166-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">find</span>&nbsp;<span class="code">p</span> </td>
            <td> An option containing the first element in <span class="code">xs</span> that satisfies <span class="code">p</span>, or <span class="code">None</span> if no element qualifies. <a id="i-1339535725-1"></a> <a id="i1113899304-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Subcollections:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.tail</span> </td>
            <td> The rest of the collection except <span class="code">xs.head</span>. <a id="i515696283-1"></a> <a id="i1114308543-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.init</span> </td>
            <td> The rest of the collection except <span class="code">xs.last</span>. <a id="i-85416101-1"></a> <a id="i1113993343-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.slice(from,</span>&nbsp;<span class="code">to)</span> </td>
            <td> A collection consisting of elements in some index range of <span class="code">xs</span> (from <span class="code">from</span>, up to and excluding <span class="code">to</span>). <a id="i-1840578211-1"></a> <a id="i183230467-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n</span> </td>
            <td> A collection consisting of the first <span class="code">n</span> elements of <span class="code">xs</span> (or, some arbitrary <span class="code">n</span> elements, if no order is defined). <a id="i1283969285-1"></a> <a id="i1114308598-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n</span> </td>
            <td> The rest of the collection except <span class="code">xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n</span>. <a id="i1550502010-1"></a> <a id="i1113848414-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p</span> </td>
            <td> The longest prefix of elements in the collection that all satisfy <span class="code">p</span>. <a id="i2060831170-1"></a> <a id="i2086626523-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">dropWhile</span>&nbsp;<span class="code">p</span> </td>
            <td> The collection without the longest prefix of elements that all satisfy <span class="code">p</span>. <a id="i-241169366-1"></a> <a id="i74099571-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">takeRight</span>&nbsp;<span class="code">n</span> </td>
            <td> A collection consisting of the last <span class="code">n</span> elements of <span class="code">xs</span> (or, some arbitrary <span class="code">n</span> elements, if no order is defined). <a id="i-1293058080-1"></a> <a id="i2082036678-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">dropRight</span>&nbsp;<span class="code">n</span> </td>
            <td> The rest of the collection except <span class="code">xs</span>&nbsp;<span class="code">takeRight</span>&nbsp;<span class="code">n</span>. <a id="i636434552-1"></a> <a id="i69509726-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p</span> </td>
            <td> The collection consisting of those elements of <span class="code">xs</span> that satisfy the predicate <span class="code">p</span>. <a id="i-1784980541-1"></a> <a id="i1010333479-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">withFilter</span>&nbsp;<span class="code">p</span> </td>
            <td> A non-strict filter of this collection. All operations on the resulting filter will only apply to those elements of <span class="code">xs</span> for which the condition <span class="code">p</span> is true. <a id="i-1712949079-1"></a> <a id="i-1221101555-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">filterNot</span>&nbsp;<span class="code">p</span> </td>
            <td> The collection consisting of those elements of <span class="code">xs</span> that do not satisfy the predicate <span class="code">p</span>. <a id="i-1795201338-1"></a> <a id="i-286058964-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Zippers:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">zip</span>&nbsp;<span class="code">ys</span> </td>
            <td> An iterable of pairs of corresponding elements from <span class="code">xs</span> and <span class="code">ys</span>. <a id="i-1097812436-1"></a> <a id="i-379690542-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">lazyZip</span>&nbsp;<span class="code">ys</span> </td>
            <td> A value providing methods for manipulating the <span class="code">xs</span> and <span class="code">ys</span> collections element-wise. See <a href="#sec-lists-zipped">Section 16.9</a>. <a id="i-1905510632-1"></a> <a id="i2069655870-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.zipAll(ys,</span>&nbsp;<span class="code">x,</span>&nbsp;<span class="code">y)</span> </td>
            <td> An iterable of pairs of corresponding elements from <span class="code">xs</span> and <span class="code">ys</span>, where the shorter sequence is extended to match the longer one by appending elements <span class="code">x</span> or <span class="code">y</span>. <a id="i1056526603-1"></a> <a id="i1582986863-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.zipWithIndex</span> </td>
            <td> An iterable of pairs of elements from <span class="code">xs</span> with their indices. <a id="i628301846-1"></a> <a id="i-1524777478-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Subdivisions:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">splitAt</span>&nbsp;<span class="code">n</span> </td>
            <td> Splits <span class="code">xs</span> at a position, giving the pair of collections <span class="code">(xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n,</span>&nbsp;<span class="code">xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n)</span>. <a id="i-1809798433-1"></a> <a id="i108302110-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">span</span>&nbsp;<span class="code">p</span> </td>
            <td> Splits <span class="code">xs</span> according to a predicate, giving the pair of collections <span class="code">(xs</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p,</span> <span class="code">xs.dropWhile</span>&nbsp;<span class="code">p)</span>. <a id="i-1964828318-1"></a> <a id="i1114292921-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">partition</span>&nbsp;<span class="code">p</span> </td>
            <td> Splits <span class="code">xs</span> into a pair of collections; one with elements that satisfy the predicate <span class="code">p</span>, the other with elements that do not, giving the pair of collections <span class="code">(xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p,</span>&nbsp;<span class="code">xs.filterNot</span>&nbsp;<span class="code">p)</span>. <a id="i4331970-1"></a> <a id="i-1204480805-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">partitionMap</span>&nbsp;<span class="code">f</span> </td>
            <td> Transforms each element of <span class="code">xs</span> into an <span class="code">Either[X,</span>&nbsp;<span class="code">Y]</span> value, and splits them into a pair of collections, one with elements contained in <span class="code">Left</span>, the other with elements contained in <span class="code">Right</span>. <a id="i1135350170-1"></a> <a id="i1764173441-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">groupBy</span>&nbsp;<span class="code">f</span> </td>
            <td> Partitions <span class="code">xs</span> into a map of collections according to a discriminator function <span class="code">f</span>. <a id="i479566337-1"></a> <a id="i-1891424921-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.groupMap(f)(g)</span> </td>
            <td> Partitions <span class="code">xs</span> into a map of collections according to a discriminator function <span class="code">f</span>, and applies the transformation function <span class="code">g</span> to every element of each collection. <a id="i2108767848-1"></a> <a id="i1495379532-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.groupMapReduce(f)(g)(h)</span> </td>
            <td> Partitions <span class="code">xs</span> into a map of collections according to a discriminator function <span class="code">f</span>, applies the transformation function <span class="code">g</span> to every element of each collection, and reduces each collection to a single value by combining their elements with the <span class="code">h</span> function. <a id="i-1214031186-1"></a> <a id="i-22239534-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Element conditions:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">forall</span>&nbsp;<span class="code">p</span> </td>
            <td> A boolean indicating whether the predicate <span class="code">p</span> holds for all elements of <span class="code">xs</span>. <a id="i1140780163-1"></a> <a id="i1016035303-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">exists</span>&nbsp;<span class="code">p</span> </td>
            <td> A boolean indicating whether the predicate <span class="code">p</span> holds for some element in <span class="code">xs</span>. <a id="i1900638119-1"></a> <a id="i995467275-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">count</span>&nbsp;<span class="code">p</span> </td>
            <td> The number of elements in <span class="code">xs</span> that satisfy the predicate <span class="code">p</span>. <a id="i-365002086-1"></a> <a id="i168555392-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Folds:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.foldLeft(z)(op)</span> </td>
            <td> Applies binary operation <span class="code">op</span> between successive elements of <span class="code">xs</span>, going left to right, starting with <span class="code">z</span>. <a id="i-85880764-1"></a> <a id="i1282388887-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.foldRight(z)(op)</span> </td>
            <td> Applies binary operation <span class="code">op</span> between successive elements of <span class="code">xs</span>, going right to left, starting with <span class="code">z</span>. <a id="i-1598724495-1"></a> <a id="i1105010828-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">reduceLeft</span>&nbsp;<span class="code">op</span> </td>
            <td> Applies binary operation <span class="code">op</span> between successive elements of non-empty collection <span class="code">xs</span>, going left to right. <a id="i1370613055-1"></a> <a id="i59384508-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">reduceRight</span>&nbsp;<span class="code">op</span> </td>
            <td> Applies binary operation <span class="code">op</span> between successive elements of non-empty collection <span class="code">xs</span>, going right to left. <a id="i-1161010399-1"></a> <a id="i1846580743-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Specific folds:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.sum</span> </td>
            <td> The sum of the numeric element values of collection <span class="code">xs</span>. <a id="i993696982-1"></a> <a id="i-379696900-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.product</span> </td>
            <td> The product of the numeric element values of collection <span class="code">xs</span>. <a id="i950003322-1"></a> <a id="i1800640288-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.min</span> </td>
            <td> The minimum of the ordered element values of collection <span class="code">xs</span>. <a id="i853539357-1"></a> <a id="i-379703037-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.max</span> </td>
            <td> The maximum of the ordered element values of collection <span class="code">xs</span>. <a id="i-377330001-1"></a> <a id="i-379703275-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Strings:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.addString(b,</span>&nbsp;<span class="code">start,</span> </td>
          </tr>
          <tr>
            <td> <span class="code">sep,</span>&nbsp;<span class="code">end)</span> </td>
            <td> Adds a string to <span class="code">StringBuilder</span> <span class="code">b</span> that shows all elements of <span class="code">xs</span> between separators <span class="code">sep</span> enclosed in strings <span class="code">start</span> and <span class="code">end</span>. <span class="code">start</span>, <span class="code">sep</span>, and <span class="code">end</span> are all optional. <a id="i1233224602-1"></a> <a id="i596183555-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.mkString(start,</span> </td>
          </tr>
          <tr>
            <td> <span class="code">sep,</span>&nbsp;<span class="code">end)</span> </td>
            <td> Converts the collection to a string that shows all elements of <span class="code">xs</span> between separators <span class="code">sep</span> enclosed in strings <span class="code">start</span> and <span class="code">end</span>. <span class="code">start</span>, <span class="code">sep</span>, and <span class="code">end</span> are all optional. <a id="i1043598554-2"></a> <a id="i642295614-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">View:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.view</span> </td>
            <td> Produces a view over <span class="code">xs</span>. <a id="i499973296-1"></a> <a id="i1114375700-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <h4>Subcategories of <span class="code">Iterable</span></h4>
      <p>In the inheritance hierarchy below <span class="code">Iterable</span> you find three traits: <span class="code">Seq</span>, <span class="code">Set</span>, and <span class="code">Map</span>. A common aspect of <span class="code">Seq</span> and <span class="code">Map</span> is that they both implement the <span class="code">PartialFunction</span> trait<a href="#footnotemain24-1">[1]</a> with its <span class="code">apply</span> and <span class="code">isDefinedAt</span> methods. However, the way each trait implements <span class="code">PartialFunction</span> differs.</p>
      <p>For sequences, <span class="code">apply</span> is positional indexing, where elements are always numbered from <span class="code">0</span>. That is, <span class="code">Seq(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)(1)</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">2</span>. For sets, <span class="code">apply</span> is a membership test. For instance, <span class="code">Set('a',</span>&nbsp;<span class="code">'b',</span>&nbsp;<span class="code">'c')('b')</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">true</span> whereas <span class="code">Set()('a')</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">false</span>. Finally for maps, <span class="code">apply</span> is a selection. For instance, <span class="code">Map('a'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1,</span>&nbsp;<span class="code">'b'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">10,</span>&nbsp;<span class="code">'c'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">100)('b')</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">10</span>.</p>
      <p>In the following three sections, we will explain each of the three kinds of collections in more detail.</p>
      <h3>24.4 The sequence traits <span class="code">Seq</span>, <span class="code">IndexedSeq</span>, and <span class="code">LinearSeq</span></h3>
      <p>The <span class="code">Seq</span> trait represents sequences. A sequence is a kind of iterable that has a <span class="code">length</span> and whose elements have fixed index positions, starting from <span class="code">0</span>.</p>
      <p>The operations on sequences, summarized in <a href="#tab-seqops">Figure 24.2</a>, fall into the following categories:</p>
      <ul>
        <li><b><span style="font-style:italic">Indexing and length operations</span></b> <span class="code">apply</span>, <span class="code">isDefinedAt</span>, <span class="code">length</span>, <span class="code">indices</span>, <span class="code">lengthCompare</span>, and <span class="code">lengthIs</span>. For a <span class="code">Seq</span>, <span class="code">apply</span> means indexing; hence a sequence of type <span class="code">Seq[T]</span> is a partial function that takes an <span class="code">Int</span> argument (an index) and yields a sequence element of type <span class="code">T</span>. In other words <span class="code">Seq[T]</span> extends <span class="code">PartialFunction[Int,</span>&nbsp;<span class="code">T]</span>. The elements of a sequence are indexed from zero up to the <span class="code">length</span> of the sequence minus one. The <span class="code">length</span> method on sequences is an alias of the <span class="code">size</span> method of general collections. The <span class="code">lengthCompare</span> method allows you to compare the lengths of two sequences even if one of the sequences has infinite length. The <span class="code">lengthIs</span> method is an alias of the <span class="code">sizeIs</span> method. </li>
        <li><b><span style="font-style:italic">Index search</span> <em>operations</em></b> <span class="code">indexOf</span>, <span class="code">lastIndexOf</span>, <span class="code">indexOfSlice</span>, <span class="code">lastIn</span>- <span class="code">dexOfSlice</span>, <span class="code">indexWhere</span>, <span class="code">lastIndexWhere</span>, <span class="code">segmentLength</span>, and <span class="code">prefixLength</span>, which return the index of an element equal to a given value or matching some predicate. </li>
        <li><b><span style="font-style:italic">Addition</span> <em>operations</em></b> <span class="code">+:</span> (alias, <span class="code">prepended</span>), <span class="code">++:</span> (alias, <span class="code">prependedAll</span>), <span class="code">:+</span> (alias, <span class="code">appended</span>), <span class="code">:++</span> (alias, <span class="code">appendedAll</span>), and <span class="code">padTo</span>, which return new sequences obtained by adding elements at the front or the end of a sequence. </li>
        <li><b><span style="font-style:italic">Update operations</span></b> <span class="code">updated</span> and <span class="code">patch</span>, which return a new sequence obtained by replacing some elements of the original sequence. </li>
        <li><b><span style="font-style:italic">Sorting operations</span></b> <span class="code">sorted</span>, <span class="code">sortWith</span>, and <span class="code">sortBy</span>, which sort sequence elements according to various criteria. </li>
        <li><b><span style="font-style:italic">Reversal operations</span></b> <span class="code">reverse</span> and <span class="code">reverseIterator</span>, which sequence or yield elements in reverse order, from last to first. </li>
        <li><b><span style="font-style:italic">Comparison operations</span></b> <span class="code">startsWith</span>, <span class="code">endsWith</span>, <span class="code">contains</span>, <span class="code">corresponds</span> <span class="code">containsSlice</span>, and <span class="code">search</span>, which relate two sequences or search<a id="i-1353253722-1"></a><a id="i71531844-1"></a> an element in a sequence. </li>
        <li><b><span style="font-style:italic">Multiset operations</span></b> <span class="code">intersect</span>, <span class="code">diff</span>, <span class="code">distinct</span>, and <span class="code">distinctBy</span>, which perform set-like operations on the elements of two sequences or remove duplicates. </li>
      </ul>
      <p>If a sequence is mutable, it offers in addition a side-effecting <span class="code">update</span> method, which lets sequence elements be updated. Recall from <a href="#chap-next-steps-in-scala">Chapter 3</a> that syntax like <span class="code">seq(idx)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">elem</span> is just a shorthand for <span class="code">seq.update(idx,</span>&nbsp;<span class="code">elem)</span>. Note the difference between <span class="code">update</span> and <span class="code">updated</span>. The <span class="code">update</span> method changes a sequence element in place, and is only available for mutable sequences. The <span class="code">updated</span> method is available for all sequences and always returns a new sequence instead of modifying the original.</p>
      <p><a id="tab-seqops"></a></p>
      <h5>Operations in trait <span class="code">Seq</span> <a id="i2004738302-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Indexing and length:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs(i)</span> </td>
            <td> (or, written out, <span class="code">xs</span>&nbsp;<span class="code">apply</span>&nbsp;<span class="code">i</span>) The element of <span class="code">xs</span> at index <span class="code">i</span>. <a id="i972576416-1"></a> <a id="i540215378-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">isDefinedAt</span>&nbsp;<span class="code">i</span> </td>
            <td> Tests whether <span class="code">i</span> is contained in <span class="code">xs.indices</span>. </td>
          </tr>
          <tr>
            <td> <span class="code">xs.length</span> </td>
            <td> The length of the sequence (same as <span class="code">size</span>). <a id="i-315498884-1"></a> <a id="i251040758-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">lengthCompare</span>&nbsp;<span class="code">len</span> </td>
            <td> Returns a negative <span class="code">Int</span> if the length of <span class="code">xs</span> is less than <span class="code">len</span>, a positive <span class="code">Int</span> if it is greater, and <span class="code">0</span> if it is equal. Works even if <span class="code">xs</span> is infinite. <a id="i473798543-1"></a> <a id="i-1000272893-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.indices</span> </td>
            <td> The index range of <span class="code">xs</span>, extending from 0 to <span class="code">xs.length</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1</span>. <a id="i-1361723020-1"></a> <a id="i-2102417525-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Index search:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">indexOf</span>&nbsp;<span class="code">x</span> </td>
            <td> The index of the first element in <span class="code">xs</span> equal to <span class="code">x</span> (several variants exist). <a id="i1954773669-1"></a> <a id="i-2102517203-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">lastIndexOf</span>&nbsp;<span class="code">x</span> </td>
            <td> The index of the last element in <span class="code">xs</span> equal to <span class="code">x</span> (several variants exist). <a id="i-1061813157-1"></a> <a id="i-115105609-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">indexOfSlice</span>&nbsp;<span class="code">ys</span> </td>
            <td> The first index of <span class="code">xs</span> such that successive elements starting from that index form the sequence <span class="code">ys</span>. <a id="i580863013-1"></a> <a id="i1348829029-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">lastIndexOfSlice</span>&nbsp;<span class="code">ys</span> </td>
            <td> The last index of <span class="code">xs</span> such that successive elements starting from that index form the sequence <span class="code">ys</span>. <a id="i-1540596689-1"></a> <a id="i-1993636069-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">indexWhere</span>&nbsp;<span class="code">p</span> </td>
            <td> The index of the first element in <span class="code">xs</span> that satisfies <span class="code">p</span> (several variants exist). <a id="i1308063033-1"></a> <a id="i1720598737-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.segmentLength(p,</span>&nbsp;<span class="code">i)</span> </td>
            <td> The length of the longest uninterrupted segment of elements in <span class="code">xs</span>, starting with <span class="code">xs(i)</span>, that all satisfy the predicate <span class="code">p</span>. <a id="i-1262494987-1"></a> <a id="i-1801931555-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Additions:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">x</span>&nbsp;<span class="code">+:</span>&nbsp;<span class="code">xs</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">prepended</span>&nbsp;<span class="code">x</span>) </td>
            <td> A new sequence consisting of <span class="code">x</span> prepended to <span class="code">xs</span>. <a id="i-1215087300-1"></a> <a id="i1318634927-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ys</span>&nbsp;<span class="code">++:</span>&nbsp;<span class="code">xs</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">prependedAll</span>&nbsp;<span class="code">ys</span>) </td>
            <td> A new sequence consisting of all the elements of <span class="code">ys</span> prepended to <span class="code">xs</span>. <a id="i1142654823-1"></a> <a id="i1188392303-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">:+</span>&nbsp;<span class="code">x</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">appended</span>&nbsp;<span class="code">x</span>) </td>
            <td> A new sequence that consists of <span class="code">x</span> appended to <span class="code">xs</span>. <a id="i-1421606018-1"></a> <a id="i1848561691-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">:++</span>&nbsp;<span class="code">ys</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">appendedAll</span>&nbsp;<span class="code">ys</span>) </td>
            <td> A new sequence that consists of all the elements of <span class="code">ys</span> appended to <span class="code">xs</span>. Same as <span class="code">xs</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">ys</span>. <a id="i-1170976857-1"></a> <a id="i-2107222009-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.padTo(len,</span>&nbsp;<span class="code">x)</span> </td>
            <td> The sequence resulting from appending the value <span class="code">x</span> to <span class="code">xs</span> until length <span class="code">len</span> is reached. <a id="i-1863493728-1"></a> <a id="i553609042-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Updates:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.patch(i,</span>&nbsp;<span class="code">ys,</span>&nbsp;<span class="code">r)</span> </td>
            <td> The sequence resulting from replacing <span class="code">r</span> elements of <span class="code">xs</span> starting with <span class="code">i</span> by the patch <span class="code">ys</span>. <a id="i-62511610-1"></a> <a id="i553624876-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.updated(i,</span>&nbsp;<span class="code">x)</span> </td>
            <td> A copy of <span class="code">xs</span> with the element at index <span class="code">i</span> replaced by <span class="code">x</span>. <a id="i-2090714253-1"></a> <a id="i14728351-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs(i)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">x</span> </td>
            <td> (or, written out, <span class="code">xs.update(i,</span>&nbsp;<span class="code">x)</span>, only available for <span class="code">mutable.Seq</span>s) Changes the element of <span class="code">xs</span> at index <span class="code">i</span> to <span class="code">y</span>. <a id="i1619007525-1"></a> <a id="i139022437-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Sorting:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.sorted</span> </td>
            <td> A new sequence obtained by sorting the elements of <span class="code">xs</span> using the standard ordering of the element type of <span class="code">xs</span>. <a id="i-78070095-1"></a> <a id="i81275481-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">sortWith</span>&nbsp;<span class="code">lessThan</span> </td>
            <td> A new sequence obtained by sorting the elements of <span class="code">xs</span>, using <span class="code">lessThan</span> as comparison operation. <a id="i1923205194-1"></a> <a id="i795917344-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">sortBy</span>&nbsp;<span class="code">f</span> </td>
            <td> A new sequence obtained by sorting the elements of <span class="code">xs</span>. Comparison between two elements proceeds by mapping the function <span class="code">f</span> over both and comparing the results. <a id="i-544663079-1"></a> <a id="i81274417-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Reversals:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.reverse</span> </td>
            <td> A sequence with the elements of <span class="code">xs</span> in reverse order. <a id="i162887596-1"></a> <a id="i1349004998-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.reverseIterator</span> </td>
            <td> An iterator yielding all the elements of <span class="code">xs</span> in reverse order. <a id="i-1214590498-1"></a> <a id="i-1415678636-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Comparisons:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">sameElements</span>&nbsp;<span class="code">ys</span> </td>
            <td> Tests whether <span class="code">xs</span> and <span class="code">ys</span> contain the same elements in the same order. <a id="i-2017721464-1"></a> <a id="i-1057289236-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">startsWith</span>&nbsp;<span class="code">ys</span> </td>
            <td> Tests whether <span class="code">xs</span> starts with sequence <span class="code">ys</span> (several variants exist). <a id="i-2129701641-1"></a> <a id="i-574339501-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">endsWith</span>&nbsp;<span class="code">ys</span> </td>
            <td> Tests whether <span class="code">xs</span> ends with sequence <span class="code">ys</span> (several variants exist). <a id="i455738416-1"></a> <a id="i877141114-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">x</span> </td>
            <td> Tests whether <span class="code">xs</span> has an element equal to <span class="code">x</span>. <a id="i752331919-1"></a> <a id="i-1433463109-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">search</span>&nbsp;<span class="code">x</span> </td>
            <td> Tests whether the sorted sequence <span class="code">xs</span> has an element equal to <span class="code">x</span>, in a possibly more efficient way than <span class="code">xs</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">x</span>. <a id="i-1353253722-2"></a> <a id="i71531844-2"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">containsSlice</span>&nbsp;<span class="code">ys</span> </td>
            <td> Tests whether <span class="code">xs</span> has a contiguous subsequence equal to <span class="code">ys</span>. <a id="i-1416645509-1"></a> <a id="i1699558295-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.corresponds(ys)(p)</span> </td>
            <td> Tests whether corresponding elements of <span class="code">xs</span> and <span class="code">ys</span> satisfy the binary predicate <span class="code">p</span>. <a id="i-1866218038-1"></a> <a id="i-2021984280-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Multiset operations:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">intersect</span>&nbsp;<span class="code">ys</span> </td>
            <td> The multi-set intersection of sequences <span class="code">xs</span> and <span class="code">ys</span> that preserves the order of elements in <span class="code">xs</span>. <a id="i-1738203761-1"></a> <a id="i-573712381-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">diff</span>&nbsp;<span class="code">ys</span> </td>
            <td> The multi-set difference of sequences <span class="code">xs</span> and <span class="code">ys</span> that preserves the order of elements in <span class="code">xs</span>. <a id="i-1220877719-1"></a> <a id="i433150625-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.distinct</span> </td>
            <td> A subsequence of <span class="code">xs</span> that contains no duplicated element. <a id="i868552658-1"></a> <a id="i-577319016-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">distinctBy</span>&nbsp;<span class="code">f</span> </td>
            <td> A subsequence of <span class="code">xs</span> that contains no duplicated element after applying the transforming function <span class="code">f</span>. <a id="i17577659-1"></a> <a id="i-752791025-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <p>Each <span class="code">Seq</span> trait has two subtraits, <span class="code">LinearSeq</span> and <span class="code">IndexedSeq</span>, which offer different performance characteristics. A linear sequence has efficient <span class="code">head</span> and <span class="code">tail</span> operations, whereas an indexed sequence has efficient <span class="code">apply</span>, <span class="code">length</span>, and (if mutable) <span class="code">update</span> operations. <span class="code">List</span> is a frequently used linear sequence, as is <span class="code">LazyList</span>.<a id="i-2092792389-1"></a> Two frequently used indexed sequences are <span class="code">Array</span> and <span class="code">ArrayBuffer</span>. The <span class="code">Vector</span> class provides an interesting compromise between indexed and linear access. It has both effectively constant time indexing overhead and constant time linear access overhead. Because of this, vectors are a good foundation for mixed access patterns where both indexed and linear accesses are used. More on vectors in <a href="#sec-collections-api-vectors">Section 24.7</a>.</p>
      <p>Mutable <span class="code">IndexedSeq</span> adds operations for transforming its elements in place. These operations, shown in <a href="#tab-mutableindexedseqops">Table 24.3</a>, contrast with operations such as <span class="code">map</span> and <span class="code">sort</span>, available on <span class="code">Seq</span>, which return a new collection instance.</p>
      <p><a id="tab-mutableindexedseqops"></a></p>
      <h5>Operations in trait <span class="code">mutable.IndexedSeq</span> <a id="i-2045714777-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Transformations:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">mapInPlace</span>&nbsp;<span class="code">f</span> </td>
            <td> Transforms all the elements of <span class="code">xs</span> by applying the function <span class="code">f</span> to each of them. <a id="i-1962373715-1"></a> <a id="i1700369504-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.sortInPlace()</span> </td>
            <td> Sorts the elements of <span class="code">xs</span> in place. <a id="i339044395-1"></a> <a id="i1190787114-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">sortInPlaceBy</span>&nbsp;<span class="code">f</span> </td>
            <td> Sorts the elements of <span class="code">xs</span> in place according to an ordering defined on the result of the application of the function <span class="code">f</span> to each element. <a id="i1619195938-1"></a> <a id="i1885117985-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">sortInPlaceWith</span>&nbsp;<span class="code">c</span> </td>
            <td> Sorts the elements of <span class="code">xs</span> in place according to the comparison function <span class="code">c</span>. <a id="i420429841-1"></a> <a id="i-877201392-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <h4>Buffers</h4>
      <p>An important sub-category of mutable sequences is buffers. Buffers allow not only updates of existing elements but also element insertions, element removals, and efficient additions of new elements at the end of the buffer. The principal new methods supported by a buffer are <span class="code">+=</span> (alias, <span class="code">append</span>) and <span class="code">++=</span> (alias, <span class="code">appendAll</span>) for element addition at the end, <span class="code">+=:</span> (alias, <span class="code">prepend</span>) and <span class="code">++=:</span> (alias, <span class="code">prependAll</span>) for addition at the front, <span class="code">insert</span> and <span class="code">insertAll</span> for element insertions, and <span class="code">remove</span>, <span class="code">-=</span> (alias, <span class="code">subtractOne</span>) and <span class="code">--=</span> (alias, <span class="code">subtractAll</span>) for element removal. These operations are summarized in <a href="#tab-bufferops">Table 24.4</a>.</p>
      <p>Two <span class="code">Buffer</span> implementations that are commonly used are <span class="code">ListBuffer</span> and <span class="code">ArrayBuffer</span>. As the name implies, a <span class="code">ListBuffer</span> is backed by a <span class="code">List</span> and supports efficient conversion of its elements to a <span class="code">List</span>, whereas an <span class="code">ArrayBuffer</span> is backed by an array, and can be quickly converted into one. You saw a glimpse of the implementation of <span class="code">ListBuffer</span> in <a href="#sec-the-listbuffer-class">Section 22.2</a>.</p>
      <p><a id="tab-bufferops"></a></p>
      <h5>Operations in trait <span class="code">Buffer</span> <a id="i95832031-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Additions:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">buf</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">x</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">buf</span>&nbsp;<span class="code">append</span>&nbsp;<span class="code">x</span>) </td>
            <td> Appends element <span class="code">x</span> to buffer <span class="code">buf</span>, and returns <span class="code">buf</span> itself as result.<a id="i1747820940-1"></a><a id="i-2090973295-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf</span>&nbsp;<span class="code">++=</span>&nbsp;<span class="code">xs</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">buf</span>&nbsp;<span class="code">appendAll</span>&nbsp;<span class="code">xs</span>) </td>
            <td> Appends all elements in <span class="code">xs</span> to buffer.<a id="i1975933948-1"></a><a id="i1809113823-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">x</span>&nbsp;<span class="code">+=:</span>&nbsp;<span class="code">buf</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">buf</span>&nbsp;<span class="code">prepend</span>&nbsp;<span class="code">x</span>) </td>
            <td> Prepends element <span class="code">x</span> to buffer.<a id="i-1505564645-1"></a><a id="i-52217715-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">++=:</span>&nbsp;<span class="code">buf</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">buf</span>&nbsp;<span class="code">prependAll</span>&nbsp;<span class="code">xs</span>) </td>
            <td> Prepends all elements in <span class="code">xs</span> to buffer.<a id="i-2007284108-1"></a><a id="i1646877859-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf.insert(i,</span>&nbsp;<span class="code">x)</span> </td>
            <td> Inserts element <span class="code">x</span> at index <span class="code">i</span> in buffer.<a id="i-1767492769-1"></a><a id="i-1775835603-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf.insertAll(i,</span>&nbsp;<span class="code">xs)</span> </td>
            <td> Inserts all elements in <span class="code">xs</span> at index <span class="code">i</span> in buffer.<a id="i1499228240-1"></a>.<a id="i1488769076-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf.padToInPlace(n,</span>&nbsp;<span class="code">x)</span> </td>
            <td> Appends element <span class="code">x</span> to buffer until it has <span class="code">n</span> elements in total.<a id="i1098047332-1"></a><a id="i717210888-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Removals:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">buf</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">x</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">buf</span>&nbsp;<span class="code">subtractOne</span>&nbsp;<span class="code">x</span>) </td>
            <td> Removes element <span class="code">x</span> from buffer.<a id="i2053756078-1"></a><a id="i703208191-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf</span>&nbsp;<span class="code">--=</span>&nbsp;<span class="code">xs</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">buf</span>&nbsp;<span class="code">subtractAll</span>&nbsp;<span class="code">xs</span>) </td>
            <td> Removes elements in <span class="code">xs</span> from buffer.<a id="i-440851548-1"></a><a id="i-864802283-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf</span>&nbsp;<span class="code">remove</span>&nbsp;<span class="code">i</span> </td>
            <td> Removes element at index <span class="code">i</span> from buffer.<a id="i-1233111692-1"></a><a id="i-1526653960-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf.remove(i,</span>&nbsp;<span class="code">n)</span> </td>
            <td> Removes <span class="code">n</span> elements starting at index <span class="code">i</span> from buffer.<a id="i-1233111692-2"></a><a id="i-1526653960-2"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf</span>&nbsp;<span class="code">trimStart</span>&nbsp;<span class="code">n</span> </td>
            <td> Removes first <span class="code">n</span> elements from buffer.<a id="i-1528855016-1"></a><a id="i1378245996-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf</span>&nbsp;<span class="code">trimEnd</span>&nbsp;<span class="code">n</span> </td>
            <td> Removes last <span class="code">n</span> elements from buffer.<a id="i1472686271-1"></a><a id="i2061753445-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">buf.clear()</span> </td>
            <td> Removes all elements from buffer.<a id="i-240297909-1"></a><a id="i-2002561959-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Replacement:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">buf.patchInPlace(i,</span>&nbsp;<span class="code">xs,</span>&nbsp;<span class="code">n)</span> </td>
            <td> Replaces (at most) <span class="code">n</span> elements of buffer by elements in <span class="code">xs</span>, starting from index <span class="code">i</span> in buffer.<a id="i-71124930-1"></a><a id="i1211178478-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Cloning:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">buf.clone()</span> </td>
            <td> A new buffer with the same elements as <span class="code">buf</span>.<a id="i1251822395-1"></a><a id="i-2002551959-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <h3>24.5 Sets</h3>
      <p><span class="code">Set</span>s are <span class="code">Iterable</span>s that contain no duplicate elements. The operations on sets are summarized in <a href="#tab-setops">Table 24.5</a> for general sets, <a href="#tab-immutsetops">Table 24.6</a> for immutable sets, and <a href="#tab-mutsetops">Table 24.7</a> for mutable sets. They fall into the following categories:</p>
      <ul>
        <li><b><span style="font-style:italic">Tests</span></b> <span class="code">contains</span>, <span class="code">apply</span>, and <span class="code">subsetOf</span>. The <span class="code">contains</span> method indicates whether a set contains a given element. The <span class="code">apply</span> method for a set is the same as <span class="code">contains</span>, so <span class="code">set(elem)</span> is the same as <span class="code">set</span>&nbsp;<span class="code">contains</span> <span class="code">elem</span>. That means sets can also be used as test functions that return true for the elements they contain. For example: <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fruit&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="quotedstring">"apple"</code>,&nbsp;<code class="quotedstring">"orange"</code>,&nbsp;<code class="quotedstring">"peach"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"banana"</code>)
  <code class="output">fruit:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Set(apple,&nbsp;orange,&nbsp;peach,&nbsp;banana)</code>
  <br>  scala&gt;&nbsp;fruit(<code class="quotedstring">"peach"</code>)
  <code class="output">res7:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;fruit(<code class="quotedstring">"potato"</code>)
  <code class="output">res8:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre> </li>
        <li><b><span style="font-style:italic">Additions</span></b> <span class="code">+</span> (alias, <span class="code">incl</span>) and <span class="code">++</span> (alias, <span class="code">concat</span>), which add one or more elements to a set, yielding a new set as a result. </li>
        <li><b><span style="font-style:italic">Removals</span></b> <span class="code">-</span> (alias, <span class="code">excl</span>) and <span class="code">--</span> (alias, <span class="code">removedAll</span>), which remove one or more elements from a set, yielding a new set. </li>
        <li><b><span style="font-style:italic">Set operations</span></b> for union, intersection, and set difference. These set operations exist in two forms: alphabetic and symbolic. The alphabetic versions are <span class="code">intersect</span>, <span class="code">union</span>, and <span class="code">diff</span>, whereas the symbolic versions are <span class="code">&amp;</span>, <span class="code">|</span>, and <span class="code">&amp;<span style="font-size:large">~</span></span>. The <span class="code">++</span> that <span class="code">Set</span> inherits from <span class="code">Iterable</span> can be seen as yet another alias of <span class="code">union</span> or <span class="code">|</span>, except that <span class="code">++</span> takes an <span class="code">IterableOnce</span> argument whereas <span class="code">union</span> and <span class="code">|</span> take sets. </li>
      </ul>
      <p><a id="tab-setops"></a></p>
      <h5>Operations in trait <span class="code">Set</span> <a id="i877342209-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Tests:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">x</span> </td>
            <td> Tests whether <span class="code">x</span> is an element of <span class="code">xs</span>. <a id="i1685795628-2"></a> <a id="i924843454-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs(x)</span> </td>
            <td> Same as <span class="code">xs</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">x</span>. </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">subsetOf</span>&nbsp;<span class="code">ys</span> </td>
            <td> Tests whether <span class="code">xs</span> is a subset of <span class="code">ys</span>. <a id="i12573170-1"></a> <a id="i-569252040-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Removals:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.empty</span> </td>
            <td> An empty set of the same class as <span class="code">xs</span>. <a id="i1039994046-1"></a> <a id="i-1275381234-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Binary operations:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">&amp;</span>&nbsp;<span class="code">ys</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">intersect</span>&nbsp;<span class="code">ys</span>) </td>
            <td> The set intersection of <span class="code">xs</span> and <span class="code">ys</span>. <a id="i617863161-2"></a> <a id="i1830753682-1"></a> <a id="i-804740052-1"></a> <a id="i-480652960-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">|</span>&nbsp;<span class="code">ys</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">union</span>&nbsp;<span class="code">ys</span>) </td>
            <td> The set union of <span class="code">xs</span> and <span class="code">ys</span>. <a id="i1836511958-1"></a> <a id="i562147141-1"></a> <a id="i-1056923524-1"></a> <a id="i-1260582000-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">&amp;<span style="font-size:large">~</span></span>&nbsp;<span class="code">ys</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">diff</span>&nbsp;<span class="code">ys</span>) </td>
            <td> The set difference of <span class="code">xs</span> and <span class="code">ys</span>. <a id="i2003546905-1"></a> <a id="i-1861524116-1"></a> <a id="i-287414010-1"></a> <a id="i1067203364-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <p>Immutable sets offer methods to add or remove elements by returning new <span class="code">Set</span>s, as summarized in <a href="#tab-immutsetops">Table 24.6</a>:</p>
      <p><a id="tab-immutsetops"></a></p>
      <h5>Operations in trait <span class="code">immutable.Set</span></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Additions:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">x</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">incl</span>&nbsp;<span class="code">x</span>) </td>
            <td> The set containing all elements of <span class="code">xs</span> as well as <span class="code">x</span>. <a id="i58065198-3"></a> <a id="i1858879238-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">ys</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">concat</span>&nbsp;<span class="code">ys</span>) </td>
            <td> The set containing all elements of <span class="code">xs</span> as well as all elements of <span class="code">ys</span>. <a id="i1112322562-1"></a> <a id="i129531150-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Removals:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">x</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">excl</span>&nbsp;<span class="code">x</span>) </td>
            <td> The set containing all elements of <span class="code">xs</span> except <span class="code">x</span>. <a id="i1951955033-2"></a> <a id="i-1593467087-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">--</span>&nbsp;<span class="code">ys</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">removedAll</span>&nbsp;<span class="code">ys</span>) </td>
            <td> The set containing all elements of <span class="code">xs</span> except the elements of <span class="code">ys</span>. <a id="i-1311479633-2"></a> <a id="i640851374-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <p>Mutable sets have methods that add, remove, or update elements, which are summarized in <a href="#tab-mutsetops">Table 24.7</a>.</p>
      <p><a id="tab-mutsetops"></a></p>
      <h5>Operations in trait <span class="code">mutable.Set</span></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Additions:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">x</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">addOne</span>&nbsp;<span class="code">x</span>) </td>
            <td> Adds element <span class="code">x</span> to set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself. <a id="i1314992430-2"></a> <a id="i-1209846120-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">++=</span>&nbsp;<span class="code">ys</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">addAll</span>&nbsp;<span class="code">ys</span>) </td>
            <td> Adds all elements in <span class="code">ys</span> to set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself. <a id="i-1693046362-2"></a> <a id="i-1254892180-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">add</span>&nbsp;<span class="code">x</span> </td>
            <td> Adds element <span class="code">x</span> to <span class="code">xs</span> and returns <span class="code">true</span> if <span class="code">x</span> was not previously contained in the set, <span class="code">false</span> if it was previously contained. <a id="i381468769-1"></a> <a id="i-1766692446-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Removals:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">x</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">subtractOne</span>&nbsp;<span class="code">x</span>) </td>
            <td> Removes element <span class="code">x</span> from set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself. <a id="i1816671796-2"></a> <a id="i-282687116-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">--=</span>&nbsp;<span class="code">ys</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">xs</span>&nbsp;<span class="code">subtractAll</span>&nbsp;<span class="code">ys</span>) </td>
            <td> Removes all elements in <span class="code">ys</span> from set <span class="code">xs</span> as a side effect and returns <span class="code">xs</span> itself. <a id="i-610143062-2"></a> <a id="i-1485797315-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">remove</span>&nbsp;<span class="code">x</span> </td>
            <td> Removes element <span class="code">x</span> from <span class="code">xs</span> and returns <span class="code">true</span> if <span class="code">x</span> was previously contained in the set, <span class="code">false</span> if it was not previously contained. <a id="i1270439364-1"></a> <a id="i-517415965-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">filterInPlace</span>&nbsp;<span class="code">p</span> </td>
            <td> Keeps only those elements in <span class="code">xs</span> that satisfy predicate <span class="code">p</span>. <a id="i-857186166-1"></a> <a id="i619455499-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.clear()</span> </td>
            <td> Removes all elements from <span class="code">xs</span>. <a id="i-914291699-2"></a> <a id="i-1277269234-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Update:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs(x)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">b</span> </td>
            <td> (or, written out, <span class="code">xs.update(x,</span>&nbsp;<span class="code">b)</span>) If boolean argument <span class="code">b</span> is <span class="code">true</span>, adds <span class="code">x</span> to <span class="code">xs</span>, otherwise removes <span class="code">x</span> from <span class="code">xs</span>. <a id="i2073506953-1"></a> <a id="i-421651416-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Cloning:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">xs.clone()</span> </td>
            <td> A new mutable set with the same elements as <span class="code">xs</span>. <a id="i-1974537443-1"></a> <a id="i-1277259234-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <p>The operation <span class="code">s</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">elem</span> adds <span class="code">elem</span> to the set <span class="code">s</span> as a side effect, and returns the mutated set as a result. Likewise, <span class="code">s</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">elem</span> removes <span class="code">elem</span> from the set, and returns the mutated set as a result. Besides <span class="code">+=</span> and <span class="code">-=</span> there are also the bulk operations <span class="code">++=</span> and <span class="code">--=</span> which add or remove all elements of an iterable or an iterator.</p>
      <p>The choice of the method names <span class="code">+=</span> and <span class="code">-=</span> means that very similar code can work with either mutable or immutable sets. Consider first the following interpreter dialogue that uses an immutable set <span class="code">s</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">var</code>&nbsp;s&nbsp;=&nbsp;<code class="typename">Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">s:&nbsp;scala.collection.immutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;s&nbsp;+=&nbsp;<code class="literal">4</code>;&nbsp;s&nbsp;-=&nbsp;<code class="literal">2</code>
  <br>  scala&gt;&nbsp;s
  <code class="output">res10:&nbsp;scala.collection.immutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;3,&nbsp;4)</code>
</pre>
      <p>In this example, we used <span class="code">+=</span> and <span class="code">-=</span> on a <span class="code">var</span> of type <span class="code">immutable.Set</span>. As was explained in <a href="#step10">Step 10</a> in <a href="#chap-next-steps-in-scala">Chapter 3</a>, a statement such as <span class="code">s</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">4</span> is an abbreviation for <span class="code">s</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">s</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">4</span>. So this invokes the addition method <span class="code">+</span> on the set <span class="code">s</span> and then assigns the result back to the <span class="code">s</span> variable. Consider now an analogous interaction with a mutable set:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;<code class="typename">collection.mutable.Set</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">s:&nbsp;scala.collection.mutable.Set[Int]&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;s&nbsp;+=&nbsp;<code class="literal">4</code>
  <code class="output">res11:&nbsp;s.type&nbsp;=&nbsp;Set(1,&nbsp;2,&nbsp;3,&nbsp;4)</code>
  <br>  scala&gt;&nbsp;s&nbsp;-=&nbsp;<code class="literal">2</code>
  <code class="output">res12:&nbsp;s.type&nbsp;=&nbsp;Set(1,&nbsp;3,&nbsp;4)</code>
</pre>
      <p>The end effect is very similar to the previous interaction; we start with a <span class="code">Set(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> and end up with a <span class="code">Set(1,</span>&nbsp;<span class="code">3,</span>&nbsp;<span class="code">4)</span>. However, even though the statements look the same as before, they do something different. The <span class="code">s</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">4</span> statement now invokes the <span class="code">+=</span> method on the mutable set value <span class="code">s</span>, changing the set in place. Likewise, the <span class="code">s</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">2</span> statement now invokes the <span class="code">-=</span> method on the same set.</p>
      <p>Comparing the two interactions shows an important principle. You often can replace a mutable collection stored in a <span class="code">val</span> by an immutable collection stored in a <span class="code">var</span>, and <span style="font-style:italic">vice versa</span>. This works at least as long as there are no alias references to the collection through which you can observe whether it was updated in place or a new collection was created.</p>
      <p>Mutable sets also provide <span class="code">add</span> and <span class="code">remove</span> as variants of <span class="code">+=</span> and <span class="code">-=</span>. The difference is that <span class="code">add</span> and <span class="code">remove</span> return a boolean result indicating whether the operation had an effect on the set.</p>
      <p>The current default implementation of a mutable set uses a hash table to store the set's elements. The default implementation of an immutable set uses a representation that adapts to the number of elements of the set. An empty set is represented by just a singleton object. Sets of sizes up to four are represented by a single object that stores all elements as fields. Beyond that size, immutable sets are implemented as compressed hash-array mapped prefix-trees.<a href="#footnotemain24-2">[2]</a></p>
      <p>A consequence of these representation choices is that for sets of small sizes, up to about four, immutable sets are more compact and more efficient than mutable sets. So if you expect the size of a set to be small, try to make it immutable.</p>
      <h3>24.6 Maps</h3>
      <p><span class="code">Map</span>s are <span class="code">Iterable</span>s of key-value pairs (also named <span style="font-style:italic">mappings</span> or <span style="font-style:italic">associations</span>). As explained in <a href="#sec-simulating-new-syntax">Section 21.4</a>, Scala's <span class="code">Predef</span> object offers an implicit conversion that lets you write <span class="code">key</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">value</span> as an alternate syntax for <span class="code">(key,</span>&nbsp;<span class="code">value)</span>. Thus, <span class="code">Map("x"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">24,</span>&nbsp;<span class="code">"y"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">25,</span>&nbsp;<span class="code">"z"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">26)</span> means exactly the same as <span class="code">Map(("x",</span>&nbsp;<span class="code">24),</span>&nbsp;<span class="code">("y",</span>&nbsp;<span class="code">25),</span>&nbsp;<span class="code">("z",</span>&nbsp;<span class="code">26))</span>, but reads better.</p>
      <p>The fundamental operations on maps, summarized in <a href="#tab-mapops">Table 24.8</a>, are similar to those on sets. Immutable maps support additional operations to add and remove mappings by returning new maps, as shown in <a href="#tab-immutmapops">Table 24.9</a>. Mutable maps additionally support the operations shown in <a href="#tab-mutmapops">Table 24.10</a>. Map operations fall into the following categories:</p>
      <ul>
        <li><b><span style="font-style:italic">Lookups</span></b> <span class="code">apply</span>, <span class="code">get</span>, <span class="code">getOrElse</span>, <span class="code">contains</span>, and <span class="code">isDefinedAt</span>. These operations turn maps into partial functions from keys to values. The fundamental lookup method for a map is: <pre>  <code class="vem">def</code>&nbsp;get(key):&nbsp;<code class="typename">Option[Value]</code>&nbsp;
</pre> <p>The operation "<span class="code">m</span>&nbsp;<span class="code">get</span>&nbsp;<span class="code">key</span>" tests whether the map contains an association for the given <span class="code">key</span>. If so, it returns the associated value in a <span class="code">Some</span>. If no <span class="code">key</span> is defined in the map, <span class="code">get</span> returns <span class="code">None</span>. Maps also define an <span class="code">apply</span> method that returns the value associated with a given key directly, without wrapping it in an <span class="code">Option</span>. If the key is not defined in the map, an exception is raised.</p> </li>
        <li><b><span style="font-style:italic">Additions and updates</span></b> <span class="code">+</span> (alias, <span class="code">updated</span>), <span class="code">++</span> (alias, <span class="code">concat</span>), <span class="code">updateWith</span>, and <span class="code">updatedWith</span>, which let you add new bindings to a map or change existing bindings. </li>
        <li><b><span style="font-style:italic">Removals</span></b> <span class="code">-</span> (alias, <span class="code">removed</span>) and <span class="code">--</span> (alias, <span class="code">removedAll</span>), which remove bindings from a map. </li>
        <li><b><span style="font-style:italic">Subcollection producers</span></b> <span class="code">keys</span>, <span class="code">keySet</span>, <span class="code">keysIterator</span>, <span class="code">valuesIterator</span>, and <span class="code">values</span>, which return a map's keys and values separately in various forms. </li>
        <li><b><span style="font-style:italic">Transformations</span></b> <span class="code">filterKeys</span> and <span class="code">mapValues</span>, which produce a new map by filtering and transforming bindings of an existing map. </li>
      </ul>
      <p><a id="tab-mapops"></a></p>
      <h5>Operations in trait <span class="code">Map</span> <a id="i-1799914245-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Lookups:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">get</span>&nbsp;<span class="code">k</span> </td>
            <td> The value associated with key <span class="code">k</span> in map <span class="code">ms</span> as an option, or <span class="code">None</span> if not found<a id="i-1160987621-1"></a><a id="i-1633357539-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms(k)</span> </td>
            <td> (or, written out, <span class="code">ms</span>&nbsp;<span class="code">apply</span>&nbsp;<span class="code">k</span>) The value associated with key <span class="code">k</span> in map <span class="code">ms</span>, or a thrown exception if not found<a id="i648989597-3"></a><a id="i-1998745739-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">getOrElse</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">d)</span> </td>
            <td> The value associated with key <span class="code">k</span> in map <span class="code">ms</span>, or the default value <span class="code">d</span> if not found<a id="i-1472564161-1"></a><a id="i1555511609-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">k</span> </td>
            <td> Tests whether <span class="code">ms</span> contains a mapping for key <span class="code">k</span><a id="i-1171514126-2"></a><a id="i-955049800-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">isDefinedAt</span>&nbsp;<span class="code">k</span> </td>
            <td> Same as <span class="code">contains</span><a id="i2055622367-1"></a><a id="i1960441049-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Subcollections:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.keys</span> </td>
            <td> An iterable containing each key in <span class="code">ms</span><a id="i1213467709-2"></a><a id="i905643277-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.keySet</span> </td>
            <td> A set containing each key in <span class="code">ms</span><a id="i891405326-2"></a><a id="i-1555199396-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.keysIterator</span> </td>
            <td> An iterator yielding each key in <span class="code">ms</span><a id="i1344362607-1"></a><a id="i854987931-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.values</span> </td>
            <td> An iterable containing each value associated with a key in <span class="code">ms</span><a id="i-546077233-2"></a><a id="i-1244327429-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.valuesIterator</span> </td>
            <td> An iterator yielding each value associated with a key in <span class="code">ms</span><a id="i1069490177-1"></a><a id="i1168331657-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Transformation:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.view</span>&nbsp;<span class="code">filterKeys</span>&nbsp;<span class="code">p</span> </td>
            <td> A map view containing only those mappings in <span class="code">ms</span> where the key satisfies predicate <span class="code">p</span><a id="i1402917267-1"></a><a id="i-356465537-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.view</span>&nbsp;<span class="code">mapValues</span>&nbsp;<span class="code">f</span> </td>
            <td> A map view resulting from applying function <span class="code">f</span> to each value associated with a key in <span class="code">ms</span><a id="i1966867365-1"></a><a id="i1850948683-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <p><a id="tab-immutmapops"></a></p>
      <h5>Operations in trait <span class="code">immutable.Map</span> <a id="i-1799914245-2"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Additions and updates:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v)</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">ms.updated(k,</span>&nbsp;<span class="code">v)</span>) </td>
            <td> The map containing all mappings of <span class="code">ms</span> as well as the mapping <span class="code">k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v</span> from key <span class="code">k</span> to value <span class="code">v</span> <a id="i57882484-2"></a> <a id="i1877298566-1"></a> <a id="i-1981412563-1"></a> <a id="i-385480958-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">kvs</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">ms.concat(kvs)</span>) </td>
            <td> The map containing all mappings of <span class="code">ms</span> as well as all key/value pairs of <span class="code">kvs</span> <a id="i-2098881509-2"></a> <a id="i-1132988814-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.updatedWith(k)(f)</span> </td>
            <td> The map with a binding added, updated, or removed for the key <span class="code">k</span>. The function <span class="code">f</span> takes as a parameter the value currently associated with the key <span class="code">k</span> (or <span class="code">None</span> if there was no such binding) and returns the new value (or <span class="code">None</span> to remove the binding). <a id="i1818572663-1"></a> <a id="i1492114152-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Removals:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">k</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">ms</span>&nbsp;<span class="code">removed</span>&nbsp;<span class="code">k</span>) </td>
            <td> The map containing all mappings of <span class="code">ms</span> except for any mapping of key <span class="code">k</span> <a id="i1951772319-2"></a> <a id="i-191488371-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">--</span>&nbsp;<span class="code">ks</span> </td>
          </tr>
          <tr>
            <td> (or <span class="code">ms</span>&nbsp;<span class="code">removedAll</span>&nbsp;<span class="code">ks</span>) </td>
            <td> The map containing all mappings of <span class="code">ms</span> except for any mapping with a key in <span class="code">ks</span> <a id="i-1311662347-2"></a> <a id="i2074410039-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <p><a id="tab-mutmapops"></a></p>
      <h5>Operations in trait <span class="code">mutable.Map</span></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Additions and updates:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">ms(k)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">v</span> </td>
            <td> (or, written out, <span class="code">ms.update(k,</span>&nbsp;<span class="code">v)</span>) Adds mapping from key <span class="code">k</span> to value <span class="code">v</span> to map <span class="code">ms</span> as a side effect, overwriting any previous mapping of <span class="code">k</span><a id="i2073501059-1"></a><a id="i-1259360862-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v)</span> </td>
            <td> Adds mapping from key <span class="code">k</span> to value <span class="code">v</span> to map <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself<a id="i1314809716-2"></a><a id="i2003257106-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">++=</span>&nbsp;<span class="code">kvs</span> </td>
            <td> Adds all mappings in <span class="code">kvs</span> to <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself<a id="i-1693229076-2"></a><a id="i-1544177818-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.put(k,</span>&nbsp;<span class="code">v)</span> </td>
            <td> Adds mapping from key <span class="code">k</span> to value <span class="code">v</span> to <span class="code">ms</span> and returns any value previously associated with <span class="code">k</span> as an option<a id="i-254405943-1"></a><a id="i-1633348394-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">getOrElseUpdate</span>&nbsp;<span class="code">(k,</span>&nbsp;<span class="code">d)</span> </td>
            <td> If key <span class="code">k</span> is defined in map <span class="code">ms</span>, returns its associated value. Otherwise, updates <span class="code">ms</span> with the mapping <span class="code">k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">d</span> and returns <span class="code">d</span><a id="i1864005077-1"></a><a id="i1498468194-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.updateWith(k)(f)</span> </td>
            <td> Adds, updates, or removes a binding for the key <span class="code">k</span>. The function <span class="code">f</span> takes as a parameter the value currently associated with the key <span class="code">k</span> (or <span class="code">None</span> if there was no such binding) and returns the new value (or <span class="code">None</span> to remove the binding). <a id="i-2081046295-1"></a> <a id="i879047048-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Removals:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">-=</span>&nbsp;<span class="code">k</span> </td>
            <td> Removes mapping with key <span class="code">k</span> from <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself<a id="i1816489082-2"></a><a id="i1608234298-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">--=</span>&nbsp;<span class="code">ks</span> </td>
            <td> Removes all keys in <span class="code">ks</span> from <span class="code">ms</span> as a side effect and returns <span class="code">ms</span> itself<a id="i-610325776-2"></a><a id="i-1837007177-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">remove</span>&nbsp;<span class="code">k</span> </td>
            <td> Removes any mapping with key <span class="code">k</span> from <span class="code">ms</span> and returns any value previously associated with <span class="code">k</span> as an option<a id="i1270433470-1"></a><a id="i-1355125411-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">filterInPlace</span>&nbsp;<span class="code">p</span> </td>
            <td> Keeps only those mappings in <span class="code">ms</span> that have a key satisfying predicate <span class="code">p</span>.<a id="i-857192060-1"></a><a id="i-1653287599-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.clear()</span> </td>
            <td> Removes all mappings from <span class="code">ms</span><a id="i-914297593-1"></a><a id="i-1997028780-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Transformation and cloning:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">ms</span>&nbsp;<span class="code">mapValuesInPlace</span>&nbsp;<span class="code">f</span> </td>
            <td> Transforms all associated values in map <span class="code">ms</span> with function <span class="code">f</span> </td>
          </tr>
          <tr>
            <td> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">ms.clone()</span> </td>
            <td> Returns a new mutable map with the same mappings as <span class="code">ms</span><a id="i-1974543337-1"></a><a id="i-1997018780-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <p>The addition and removal operations for maps mirror those for sets. An immutable map can be transformed with operations such as <span class="code">+</span>, <span class="code">-</span>, and <span class="code">updated</span>. A mutable map, by contrast, <span class="code">m</span> can be updated "in place" using the two variants <span class="code">m(key)</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">value</span> and <span class="code">m</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">(key</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">value)</span>. Mutable maps also offer the variant <span class="code">m.put(key,</span>&nbsp;<span class="code">value)</span>, which returns an <span class="code">Option</span> value that contains the value previously associated with <span class="code">key</span>, or <span class="code">None</span> if the <span class="code">key</span> did not exist in the map before.</p>
      <p>The <span class="code">getOrElseUpdate</span> is useful for accessing maps that act as caches. Say you have an expensive computation triggered by invoking a function <span class="code">f</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;f(x:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"taking&nbsp;my&nbsp;time."</code>);&nbsp;Thread.sleep(<code class="literal">100</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.reverse&nbsp;}
  <code class="output">f:&nbsp;(x:&nbsp;String)String</code>
</pre>
      <p>Assume further that <span class="code">f</span> has no side-effects, so invoking it again with the same argument will always yield the same result. In that case you could save time by storing previously computed bindings of argument and results of <span class="code">f</span> in a map, and only computing the result of <span class="code">f</span> if a result of an argument was not found there. You could say the map is a <span style="font-style:italic">cache</span> for the computations of the function <span class="code">f</span>.</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;cache&nbsp;=&nbsp;<code class="typename">collection.mutable.Map[String,&nbsp;String]</code>()
  <code class="output">cache:&nbsp;scala.collection.mutable.Map[String,String]&nbsp;=&nbsp;Map()</code>
</pre>
      <p>You can now create a more efficient caching version of the <span class="code">f</span> function:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;cachedF(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;cache.getOrElseUpdate(s,&nbsp;f(s))
  <code class="output">cachedF:&nbsp;(s:&nbsp;String)String</code>
  <br>  scala&gt;&nbsp;cachedF(<code class="quotedstring">"abc"</code>)
  <code class="output">taking&nbsp;my&nbsp;time.</code>
  <code class="output">res16:&nbsp;String&nbsp;=&nbsp;cba</code>
  <br>  scala&gt;&nbsp;cachedF(<code class="quotedstring">"abc"</code>)
  <code class="output">res17:&nbsp;String&nbsp;=&nbsp;cba</code>
</pre>
      <p>Note that the second argument to <span class="code">getOrElseUpdate</span> is "by-name," so the computation of <span class="code">f("abc")</span> above is only performed if <span class="code">getOrElseUpdate</span> requires the value of its second argument, which is precisely if its first argument is not found in the <span class="code">cache</span> map. You could also have implemented <span class="code">cachedF</span> directly, using just basic map operations, but it would have taken more code to do so:</p> <pre>  <code class="vem">def</code>&nbsp;cachedF(arg:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;cache&nbsp;get&nbsp;arg&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Some</code>(result)&nbsp;=&gt;&nbsp;result
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">None</code>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;result&nbsp;=&nbsp;f(arg)
  &nbsp;&nbsp;&nbsp;&nbsp;cache(arg)&nbsp;=&nbsp;result
  &nbsp;&nbsp;&nbsp;&nbsp;result
  }
</pre>
      <h3>24.7 Concrete immutable collection classes</h3>
      <p>Scala provides many concrete immutable collection classes for you to choose from. They differ in the traits they implement (maps, sets, sequences), whether they can be infinite, and the speed of various operations. We'll start by reviewing the most common immutable collection types.</p>
      <h4>Lists</h4>
      <p>Lists are finite immutable sequences. They provide constant-time access to their first element as well as the rest of the list, and they have a constant-time cons operation for adding a new element to the front of the list. Many other operations take linear time. See <a href="#chap-working-with-lists">Chapters 16</a> and<a href="#chap-implementing-lists"> 22</a> for extensive discussions about lists.</p>
      <h4><span class="code">LazyList</span>s</h4>
      <p>A lazy list is a list whose elements are computed lazily.<a id="i-2092792389-2"></a> Only those elements requested will be computed. A lazy list can, therefore, be infinitely long. Otherwise, lazy lists have the same performance characteristics as lists.</p>
      <p>Whereas lists are constructed with the <span class="code">::</span> operator, lazy lists are constructed with the similar-looking <span class="code">#::</span>. Here is a simple example of a lazy list containing the integers 1, 2, and 3:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;str&nbsp;=&nbsp;<code class="literal">1</code>&nbsp;#::&nbsp;<code class="literal">2</code>&nbsp;#::&nbsp;<code class="literal">3</code>&nbsp;#::&nbsp;LazyList.empty
  <code class="output">str:&nbsp;scala.collection.immutable.LazyList[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;LazyList(&lt;not&nbsp;computed&gt;)</code>
</pre>
      <p>The head of this lazy list is 1, and the tail of it has 2 and 3. None of the elements are printed here, though, because the list hasn't been computed yet! Lazy lists are specified to compute lazily, and the <span class="code">toString</span> method of a lazy list is careful not to force any extra evaluation.</p>
      <p>Below is a more complex example. It computes a lazy list that contains a Fibonacci sequence starting with the given two numbers. A Fibonacci sequence is one where each element is the sum of the previous two elements in the series:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;fibFrom(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">LazyList[Int]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;#::&nbsp;fibFrom(b,&nbsp;a&nbsp;+&nbsp;b)
  <code class="output">fibFrom:&nbsp;(a:&nbsp;Int,&nbsp;b:&nbsp;Int)LazyList[Int]</code>
</pre>
      <p>This function is deceptively simple. The first element of the sequence is clearly <span class="code">a</span>, and the rest of the sequence is the Fibonacci sequence starting with <span class="code">b</span> followed by <span class="code">a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b</span>. The tricky part is computing this sequence without causing an infinite recursion. If the function used <span class="code">::</span> instead of <span class="code">#::</span>, then every call to the function would result in another call, thus causing an infinite recursion. Since it uses <span class="code">#::</span>, though, the right-hand side is not evaluated until it is requested.</p>
      <p>Here are the first few elements of the Fibonacci sequence starting with two ones:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fibs&nbsp;=&nbsp;fibFrom(<code class="literal">1</code>,&nbsp;<code class="literal">1</code>).take(<code class="literal">7</code>)
  <code class="output">fibs:&nbsp;scala.collection.immutable.LazyList[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;LazyList(&lt;not&nbsp;computed&gt;)</code>
  <br>  scala&gt;&nbsp;fibs.toList
  <code class="output">res23:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;8,&nbsp;13)</code>
</pre>
      <h4>Immutable <span class="code">ArraySeq</span>s</h4>
      <p>Lists<a id="i-2113240002-1"></a> are very efficient if you use algorithms that work exclusively at the front of the list. Accessing, adding, and removing the head of a list takes constant time. Accessing or modifying elements deeper in the list, however, takes time linear in the depth into the list. As a result, a list may not be the best choice for algorithms that don't limit themselves to processing just the front of the sequence.</p>
      <p><span class="code">ArraySeq</span><a id="i1241280955-1"></a> is an immutable sequence type, backed by a private <span class="code">Array</span>, that addresses the inefficiency of random access on lists. <span class="code">ArraySeq</span>s allow you to access any element of the collection in constant time. As a result, you need not worry about accessing just the head of an <span class="code">ArraySeq</span>. Because you can access elements at arbitrary locations in contant time, <span class="code">ArraySeq</span>s can be more efficient than lists for some algorithms.</p>
      <p>On the other hand, since <span class="code">ArraySeq</span>s are backed by an <span class="code">Array</span>, prepending to an <span class="code">ArraySeq</span> requires linear time, not constant time as with list. Moreover, any addition or update of a single element requires linear time on <span class="code">ArraySeq</span>, because the entire underlying array must be copied.</p>
      <h4>Vectors</h4>
      <p><a id="sec-collections-api-vectors"></a></p>
      <p><span class="code">List</span> and <span class="code">ArraySeq</span> are efficient data structures for some use cases but inefficient for others. For example, prepending an element is constant time for <span class="code">List</span>, but linear time for <span class="code">ArraySeq</span>. Conversely, indexed access is constant time for <span class="code">ArraySeq</span>, but linear time for <span class="code">List</span>.</p>
      <p>Vector provides good performance for all its operations. Access and update to any elements of a vector takes only "effectively constant time," as defined below. It's a larger constant than for access to the head of a list or for reading an element of an <span class="code">ArraySeq</span>, but it's a constant nonetheless. As a result, algorithms using vectors do not have to be careful about accessing or updating just the head of the sequence. They can access and update elements at arbitrary locations, and thus they can be much more convenient to write.</p>
      <p>Vectors are built and modified just like any other sequence:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec&nbsp;=&nbsp;scala.collection.immutable.Vector.empty
  <code class="output">vec:&nbsp;scala.collection.immutable.Vector[Nothing]&nbsp;=&nbsp;Vector()</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec2&nbsp;=&nbsp;vec&nbsp;:+&nbsp;<code class="literal">1</code>&nbsp;:+&nbsp;<code class="literal">2</code>
  <code class="output">vec2:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec3&nbsp;=&nbsp;<code class="literal">100</code>&nbsp;+:&nbsp;vec2
  <code class="output">vec3:&nbsp;scala.collection.immutable.Vector[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Vector(100,&nbsp;1,&nbsp;2)</code>
  <br>  scala&gt;&nbsp;vec3(<code class="literal">0</code>)
  <code class="output">res24:&nbsp;Int&nbsp;=&nbsp;100</code>
</pre>
      <p>Vectors are represented as broad, shallow trees. Every tree node contains up to 32 elements of the vector or contains up to 32 other tree nodes. Vectors with up to 32 elements can be represented in a single node. Vectors with up to <span class="code">32</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">32</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">1024</span> elements can be represented with a single indirection. Two hops from the root of the tree to the final element node are sufficient for vectors with up to 2<sup>15</sup> elements, three hops for vectors with 2<sup>20</sup>, four hops for vectors with 2<sup>25</sup> elements and five hops for vectors with up to 2<sup>30</sup> elements. So for all vectors of reasonable size, an element selection involves up to five primitive array selections. This is what we meant when we wrote that element access is "effectively constant time."</p>
      <p>Vectors are immutable, so you cannot change an element of a vector in place. However, with the <span class="code">updated</span> method you can create a new vector that differs from a given vector only in a single element:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vec&nbsp;=&nbsp;<code class="typename">Vector</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">vec:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;vec&nbsp;updated&nbsp;(<code class="literal">2</code>,&nbsp;<code class="literal">4</code>)
  <code class="output">res25:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;4)</code>
  <br>  scala&gt;&nbsp;vec
  <code class="output">res26:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;3)</code>
</pre>
      <p>As the last line above shows, a call to <span class="code">updated</span> has no effect on the original vector <span class="code">vec</span>. Like selection, functional vector updates are also "effectively constant time." Updating an element in the middle of a vector can be done by copying the node that contains the element, and every node that points to it, starting from the root of the tree. This means that a functional update creates between one and five nodes that each contain up to 32 elements or subtrees. This is certainly more expensive than an in-place update in a mutable array, but still a lot cheaper than copying the whole vector.</p>
      <p>Because vectors strike a good balance between fast random selections and fast random functional updates, they are currently the default implementation of immutable indexed sequences:</p> <pre>  scala&gt;&nbsp;<code class="typename">collection.immutable.IndexedSeq</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res27:&nbsp;scala.collection.immutable.IndexedSeq[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Vector(1,&nbsp;2,&nbsp;3)</code>
</pre>
      <h4>Immutable queues</h4>
      <p>A queue is a first-in-first-out sequence<a id="i-705909367-1"></a>. A simplified implementation of immutable queues was discussed in <a href="#chap-type-parameterization">Chapter 19</a>. Here's how you can create an empty immutable queue:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;empty&nbsp;=&nbsp;<code class="typename">scala.collection.immutable.Queue[Int]</code>()
  <code class="output">empty:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue()</code>
</pre>
      <p>You can append an element to an immutable queue with <span class="code">enqueue</span><a id="i432237508-1"></a>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;has1&nbsp;=&nbsp;empty.enqueue(<code class="literal">1</code>)
  <code class="output">has1:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(1)</code>
</pre>
      <p>To append multiple elements to a queue, call <span class="code">enqueueAll</span> with a collection as its argument:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;has123&nbsp;=&nbsp;has1.enqueueAll(<code class="typename">List</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>))
  <code class="output">has123:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;</code>
  <code class="output">3)</code>
</pre>
      <p>To remove an element from the head of the queue, use <span class="code">dequeue</span><a id="i2031764716-1"></a>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;(element,&nbsp;has23)&nbsp;=&nbsp;has123.dequeue
  <code class="output">element:&nbsp;Int&nbsp;=&nbsp;1</code>
  <code class="output">has23:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(2,&nbsp;3)</code>
</pre>
      <p>Note that <span class="code">dequeue</span> returns a pair consisting of the element removed and the rest of the queue.</p>
      <h4>Ranges</h4>
      <p>A range is an ordered sequence of integers that are equally spaced apart. For example, "1, 2, 3" is a range, as is "5, 8, 11, 14." To create a range in Scala, use the predefined methods <span class="code">to</span> and <span class="code">by</span>. Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">3</code>
  <code class="output">res31:&nbsp;scala.collection.immutable.Range.Inclusive</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;Range(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;<code class="literal">5</code>&nbsp;to&nbsp;<code class="literal">14</code>&nbsp;by&nbsp;<code class="literal">3</code>
  <code class="output">res32:&nbsp;scala.collection.immutable.Range&nbsp;=&nbsp;Range(5,&nbsp;8,&nbsp;11,&nbsp;14)</code>
</pre>
      <p>If you want to create a range that is exclusive of its upper limit, use the convenience method <span class="code">until</span> instead of <span class="code">to</span>:</p> <pre>  scala&gt;&nbsp;<code class="literal">1</code>&nbsp;until&nbsp;<code class="literal">3</code>
  <code class="output">res33:&nbsp;scala.collection.immutable.Range&nbsp;=&nbsp;Range(1,&nbsp;2)</code>
</pre>
      <p>Ranges are represented in constant space, because they can be defined by just three numbers: their start, their end, and the stepping value. Because of this representation, most operations on ranges are extremely fast.</p>
      <h4>Compressed hash-array mapped prefix-trees</h4>
      <p><a id="sec-hash-tries"></a></p>
      <p>Hash tries<a href="#footnotemain24-3">[3]</a><a id="i-794402297-2"></a> are a standard way to implement immutable sets and maps efficiently. Compressed hash-array mapped prefix-trees<a href="#footnotemain24-4">[4]</a> are a design for hash tries on the JVM that improves locality and makes sure the trees remain in a canonical and compact representation. Their representation is similar to vectors in that they are also trees where every node has 32 elements or 32 subtrees, but selection is done based on a hash code. For instance, to find a given key in a map, you use the lowest five bits of the hash code of the key to select the first subtree, the next five bits the next subtree, and so on. Selection stops once all elements stored in a node have hash codes that differ from each other in the bits that are selected so far. Thus, not all the bits of the hash code are necessarily used.</p>
      <p>Hash tries strike a nice balance between reasonably fast lookups and reasonably efficient functional insertions <span class="code">(+)</span> and deletions <span class="code">(-)</span>. That's why they underlie Scala's default implementations of immutable maps and sets. In fact, Scala has a further optimization for immutable sets and maps that contain less than five elements. Sets and maps with one to four elements are stored as single objects that just contain the elements (or key/value pairs in the case of a map) as fields. The empty immutable set and empty immutable map is in each case a singleton object—there's no need to duplicate storage for those because an empty immutable set or map will always stay empty.</p>
      <h4>Red-black trees</h4>
      <p>Red-black trees are a form of balanced binary trees where some nodes are designated "red" and others "black." Like any balanced binary tree, operations on them reliably complete in time logarithmic to the size of the tree.</p>
      <p>Scala provides implementations of sets and maps that use a red-black tree internally. You access them under the names <span class="code">TreeSet</span> and <span class="code">TreeMap</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;set&nbsp;=&nbsp;collection.immutable.TreeSet.empty[<code class="typename">Int</code>]
  <code class="output">set:&nbsp;scala.collection.immutable.TreeSet[Int]&nbsp;=&nbsp;TreeSet()</code>
  <br>  scala&gt;&nbsp;set&nbsp;+&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;<code class="literal">3</code>&nbsp;+&nbsp;<code class="literal">3</code>
  <code class="output">res34:&nbsp;scala.collection.immutable.TreeSet[Int]&nbsp;=&nbsp;TreeSet(1,&nbsp;3)</code>
</pre>
      <p>Red-black trees are also the standard implementation of <span class="code">SortedSet</span> in Scala, because they provide an efficient iterator that returns all elements of the set in sorted order.</p>
      <h4>Immutable bit sets</h4>
      <p>A bit set represents a collection of small integers as the bits of a larger integer. For example, the bit set containing 3, 2, and 0 would be represented as the integer 1101 in binary, which is 13 in decimal.</p>
      <p>Internally, bit sets use an array of 64-bit <span class="code">Long</span>s. The first <span class="code">Long</span> in the array is for integers 0 through 63, the second is for 64 through 127, and so on. Thus, bit sets are very compact so long as the largest integer in the set is less than a few hundred or so.</p>
      <p>Operations on bit sets are very fast. Testing for inclusion takes constant time. Adding an item to the set takes time proportional to the number of <span class="code">Long</span>s in the bit set's array, which is typically a small number. Here are some simple examples of the use of a bit set:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bits&nbsp;=&nbsp;scala.collection.immutable.BitSet.empty
  <code class="output">bits:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet()</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;moreBits&nbsp;=&nbsp;bits&nbsp;+&nbsp;<code class="literal">3</code>&nbsp;+&nbsp;<code class="literal">4</code>&nbsp;+&nbsp;<code class="literal">4</code>
  <code class="output">moreBits:&nbsp;scala.collection.immutable.BitSet&nbsp;=&nbsp;BitSet(3,&nbsp;4)</code>
  <br>  scala&gt;&nbsp;moreBits(<code class="literal">3</code>)
  <code class="output">res35:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;moreBits(<code class="literal">0</code>)
  <code class="output">res36:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <h4>Vector maps</h4>
      <p>A <span class="code">VectorMap</span><a id="i-1289707631-1"></a> represents a map using both a <span class="code">Vector</span> of keys and a <span class="code">HashMap</span>. It provides an iterator that returns all the entries in their insertion order.</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vm&nbsp;=&nbsp;scala.collection.immutable.VectorMap.
  &nbsp;&nbsp;empty[<code class="typename">Int</code>,&nbsp;<code class="typename">String</code>]
  <code class="output">vm:&nbsp;scala.collection.immutable.VectorMap[Int,String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;VectorMap()</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vm1&nbsp;=&nbsp;vm&nbsp;+&nbsp;(<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"one"</code>)
  <code class="output">vm1:&nbsp;scala.collection.immutable.VectorMap[Int,String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;VectorMap(1&nbsp;-&gt;&nbsp;one)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vm2&nbsp;=&nbsp;vm1&nbsp;+&nbsp;(<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"two"</code>)
  <code class="output">vm2:&nbsp;scala.collection.immutable.VectorMap[Int,String]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;VectorMap(1&nbsp;-&gt;&nbsp;one,&nbsp;2&nbsp;-&gt;&nbsp;two)</code>
  <br>  scala&gt;&nbsp;vm2&nbsp;==&nbsp;<code class="typename">Map</code>(<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"two"</code>,&nbsp;<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"one"</code>)
  <code class="output">res29:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>The first lines show that the content of the <span class="code">VectorMap</span> keeps the insertion order, and the last line shows that <span class="code">VectorMap</span>s are comparable with other maps, and that this comparison does not take the order of elements into account.</p>
      <h4>List maps</h4>
      <p>A list map represents a map as a linked list of key-value pairs. In general, operations on a list map might have to iterate through the entire list. Thus, operations on a list map take time linear in the size of the map. In fact there is little usage for list maps in Scala because standard immutable maps are almost always faster. The only possible difference is if the map is for some reason constructed in such a way that the first elements in the list are selected much more often than the other elements.</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;<code class="typename">collection.immutable.ListMap</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"one"</code>,&nbsp;<code class="literal">2</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"two"</code>)
  <code class="output">map:&nbsp;scala.collection.immutable.ListMap[Int,String]&nbsp;=&nbsp;Map(1&nbsp;</code>
  <code class="output">-&gt;&nbsp;one,&nbsp;2&nbsp;-&gt;&nbsp;two)</code>
  <br>  scala&gt;&nbsp;map(<code class="literal">2</code>)
  <code class="output">res37:&nbsp;String&nbsp;=&nbsp;"two"</code>
</pre>
      <h3>24.8 Concrete mutable collection classes</h3>
      <p>Now that you've seen the most commonly used immutable collection classes that Scala provides in its standard library, take a look at the mutable collection classes.</p>
      <h4>Array buffers</h4>
      <p>You've already seen array buffers in <a href="#sec-collections-arraybuf">Section 17.1</a>. An array buffer holds an array and a size. Most operations on an array buffer have the same speed as an array, because the operations simply access and modify the underlying array. Additionally, array buffers can have data efficiently added to the end. Appending an item to an array buffer takes amortized constant time. Thus, array buffers are useful for efficiently building up a large collection whenever the new items are always added to the end. Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;collection.mutable.ArrayBuffer.empty[<code class="typename">Int</code>]
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;ArrayBuffer()</code>
  <br>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">1</code>
  <code class="output">res38:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(1)</code>
  <br>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">10</code>
  <code class="output">res39:&nbsp;buf.type&nbsp;=&nbsp;ArrayBuffer(1,&nbsp;10)</code>
  <br>  scala&gt;&nbsp;buf.toArray
  <code class="output">res40:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;10)</code>
</pre>
      <h4>List buffers</h4>
      <p>You've also already seen list buffers in <a href="#sec-collections-listbuf">Section 17.1</a>. A list buffer is like an array buffer except that it uses a linked list internally instead of an array. If you plan to convert the buffer to a list once it is built up, use a list buffer instead of an array buffer. Here's an example:<a href="#footnotemain24-5">[5]</a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;collection.mutable.ListBuffer.empty[<code class="typename">Int</code>]
  <code class="output">buf:&nbsp;scala.collection.mutable.ListBuffer[Int]</code>
  <code class="output">&nbsp;&nbsp;=&nbsp;ListBuffer()</code>
  <br>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">1</code>
  <code class="output">res41:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1)</code>
  <br>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="literal">10</code>
  <code class="output">res42:&nbsp;buf.type&nbsp;=&nbsp;ListBuffer(1,&nbsp;10)</code>
  <br>  scala&gt;&nbsp;buf.toList
  <code class="output">res43:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;10)</code>
</pre>
      <h4>String builders</h4>
      <p>Just like an array buffer is useful for building arrays, and a list buffer is useful for building lists, a string builder is useful for building strings. String builders are so commonly used that they are already imported into the default namespace. Create them with a simple <span class="code">new</span>&nbsp;<span class="code">StringBuilder</span>, like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">StringBuilder</code>
  <code class="output">buf:&nbsp;StringBuilder&nbsp;=</code>
  <br>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<code class="quotedstring">'a'</code>
  <code class="output">res44:&nbsp;buf.type&nbsp;=&nbsp;a</code>
  <br>  scala&gt;&nbsp;buf&nbsp;++=&nbsp;<code class="quotedstring">"bcdef"</code>
  <code class="output">res45:&nbsp;buf.type&nbsp;=&nbsp;abcdef</code>
  <br>  scala&gt;&nbsp;buf.toString
  <code class="output">res46:&nbsp;String&nbsp;=&nbsp;abcdef</code>
</pre>
      <h4><span class="code">ArrayDeque</span></h4>
      <p>An <span class="code">ArrayDeque</span><a id="i-703804417-1"></a> is a mutable sequence that supports efficient addition of elements in the front and in the end. Internally it uses a resizable array. If you need to append and prepend elements to a buffer, use an <span class="code">ArrayDeque</span> instead of an <span class="code">ArrayBuffer</span>.</p>
      <h4>Queues</h4>
      <p>Scala provides mutable queues in addition to immutable ones. You use a mutable queue similarly to the way you use an immutable one, but instead of <span class="code">enqueue</span>, you use the <span class="code">+=</span> and <span class="code">++=</span> operators to append. Also, on a mutable queue, the <span class="code">dequeue</span> method will just remove the head element from the queue and return it. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;queue&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">scala.collection.mutable.Queue[String]</code>
  <code class="output">queue:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue()</code>
  <br>  scala&gt;&nbsp;queue&nbsp;+=&nbsp;<code class="quotedstring">"a"</code>
  <code class="output">res47:&nbsp;queue.type&nbsp;=&nbsp;Queue(a)</code>
  <br>  scala&gt;&nbsp;queue&nbsp;++=&nbsp;<code class="typename">List</code>(<code class="quotedstring">"b"</code>,&nbsp;<code class="quotedstring">"c"</code>)
  <code class="output">res48:&nbsp;queue.type&nbsp;=&nbsp;Queue(a,&nbsp;b,&nbsp;c)</code>
  <br>  scala&gt;&nbsp;queue
  <code class="output">res49:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue(a,&nbsp;b,&nbsp;c)</code>
  <br>  scala&gt;&nbsp;queue.dequeue
  <code class="output">res50:&nbsp;String&nbsp;=&nbsp;a</code>
  <br>  scala&gt;&nbsp;queue
  <code class="output">res51:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue(b,&nbsp;c)</code>
</pre>
      <h4>Stacks</h4>
      <p>Scala provides a mutable <span class="code">Stack</span>. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stack&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">scala.collection.mutable.Stack[Int]</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">stack:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack()</code>
  <br>  scala&gt;&nbsp;stack.push(<code class="literal">1</code>)
  <code class="output">res52:&nbsp;stack.type&nbsp;=&nbsp;Stack(1)</code>
  <br>  scala&gt;&nbsp;stack
  <code class="output">res53:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</code>
  <br>  scala&gt;&nbsp;stack.push(<code class="literal">2</code>)
  <code class="output">res54:&nbsp;stack.type&nbsp;=&nbsp;Stack(2,&nbsp;1)</code>
  <br>  scala&gt;&nbsp;stack
  <code class="output">res55:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(2,&nbsp;1)</code>
  <br>  scala&gt;&nbsp;stack.top
  <code class="output">res56:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;stack
  <code class="output">res57:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(2,&nbsp;1)</code>
  <br>  scala&gt;&nbsp;stack.pop
  <code class="output">res58:&nbsp;Int&nbsp;=&nbsp;2</code>
  <br>  scala&gt;&nbsp;stack&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">res59:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</code>
</pre>
      <p>Note that Scala does not offer an immutable stack, because <span class="code">List</span> provides the same functions. A push on an immutable stack is the same as a <span class="code">::</span> on a list. A <span class="code">pop</span> is the same as calling both <span class="code">head</span> and <span class="code">tail</span> on list.</p>
      <h4>Mutable <span class="code">ArraySeq</span>s</h4>
      <p>Array sequences are mutable sequences of fixed size that store their elements internally in an <span class="code">Array[AnyRef]</span>. They are implemented in Scala by class <span class="code">ArraySeq</span>.</p>
      <p>You would typically use an <span class="code">ArraySeq</span> if you want an array for its performance characteristics, but you also want to create generic instances of the sequence where you do not know the type of the elements and do not have a <span class="code">ClassTag</span> to provide it at run-time. You will find out about these issues with arrays shortly, in <a href="#sec-arrays">Section 24.9</a>.</p>
      <h4>Hash tables</h4>
      <p>A hash table stores its elements in an underlying array, placing each item at a position in the array determined by the hash code of that item. Adding an element to a hash table takes only constant time, so long as there isn't already another element in the array that has the same hash code. Hash tables are thus very fast so long as the objects placed in them have a good distribution of hash codes. As a result, the default mutable map and set types in Scala are based on hash tables.</p>
      <p>Hash sets and maps are used just like any other set or map. Here are some simple examples:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;collection.mutable.HashMap.empty[<code class="typename">Int</code>,<code class="typename">String</code>]
  <code class="output">map:&nbsp;scala.collection.mutable.HashMap[Int,String]&nbsp;=&nbsp;Map()</code>
  <br>  scala&gt;&nbsp;map&nbsp;+=&nbsp;(<code class="literal">1</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"make&nbsp;a&nbsp;web&nbsp;site"</code>)
  <code class="output">res60:&nbsp;map.type&nbsp;=&nbsp;Map(1&nbsp;-&gt;&nbsp;make&nbsp;a&nbsp;web&nbsp;site)</code>
  <br>  scala&gt;&nbsp;map&nbsp;+=&nbsp;(<code class="literal">3</code>&nbsp;-&gt;&nbsp;<code class="quotedstring">"profit!"</code>)
  <code class="output">res61:&nbsp;map.type&nbsp;=&nbsp;Map(1&nbsp;-&gt;&nbsp;make&nbsp;a&nbsp;web&nbsp;site,&nbsp;3&nbsp;-&gt;&nbsp;profit!)</code>
  <br>  scala&gt;&nbsp;map(<code class="literal">1</code>)
  <code class="output">res62:&nbsp;String&nbsp;=&nbsp;make&nbsp;a&nbsp;web&nbsp;site</code>
  <br>  scala&gt;&nbsp;map&nbsp;contains&nbsp;<code class="literal">2</code>
  <code class="output">res63:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>Iteration over a hash table is not guaranteed to occur in any particular order. Iteration simply proceeds through the underlying array in whichever order it happens to be. To get a guaranteed iteration order, use a <em>linked</em> hash map or set instead of a regular one. A linked hash map or set is just like a regular hash map or set except that it also includes a linked list of the elements in the order they were added. Iteration over such a collection is always in the same order that the elements were initially added.</p>
      <h4>Weak hash maps</h4>
      <p>A weak hash map<a id="i-707232831-1"></a> is a special kind of hash map in which the garbage collector does not follow links from the map to the keys stored in it. This means that a key and its associated value will disappear from the map if there is no other reference to that key. Weak hash maps are useful for tasks such as caching, where you want to re-use an expensive function's result if the function is called again on the same key. If keys and function results are stored in a regular hash map, the map could grow without bounds, and no key would ever become garbage. Using a weak hash map avoids this problem. As soon as a key object becomes unreachable, its entry is removed from the weak hash map. Weak hash maps in Scala are implemented as a wrapper of an underlying Java implementation, <span class="code">java.util.WeakHashMap</span>.</p>
      <h4>Concurrent maps</h4>
      <p>A concurrent map can be accessed by several threads at once. In addition to the usual <span class="code">Map</span> operations, it provides the following atomic operations:</p>
      <p><a id="tab-cmapops"></a></p>
      <h5>Operations in trait <span class="code">concurrent.Map</span> <a id="i-1337741596-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span class="code">m.putIfAbsent(k,</span>&nbsp;<span class="code">v)</span> </td>
            <td> Adds key/value binding <span class="code">k</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">v</span> unless <span class="code">k</span> is already defined in <span class="code">m</span><a id="i-432133008-1"></a><a id="i-1114573962-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">m.remove(k,</span>&nbsp;<span class="code">v)</span> </td>
            <td> Removes entry for <span class="code">k</span> if it is currently mapped to <span class="code">v</span><a id="i-573548081-1"></a><a id="i-218120845-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">m.replace(k,</span>&nbsp;<span class="code">old,</span>&nbsp;<span class="code">new)</span> </td>
            <td> Replaces value associated with key <span class="code">k</span> to <span class="code">new</span>, if it was previously bound to <span class="code">old</span><a id="i-400154625-1"></a><a id="i1830849445-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">m.replace(k,</span>&nbsp;<span class="code">v)</span> </td>
            <td> Replaces value associated with key <span class="code">k</span> to <span class="code">v</span>, if it was previously bound to some value </td>
          </tr>
        </tbody>
      </table>
      <p>The <span class="code">scala.concurrent.Map</span> trait defines an interface for mutable maps that allow concurrent access. The standard library offers two implentations of this trait. The first is Java's <span class="code">java.util.concurrent.ConcurrentMap</span>, which can be converted automatically to a Scala map using the standard Java/Scala collection conversions. (These conversions will be described in <a href="#sec-javaconversions">Section 24.16</a>.) The second is <span class="code">TrieMap</span>,<a id="i2026030746-1"></a> a lock-free implementation of a hash array mapped trie.</p>
      <h4>Mutable bit sets</h4>
      <p>A mutable bit set is just like an immutable one, except that it can be modified in place. Mutable bit sets are slightly more efficient at updating than immutable ones, because they don't have to copy around <span class="code">Long</span>s that haven't changed. Here is an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bits&nbsp;=&nbsp;scala.collection.mutable.BitSet.empty
  <code class="output">bits:&nbsp;scala.collection.mutable.BitSet&nbsp;=&nbsp;BitSet()</code>
  <br>  scala&gt;&nbsp;bits&nbsp;+=&nbsp;<code class="literal">1</code>
  <code class="output">res64:&nbsp;bits.type&nbsp;=&nbsp;BitSet(1)</code>
  <br>  scala&gt;&nbsp;bits&nbsp;+=&nbsp;<code class="literal">3</code>
  <code class="output">res65:&nbsp;bits.type&nbsp;=&nbsp;BitSet(1,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;bits
  <code class="output">res66:&nbsp;scala.collection.mutable.BitSet&nbsp;=&nbsp;BitSet(1,&nbsp;3)</code>
</pre>
      <h3 id="sec-arrays">24.9 Arrays</h3>
      <p>Arrays are a special kind of collection in Scala. On the one hand, Scala arrays correspond one-to-one to Java arrays. That is, a Scala array <span class="code">Array[Int]</span> is represented as a Java <span class="code">int[]</span>, an <span class="code">Array[Double]</span> is represented as a Java <span class="code">double[]</span> and an <span class="code">Array[String]</span> is represented as a Java <span class="code">String[]</span>. But at the same time, Scala arrays offer much more than their Java analogues. First, Scala arrays can be <span style="font-style:italic">generic</span>. That is, you can have an <span class="code">Array[T]</span>, where <span class="code">T</span> is a type parameter or abstract type. Second, Scala arrays are compatible with Scala sequences—you can pass an <span class="code">Array[T]</span> where a <span class="code">Seq[T]</span> is required. Finally, Scala arrays also support all sequence operations. Here's an example of this in action:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a1&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">a1:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a2&nbsp;=&nbsp;a1&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">3</code>)
  <code class="output">a2:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;6,&nbsp;9)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a3&nbsp;=&nbsp;a2&nbsp;filter&nbsp;(_&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;!=&nbsp;<code class="literal">0</code>)
  <code class="output">a3:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;9)</code>
  <br>  scala&gt;&nbsp;a3.reverse
  <code class="output">res1:&nbsp;Array[Int]&nbsp;=&nbsp;Array(9,&nbsp;3)</code>
</pre>
      <p>Given that Scala arrays are represented just like Java arrays, how can these additional features be supported in Scala?</p>
      <p>The answer lies in systematic use of implicit conversions. An array cannot pretend to <span style="font-style:italic">be</span> a sequence, because the data type representation of a native array is not a subtype of <span class="code">Seq</span>. Instead, whenever an array would be used as a <span class="code">Seq</span>, implicitly wrap it in a subclass of <span class="code">Seq</span>. The name of that subclass is <span class="code">scala.collection.mutable.ArraySeq</span>. Here you see it in action:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;seq:&nbsp;<code class="typename">collection.Seq[Int]</code>&nbsp;=&nbsp;a1
  seq:&nbsp;<code class="typename">scala.collection.Seq[Int]</code>&nbsp;=&nbsp;<code class="typename">ArraySeq</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;a4:&nbsp;<code class="typename">Array[Int]</code>&nbsp;=&nbsp;seq.toArray
  a4:&nbsp;<code class="typename">Array[Int]</code>&nbsp;=&nbsp;<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <br>  scala&gt;&nbsp;a1&nbsp;eq&nbsp;a4
  res2:&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;<code class="vem">false</code>
</pre>
      <p>This interaction demonstrates that arrays are compatible with sequences, because there's an implicit conversion from <span class="code">Array</span> to <span class="code">ArraySeq</span>. To go the other way, from an <span class="code">ArraySeq</span> to an <span class="code">Array</span>, you can use the <span class="code">toArray</span> method defined in <span class="code">Iterable</span>. The last interpreter line above shows that wrapping then unwrapping with <span class="code">toArray</span> produces a copy of the original array.</p>
      <p>There is yet another implicit conversion that gets applied to arrays. This conversion simply "adds" all sequence methods to arrays but does not turn the array itself into a sequence. "Adding" means that the array is wrapped in another object of type <span class="code">ArrayOps</span>, which supports all sequence methods. Typically, this <span class="code">ArrayOps</span> object is short-lived; it will usually be inaccessible after the call to the sequence method and its storage can be recycled. Modern VMs often avoid creating this object entirely.</p>
      <p>The difference between the two implicit conversions on arrays is demonstrated here:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;seq:&nbsp;<code class="typename">collection.Seq[Int]</code>&nbsp;=&nbsp;a1
  <code class="output">seq:&nbsp;scala.collection.Seq[Int]&nbsp;=&nbsp;ArraySeq(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;seq.reverse
  <code class="output">res2:&nbsp;scala.collection.Seq[Int]&nbsp;=&nbsp;ArraySeq(3,&nbsp;2,&nbsp;1)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;ops:&nbsp;<code class="typename">collection.ArrayOps[Int]</code>&nbsp;=&nbsp;a1
  <code class="output">ops:&nbsp;scala.collection.ArrayOps[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;ops.reverse
  <code class="output">res3:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;2,&nbsp;1)</code>
</pre>
      <p>You see that calling <span class="code">reverse</span> on <span class="code">seq</span>, which is an <span class="code">ArraySeq</span>, will give again an <span class="code">ArraySeq</span>. That's logical, because <span class="code">ArraySeq</span>s are <span class="code">Seq</span>s, and calling <span class="code">reverse</span> on any <span class="code">Seq</span> will give again a <span class="code">Seq</span>. On the other hand, calling <span class="code">reverse</span> on the <span class="code">ops</span> value, which has type <span class="code">ArrayOps</span>, will result in an <span class="code">Array</span>, not a <span class="code">Seq</span>.</p>
      <p>The <span class="code">ArrayOps</span> example above was quite artificial, intended only to show the difference to <span class="code">ArraySeq</span>. Normally, you'd never define a value of class <span class="code">ArrayOps</span>. You'd just call a <span class="code">Seq</span> method on an array:</p> <pre>  scala&gt;&nbsp;a1.reverse
  <code class="output">res4:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;2,&nbsp;1)</code>
</pre>
      <p>The <span class="code">ArrayOps</span> object gets inserted automatically by the implicit conversion. So the line above is equivalent to the following line, where <span class="code">intArrayOps</span> was the conversion that was implicitly inserted previously:</p> <pre>  scala&gt;&nbsp;intArrayOps(a1).reverse
  <code class="output">res5:&nbsp;Array[Int]&nbsp;=&nbsp;Array(3,&nbsp;2,&nbsp;1)</code>
</pre>
      <p>This raises the question how the compiler picked <span class="code">intArrayOps</span> over the other implicit conversion to <span class="code">ArraySeq</span> in the line above. After all, both conversions map an array to a type that supports a <span class="code">reverse</span> method, which is what the input specified. The answer to that question is that the two implicit conversions are prioritized. The <span class="code">ArrayOps</span> conversion has a higher priority than the <span class="code">ArraySeq</span> conversion. The first is defined in the <span class="code">Predef</span> object whereas the second is defined in a class <span class="code">scala.LowPriorityImplicits</span>, which is a superclass of <span class="code">Predef</span>. Implicits in subclasses and subobjects take precedence over implicits in base classes. So if both conversions are applicable, the one in <span class="code">Predef</span> is chosen. A very similar scheme, which was described in <a href="#sec-when-multiple-conversions-apply">Section 21.7</a>, works for strings.</p>
      <p>So now you know how arrays can be compatible with sequences and how they can support all sequence operations. What about genericity? In Java you cannot write a <span class="code">T[]</span> where <span class="code">T</span> is a type parameter. How then is Scala's <span class="code">Array[T]</span> represented? In fact a generic array<a id="i953627543-1"></a><a id="i337692579-1"></a> like <span class="code">Array[T]</span> could be at run time any of Java's eight primitive array types <span class="code">byte[]</span>, <span class="code">short[]</span>, <span class="code">char[]</span>, <span class="code">int[]</span>, <span class="code">long[]</span>, <span class="code">float[]</span>, <span class="code">double[]</span>, <span class="code">boolean[]</span>, or it could be an array of objects. The only common run-time type encompassing all of these types is <span class="code">AnyRef</span> (or, equivalently <span class="code">java.lang.Object</span>), so that's the type to which the Scala compiler maps <span class="code">Array[T]</span>. At run-time, when an element of an array of type <span class="code">Array[T]</span> is accessed or updated there is a sequence of type tests that determine the actual array type, followed by the correct array operation on the Java array. These type tests slow down array operations somewhat. You can expect accesses to generic arrays to be three to four times slower than accesses to primitive or object arrays. This means that if you need maximal performance, you should prefer concrete over generic arrays.</p>
      <p>Representing the generic array type is not enough, however, there must also be a way to <span style="font-style:italic">create</span> generic arrays. This is an even harder problem, which requires a little bit of help from you. To illustrate the problem, consider the following attempt to write a generic method that creates an array:</p> <pre>  <code class="comment">//&nbsp;This&nbsp;is&nbsp;wrong!</code>
  <code class="vem">def</code>&nbsp;evenElems[T](xs:&nbsp;<code class="typename">Vector[T]</code>):&nbsp;<code class="typename">Array[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[T]</code>((xs.length&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;xs.length&nbsp;by&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;arr(i&nbsp;/&nbsp;<code class="literal">2</code>)&nbsp;=&nbsp;xs(i)
  &nbsp;&nbsp;arr
  }
</pre>
      <p>The <span class="code">evenElems</span> method returns a new array that consists of all elements of the argument vector <span class="code">xs</span> that are at even positions in the vector. The first line of the body of <span class="code">evenElems</span> creates the result array, which has the same element type as the argument. So depending on the actual type parameter for <span class="code">T</span>, this could be an <span class="code">Array[Int]</span>, or an <span class="code">Array[Boolean]</span>, or an array of some of the other primitive types in Java, or an array of some reference type. But these types all have different runtime representations, so how is the Scala runtime going to pick the correct one? In fact, it can't do that based on the information it is given, because the actual type that corresponds to the type parameter <span class="code">T</span> is erased at runtime. That's why you will get the following error message if you attempt to compile the code above:</p> <pre>  error:&nbsp;cannot&nbsp;find&nbsp;<code class="vem">class</code>&nbsp;tag&nbsp;<code class="vem">for</code>&nbsp;element&nbsp;<code class="vem">type</code>&nbsp;T
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[T]</code>((arr.length&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre>
      <p>What's required here is that you help the compiler by providing a runtime hint of what the actual type parameter of <span class="code">evenElems</span> is. This runtime hint takes the form of a <span style="font-style:italic">class tag</span> of type <span class="code">scala.reflect.ClassTag</span>. A class tag describes the <em>erased type</em> of a given type, which is all the information needed to construct an array of that type.</p>
      <p>In many cases the compiler can generate a class tag on its own. Such is the case for a concrete type like <span class="code">Int</span> or <span class="code">String</span>. It's also the case for certain generic types, like <span class="code">List[T]</span>, where enough information is known to predict the erased type; in this example the erased type would be <span class="code">List</span>.</p>
      <p>For fully generic cases, the usual idiom is to pass the class tag using a context bound, as discussed in <a href="#sec-context-bounds">Section 21.6</a>. Here is how the above definition could be fixed by using a context bound:</p> <pre>  <code class="comment">//&nbsp;This&nbsp;works</code>
  <code class="vem">import</code>&nbsp;scala.reflect.ClassTag
  <code class="vem">def</code>&nbsp;evenElems[T:&nbsp;<code class="typename">ClassTag</code>](xs:&nbsp;<code class="typename">Vector[T]</code>):&nbsp;<code class="typename">Array[T]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;arr&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[T]</code>((xs.length&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;xs.length&nbsp;by&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;arr(i&nbsp;/&nbsp;<code class="literal">2</code>)&nbsp;=&nbsp;xs(i)
  &nbsp;&nbsp;arr
  }
</pre>
      <p>In this new definition, when the <span class="code">Array[T]</span> is created, the compiler looks for a class tag for the type parameter <span class="code">T</span>, that is, it will look for an implicit value of type <span class="code">ClassTag[T]</span>. If such a value is found, the class tag is used to construct the right kind of array. Otherwise, you'll see an error message like the one shown previously.</p>
      <p>Here is an interpreter interaction that uses the <span class="code">evenElems</span> method:</p> <pre>  scala&gt;&nbsp;evenElems(<code class="typename">Vector</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>))
  <code class="output">res6:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;3,&nbsp;5)</code>
  <br>  scala&gt;&nbsp;evenElems(<code class="typename">Vector</code>(<code class="quotedstring">"this"</code>,&nbsp;<code class="quotedstring">"is"</code>,&nbsp;<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"test"</code>,&nbsp;<code class="quotedstring">"run"</code>))
  <code class="output">res7:&nbsp;Array[java.lang.String]&nbsp;=&nbsp;Array(this,&nbsp;a,&nbsp;run)</code>
</pre>
      <p>In both cases, the Scala compiler automatically constructed a class tag for the element type (first <span class="code">Int</span>, then <span class="code">String</span>) and passed it to the implicit parameter of the <span class="code">evenElems</span> method. The compiler can do that for all concrete types, but not if the argument is itself another type parameter without its class tag. For instance, the following fails:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;wrap[U](xs:&nbsp;<code class="typename">Vector[U]</code>)&nbsp;=&nbsp;evenElems(xs)
  <code class="output">&lt;console&gt;:9:&nbsp;error:&nbsp;No&nbsp;ClassTag&nbsp;available&nbsp;for&nbsp;U</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;wrap[U](xs:&nbsp;Vector[U])&nbsp;=&nbsp;evenElems(xs)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>What happened here is that the <span class="code">evenElems</span> demands a class tag for the type parameter <span class="code">U</span>, but none was found. The solution in this case is, of course, to demand another implicit class tag for <span class="code">U</span>. So the following works:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;wrap[U:&nbsp;<code class="typename">ClassTag</code>](xs:&nbsp;<code class="typename">Vector[U]</code>)&nbsp;=&nbsp;evenElems(xs)
  <code class="output">wrap:&nbsp;[U](xs:&nbsp;Vector[U])(implicit&nbsp;evidence$1:</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.reflect.ClassTag[U])Array[U]</code>
</pre>
      <p>This example also shows that the context bound in the definition of <span class="code">U</span> is just a shorthand for an implicit parameter named here <span class="code">evidence$1</span> of type <span class="code">ClassTag[U]</span>.</p>
      <h3>24.10 Strings</h3>
      <p>Like arrays, strings are not directly sequences, but they can be converted to them, and they also support all sequence operations. Here are some examples of operations you can invoke on strings:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;str&nbsp;=&nbsp;<code class="quotedstring">"hello"</code>
  <code class="output">str:&nbsp;java.lang.String&nbsp;=&nbsp;hello</code>
  <br>  scala&gt;&nbsp;str.reverse
  <code class="output">res6:&nbsp;String&nbsp;=&nbsp;olleh</code>
  <br>  scala&gt;&nbsp;str.map(_.toUpper)
  <code class="output">res7:&nbsp;String&nbsp;=&nbsp;HELLO</code>
  <br>  scala&gt;&nbsp;str&nbsp;drop&nbsp;<code class="literal">3</code>&nbsp;
  <code class="output">res8:&nbsp;String&nbsp;=&nbsp;lo</code>
  <br>  scala&gt;&nbsp;str.slice(<code class="literal">1</code>,&nbsp;<code class="literal">4</code>)
  <code class="output">res9:&nbsp;String&nbsp;=&nbsp;ell</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s:&nbsp;<code class="typename">Seq[Char]</code>&nbsp;=&nbsp;str
  <code class="output">s:&nbsp;Seq[Char]&nbsp;=&nbsp;hello</code>
</pre>
      <p>These operations are supported by two implicit conversions, which were explained in <a href="#sec-when-multiple-conversions-apply">Section 21.7</a>. The first, low-priority conversion maps a <span class="code">String</span> to a <span class="code">WrappedString</span>, which is a subclass of <span class="code">immutable.IndexedSeq</span>. This conversion was applied in the last line of the previous example in which a string was converted into a <span class="code">Seq</span>. The other, high-priority conversion maps a string to a <span class="code">StringOps</span> object, which adds all methods on immutable sequences to strings. This conversion was implicitly inserted in the method calls of <span class="code">reverse</span>, <span class="code">map</span>, <span class="code">drop</span>, and <span class="code">slice</span> in the previous example.</p>
      <h3>24.11 Performance characteristics</h3>
      <p>As the previous explanations have shown, different collection types have different performance characteristics.<a id="i1597641046-1"></a> That's often the primary reason for picking one collection type over another. You can see the performance characteristics of some common operations on collections summarized in two tables, <a href="#tab-seq-perf">Table 24.11</a> and <a href="#tab-setmap-perf">Table 24.11</a>.</p>
      <p><a id="tab-seq-perf"></a></p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> </td>
            <td> <span style="font-size:small">head</span> </td>
            <td> <span style="font-size:small">tail</span> </td>
            <td> <span style="font-size:small">apply</span> </td>
            <td> <span style="font-size:small">update</span> </td>
            <td> <span style="font-size:small">prepend</span> </td>
            <td> <span style="font-size:small">append</span> </td>
            <td> <span style="font-size:small">insert</span> </td>
          </tr>
          <tr class="topline ">
            <td> <span style="font-weight:bold">immutable</span> </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">List</span> </td>
            <td> C </td>
            <td> C </td>
            <td> L </td>
            <td> L </td>
            <td> C </td>
            <td> L </td>
            <td> - </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">LazyList</span> </td>
            <td> C </td>
            <td> C </td>
            <td> L </td>
            <td> L </td>
            <td> C </td>
            <td> L </td>
            <td> - </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ArraySeq</span> </td>
            <td> C </td>
            <td> L </td>
            <td> C </td>
            <td> L </td>
            <td> L </td>
            <td> L </td>
            <td> - </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Vector</span> </td>
            <td> eC </td>
            <td> eC </td>
            <td> eC </td>
            <td> eC </td>
            <td> eC </td>
            <td> eC </td>
            <td> - </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Queue</span> </td>
            <td> aC </td>
            <td> aC </td>
            <td> L </td>
            <td> L </td>
            <td> L </td>
            <td> C </td>
            <td> - </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Range</span> </td>
            <td> C </td>
            <td> C </td>
            <td> C </td>
            <td> - </td>
            <td> - </td>
            <td> - </td>
            <td> - </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">String</span> </td>
            <td> C </td>
            <td> L </td>
            <td> C </td>
            <td> L </td>
            <td> L </td>
            <td> L </td>
            <td> - </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">mutable</span> </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ArrayBuffer</span> </td>
            <td> C </td>
            <td> L </td>
            <td> C </td>
            <td> C </td>
            <td> L </td>
            <td> aC </td>
            <td> L </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ListBuffer</span> </td>
            <td> C </td>
            <td> L </td>
            <td> L </td>
            <td> L </td>
            <td> C </td>
            <td> C </td>
            <td> L </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">StringBuilder</span> </td>
            <td> C </td>
            <td> L </td>
            <td> C </td>
            <td> C </td>
            <td> L </td>
            <td> aC </td>
            <td> L </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Queue</span> </td>
            <td> C </td>
            <td> L </td>
            <td> L </td>
            <td> L </td>
            <td> C </td>
            <td> C </td>
            <td> L </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ArraySeq</span> </td>
            <td> C </td>
            <td> L </td>
            <td> C </td>
            <td> C </td>
            <td> - </td>
            <td> - </td>
            <td> - </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Stack</span> </td>
            <td> C </td>
            <td> L </td>
            <td> L </td>
            <td> L </td>
            <td> C </td>
            <td> L </td>
            <td> L </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">Array</span> </td>
            <td> C </td>
            <td> L </td>
            <td> C </td>
            <td> C </td>
            <td> - </td>
            <td> - </td>
            <td> - </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ArrayDeque</span> </td>
            <td> C </td>
            <td> L </td>
            <td> C </td>
            <td> C </td>
            <td> aC </td>
            <td> aC </td>
            <td> L </td>
          </tr>
        </tbody>
      </table>
      <h5>Performance characteristics of sequence types</h5>
      <p><a id="tab-setmap-perf"></a></p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> </td>
            <td> <span style="font-size:small">lookup</span> </td>
            <td> <span style="font-size:small">add</span> </td>
            <td> <span style="font-size:small">remove</span> </td>
            <td> <span style="font-size:small">min</span> </td>
          </tr>
          <tr class="topline ">
            <td> <span style="font-weight:bold">immutable</span> </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">HashSet/HashMap</span> </td>
            <td> eC </td>
            <td> eC </td>
            <td> eC </td>
            <td> L </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">TreeSet/TreeMap</span> </td>
            <td> Log </td>
            <td> Log </td>
            <td> Log </td>
            <td> Log </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">BitSet</span> </td>
            <td> C </td>
            <td> L </td>
            <td> L </td>
            <td> eC<a href="#footnotemain24-6">[6]</a> </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">VectorMap</span> </td>
            <td> eC </td>
            <td> eC </td>
            <td> aC </td>
            <td> L </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ListMap</span> </td>
            <td> L </td>
            <td> L </td>
            <td> L </td>
            <td> L </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">mutable</span> </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">HashSet/HashMap</span> </td>
            <td> eC </td>
            <td> eC </td>
            <td> eC </td>
            <td> L </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">WeakHashMap</span> </td>
            <td> eC </td>
            <td> eC </td>
            <td> eC </td>
            <td> L </td>
          </tr>
          <tr>
            <td> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">BitSet</span> </td>
            <td> C </td>
            <td> aC </td>
            <td> C </td>
            <td> eC[5] </td>
          </tr>
        </tbody>
      </table>
      <h5>Performance characteristics of set and map types</h5>
      <p>The entries in these two tables are explained as follows:</p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> C </td>
            <td> The operation takes (fast) constant time. </td>
          </tr>
          <tr>
            <td> eC </td>
            <td> The operation takes effectively constant time, but this might depend on some assumptions such as the maximum length of a vector or the distribution of hash keys. </td>
          </tr>
          <tr>
            <td> aC </td>
            <td> The operation takes amortized constant time. Some invocations of the operation might take longer, but if many operations are performed on average only constant time per operation is taken. </td>
          </tr>
          <tr>
            <td> Log </td>
            <td> The operation takes time proportional to the logarithm of the collection size. </td>
          </tr>
          <tr>
            <td> L </td>
            <td> The operation is linear, that is it takes time proportional to the collection size. </td>
          </tr>
          <tr>
            <td> - </td>
            <td> The operation is not supported. </td>
          </tr>
        </tbody>
      </table>
      <p><a href="#tab-seq-perf">Table 24.11</a> treats sequence types—both immutable and mutable—with the following operations:</p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> head </td>
            <td> Selecting the first element of the sequence. </td>
          </tr>
          <tr>
            <td> tail </td>
            <td> Producing a new sequence that consists of all elements except the first one. </td>
          </tr>
          <tr>
            <td> apply </td>
            <td> Indexing. </td>
          </tr>
          <tr>
            <td> update </td>
            <td> Functional update (with <span class="code">updated</span>) for immutable sequences, side-effecting update (with <span class="code">update</span>) for mutable sequences. </td>
          </tr>
          <tr>
            <td> prepend </td>
            <td> Adding an element to the front of the sequence. For immutable sequences, this produces a new sequence. For mutable sequences it modifies the existing sequence. </td>
          </tr>
          <tr>
            <td> append </td>
            <td> Adding an element at the end of the sequence. For immutable sequences, this produces a new sequence. For mutable sequences it modifies the existing sequence. </td>
          </tr>
          <tr>
            <td> insert </td>
            <td> Inserting an element at an arbitrary position in the sequence. This is only supported directly for mutable sequences. </td>
          </tr>
        </tbody>
      </table>
      <p><a href="#tab-setmap-perf">Table 24.11</a> treats mutable and immutable sets and maps with the following operations:</p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> lookup </td>
            <td> Testing whether an element is contained in set, or selecting a value associated with a key. </td>
          </tr>
          <tr>
            <td> add </td>
            <td> Adding a new element to a set or a new key/value pair to a map. </td>
          </tr>
          <tr>
            <td> remove </td>
            <td> Removing an element from a set or a key from a map. </td>
          </tr>
          <tr>
            <td> min </td>
            <td> The smallest element of the set, or the smallest key of a map. </td>
          </tr>
        </tbody>
      </table>
      <h3 id="sec-coll-arch-eq">24.12 Equality</h3>
      <p>The collection libraries have a uniform approach to equality and hashing. The idea is, first, to divide collections into sets, maps, and sequences. Collections in different categories are always unequal. For instance, <span class="code">Set(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> is unequal to <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> even though they contain the same elements. On the other hand, within the same category, collections are equal if and only if they have the same elements (for sequences: the same elements in the same order). For example, <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">Vector(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>, and <span class="code">HashSet(1,</span>&nbsp;<span class="code">2)</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">TreeSet(2,</span>&nbsp;<span class="code">1)</span>.</p>
      <p>It does not matter for the equality check whether a collection is mutable or immutable. For a mutable collection, equality simply depends on the current elements at the time the equality test is performed. This means that a mutable collection might be equal to different collections at different times, depending what elements are added or removed. This is a potential trap when using a mutable collection as a key in a hash map. For example:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.mutable.{<code class="typename">HashMap</code>,&nbsp;<code class="typename">ArrayBuffer</code>}
  <code class="output">import&nbsp;collection.mutable.{HashMap,&nbsp;ArrayBuffer}</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf&nbsp;=&nbsp;<code class="typename">ArrayBuffer</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;</code>
  <code class="output">ArrayBuffer(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;map&nbsp;=&nbsp;<code class="typename">HashMap</code>(buf&nbsp;-&gt;&nbsp;<code class="literal">3</code>)
  <code class="output">map:&nbsp;scala.collection.mutable.HashMap[scala.collection.</code>
  <code class="output">mutable.ArrayBuffer[Int],Int]&nbsp;=&nbsp;Map((ArrayBuffer(1,&nbsp;2,&nbsp;3),3))</code>
  <br>  scala&gt;&nbsp;map(buf)
  <code class="output">res13:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br>  scala&gt;&nbsp;buf(<code class="literal">0</code>)&nbsp;+=&nbsp;<code class="literal">1</code>
  <br>  scala&gt;&nbsp;map(buf)
  <code class="output">java.util.NoSuchElementException:&nbsp;key&nbsp;not&nbsp;found:&nbsp;</code>
  <code class="output">&nbsp;&nbsp;ArrayBuffer(2,&nbsp;2,&nbsp;3)&nbsp;</code>
</pre>
      <p>In this example, the selection in the last line will most likely fail because the hash code of the array <span class="code">xs</span> has changed in the second-to-last line. Therefore, the hash-code-based lookup will look at a different place than the one in which <span class="code">xs</span> was stored.</p>
      <h3 id="sec-views">24.13 Views</h3>
      <p>Collections have quite a few methods that construct new collections.<a id="i112204398-1"></a><a id="i-1938971378-1"></a> Some examples are <span class="code">map</span>, <span class="code">filter</span>, and <span class="code">++</span>. We call such methods <span style="font-style:italic">transformers</span><a id="i-1856481670-1"></a> because they take at least one collection as their receiver object and produce another collection in their result.</p>
      <p>Transformers can be implemented in two principal ways: strict and non-strict (or lazy). A strict transformer constructs a new collection with all of its elements. A non-strict, or lazy, transformer constructs only a proxy for the result collection, and its elements are constructed on demand.</p>
      <p>As an example of a non-strict transformer, consider the following implementation of a lazy map operation:</p> <pre>  <code class="vem">def</code>&nbsp;lazyMap[T,&nbsp;U](coll:&nbsp;<code class="typename">Iterable[T]</code>,&nbsp;f:&nbsp;T&nbsp;=&gt;&nbsp;U)&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Iterable[U]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator&nbsp;=&nbsp;coll.iterator&nbsp;map&nbsp;f
  &nbsp;&nbsp;}
</pre>
      <p>Note that <span class="code">lazyMap</span> constructs a new <span class="code">Iterable</span> without stepping through all elements of the given collection <span class="code">coll</span>. The given function <span class="code">f</span> is instead applied to the elements of the new collection's <span class="code">iterator</span> as they are demanded.</p>
      <p>Scala collections are by default strict in all their transformers, except for <span class="code">LazyList</span>, which implements all its transformer methods lazily. However, there is a systematic way to turn every collection into a lazy one and <span style="font-style:italic">vice versa</span>, which is based on collection views. A <span style="font-style:italic">view</span> is a special kind of collection that represents some base collection, but implements all of its transformers lazily.</p>
      <p>To go from a collection to its view, you can use the <span class="code">view</span> method on the collection. If <span class="code">xs</span> is some collection, then <span class="code">xs.view</span><a id="i499973296-2"></a><a id="i1114375700-2"></a> is the same collection, but with all transformers implemented lazily. To get back from a view to a strict collection, you can use the <span class="code">to</span> conversion operation<a id="i1722437569-1"></a> with a strict collection factory as parameter.</p>
      <p>As an example, say you have a vector of <span class="code">Int</span>s over which you want to map two functions in succession:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;v&nbsp;=&nbsp;<code class="typename">Vector</code>(<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>:&nbsp;_*)
  <code class="output">v:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Vector(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9,&nbsp;10)</code>
  <br>  scala&gt;&nbsp;v&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res5:&nbsp;scala.collection.immutable.Vector[Int]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Vector(4,&nbsp;6,&nbsp;8,&nbsp;10,&nbsp;12,&nbsp;14,&nbsp;16,&nbsp;18,&nbsp;20,&nbsp;22)</code>
</pre>
      <p>In the last statement, the expression <span class="code">v</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">(_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span> constructs a new vector that is then transformed into a third vector by the second call to <span class="code">map</span>&nbsp;<span class="code">(_</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2)</span>. In many situations, constructing the intermediate result from the first call to <span class="code">map</span> is a bit wasteful. In the pseudo example, it would be faster to do a single <span class="code">map</span> with the composition of the two functions <span class="code">(_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span> and <span class="code">(_</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2)</span>. If you have the two functions available in the same place you can do this by hand. But quite often, successive transformations of a data structure are done in different program modules. Fusing those transformations would then undermine modularity. A more general way to avoid the intermediate results is by turning the vector first into a view, applying all transformations to the view, and finally forcing the view to a vector:</p> <pre>  scala&gt;&nbsp;(v.view&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)).to(<code class="typename">Vector</code>)
  <code class="output">res12:&nbsp;Seq[Int]&nbsp;=&nbsp;Vector(4,&nbsp;6,&nbsp;8,&nbsp;10,&nbsp;12,&nbsp;14,&nbsp;16,&nbsp;18,&nbsp;20,&nbsp;22)&nbsp;&nbsp;</code>
</pre>
      <p>We'll do this sequence of operations again, one by one:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;vv&nbsp;=&nbsp;v.view
  <code class="output">vv:&nbsp;scala.collection.IndexedSeqView[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;IndexedSeqView(&lt;not&nbsp;computed&gt;)</code>
</pre>
      <p>The application <span class="code">v.view</span> gives you an <span class="code">IndexedSeqView</span>, a lazily evaluated <span class="code">IndexedSeq</span>. As with <span class="code">LazyList</span>, <span class="code">toString</span> on views does not force the view elements. That's why the <span class="code">vv</span>'s elements are displayed as <span class="code">not</span>&nbsp;<span class="code">computed</span>.</p>
      <p>Applying the first <span class="code">map</span> to the view gives you:</p> <pre>  scala&gt;&nbsp;vv&nbsp;map&nbsp;(_&nbsp;+&nbsp;<code class="literal">1</code>)
  <code class="output">res13:&nbsp;scala.collection.IndexedSeqView[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;IndexedSeqView(&lt;not&nbsp;computed&gt;)</code>
</pre>
      <p>The result of the <span class="code">map</span> is another <span class="code">IndexedSeqView[Int]</span> value. This is in essence a wrapper that <span style="font-style:italic">records</span> the fact that a <span class="code">map</span> with function <span class="code">(_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span> needs to be applied on the vector <span class="code">v</span>. It does not apply that map until the view is forced, however. We'll now apply the second <span class="code">map</span> to the last result.</p> <pre>  scala&gt;&nbsp;res13&nbsp;map&nbsp;(_&nbsp;*&nbsp;<code class="literal">2</code>)
  <code class="output">res14:&nbsp;scala.collection.IndexedSeqView[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;IndexedSeqView(&lt;not&nbsp;computed&gt;)</code>
</pre>
      <p>Finally, forcing the last result gives:</p> <pre>  scala&gt;&nbsp;res14.to(<code class="typename">Vector</code>)
  <code class="output">res15:&nbsp;Seq[Int]&nbsp;=&nbsp;Vector(4,&nbsp;6,&nbsp;8,&nbsp;10,&nbsp;12,&nbsp;14,&nbsp;16,&nbsp;18,&nbsp;20,&nbsp;22)</code>
</pre>
      <p>Both stored functions, <span class="code">(_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span> and <span class="code">(_</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2)</span>, get applied as part of the execution of the <span class="code">to</span> operation and a new vector is constructed. That way, no intermediate data structure is needed.</p>
      <p>Transformation operations applied to views don't build a new data structure. Instead, they return an iterable whose iterator is the result of applying the transformation operation to the underlying collection's iterator.</p>
      <p>The main reason for using views is performance. You have seen that by switching a collection to a view the construction of intermediate results can be avoided. These savings can be quite important. As another example, consider the problem of finding the first palindrome in a list of words. A palindrome is a word that reads backwards the same as forwards. Here are the necessary definitions:</p> <pre>  <code class="vem">def</code>&nbsp;isPalindrome(x:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;x&nbsp;==&nbsp;x.reverse
  <code class="vem">def</code>&nbsp;findPalindrome(s:&nbsp;<code class="typename">Iterable[String]</code>)&nbsp;=&nbsp;s&nbsp;find&nbsp;isPalindrome
</pre>
      <p>Now, assume you have a very long sequence, <span class="code">words</span>, and you want to find a palindrome in the first million words of that sequence. Can you re-use the definition of <span class="code">findPalindrome</span>? Of course, you could write:</p> <pre>  findPalindrome(words&nbsp;take&nbsp;<code class="literal">1000000</code>)
</pre>
      <p>This nicely separates the two aspects of taking the first million words of a sequence and finding a palindrome in it. But the downside is that it always constructs an intermediary sequence consisting of one million words, even if the first word of that sequence is already a palindrome. So potentially, 999,999 words are copied into the intermediary result without being inspected at all afterwards. Many programmers would give up here and write their own specialized version of finding palindromes in some given prefix of an argument sequence. But with views, you don't have to. Simply write:</p> <pre>  findPalindrome(words.view&nbsp;take&nbsp;<code class="literal">1000000</code>)
</pre>
      <p>This has the same nice separation of concerns, but instead of a sequence of a million elements it will only construct a single lightweight view object. This way, you do not need to choose between performance and modularity.</p>
      <p>After having seen all these nifty uses of views you might wonder why have strict collections at all? One reason is that performance comparisons do not always favor lazy over strict collections. For smaller collection sizes the added overhead of forming and applying closures in views is often greater than the gain from avoiding the intermediary data structures. A possibly more important reason is that evaluation in views can be very confusing if the delayed operations have side effects.</p>
      <p>Here's an example that bit a few users of versions of Scala before 2.8. In these versions the <span class="code">Range</span> type was lazy, so it behaved in effect like a view. People were trying to create a number of actors<a href="#footnotemain24-7">[7]</a> like this:</p> <pre>  <code class="vem">val</code>&nbsp;actors&nbsp;=&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)&nbsp;<code class="vem">yield</code>&nbsp;actor&nbsp;{&nbsp;...&nbsp;}
</pre>
      <p>They were surprised that none of the actors were executing afterwards, even though the <span class="code">actor</span> method should create and start an actor from the code that's enclosed in the braces following it. To explain why nothing happened, remember that the <span class="code">for</span> expression above is equivalent to an application of the <span class="code">map</span> method:</p> <pre>  <code class="vem">val</code>&nbsp;actors&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>)&nbsp;map&nbsp;(i&nbsp;=&gt;&nbsp;actor&nbsp;{&nbsp;...&nbsp;})
</pre>
      <p>Since previously the range produced by <span class="code">(1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">10)</span> behaved like a view, the result of the <span class="code">map</span> was again a view. That is, no element was computed, and, consequently, no actor was created! Actors would have been created by forcing the range of the whole expression, but it's far from obvious that this is what was required to make the actors do their work.</p>
      <p>To avoid surprises like this, the Scala collections gained more regular rules in version 2.8. All collections except lazy lists and views are strict. The only way to go from a strict to a lazy collection is via the <span class="code">view</span> method. The only way to go back is via <span class="code">to</span>. So the <span class="code">actors</span> definition above would behave as expected in Scala 2.8 in that it would create and start ten actors. To get back the surprising previous behavior, you'd have to add an explicit <span class="code">view</span> method call:</p> <pre>  <code class="vem">val</code>&nbsp;actors&nbsp;=&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;(<code class="literal">1</code>&nbsp;to&nbsp;<code class="literal">10</code>).view)&nbsp;<code class="vem">yield</code>&nbsp;actor&nbsp;{&nbsp;...&nbsp;}
</pre>
      <p>In summary, views are a powerful tool to reconcile concerns of efficiency with concerns of modularity. But in order not to be entangled in aspects of delayed evaluation, you should restrict views to purely functional code where collection transformations do not have side effects. What's best avoided is a mixture of views and operations that create new collections while also having side effects.</p>
      <h3>24.14 Iterators</h3>
      <p>An iterator is not a collection, but rather a way to access the elements of a collection one by one. The two basic operations on an iterator <span class="code">it</span> are <span class="code">next</span> and <span class="code">hasNext</span>. A call to <span class="code">it.next()</span> will return the next element of the iterator and advance the state of the iterator. Calling <span class="code">next</span> again on the same iterator will then yield the element one beyond the one returned previously. If there are no more elements to return, a call to <span class="code">next</span> will throw a <span class="code">NoSuchElementException</span>. You can find out whether there are more elements to return using <span class="code">Iterator</span>'s <span class="code">hasNext</span> method.</p>
      <p>The most straightforward way to "step through" all the elements returned by an iterator is to use a <span class="code">while</span> loop:</p> <pre>  <code class="vem">while</code>&nbsp;(it.hasNext)&nbsp;
  &nbsp;&nbsp;println(it.next())
</pre>
      <p>Iterators in Scala also provide analogues of most of the methods that you find in the <span class="code">Iterable</span> and <span class="code">Seq</span> traits. For instance, they provide a <span class="code">foreach</span> method that executes a given procedure on each element returned by an iterator. Using <span class="code">foreach</span>, the loop above could be abbreviated to:</p> <pre>  it&nbsp;foreach&nbsp;println
</pre>
      <p>As always, <span class="code">for</span> expressions can be used as an alternate syntax for expressions involving <span class="code">foreach</span>, <span class="code">map</span>, <span class="code">filter</span>, and <span class="code">flatMap</span>, so yet another way to print all elements returned by an iterator would be:</p> <pre>  <code class="vem">for</code>&nbsp;(elem&nbsp;&lt;-&nbsp;it)&nbsp;println(elem)
</pre>
      <p>There's an important difference between the <span class="code">foreach</span> method on iterators and the same method on iterable collections: When called on an iterator, <span class="code">foreach</span> will leave the iterator at its end when it is done. So calling <span class="code">next</span> again on the same iterator will fail with a <span class="code">NoSuchElementException</span>. By contrast, when called on a collection, <span class="code">foreach</span> leaves the number of elements in the collection unchanged (unless the passed function adds or removes elements, but this is discouraged, because it can easily lead to surprising results).</p>
      <p>The other operations that <span class="code">Iterator</span> has in common with <span class="code">Iterable</span> have the same property of leaving the iterator at its end when done. For instance, iterators provide a <span class="code">map</span> method, which returns a new iterator:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;<code class="typename">Iterator</code>(<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"number"</code>,&nbsp;<code class="quotedstring">"of"</code>,&nbsp;<code class="quotedstring">"words"</code>)
  <code class="output">it:&nbsp;Iterator[java.lang.String]&nbsp;=&nbsp;&lt;iterator&gt;</code>
  <br>  scala&gt;&nbsp;it.map(_.length)
  <code class="output">res1:&nbsp;Iterator[Int]&nbsp;=&nbsp;&lt;iterator&gt;</code>
  <br>  scala&gt;&nbsp;it.hasNext
  <code class="output">res2:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;res1&nbsp;foreach&nbsp;println
  <code class="output">1</code>
  <code class="output">6</code>
  <code class="output">2</code>
  <code class="output">5</code>
  <br>  scala&gt;&nbsp;it.hasNext
  <code class="output">res4:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>As you can see, after the call to <span class="code">map</span>, the <span class="code">it</span> iterator hasn't advanced to its end, but traversing the iterator resulting from the call to <span class="code">it.map</span> also traverses <span class="code">it</span> and advances it to its end.</p>
      <p>Another example is the <span class="code">dropWhile</span> method, which can be used to find the first element of an iterator that has a certain property. For instance, to find the first word in the iterator shown previously that has at least two characters, you could write:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;<code class="typename">Iterator</code>(<code class="quotedstring">"a"</code>,&nbsp;<code class="quotedstring">"number"</code>,&nbsp;<code class="quotedstring">"of"</code>,&nbsp;<code class="quotedstring">"words"</code>)
  <code class="output">it:&nbsp;Iterator[java.lang.String]&nbsp;=&nbsp;&lt;iterator&gt;</code>
  <br>  scala&gt;&nbsp;it&nbsp;dropWhile&nbsp;(_.length&nbsp;&lt;&nbsp;<code class="literal">2</code>)
  <code class="output">res4:&nbsp;Iterator[java.lang.String]&nbsp;=&nbsp;&lt;iterator&gt;</code>
  <br>  scala&gt;&nbsp;it.next()
  <code class="output">res5:&nbsp;java.lang.String&nbsp;=&nbsp;number</code>
</pre>
      <p>Note again that <span class="code">it</span> has changed by the call to <span class="code">dropWhile</span>: it now points to the second word "number" in the list. In fact, <span class="code">it</span> and the result <span class="code">res4</span> returned by <span class="code">dropWhile</span> will return exactly the same sequence of elements.</p>
      <p>There is only one standard operation, <span class="code">duplicate</span>, which allows you to re-use the same iterator:</p> <pre>  <code class="vem">val</code>&nbsp;(it1,&nbsp;it2)&nbsp;=&nbsp;it.duplicate
</pre>
      <p>The call to duplicate gives you <span style="font-style:italic">two</span> iterators, which each return exactly the same elements as the iterator <span class="code">it</span>. The two iterators work independently; advancing one does not affect the other. By contrast the original iterator, <span class="code">it</span>, is advanced to its end by <span class="code">duplicate</span> and is thus rendered unusable.</p>
      <p>In summary, iterators behave like collections <span style="font-style:italic">if you never access an iterator again after invoking a method on it</span>. The Scala collection libraries make this explicit with an abstraction called <span class="code">IterableOnce</span>, which is a common supertrait of <span class="code">Iterable</span> and <span class="code">Iterator</span>. As the name implies, <span class="code">IterableOnce</span> objects can be traversed at least once but the state of that object after the traversal is not specified. If the <span class="code">IterableOnce</span> object is in fact an <span class="code">Iterator</span>, it will be at its end after the traversal, but if it is an <span class="code">Iterable</span>, it will still exist as before. A common use case of <span class="code">IterableOnce</span> is as an argument type for methods that can take either an iterator or an iterable as argument. An example is the appending method <span class="code">++</span> in trait <span class="code">Iterable</span>. It takes a <span class="code">IterableOnce</span> parameter, so you can append elements coming from either an iterator or an iterable collection.</p>
      <p>All operations on iterators are summarized in <a href="#tab-iteratorops">Table 24.14</a>.</p>
      <p><a id="tab-iteratorops"></a></p>
      <h5>Operations in trait <span class="code">Iterator</span> <a id="i-1527861747-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Abstract methods:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it.next()</span> </td>
            <td> Returns the next element in the iterator and advances past <span class="code">it</span>.<a id="i569433333-1"></a><a id="i314774649-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.hasNext</span> </td>
            <td> Returns <span class="code">true</span> if <span class="code">it</span> can return another element.<a id="i-2058143621-1"></a><a id="i387741031-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Variations:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it.buffered</span> </td>
            <td> A buffered iterator returning all elements of <span class="code">it</span>.<a id="i-1907025783-1"></a><a id="i1783293797-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">grouped</span>&nbsp;<span class="code">size</span> </td>
            <td> An iterator that yields the elements returned by <span class="code">it</span> in fixed-sized sequence "chunks."<a id="i-1552726294-1"></a><a id="i-15589352-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">xs</span>&nbsp;<span class="code">sliding</span>&nbsp;<span class="code">size</span> </td>
            <td> An iterator that yields the elements returned by <span class="code">it</span> in sequences representing a sliding fixed-sized window.<a id="i966114842-1"></a><a id="i1866691304-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Copying:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it.copyToArray(arr,</span>&nbsp;<span class="code">s,</span>&nbsp;<span class="code">l)</span> </td>
            <td> Copies at most <span class="code">l</span> elements returned by <span class="code">it</span> to array <span class="code">arr</span> starting at index <span class="code">s</span>. The last two arguments are optional.<a id="i172626160-1"></a><a id="i869836579-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Duplication:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it.duplicate</span> </td>
            <td> A pair of iterators that each independently return all elements of <span class="code">it</span>.<a id="i-1453185571-1"></a><a id="i587712325-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Additions:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">++</span>&nbsp;<span class="code">jt</span> </td>
            <td> An iterator returning all elements returned by iterator <span class="code">it</span>, followed by all elements returned by iterator <span class="code">jt</span>.<a id="i-387881431-1"></a><a id="i-456055993-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.padTo(len,</span>&nbsp;<span class="code">x)</span> </td>
            <td> The iterator that returns all elements of <span class="code">it</span> followed by copies of <span class="code">x</span> until length <span class="code">len</span> elements are returned overall.<a id="i1257723354-1"></a><a id="i1169787304-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Maps:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">f</span> </td>
            <td> The iterator obtained from applying the function <span class="code">f</span> to every element returned from <span class="code">it</span>.<a id="i-1166599508-1"></a><a id="i1949815574-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">flatMap</span>&nbsp;<span class="code">f</span> </td>
            <td> The iterator obtained from applying the iterator-valued function <span class="code">f</span> to every element in <span class="code">it</span> and appending the results.<a id="i1343836714-1"></a><a id="i-1087860771-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">collect</span>&nbsp;<span class="code">f</span> </td>
            <td> The iterator obtained from applying the partial function <span class="code">f</span> to every element in <span class="code">it</span> for which it is defined and collecting the results.<a id="i538616478-1"></a><a id="i640426468-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Conversions:<!-- \hfill --> </span> </td>
          </tr>
          <tr>
            <td> <span class="code">it.toArray</span> </td>
            <td> Collects the elements returned by <span class="code">it</span> in an array.<a id="i-681097814-1"></a><a id="i-1491400360-1"></a><a id="i595962916-4"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.toList</span> </td>
            <td> Collects the elements returned by <span class="code">it</span> in a list.<a id="i240940271-1"></a><a id="i2030419391-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.toIterable</span> </td>
            <td> Collects the elements returned by <span class="code">it</span> in an iterable.<a id="i-1426035429-1"></a><a id="i-690923245-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.toSeq</span> </td>
            <td> Collects the elements returned by <span class="code">it</span> in a sequence.<a id="i1681639716-1"></a><a id="i1173882654-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.toIndexedSeq</span> </td>
            <td> Collects the elements returned by <span class="code">it</span> in an indexed sequence.<a id="i721790495-1"></a><a id="i-31950321-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.toSet</span> </td>
            <td> Collects the elements returned by <span class="code">it</span> in a set.<a id="i1774699137-1"></a><a id="i1173882657-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.toMap</span> </td>
            <td> Collects the key/value pairs returned by <span class="code">it</span> in a map.<a id="i-667416889-1"></a><a id="i1173876763-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">SortedSet</span> </td>
            <td> Generic conversion operation that takes a collection factory as parameter. <a id="i1889657453-1"></a> <a id="i1171276161-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Size info:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it.isEmpty</span> </td>
            <td> Tests whether the iterator is empty (opposite of <span class="code">hasNext</span>).<a id="i-461566043-1"></a><a id="i1749021437-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.nonEmpty</span> </td>
            <td> Tests whether the collection contains elements (alias of <span class="code">hasNext</span>).<a id="i-1077580280-1"></a><a id="i390920454-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.size</span> </td>
            <td> The number of elements returned by <span class="code">it</span>. Note: <span class="code">it</span> will be at its end after this operation!<a id="i178959271-1"></a><a id="i314927495-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.length</span> </td>
            <td> Same as <span class="code">it.size</span>.<a id="i510850146-1"></a><a id="i1793161964-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.knownSize</span> </td>
            <td> The number of elements, if it is known without modifying the iterator's state, otherwise <span class="code">-1</span>.<a id="i-1896191196-1"></a><a id="i937228318-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Element retrieval index search:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">find</span>&nbsp;<span class="code">p</span> </td>
            <td> An option containing the first element returned by <span class="code">it</span> that satisfies <span class="code">p</span>, or <span class="code">None</span> if no element qualifies. Note: The iterator advances to just after the element, or, if none is found, to the end.<a id="i1544372032-1"></a><a id="i314539839-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">indexOf</span>&nbsp;<span class="code">x</span> </td>
            <td> The index of the first element returned by <span class="code">it</span> that equals <span class="code">x</span>. Note: The iterator advances past the position of this element.<a id="i1628073567-1"></a><a id="i1634273027-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">indexWhere</span>&nbsp;<span class="code">p</span> </td>
            <td> The index of the first element returned by <span class="code">it</span> that satisfies <span class="code">p</span>. Note: The iterator advances past the position of this element.<a id="i337051379-1"></a><a id="i-1113971653-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Subiterators:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n</span> </td>
            <td> An iterator returning of the first <span class="code">n</span> elements of <span class="code">it</span>. Note: <span class="code">it</span> will advance to the position after the <span class="code">n</span>'th element, or to its end, if it contains less than <span class="code">n</span> elements.<a id="i1767548558-1"></a><a id="i314949133-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n</span> </td>
            <td> The iterator that starts with the <span class="code">(n</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span>'th element of <span class="code">it</span>. Note: <span class="code">it</span> will advance to the same position.<a id="i-1271894919-1"></a><a id="i314488949-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.slice(m,</span>&nbsp;<span class="code">n)</span> </td>
            <td> The iterator that returns a slice of the elements returned from <span class="code">it</span>, starting with the <span class="code">m</span>'th element and ending before the <span class="code">n</span>'th element.<a id="i281283382-1"></a><a id="i1172890828-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p</span> </td>
            <td> An iterator returning elements from <span class="code">it</span> as long as condition <span class="code">p</span> is true.<a id="i-147054031-1"></a><a id="i877321508-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">dropWhile</span>&nbsp;<span class="code">p</span> </td>
            <td> An iterator skipping elements from <span class="code">it</span> as long as condition <span class="code">p</span> is true, and returning the remainder.<a id="i1718350537-1"></a><a id="i-1135205444-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p</span> </td>
            <td> An iterator returning all elements from <span class="code">it</span> that satisfy the condition <span class="code">p</span>.<a id="i1114360848-1"></a><a id="i1625033598-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">withFilter</span>&nbsp;<span class="code">p</span> </td>
            <td> Same as <span class="code">it</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p</span>. Needed so that iterators can be used in <span class="code">for</span> expressions.<a id="i-545883542-1"></a><a id="i-54851356-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">filterNot</span>&nbsp;<span class="code">p</span> </td>
            <td> An iterator returning all elements from <span class="code">it</span> that do not satisfy the condition <span class="code">p</span>.<a id="i1252578477-1"></a><a id="i-1495363979-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.distinct</span> </td>
            <td> An iterator returning the elements from <span class="code">it</span> without duplicates.<a id="i-839670516-1"></a><a id="i-700938878-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Subdivisions:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">partition</span>&nbsp;<span class="code">p</span> </td>
            <td> Splits <span class="code">it</span> into a pair of two iterators; one returning all elements from <span class="code">it</span> that satisfy the predicate <span class="code">p</span>, the other returning all elements from <span class="code">it</span> that do not.<a id="i-351940047-1"></a><a id="i1881181476-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Element conditions:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">forall</span>&nbsp;<span class="code">p</span> </td>
            <td> A boolean indicating whether the predicate <span class="code">p</span> holds for all elements returned by <span class="code">it</span>.<a id="i-453827760-1"></a><a id="i1630735422-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">exists</span>&nbsp;<span class="code">p</span> </td>
            <td> A boolean indicating whether the predicate <span class="code">p</span> holds for some element in <span class="code">it</span>.<a id="i679062444-1"></a><a id="i1610167394-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">count</span>&nbsp;<span class="code">p</span> </td>
            <td> The number of elements in <span class="code">it</span> that satisfy the predicate <span class="code">p</span>.<a id="i1575808601-1"></a><a id="i1158215753-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Folds:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it.foldLeft(z)(op)</span> </td>
            <td> Applies binary operation <span class="code">op</span> between successive elements returned by <span class="code">it</span>, going left to right, starting with <span class="code">z</span>.<a id="i2000454511-1"></a><a id="i-696283602-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.foldRight(z)(op)</span> </td>
            <td> Applies binary operation <span class="code">op</span> between successive elements returned by <span class="code">it</span>, going right to left, starting with <span class="code">z</span>.<a id="i-542198878-1"></a><a id="i-104294187-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">reduceLeft</span>&nbsp;<span class="code">op</span> </td>
            <td> Applies binary operation <span class="code">op</span> between successive elements returned by non-empty iterator <span class="code">it</span>, going left to right.<a id="i-723508460-1"></a><a id="i1225634707-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">reduceRight</span>&nbsp;<span class="code">op</span> </td>
            <td> Applies binary operation <span class="code">op</span> between successive elements returned by non-empty iterator <span class="code">it</span>, going right to left.<a id="i2104320242-1"></a><a id="i-654368752-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Specific folds:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it.sum</span> </td>
            <td> The sum of the numeric element values returned by iterator <span class="code">it</span>.<a id="i-735667043-1"></a><a id="i1949821957-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.product</span> </td>
            <td> The product of the numeric element values returned by iterator <span class="code">it</span>.<a id="i232754809-1"></a><a id="i-618492503-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.min</span> </td>
            <td> The minimum of the ordered element values returned by iterator <span class="code">it</span>.<a id="i-2125661578-1"></a><a id="i1949815820-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.max</span> </td>
            <td> The maximum of the ordered element values returned by iterator <span class="code">it</span>.<a id="i-918441052-1"></a><a id="i1949815582-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Zippers:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">zip</span>&nbsp;<span class="code">jt</span> </td>
            <td> An iterator of pairs of corresponding elements returned from iterators <span class="code">it</span> and <span class="code">jt</span>.<a id="i-1080229753-1"></a><a id="i1949828315-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.zipAll(jt,</span>&nbsp;<span class="code">x,</span>&nbsp;<span class="code">y)</span> </td>
            <td> An iterator of pairs of corresponding elements returned from iterators <span class="code">it</span> and <span class="code">jt</span>, where the shorter iterator is extended to match the longer one by appending elements <span class="code">x</span> or <span class="code">y</span>.<a id="i374738376-1"></a><a id="i-2097280314-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.zipWithIndex</span> </td>
            <td> An iterator of pairs of elements returned from <span class="code">it</span> with their indices.<a id="i-886001315-1"></a><a id="i-1744800495-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Update:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it.patch(i,</span>&nbsp;<span class="code">jt,</span>&nbsp;<span class="code">r)</span> </td>
            <td> The iterator resulting from <span class="code">it</span> by replacing <span class="code">r</span> elements starting with <span class="code">i</span> by the patch iterator <span class="code">jt</span>.<a id="i-1495891648-1"></a><a id="i1169803138-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Comparison:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it</span>&nbsp;<span class="code">sameElements</span>&nbsp;<span class="code">jt</span> </td>
            <td> A test whether iterators <span class="code">it</span> and <span class="code">jt</span> return the same elements in the same order. Note: Both <span class="code">it</span> and <span class="code">jt</span> should be discarded after this operation.<a id="i-278620245-1"></a><a id="i-1277312253-1"></a> </td>
          </tr>
          <tr>
            <td> <span style="font-weight:bold">Strings:<!-- \hfill --> </span> </td>
            <td> </td>
          </tr>
          <tr>
            <td> <span class="code">it.addString(b,</span>&nbsp;<span class="code">start,</span> </td>
          </tr>
          <tr>
            <td> <span class="code">sep,</span>&nbsp;<span class="code">end)</span> </td>
            <td> Adds a string to <span class="code">StringBuilder</span> <span class="code">b</span> that shows all elements returned by <span class="code">it</span> between separators <span class="code">sep</span> enclosed in strings <span class="code">start</span> and <span class="code">end</span>. <span class="code">start</span>,<span class="code">sep</span>, and <span class="code">end</span> are all optional.<a id="i2043006297-1"></a><a id="i-613121460-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">it.mkString(start,</span> </td>
          </tr>
          <tr>
            <td> <span class="code">sep,</span>&nbsp;<span class="code">end)</span> </td>
            <td> Converts the iterator to a string that shows all elements returned by <span class="code">it</span> between separators <span class="code">sep</span> enclosed in strings <span class="code">start</span> and <span class="code">end</span>. <span class="code">start</span>,<span class="code">sep</span>, and <span class="code">end</span> are all optional.<a id="i-872604647-1"></a><a id="i-1336376875-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <h4>Buffered iterators</h4>
      <p>Sometimes you want an iterator that can "look ahead" so that you can inspect the next element to be returned without advancing past that element. Consider, for instance, the task to skip leading empty strings from an iterator that returns a sequence of strings. You might be tempted to write something like the following method:</p> <pre>  <code class="comment">//&nbsp;This&nbsp;won't&nbsp;work</code>
  <code class="vem">def</code>&nbsp;skipEmptyWordsNOT(it:&nbsp;<code class="typename">Iterator[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(it.next().isEmpty)&nbsp;{}
  }
</pre>
      <p>But looking at this code more closely, it's clear that this is wrong: the code will indeed skip leading empty strings, but it will also advance <span class="code">it</span> past the first non-empty string!</p>
      <p>The solution to this problem is to use a buffered iterator, an instance of trait <span class="code">BufferedIterator</span>. <span class="code">BufferedIterator</span> is a subtrait of <span class="code">Iterator</span>, which provides one extra method, <span class="code">head</span>. Calling <span class="code">head</span> on a buffered iterator will return its first element, but will not advance the iterator. Using a buffered iterator, skipping empty words can be written like this:</p> <pre>  <code class="vem">def</code>&nbsp;skipEmptyWords(it:&nbsp;<code class="typename">BufferedIterator[String]</code>)&nbsp;=
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(it.head.isEmpty)&nbsp;{&nbsp;it.next()&nbsp;}
</pre>
      <p>Every iterator can be converted to a buffered iterator by calling its <span class="code">buffered</span> method. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;it&nbsp;=&nbsp;<code class="typename">Iterator</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>)
  <code class="output">it:&nbsp;Iterator[Int]&nbsp;=&nbsp;&lt;iterator&gt;</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bit&nbsp;=&nbsp;it.buffered
  <code class="output">bit:&nbsp;java.lang.Object&nbsp;with&nbsp;scala.collection.</code>
  <code class="output">&nbsp;&nbsp;BufferedIterator[Int]&nbsp;=&nbsp;&lt;iterator&gt;</code>
  <br>  scala&gt;&nbsp;bit.head
  <code class="output">res10:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;bit.next()
  <code class="output">res11:&nbsp;Int&nbsp;=&nbsp;1</code>
  <br>  scala&gt;&nbsp;bit.next()
  <code class="output">res11:&nbsp;Int&nbsp;=&nbsp;2</code>
</pre>
      <p>Note that calling <span class="code">head</span> on the buffered iterator, <span class="code">bit</span>, did not advance it. Therefore, the subsequent call, <span class="code">bit.next()</span>, returned again the same value as <span class="code">bit.head</span>.</p>
      <h3>24.15 Creating collections from scratch</h3>
      <p>You have already seen syntax like <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>, which creates a list of three integers, and <span class="code">Map('A'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">1,</span>&nbsp;<span class="code">'C'</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">2)</span>, which creates a map with two bindings. This is actually a universal feature of Scala collections. You can take any collection name and follow it by a list of elements in parentheses. The result will be a new collection with the given elements. Here are some more examples:</p> <pre>  <code class="typename">Iterable</code>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;An&nbsp;empty&nbsp;collection</code>
  <code class="typename">List</code>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;empty&nbsp;list</code>
  <code class="typename">List</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;list&nbsp;with&nbsp;elements&nbsp;1.0,&nbsp;2.0</code>
  <code class="typename">Vector</code>(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;vector&nbsp;with&nbsp;elements&nbsp;1.0,&nbsp;2.0</code>
  <code class="typename">Iterator</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;An&nbsp;iterator&nbsp;returning&nbsp;three&nbsp;integers.</code>
  <code class="typename">Set</code>(dog,&nbsp;cat,&nbsp;bird)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;set&nbsp;of&nbsp;three&nbsp;animals</code>
  <code class="typename">HashSet</code>(dog,&nbsp;cat,&nbsp;bird)&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;hash&nbsp;set&nbsp;of&nbsp;the&nbsp;same&nbsp;animals</code>
  <code class="typename">Map</code>(<code class="quotedstring">'a'</code>&nbsp;-&gt;&nbsp;<code class="literal">7</code>,&nbsp;<code class="quotedstring">'b'</code>&nbsp;-&gt;&nbsp;<code class="literal">0</code>)&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;A&nbsp;map&nbsp;from&nbsp;characters&nbsp;to&nbsp;integers</code>
</pre>
      <p>"Under the covers" each of the above lines is a call to the <span class="code">apply</span> method of some object. For instance, the third line above expands to:</p> <pre>  List.apply(<code class="literal">1.0</code>,&nbsp;<code class="literal">2.0</code>)
</pre>
      <p>So this is a call to the <span class="code">apply</span> method of the companion object of the <span class="code">List</span> class. That method takes an arbitrary number of arguments and constructs a list from them. Every collection class in the Scala library has a companion object with such an <span class="code">apply</span> method. It does not matter whether the collection class represents a concrete implementation, like <span class="code">List</span>, <span class="code">LazyList</span>, or <span class="code">Vector</span>, or whether it is a trait such as <span class="code">Seq</span>, <span class="code">Set</span>, or <span class="code">Iterable</span>. In the latter case, calling <span class="code">apply</span> will produce some default implementation of the trait. Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res17:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
</pre> <pre>  scala&gt;&nbsp;<code class="typename">Iterable</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res18:&nbsp;Iterable[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;<code class="typename">mutable.Iterable</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">res19:&nbsp;scala.collection.mutable.Iterable[Int]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;ArrayBuffer(1,&nbsp;2,&nbsp;3)</code>
</pre>
      <p>Besides <span class="code">apply</span>, every collection companion object also defines a member <span class="code">empty</span>, which returns an empty collection. So instead of <span class="code">List()</span> you could write <span class="code">List.empty</span>, instead of <span class="code">Map()</span>, <span class="code">Map.empty</span>, and so on.</p>
      <p>Descendants of <span class="code">Seq</span> and <span class="code">Set</span> traits also provide other factor operations in their companion objects. These are summarized in <a href="#tab-seqfac">Table 24.15</a>. In short, there's:</p>
      <ul>
        <li><b></b> <span class="code">concat</span>, which concatenates an arbitrary number of collections together, </li>
        <li><b></b> <span class="code">fill</span> and <span class="code">tabulate</span>, which generate single or multi-dimensional collections of given dimensions initialized by some expression or tabulating function, </li>
        <li><b></b> <span class="code">range</span>, which generates integer collections with some constant step length, and </li>
        <li><b></b> <span class="code">iterate</span> and <span class="code">unfold</span>, which generate a collection resulting from repeated application of a function to a start element or state. </li>
      </ul>
      <p><a id="tab-seqfac"></a></p>
      <h5>Factory methods for <span class="code">Seq</span>s and <span class="code">Set</span>s <a id="i-36026129-1"></a></h5>
      <table style="border-collapse: collapse">
        <tbody>
          <tr class="topline bottomline">
            <th> <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span> </th>
            <th>
              <div style="text-align: center">
                <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
              </div> </th>
          </tr>
          <tr>
            <td> <span class="code">C.empty</span> </td>
            <td> The empty collection<a id="i-916064703-1"></a><a id="i1189395089-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">C(x,</span>&nbsp;<span class="code">y,</span>&nbsp;<span class="code">z)</span> </td>
            <td> A collection consisting of elements <span class="code">x</span>, <span class="code">y</span>, and <span class="code">z</span><a id="i-1663030400-1"></a><a id="i1185790130-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">C.concat(xs,</span>&nbsp;<span class="code">ys,</span>&nbsp;<span class="code">zs)</span> </td>
            <td> The collection obtained by concatenating the elements of <span class="code">xs</span>, <span class="code">ys</span>, and <span class="code">zs</span><a id="i1362483777-1"></a><a id="i-1838945712-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">C.fill(n)(e)</span> </td>
            <td> A collection of length <span class="code">n</span> where each element is computed by expression <span class="code">e</span><a id="i-1991390416-1"></a><a id="i454035391-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">C.fill(m,</span>&nbsp;<span class="code">n)(e)</span> </td>
            <td> A collection of collections of dimension <span class="code">m</span> <span style="font-family:sans-serif">x</span> <span class="code">n</span> where each element is computed by expression <span class="code">e</span> (exists also in higher dimensions) </td>
          </tr>
          <tr>
            <td> <span class="code">C.tabulate(n)(f)</span> </td>
            <td> A collection of length <span class="code">n</span> where the element at each index <i>i</i> is computed by <span class="code">f(<i>i</i>)</span><a id="i-243454893-1"></a><a id="i1995938402-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">C.tabulate(m,</span>&nbsp;<span class="code">n)(f)</span> </td>
            <td> A collection of collections of dimension <span class="code">m</span> <span style="font-family:sans-serif">x</span> <span class="code">n</span> where the element at each index (<i>i</i>, <i>j</i>) is computed by <span class="code">f(<i>i</i>,</span>&nbsp;<span class="code"><i>j</i>)</span> (exists also in higher dimensions) </td>
          </tr>
          <tr>
            <td> <span class="code">C.range(start,</span>&nbsp;<span class="code">end)</span> </td>
            <td> The collection of integers <span class="code">start</span> ... <span class="code">end</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1</span><a id="i-835498927-1"></a><a id="i1201041025-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">C.range(start,</span>&nbsp;<span class="code">end,</span>&nbsp;<span class="code">step)</span> </td>
            <td> The collection of integers starting with <span class="code">start</span> and progressing by <span class="code">step</span> increments up to, and excluding, the <span class="code">end</span> value </td>
          </tr>
          <tr>
            <td> <span class="code">C.iterate(x,</span>&nbsp;<span class="code">n)(f)</span> </td>
            <td> The collection of length <span class="code">n</span> with elements <span class="code">x</span>, <span class="code">f(x)</span>, <span class="code">f(f(x))</span>, ...<a id="i1866981108-1"></a><a id="i-7406402-1"></a> </td>
          </tr>
          <tr>
            <td> <span class="code">C.unfold(init)(f)</span> </td>
            <td> A collection that uses a function <span class="code">f</span> to compute its next element and state, starting from the <span class="code">init</span> state. <a id="i2013412692-1"></a><a id="i-1324770986-1"></a> </td>
          </tr>
        </tbody>
      </table>
      <h3 id="sec-javaconversions">24.16 Conversions between Java and Scala collections</h3>
      <p>Like Scala, Java has a rich collections library. There are many<a id="i-1787774928-1"></a><a id="i884164092-1"></a><a id="i1284266897-1"></a> similarities between the two. For instance, both libraries know iterators, iterables, sets, maps, and sequences. But there are also important differences. In particular, the Scala libraries put much more emphasis on immutable collections, and provide many more operations that transform a collection into a new one.</p>
      <p>Sometimes you might need to convert from one collection framework to the other. For instance, you might want to access to an existing Java collection, as if it were a Scala collection. Or you might want to pass one of Scala's collections to a Java method that expects the Java counterpart. It is quite easy to do this, because Scala offers implicit conversions between all the major collection types in the <span class="code">JavaConverters</span> object.<a id="i-1017099510-1"></a> In particular, you will find bidirectional conversions between the following types:</p> <pre>  <code class="typename">Iterator</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Iterator</code>
  <code class="typename">Iterator</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Enumeration</code>
  <code class="typename">Iterable</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.lang.Iterable</code>
  <code class="typename">Iterable</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Collection</code>
  <code class="typename">mutable.Buffer</code>&nbsp;&nbsp;&nbsp;⇔&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.List</code>
  <code class="typename">mutable.Set</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Set</code>
  <code class="typename">mutable.Map</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇔&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Map</code>
</pre>
      <p>To enable these conversions, simply import like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.JavaConverters._
  <code class="vem">import</code>&nbsp;collection.JavaConverters._
</pre>
      <p>This enables implicit conversions between Scala collections and their corresponding Java collections via extension methods <span class="code">asScala</span> and <span class="code">asJava</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;collection.mutable._
  <code class="output">import&nbsp;collection.mutable._</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;jul:&nbsp;<code class="typename">java.util.List[Int]</code>&nbsp;=&nbsp;<code class="typename">ArrayBuffer</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>).asJava
  <code class="output">jul:&nbsp;java.util.List[Int]&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3]</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;buf:&nbsp;<code class="typename">Seq[Int]</code>&nbsp;=&nbsp;jul.asScala
  <code class="output">buf:&nbsp;scala.collection.mutable.Seq[Int]&nbsp;=&nbsp;ArrayBuffer(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;m:&nbsp;<code class="typename">java.util.Map[String,&nbsp;Int]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">HashMap</code>(<code class="quotedstring">"abc"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"hello"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>).asJava
  <code class="output">m:&nbsp;java.util.Map[String,Int]&nbsp;=&nbsp;{hello=2,&nbsp;abc=1}</code>
</pre>
      <p>Internally, these conversions work by setting up a "wrapper" object that forwards all operations to the underlying collection object. So collections are never copied when converting between Java and Scala. An interesting property is that if you do a round-trip conversion from, say, a Java type to its corresponding Scala type, and back to the same Java type, you end up with the identical collection object you started with.</p>
      <p>Some other common Scala collections exist that can also be converted to Java types, but for which no corresponding conversion exists in the other direction. These are:</p> <pre>  <code class="typename">Seq</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇒&nbsp;&nbsp;&nbsp;<code class="typename">java.util.List</code>&nbsp;
  <code class="typename">mutable.Seq</code>&nbsp;&nbsp;⇒&nbsp;&nbsp;&nbsp;<code class="typename">java.util.List</code>
  <code class="typename">Set</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇒&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Set</code>&nbsp;
  <code class="typename">Map</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇒&nbsp;&nbsp;&nbsp;<code class="typename">java.util.Map</code>&nbsp;
</pre>
      <p>Because Java does not distinguish between mutable and immutable collections in their type, a conversion from, say, <span class="code">collection.immutable.List</span> will yield a <span class="code">java.util.List</span>, on which all attempted mutation operations will throw an <span class="code">UnsupportedOperationException</span>. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;jul:&nbsp;<code class="typename">java.util.List[Int]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">jul:&nbsp;java.util.List[Int]&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3]</code>
  <br>  scala&gt;&nbsp;jul.add(<code class="literal">7</code>)
  <code class="output">java.lang.UnsupportedOperationException</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;java.util.AbstractList.add(AbstractList.java:131)</code>
</pre>
      <h3>24.17 Conclusion</h3>
      <p>You've now seen how to use Scala's collection in great detail. Scala's collections take the approach of giving you powerful building blocks rather than a number of ad hoc utility methods. Putting together two or three such building blocks allows you to express an enormous number of useful computations. This style of library is especially effective due to Scala having a light syntax for function literals, and due to it providing many collection types that are persistent and immutable.</p>
      <p>This chapter has shown collections from the point of view of a programmer using the collection library. The next chapter will show you how the collections are built and how you can add your own collection types.</p>
      <hr>
      <h4>Footnotes for Chapter 24:</h4>
      <p><a id="footnotemain24-1"></a>[1] Partial functions were described in <a href="#sec-partial-functions">Section 15.7</a>.</p>
      <p><a id="footnotemain24-2"></a>[2] Compressed hash-array mapped prefix-trees are described in <a href="#sec-hash-tries">Section 24.7</a>.</p>
      <p><a id="footnotemain24-3"></a>[3] "Trie" comes from the word "re<em>trie</em>val" and is pronounced <em>tree</em> or <em>try</em>.</p>
      <p><a id="footnotemain24-4"></a>[4] Steindorfer, <i>et. al.</i>, "Optimizing hash-array mapped tries for fast and lean immutable JVM collections." <a href="#steindorfer-champ">[Ste15]</a></p>
      <p><a id="footnotemain24-5"></a>[5] The "<span class="code">buf.type</span>" that appears in the interpreter responses in this and several other examples in this section is a <em>singleton type</em>.<a id="i-108236764-1"></a> As will be explained in <a href="#sec-tracking-module-instances">Section 29.6</a>, <span class="code">buf.type</span> means the variable holds exactly the object referred to by <span class="code">buf</span>.</p>
      <p><a id="footnotemain24-6"></a>[6] Assuming bits are densely packed.</p>
      <p><a id="footnotemain24-7"></a>[7] The Scala actors library has been deprecated, but this historical example is still relevant.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-the-architecture-of-scala-collections">Chapter 25</a></h2>
      <h1>The Architecture of Scala Collections</h1>
      <p>This chapter describes the architecture of the Scala collections framework in detail. Continuing the theme of <a href="#chap-collections-in-depth">Chapter 24</a>, you will find out more about the internal workings of the framework. You will also learn how this architecture helps you define your own collections in a few lines of code, while reusing the overwhelming part of collection functionality from the framework.<a id="i-512346344-1"></a></p>
      <p><a href="#chap-collections-in-depth">Chapter 24</a> enumerated a large number of collection operations, which exist uniformly on many different collection implementations. Implementing every collection operation anew for every collection type would lead to an enormous amount of code, most of which would be copied from somewhere else. Such code duplication could lead to inconsistencies over time, when an operation is added or modified in one part of the collection library but not in others. The principal design objective of the collections framework is to avoid any duplication, defining every operation in as few places as possible.<a href="#footnotemain25-1">[1]</a> The approach is to implement most operations in "template traits" that can be mixed into individual collection base and implementation classes. In this chapter, we will examine these templates, and other classes and traits that constitute the building blocks of the framework, as well as the construction principles they support.</p>
      <h3>25.1 Factoring out common operations</h3>
      <p>The main design objective of the collection library is to provide natural types to users while sharing as much implementation code as possible. In particular, Scala's collection framework needs to support the following aspects of various concrete collection types:</p>
      <ul>
        <li>Some transformation operations return the same concrete collection type. For example, <span class="code">filter</span> on <span class="code">List[Int]</span> returns <span class="code">List[Int]</span>. </li>
        <li>Some transformation operations return the same concrete collection type with possibly a different type of elements. For example, <span class="code">map</span> on <span class="code">List[Int]</span> can return <span class="code">List[String]</span>. </li>
        <li>Some collection types, such as <span class="code">List[A]</span>, have a single type parameter, whereas others, like <span class="code">Map[K,</span>&nbsp;<span class="code">V]</span>, have two. </li>
        <li>Some operations on collections return a different concrete collection depending on an element type. For example, <span class="code">map</span> on <span class="code">Map</span> returns another <span class="code">Map</span> if the mapping function results in a key-value pair, but otherwise returns an <span class="code">Iterable</span>. </li>
        <li>Transformation operations on certain collection types require additional implicit parameters. For example, <span class="code">map</span> on <span class="code">SortedSet</span> requires an implicit <span class="code">Ordering</span>. </li>
        <li>Lastly, some collections, such as <span class="code">List</span>, are strict, while other collections, like <span class="code">View</span> and <span class="code">LazyList</span>, are non-strict. </li>
      </ul>
      <p>The collection framework's template traits abstract over the above list of differences between various collections. In the rest of this section, you will find out how this is achieved.</p>
      <p>As previously mentioned, one challenge for the template traits is to define transformation operations returning yet unknown concrete collection types. For instance, consider the signature of the <span class="code">map</span> operation on <span class="code">List[A]</span> and <span class="code">Vector[A]</span>:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">List[A]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;<code class="typename">List[B]</code>
  }
  <br>  <code class="vem">trait</code>&nbsp;<code class="typename">Vector[A]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;<code class="typename">Vector[B]</code>
  }
</pre>
      <p>The return type of <span class="code">map</span> is specific to each concrete collection type. The <span class="code">map</span> method on <span class="code">List</span> returns a <span class="code">List</span>, whereas on <span class="code">Vector</span> it returns a <span class="code">Vector</span>. This feature of the collections framework is named the "same-result-type" principle: wherever possible, a transformation operation on a collection will yield a collection of the same type. In the case of <span class="code">map</span>, the template traits need to abstract over the resulting collection type constructor.<a href="#footnotemain25-2">[2]</a><a id="i-254642465-1"></a></p>
      <p>The <span class="code">filter</span> method has a slightly different requirement. Consider its type signature on <span class="code">List[A]</span> and <span class="code">Map[K,</span>&nbsp;<span class="code">V]</span>:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">List[A]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;filter(p:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;<code class="typename">List[A]</code>
  }
  <br>  <code class="vem">trait</code>&nbsp;<code class="typename">Map[K,&nbsp;V]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;filter(p:&nbsp;((K,&nbsp;V))&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;<code class="typename">Map[K,&nbsp;V]</code>
  }
</pre>
      <p>To generalize the type signature of <span class="code">filter</span>, template traits can't just abstract over the collection type constructor, because <span class="code">List</span> takes one type parameter, whereas <span class="code">Map</span> takes two. In this case, therefore, the templates traits need to abstract over the entire resulting collection type.</p>
      <h4>Abstracting over collection types</h4>
      <p>The <span class="code">IterableOps</span><a id="i-163913042-1"></a> template trait implements the operations available on the <span class="code">Iterable[A]</span> collection type. <span class="code">IterableOps</span> is defined like this:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">IterableOps[+A,&nbsp;+CC[_],&nbsp;+C]</code>
</pre>
      <p><span class="code">IterableOps</span> declares three type parameters named <span class="code">A</span>, <span class="code">CC</span>, and <span class="code">C</span>. For an <span class="code">Iterable</span> that extends <span class="code">IterableOps</span>, <span class="code">A</span> defines its element type, <span class="code">CC</span> its type constructor,<a id="i-254642465-2"></a> and <span class="code">C</span> its complete type. The signatures of <span class="code">filter</span> and <span class="code">map</span> on <span class="code">IterableOps</span> are defined like this:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">IterableOps[+A,&nbsp;+CC[_],&nbsp;+C]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;filter(p:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;C
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;CC[B]
  }
</pre>
      <p>Concrete types in the collections framework pass appropriate type parameters when they mix in <span class="code">IterableOps</span>. For example, <span class="code">List[A]</span> passes the element type <span class="code">A</span> for <span class="code">A</span>, <span class="code">List</span> for <span class="code">CC</span>, and <span class="code">List[A]</span> for <span class="code">C</span>:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">List[+A]</code>
  &nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Iterable[A]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IterableOps[A,&nbsp;List,&nbsp;List[A]]</code>
</pre>
      <p>The <span class="code">SetOps</span><a id="i576449790-1"></a> template trait extends <span class="code">IterableOps</span> and adds default implementations for methods defined in <span class="code">Set</span> that are not defined in <span class="code">Iterable</span>. Here's how <span class="code">SetOps</span> is defined:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">SetOps[A,&nbsp;+CC[_],&nbsp;+C]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IterableOps[A,&nbsp;CC,&nbsp;C]</code>
</pre>
      <p>Trait <span class="code">Set</span> mixes in <span class="code">SetOps</span>, passing the appropriate type parameters:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">Set[A]</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Iterable[A]</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">SetOps[A,&nbsp;Set,&nbsp;Set[A]]</code>
</pre>
      <p>For <span class="code">Map</span>s, the story is slightly more involved. Although <span class="code">IterableOps</span> works for <span class="code">List</span>s, the type signature for its <span class="code">map</span> operation doesn't work with <span class="code">Map</span>s. The problem is that <span class="code">Map[K,</span>&nbsp;<span class="code">V]</span>'s type constructor takes two type parameters, <span class="code">K</span> and <span class="code">V</span>, but <span class="code">IterableOps</span> <span class="code">CC[_]</span> type parameter takes only one. Because of this, the collections framework provides a <span class="code">MapOps</span><a id="i-814121660-1"></a> template trait that includes a second, overloaded form of the <span class="code">map</span> method:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">MapOps[K,&nbsp;+V,&nbsp;+CC[_,&nbsp;_],&nbsp;+C]</code>
  &nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IterableOps[(K,&nbsp;V),&nbsp;Iterable,&nbsp;C]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[K2,&nbsp;V2](f:&nbsp;((K,&nbsp;V))&nbsp;=&gt;&nbsp;(K2,&nbsp;V2)):&nbsp;CC[K2,&nbsp;V2]
  }
</pre>
      <p>Because the <span class="code">MapOps</span> trait extends <span class="code">IterableOps</span>, operations defined in <span class="code">IterableOps</span> are also available in <span class="code">MapOps</span>. Therefore, given the collection type constructor passed to <span class="code">IterableOps</span> is <span class="code">Iterable</span>, the <span class="code">Map[K,</span>&nbsp;<span class="code">V]</span> trait inherits two overloaded forms of the <span class="code">map</span> operation:</p> <pre>  <code class="comment">//&nbsp;Inherited&nbsp;from&nbsp;MapOps</code>
  <code class="vem">def</code>&nbsp;map[K2,&nbsp;V2](f:&nbsp;((K,&nbsp;V))&nbsp;=&gt;&nbsp;(K2,&nbsp;V2)):&nbsp;<code class="typename">Map[K2,&nbsp;V2]</code>
  <br>  <code class="comment">//&nbsp;Inherited&nbsp;from&nbsp;IterableOps</code>
  <code class="vem">def</code>&nbsp;map[B](f:&nbsp;((K,&nbsp;V))&nbsp;=&gt;&nbsp;B):&nbsp;<code class="typename">Iterable[B]</code>
</pre>
      <p>At the usage site, when you call <span class="code">map</span>, the compiler selects one of the two overloaded forms. If the function passed as the argument to <span class="code">map</span> returns a pair, both functions are applicable. In this case, the version from <span class="code">MapOps</span> is selected because it is more specific by the rules of overload resolution, so the resulting collection is a <span class="code">Map</span>. If the argument function does not return a pair, only the version defined in <span class="code">IterableOps</span> is applicable. In this case, the resulting collection is an <span class="code">Iterable</span>. This is how the design facilitates the same-result-type principle.</p>
      <p>Another situation where the type signatures of transformation operations defined in <span class="code">IterableOps</span> don't match those of a concrete collection type is <span class="code">SortedSet[A]</span>. In this case, the type signature of the <span class="code">map</span> operation requires an implicit <span class="code">Ordering</span> for the element type:</p> <pre>  <code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">implicit</code>&nbsp;ord:&nbsp;<code class="typename">Ordering[B]</code>):&nbsp;<code class="typename">SortedSet[B]</code>
</pre>
      <p>Like <span class="code">Map</span>, <span class="code">SortedSet</span> needs a specialized template trait with overloaded variants of transformation operations. The <span class="code">SortedSetOps</span><a id="i1230997595-1"></a> template traits provides these. Here is how <span class="code">SortedSetOps</span> defines <span class="code">map</span>:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">SortedSetOps[A,&nbsp;+CC[_],&nbsp;+C]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">SetOps[A,&nbsp;Set,&nbsp;C]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B)(<code class="vem">implicit</code>&nbsp;ord:&nbsp;<code class="typename">Ordering[B]</code>):&nbsp;CC[B]
  }
</pre>
      <p>Collection types that extend <span class="code">SortedSetOps</span> pass the appropriate type parameters. For example, <span class="code">SortedSet[A]</span> passes its element type <span class="code">A</span> for <span class="code">A</span>, <span class="code">SortedSet</span> for <span class="code">CC</span>, and <span class="code">SortedSet[A]</span> for <span class="code">C</span>:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">SortedSet[A]</code>&nbsp;<code class="vem">extends</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">SortedSetOps[A,&nbsp;SortedSet,&nbsp;SortedSet[A]]</code>
</pre>
      <p>Because <span class="code">SortedSetOps</span> extends <span class="code">SetOps</span>, and the collection type constructor passed to <span class="code">SetOps</span> is <span class="code">Set</span>, the <span class="code">SortedSet[A]</span> trait inherits these two overloaded forms of the <span class="code">map</span> operation:</p> <pre>  <code class="comment">//&nbsp;Inherited&nbsp;from&nbsp;SortedSetOps</code>
  <code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B)(<code class="vem">implicit</code>&nbsp;ord:&nbsp;<code class="typename">Ordering[B]</code>):&nbsp;<code class="typename">SortedSet[B]</code>
  <br>  <code class="comment">//&nbsp;Inherited&nbsp;from&nbsp;IterableOps,&nbsp;by&nbsp;way&nbsp;of&nbsp;SetOps</code>
  <code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;<code class="typename">Set[B]</code>
</pre>
      <p>If you call <span class="code">map</span> and an implicit <span class="code">Ordering[B]</span> is available, the version defined in <span class="code">SortedSetOps</span> will be selected by the rules of overload resolution, and the result will be a <span class="code">SortedSet[B]</span>. Otherwise the version defined in <span class="code">IterableOps</span> will be used, and the result will be a <span class="code">Set[B]</span>.</p>
      <p>Lastly, a fifth kind of collection that requires a specialized template trait is <span class="code">SortedMap[K,</span>&nbsp;<span class="code">V]</span>. This type of collection takes two type parameters and needs an implicit ordering on the type of keys. A <span class="code">SortedMapOps</span><a id="i-159573855-1"></a> template trait provides the appropriate overloaded methods.</p>
      <p><a href="#fig-collections-architecture">Figure 25.1</a> shows the inheritance relationships between the main template traits and collection types. Traits whose name ends in <span class="code">Ops</span> are the template traits.</p>
      <div class="figure">
        <a id="fig-collections-architecture"></a>
        <p><img src="collectionsFramework160.png" alt="images/collectionsFramework160.png"></p>
      </div>
      <h5> Figure 25.1 - The main traits of the collections framework.</h5>
      <h4>Handling strictness</h4>
      <p>Scala's collections library includes both <em>strict</em><a id="i-112375106-1"></a> and <em>non-strict</em><a id="i-342672962-1"></a> collection types. Strict types, such as <span class="code">List</span> and <span class="code">Set</span>, eagerly evaluate their elements. Non-strict types, such as <span class="code">LazyList</span> and <span class="code">View</span>, delay evaluation until each element is needed.</p>
      <p>The collection framework's template traits, therefore, must support both strict and non-strict evaluation, and allow concrete collection types that extend the template traits to determine strictness. For instance, the default implementation of <span class="code">map</span> needs to be strict when inherited by <span class="code">List</span>, but non-strict when inherited by <span class="code">View</span>.</p>
      <p>To achieve this, operations in template traits are by default implemented in terms of non-strict <span class="code">View</span>s. A <span class="code">View</span> maintains a "description" of an operation applied to a collection, but does not evaluate its result until the <span class="code">View</span> is actually traversed.<a href="#footnotemain25-3">[3]</a> As shown in <a href="#lst-view-def">Listing 25.1</a>, trait <span class="code">View</span> is defined as an <span class="code">Iterable</span> with one abstract method that provides an <span class="code">Iterator</span> for traversing the <span class="code">View</span>'s elements. These elements will be evaluated only when the <span class="code">Iterator</span> is traversed.</p>
      <p><a id="lst-view-def"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">View[+A]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Iterable[A]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IterableOps[A,&nbsp;View,&nbsp;View[A]]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[A]</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 25.1 - Simplified definition of <span class="code">View</span></h5>
      <p><a id="lst-iterableops-filter-map-impl"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">IterableOps[+A,&nbsp;+CC[_],&nbsp;+C]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;filter(pred:&nbsp;A&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>):&nbsp;C&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fromSpecific(<code class="vem">new</code>&nbsp;<code class="typename">View.Filter</code>(<code class="vem">this</code>,&nbsp;pred))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;CC[B]&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from(<code class="vem">new</code>&nbsp;<code class="typename">View.Map</code>(<code class="vem">this</code>,&nbsp;f))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(source:&nbsp;<code class="typename">IterableOnce[A]</code>):&nbsp;C
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;from[E](source:&nbsp;<code class="typename">IterableOnce[E]</code>):&nbsp;CC[E]
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 25.2 - Implementation of <span class="code">filter</span> and <span class="code">map</span> in <span class="code">IterableOps</span>.</h5>
      <p><a href="#lst-iterableops-filter-map-impl">Listing 25.2</a> shows the implementation of the <span class="code">filter</span> and <span class="code">map</span> methods in <span class="code">IterableOps</span>. This <span class="code">filter</span> method first instantiates a <span class="code">View.Filter</span>, which is a <span class="code">View</span> that will filter the elements of the underlying collection when and if they are traversed. This <span class="code">View.Filter</span> is passed to <span class="code">fromSpecific</span>, which will turn the <span class="code">View</span> into a concrete collection of type <span class="code">C</span>. The implementation of <span class="code">map</span> is similar, except that instead of calling <span class="code">fromSpecific</span> it calls <span class="code">from</span>, which takes as its <span class="code">source</span> parameter an iterable or iterator whose element type <span class="code">E</span> is arbitrary.</p>
      <p>The implementation of <span class="code">from</span> and <span class="code">fromSpecific</span> is left to concrete collections: they can decide to evaluate the source elements in either a strict or non-strict way. For instance, trait <span class="code">List</span> implements the <span class="code">from</span> method by evaluating the elements of the source collection eagerly:</p> <pre>  <code class="vem">def</code>&nbsp;from[E](source:&nbsp;<code class="typename">IterableOnce[E]</code>):&nbsp;<code class="typename">List[E]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">ListBuffer[E]</code>&nbsp;++=&nbsp;source).toList
</pre>
      <p>By contrast, the implementation of <span class="code">from</span> in <span class="code">LazyList</span> (not shown), does not evaluate its source unless the <span class="code">LazyList</span> is actually traversed.</p>
      <p>One other implementation detail that you should know is that the <span class="code">from</span> method is actually defined in companion objects of collections, as a general factory method for instantiating a collection. The <span class="code">IterableOps</span> template trait just forwards to it through an <span class="code">iterableFactory</span><a id="i437231747-1"></a><a id="i-1654748823-1"></a> method, which links collection classes to their companion object:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">IterableOps[+A,&nbsp;+CC[_],&nbsp;+C]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;CC[B]&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;iterableFactory.from(<code class="vem">new</code>&nbsp;<code class="typename">View.Map</code>(<code class="vem">this</code>,&nbsp;f))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterableFactory:&nbsp;<code class="typename">IterableFactory[CC]</code>
  }
  <br>  <code class="vem">trait</code>&nbsp;<code class="typename">IterableFactory[+CC[_]]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;from[A](source:&nbsp;<code class="typename">IterableOnce[A]</code>):&nbsp;CC[A]
  }
</pre>
      <p>Lastly, similar to the way there are multiple variants of template traits (such as <span class="code">IterableOps</span>, <span class="code">MapOps</span>, and <span class="code">SortedSetOps</span>), there are also multiple variants of factory traits. For instance, <a href="#lst-mapops-def">Listing 25.3</a> shows the relevant parts of code of the <span class="code">map</span> operation implementation in the <span class="code">MapOps</span> template trait.</p>
      <p><a id="lst-mapops-def"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">MapOps[K,&nbsp;+V,&nbsp;+CC[_,&nbsp;_],&nbsp;+C]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IterableOps[(K,&nbsp;V),&nbsp;Iterable,&nbsp;C]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[K2,&nbsp;V2](f:&nbsp;((K,&nbsp;V))&nbsp;=&gt;&nbsp;(K2,&nbsp;V2)):&nbsp;CC[K2,&nbsp;V2]&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapFactory.from(<code class="vem">new</code>&nbsp;<code class="typename">View.Map</code>(<code class="vem">this</code>,&nbsp;f))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;mapFactory:&nbsp;<code class="typename">MapFactory[CC]</code>
  <br>  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">MapFactory[+CC[_,&nbsp;_]]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;from[K,&nbsp;V](source:&nbsp;<code class="typename">IterableOnce[(K,&nbsp;V)]</code>):&nbsp;CC[K,&nbsp;V]
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 25.3 - The <span class="code">MapOps</span> template trait and its related <span class="code">MapFactory</span><a id="i-404870244-1"></a> trait.</h5>
      <h4>When strict evaluation is preferable or unavoidable</h4>
      <p>In the previous sections we explained that the strictness of concrete collections should be preserved by default operation implementations. However in some cases this leads to less efficient implementations. For instance, <span class="code">partition</span>, if done lazily, needs to perform two traversals of the underlying collection. In other cases, such as <span class="code">groupBy</span>, the operation must be performed strictly: it is simply not possible to implement the operation without evaluating the collection elements.</p>
      <p>For such cases, the collections library also provides ways to implement operations strictly. Instead of being based on a <span class="code">View</span>, however, it is based on a <span class="code">Builder</span>.<a id="i-720583383-1"></a> Here is an outline of the <span class="code">Builder</span> trait:</p> <pre>  <code class="vem">package</code>&nbsp;scala.collection.mutable
  <br>  <code class="vem">trait</code>&nbsp;<code class="typename">Builder[-A,&nbsp;+C]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;addOne(elem:&nbsp;A):&nbsp;<code class="vem">this</code>.type
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;result():&nbsp;C
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;clear():&nbsp;<code class="typename">Unit</code>
  }
</pre>
      <p>Builders are generic in both the element type, <span class="code">A</span>, and the type of collection they return, <span class="code">C</span>. You can add an element, <span class="code">x</span>, to a builder, <span class="code">b</span>, with <span class="code">b.addOne(x)</span> (or <span class="code">b</span>&nbsp;<span class="code">+=</span>&nbsp;<span class="code">x</span>). The <span class="code">result</span> method returns a collection from the builder. The state of the builder is undefined after taking its result, but it can be reset into a new empty state using <span class="code">clear</span>.</p>
      <p>Similar to <span class="code">fromSpecific</span> and <span class="code">from</span>, template traits provide one method, named <span class="code">newSpecificBuilder</span>, to get a builder resulting in a collection with the same type of elements, and another method, named <span class="code">newBuilder</span>, to get a builder resulting in a collection of the same type but with a different type of elements. <a href="#lst-strict-and-non-strict-factories">Listing 25.4</a> shows the relevant parts of <span class="code">IterableOps</span> and <span class="code">IterableFactory</span><a id="i1530579974-1"></a> to build collections in both strict and non-strict modes.</p>
      <p><a id="lst-strict-and-non-strict-factories"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">IterableOps[+A,&nbsp;+CC[_],&nbsp;+C]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterableFactory:&nbsp;<code class="typename">IterableFactory[CC]</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(source:&nbsp;<code class="typename">IterableOnce[A]</code>):&nbsp;C
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;newSpecificBuilder:&nbsp;<code class="typename">Builder[A,&nbsp;C]</code>
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">IterableFactory[+CC[_]]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;from[A](source:&nbsp;<code class="typename">IterableOnce[A]</code>):&nbsp;CC[A]
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder[A]:&nbsp;<code class="typename">Builder[A,&nbsp;CC[A]]</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 25.4 - Strict and non-strict methods for building collection instances.</h5>
      <p>Note that in general, an operation that doesn't <span style="font-style:italic">need to</span> be strict should be implemented in a non-strict way, otherwise it would lead to surprising behavior when used on a non-strict concrete collection. That being said, the strict mode is often more efficient. This is why the library provides another set of template traits whose operation implementations have been overridden to take advantage of strict builders. The name of these template traits always starts with <span class="code">StrictOptimized</span>. You should use such a template trait for your custom collection if it is a strict collection.</p>
      <h3 id="sec-integrating">25.2 Integrating new collections</h3>
      <p>What needs to be done if you want to integrate a new collection class, so that it can profit from all predefined operations at the right types? In this section we'll walk you through three examples that do this: capped sequences, sequences of RNA bases, and prefix maps implemented with Patricia tries.</p>
      <h4>Capped sequences</h4>
      <p>Say you want to create an immutable collection containing <span style="font-style:italic">at most</span> <span class="code">n</span> elements: if more elements than the maximum number of elements are added, then the first elements are removed. The first task is to select a supertype for your collection: is it <span class="code">Seq</span>, <span class="code">Set</span>, <span class="code">Map</span>, or just <span class="code">Iterable</span>? In this case, it might be tempting to choose <span class="code">Seq</span> because your collection can contain duplicates, and iteration order is determined by insertion order. However, some properties of <span class="code">Seq</span> are not satisfied. For example, the size of the <span class="code">Seq</span> resulting from concatenating two <span class="code">Seq</span>s should be the sum of the original sizes:</p> <pre>  (xs&nbsp;++&nbsp;ys).size&nbsp;==&nbsp;xs.size&nbsp;+&nbsp;ys.size
</pre>
      <p>As a result, the only sensible choice as a base type for your new collection is <span class="code">scala.collection.immutable.Iterable</span>.</p>
      <h5>Capped collection, first version</h5>
      <p><a href="#lst-capped1">Listing 25.5</a> presents a first version of a capped collection. It will be refined later. Class <span class="code">Capped1</span> has a private constructor that takes as parameters the collection capacity, length, offset (index of the first element), and an array to hold the elements. The public constructor takes only the capacity of the collection. It sets the length and offset to 0, and creates an uninitialized array of capacity length to hold the elements.</p>
      <p><a id="lst-capped1"></a></p> <pre>  <code class="vem">import</code>&nbsp;scala.collection._
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">Capped1[A]</code>&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;capacity:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;offset:&nbsp;<code class="typename">Int</code>,&nbsp;elems:&nbsp;<code class="typename">Array[Any]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">immutable.Iterable[A]</code>&nbsp;{&nbsp;self&nbsp;=&gt;
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(capacity:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(capacity,&nbsp;length&nbsp;=&nbsp;<code class="literal">0</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;offset&nbsp;=&nbsp;<code class="literal">0</code>,&nbsp;elems&nbsp;=&nbsp;Array.ofDim(capacity))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;appended[B&nbsp;&gt;:&nbsp;A](elem:&nbsp;B):&nbsp;<code class="typename">Capped1[B]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;newElems&nbsp;=&nbsp;Array.ofDim[<code class="typename">Any</code>](capacity)
  &nbsp;&nbsp;&nbsp;&nbsp;Array.copy(elems,&nbsp;<code class="literal">0</code>,&nbsp;newElems,&nbsp;<code class="literal">0</code>,&nbsp;capacity)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;(newOffset,&nbsp;newLength)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(length&nbsp;==&nbsp;capacity)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newElems(offset)&nbsp;=&nbsp;elem
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((offset&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;<code class="texttt">%</code>&nbsp;capacity,&nbsp;length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newElems(length)&nbsp;=&nbsp;elem
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(offset,&nbsp;length&nbsp;+&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Capped1[B]</code>(capacity,&nbsp;newLength,&nbsp;newOffset,&nbsp;newElems)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;@inline&nbsp;<code class="vem">def</code>&nbsp;:+&nbsp;[B&nbsp;&gt;:&nbsp;A](elem:&nbsp;B):&nbsp;<code class="typename">Capped1[B]</code>&nbsp;=&nbsp;appended(elem)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(i:&nbsp;<code class="typename">Int</code>):&nbsp;A&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;elems((i&nbsp;+&nbsp;offset)&nbsp;<code class="texttt">%</code>&nbsp;capacity).asInstanceOf[A]
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[A]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">AbstractIterator[A]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;current&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;hasNext&nbsp;=&nbsp;current&nbsp;&lt;&nbsp;self.length
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;next():&nbsp;A&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;elem&nbsp;=&nbsp;self(current)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;className&nbsp;=&nbsp;<code class="quotedstring">"Capped1"</code>
  }
</pre>
      <h5>Listing 25.5 - <span class="code">Capped</span> collection, first version</h5>
      <p>The <span class="code">appended</span> method defines how elements can be appended to a given <span class="code">Capped1</span> collection: it creates a new array of elements, copies the current elements, and adds the new element. As long as the number of elements does not exceed the <span class="code">capacity</span>, the new element is appended after the previous elements. However, as soon as the maximal capacity has been reached, the new element replaces the first element of the collection at index <span class="code">offset</span>.</p>
      <p>The <span class="code">apply</span> method implements indexed access: it translates the given index into its corresponding index in the underlying array, and returns the element at that index. The <span class="code">appended</span> and <span class="code">apply</span> methods implement the "capping" behavior of the <span class="code">Capped1</span> collection.</p>
      <p>The <span class="code">iterator</span> method makes the generic collection operations (such as <span class="code">foldLeft</span>, <span class="code">count</span>, <i>etc.</i>) work on <span class="code">Capped</span> collections. It is implemented using indexed access.</p>
      <p>Lastly, the <span class="code">className</span> method is overridden to return the name of the collection, <span class="code">Capped1</span>. This name will be used by <span class="code">toString</span>.</p>
      <p>Here are some interactions with the <span class="code">Capped1</span> collection:</p> <pre>  scala&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Capped1</code>(capacity&nbsp;=&nbsp;<code class="literal">4</code>)
  <code class="output">&nbsp;res0:&nbsp;Capped1[Nothing]&nbsp;=&nbsp;Capped1()</code>
  <br>  scala&gt;&nbsp;res0&nbsp;:+&nbsp;<code class="literal">1</code>&nbsp;:+&nbsp;<code class="literal">2</code>&nbsp;:+&nbsp;<code class="literal">3</code>
  <code class="output">&nbsp;res1:&nbsp;Capped1[Int]&nbsp;=&nbsp;Capped1(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;res1.length
  <code class="output">&nbsp;res2:&nbsp;Int&nbsp;=&nbsp;3</code>
  <br>  scala&gt;&nbsp;res1.lastOption
  <code class="output">&nbsp;res3:&nbsp;Option[Int]&nbsp;=&nbsp;Some(3)</code>
  <br>  scala&gt;&nbsp;res1&nbsp;:+&nbsp;<code class="literal">4</code>&nbsp;:+&nbsp;<code class="literal">5</code>&nbsp;:+&nbsp;<code class="literal">6</code>
  <code class="output">&nbsp;res4:&nbsp;Capped1[Int]&nbsp;=&nbsp;Capped1(3,&nbsp;4,&nbsp;5,&nbsp;6)</code>
  <br>  scala&gt;&nbsp;res4.take(<code class="literal">3</code>)
  <code class="output">&nbsp;res5:&nbsp;collection.immutable.Iterable[Int]&nbsp;=&nbsp;List(3,&nbsp;4,&nbsp;5)</code>
</pre>
      <p>As you can see in <span class="code">res4</span>, if you append more than four elements to a <span class="code">Capped1</span>, the first elements are dropped. The operations behave as desired except for the last one: after calling <span class="code">take</span> you get back a <span class="code">List</span> instead of a <span class="code">Capped1</span>. This is because <span class="code">Capped1</span> extends <span class="code">Iterable</span> and inherits its <span class="code">take</span> method. <span class="code">Iterable</span>'s <span class="code">take</span> method returns another <span class="code">Iterable</span>, which by default is implemented in terms of <span class="code">List</span>. That's why you get a <span class="code">List</span> on the last line of the previous interaction.</p>
      <p>Now that you understand why things are the way they are, the next question should be what needs to be done to change them? One way to do this would be to override the <span class="code">take</span> method in class <span class="code">Capped1</span>, maybe like this:</p> <pre>  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;take(count:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Capped1</code>&nbsp;=&nbsp;...
</pre>
      <p>This would do the job for <span class="code">take</span>. But what about <span class="code">drop</span>, <span class="code">filter</span>, or <span class="code">init</span>? In fact there are over fifty methods on collections that return another collection. For consistency, all of these would need to be overridden. This looks less and less like an attractive option. Fortunately, there is a much easier way to achieve the same effect, shown in the next section.</p>
      <h5>Capped collection, second version</h5>
      <p>The capped collection class needs to inherit not only from <span class="code">Iterable</span>, but also from the template trait <span class="code">IterableOps</span>. This is done by <span class="code">Capped2</span>, shown in <a href="#lst-capped2">Listing 25.6</a>, which extends <span class="code">IterableOps[A,</span>&nbsp;<span class="code">Capped2,</span>&nbsp;<span class="code">Capped2[A]]</span>. In addition, its <span class="code">iterableFactory</span> member has been overridden to return an <span class="code">IterableFactory[Capped2]</span>. As mentioned in the previous sections, the <span class="code">IterableOps</span> trait implements all concrete methods of <span class="code">Iterable</span> in a generic way. For instance, the result type of methods like <span class="code">take</span>, <span class="code">drop</span>, <span class="code">filter</span>, or <span class="code">init</span> is the third type parameter passed to <span class="code">IterableOps</span>. In class <span class="code">Capped2</span>, therefore, it is <span class="code">Capped2[A]</span>. Similarly, the result type of methods like <span class="code">map</span>, <span class="code">flatMap</span>, or <span class="code">concat</span> is defined by the second type parameter passed to class <span class="code">IterableOps</span>, In class <span class="code">Capped2</span>, that is <span class="code">Capped2</span> itself.</p>
      <p><a id="lst-capped2"></a></p> <pre>  <code class="vem">import</code>&nbsp;scala.collection._
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">Capped2[A]</code>&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;capacity:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;offset:&nbsp;<code class="typename">Int</code>,&nbsp;elems:&nbsp;<code class="typename">Array[Any]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">immutable.Iterable[A]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IterableOps[A,&nbsp;Capped2,&nbsp;Capped2[A]]</code>&nbsp;{&nbsp;self&nbsp;=&gt;
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(capacity:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;appended[B&nbsp;&gt;:&nbsp;A](elem:&nbsp;B):&nbsp;<code class="typename">Capped2[B]</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  &nbsp;&nbsp;@inline&nbsp;<code class="vem">def</code>&nbsp;:+&nbsp;[B&nbsp;&gt;:&nbsp;A](elem:&nbsp;B):&nbsp;<code class="typename">Capped2[B]</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(i:&nbsp;<code class="typename">Int</code>):&nbsp;A&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[A]</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;className&nbsp;=&nbsp;<code class="quotedstring">"Capped2"</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;iterableFactory:&nbsp;<code class="typename">IterableFactory[Capped2]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Capped2Factory</code>(capacity)
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coll:&nbsp;<code class="typename">IterableOnce[A]</code>):&nbsp;<code class="typename">Capped2[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;iterableFactory.from(coll)
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;newSpecificBuilder:
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">mutable.Builder[A,&nbsp;Capped2[A]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;iterableFactory.newBuilder
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;empty:&nbsp;<code class="typename">Capped2[A]</code>&nbsp;=&nbsp;iterableFactory.empty
  }
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">Capped2Factory</code>(capacity:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">IterableFactory[Capped2]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;from[A](source:&nbsp;<code class="typename">IterableOnce[A]</code>):&nbsp;<code class="typename">Capped2[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(newBuilder[A]&nbsp;++=&nbsp;source).result()
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;empty[A]:&nbsp;<code class="typename">Capped2[A]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Capped2[A]</code>(capacity)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder[A]:&nbsp;<code class="typename">mutable.Builder[A,&nbsp;Capped2[A]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">mutable.ImmutableBuilder[A,&nbsp;Capped2[A]]</code>(empty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;addOne(elem:&nbsp;A):&nbsp;<code class="vem">this</code>.type&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elems&nbsp;=&nbsp;elems&nbsp;:+&nbsp;elem
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }
</pre>
      <h5>Listing 25.6 - <span class="code">Capped</span> collection, second version</h5>
      <p>The <span class="code">fromSpecific</span> and <span class="code">newSpecificBuilder</span> methods must be overridden because the implementations inherited from the <span class="code">Iterable</span> parent trait return <span class="code">Iterable</span> instead of the desired <span class="code">Capped2</span>. Another inherited operation returning an overly general type is <span class="code">empty</span>. This method is overridden to return <span class="code">Capped2[A]</span> as well. All these overrides simply forward to the collection factory referred to by the <span class="code">iterableFactory</span> member, whose value is an instance of class <span class="code">Capped2Factory</span>.</p>
      <p>Class <span class="code">Capped2Factory</span> provides convenient factory methods for building collections. Eventually, these methods delegate to the <span class="code">empty</span> operation, which builds an empty <span class="code">Capped2</span> instance, and <span class="code">newBuilder</span>, which uses the <span class="code">appended</span> operation to grow a <span class="code">Capped2</span> collection.</p>
      <p>With the refined implementation of the <span class="code">Capped2</span> class, the transformation operations work now as expected. In addition, the <span class="code">Capped2Factory</span> class provides seamless conversions from other collections:</p> <pre>  scala&gt;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Capped</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Capped2Factory</code>(capacity&nbsp;=&nbsp;<code class="literal">4</code>)
  <code class="output">&nbsp;defined&nbsp;object&nbsp;Capped</code>
  <br>  scala&gt;&nbsp;<code class="typename">Capped</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">&nbsp;res0:&nbsp;Capped2[Int]&nbsp;=&nbsp;Capped2(1,&nbsp;2,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;res0.take(<code class="literal">2</code>)
  <code class="output">&nbsp;res1:&nbsp;Capped2[Int]&nbsp;=&nbsp;Capped2(1,&nbsp;2)</code>
  <br>  scala&gt;&nbsp;res0.filter(x&nbsp;=&gt;&nbsp;x&nbsp;<code class="texttt">%</code>&nbsp;<code class="literal">2</code>&nbsp;==&nbsp;<code class="literal">1</code>)
  <code class="output">&nbsp;res2:&nbsp;Capped2[Int]&nbsp;=&nbsp;Capped2(1,&nbsp;3)</code>
  <br>  scala&gt;&nbsp;res0.map(x&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;x)
  <code class="output">&nbsp;res3:&nbsp;Capped2[Int]&nbsp;=&nbsp;Capped2(1,&nbsp;4,&nbsp;9)</code>
  <br>  scala&gt;&nbsp;<code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>,&nbsp;<code class="literal">4</code>,&nbsp;<code class="literal">5</code>).to(<code class="typename">Capped</code>)
  <code class="output">&nbsp;res4:&nbsp;Capped2[Int]&nbsp;=&nbsp;Capped2(2,&nbsp;3,&nbsp;4,&nbsp;5)</code>
</pre>
      <p>This implementation now behaves correctly, but you can still improve a few things. Since the collection is strict, you can take advantage of the better performance offered by strict implementations of transformation operations.</p>
      <h5>Capped collection, final version</h5>
      <p>The final version of class <span class="code">Capped</span> is shown in <a href="#lst-capped">Listings 25.7</a> <a href="#lst-capped-continued">and 25.8</a>. It mixes in trait <span class="code">StrictOptimizedIterableOps</span>,<a id="i-1210707408-1"></a> which overrides all transformation operations, allowing <span class="code">Capped</span> to take advantage of strict builders. This version also overrides a few operations for performance. The <span class="code">view</span> now uses indexed access, and <span class="code">iterator</span> delegates to the view. The <span class="code">knownSize</span> operation is also overridden, because the size is always known.</p>
      <p><a id="lst-capped"></a></p> <pre>  <code class="vem">import</code>&nbsp;scala.collection._
  <br>  <code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Capped[A]</code>&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;capacity:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;offset:&nbsp;<code class="typename">Int</code>,&nbsp;elems:&nbsp;<code class="typename">Array[Any]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">immutable.Iterable[A]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IterableOps[A,&nbsp;Capped,&nbsp;Capped[A]]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">StrictOptimizedIterableOps[A,&nbsp;Capped,&nbsp;Capped[A]]</code>&nbsp;{&nbsp;self&nbsp;=&gt;
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code class="vem">this</code>(capacity:&nbsp;<code class="typename">Int</code>)&nbsp;=&nbsp;<code class="vem">this</code>(capacity,&nbsp;length&nbsp;=&nbsp;<code class="literal">0</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;offset&nbsp;=&nbsp;<code class="literal">0</code>,&nbsp;elems&nbsp;=&nbsp;Array.ofDim(capacity))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;appended[B&nbsp;&gt;:&nbsp;A](elem:&nbsp;B):&nbsp;<code class="typename">Capped[B]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;newElems&nbsp;=&nbsp;Array.ofDim[<code class="typename">Any</code>](capacity)
  &nbsp;&nbsp;&nbsp;&nbsp;Array.copy(elems,&nbsp;<code class="literal">0</code>,&nbsp;newElems,&nbsp;<code class="literal">0</code>,&nbsp;capacity)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;(newOffset,&nbsp;newLength)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(length&nbsp;==&nbsp;capacity)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newElems(offset)&nbsp;=&nbsp;elem
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((offset&nbsp;+&nbsp;<code class="literal">1</code>)&nbsp;<code class="texttt">%</code>&nbsp;capacity,&nbsp;length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newElems(length)&nbsp;=&nbsp;elem
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(offset,&nbsp;length&nbsp;+&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Capped[B]</code>(capacity,&nbsp;newLength,&nbsp;newOffset,&nbsp;newElems)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;@inline&nbsp;<code class="vem">def</code>&nbsp;:+&nbsp;[B&nbsp;&gt;:&nbsp;A](elem:&nbsp;B):&nbsp;<code class="typename">Capped[B]</code>&nbsp;=&nbsp;appended(elem)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(i:&nbsp;<code class="typename">Int</code>):&nbsp;A&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;elems((i&nbsp;+&nbsp;offset)&nbsp;<code class="texttt">%</code>&nbsp;capacity).asInstanceOf[A]
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;continued&nbsp;in&nbsp;Listing&nbsp;25.8...</code>
</pre>
      <h5>Listing 25.7 - <span class="code">Capped</span> collection, final version</h5>
      <p><a id="lst-capped-continued"></a></p> <pre>  &nbsp;&nbsp;<code class="comment">//&nbsp;...continued&nbsp;from&nbsp;Listing&nbsp;25.7</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[A]</code>&nbsp;=&nbsp;view.iterator
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;view:&nbsp;<code class="typename">IndexedSeqView[A]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IndexedSeqView[A]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;length:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;self.length
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(i:&nbsp;<code class="typename">Int</code>):&nbsp;A&nbsp;=&nbsp;self(i)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;knownSize:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;length
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;className&nbsp;=&nbsp;<code class="quotedstring">"Capped"</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;iterableFactory:&nbsp;<code class="typename">IterableFactory[Capped]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">CappedFactory</code>(capacity)
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(coll:&nbsp;<code class="typename">IterableOnce[A]</code>):
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Capped[A]</code>&nbsp;=&nbsp;iterableFactory.from(coll)
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;newSpecificBuilder:
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">mutable.Builder[A,&nbsp;Capped[A]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;iterableFactory.newBuilder
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;empty:&nbsp;<code class="typename">Capped[A]</code>&nbsp;=&nbsp;iterableFactory.empty
  }
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">CappedFactory</code>(capacity:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IterableFactory[Capped]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;from[A](source:&nbsp;<code class="typename">IterableOnce[A]</code>):&nbsp;<code class="typename">Capped[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;source&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;capped:&nbsp;<code class="typename">Capped[A]</code>&nbsp;<code class="vem">if</code>&nbsp;capped.capacity&nbsp;==&nbsp;capacity&nbsp;=&gt;&nbsp;capped
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;(newBuilder[A]&nbsp;++=&nbsp;source).result()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;empty[A]:&nbsp;<code class="typename">Capped[A]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Capped[A]</code>(capacity)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder[A]:&nbsp;<code class="typename">mutable.Builder[A,&nbsp;Capped[A]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">mutable.ImmutableBuilder[A,&nbsp;Capped[A]]</code>(empty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;addOne(elem:&nbsp;A):&nbsp;<code class="vem">this</code>.type&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elems&nbsp;=&nbsp;elems&nbsp;:+&nbsp;elem
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }
</pre>
      <h5>Listing 25.8 - <span class="code">Capped</span> collection, final version (continued)</h5>
      <p>As demonstrated by <span class="code">Capped</span>, creating a new collection type requires a few steps. In addition to extending the appropriate collection type, you must mix in the appropriate <span class="code">Ops</span> template, then override <span class="code">iterableFactory</span> to return a more specific factory. Lastly, you must implement any abstract methods (such as <span class="code">iterator</span> in <span class="code">Capped</span>).</p>
      <h4>RNA sequences</h4>
      <p>As another example, say you want to create a new immutable sequence type for RNA strands, which are sequences of bases A (adenine), U (uracil), G (guanine), and C (cytosine). The definitions for bases are easily set up as shown in <a href="#lst-bases">Listing 25.9</a>.</p>
      <p><a id="lst-bases"></a></p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;A&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;U&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;G&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <code class="vem">case</code>&nbsp;<code class="vem">object</code>&nbsp;C&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Base</code>
  <br>  <code class="vem">object</code>&nbsp;<code class="typename">Base</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;fromInt:&nbsp;<code class="typename">Int</code>&nbsp;=&gt;&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;<code class="typename">Array</code>(A,&nbsp;U,&nbsp;G,&nbsp;C)
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;toInt:&nbsp;<code class="typename">Base</code>&nbsp;=&gt;&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;<code class="typename">Map</code>(A&nbsp;-&gt;&nbsp;<code class="literal">0</code>,&nbsp;U&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;G&nbsp;-&gt;&nbsp;<code class="literal">2</code>,&nbsp;C&nbsp;-&gt;&nbsp;<code class="literal">3</code>)
  }
</pre>
      <h5>Listing 25.9 - RNA bases.</h5>
      <p>Every base is defined as a case object that inherits from a common abstract class <span class="code">Base</span>. The <span class="code">Base</span> class has a companion object that defines two functions that map between bases and the integers 0 to 3. You can see in the examples two different ways to use collections to implement these functions. The <span class="code">toInt</span> function is implemented as a <span class="code">Map</span> from <span class="code">Base</span> values to integers. The reverse function, <span class="code">fromInt</span>, is implemented as an array. This makes use of the fact that both maps and arrays <span style="font-style:italic">are</span> functions because they inherit from the <span class="code">Function1</span> trait.</p>
      <p>The next task is to define a class for strands of RNA. Conceptually, a strand of RNA is simply a <span class="code">Seq[Base]</span>. However, RNA strands can get quite long, so it makes sense to invest some work in a compact representation. Because there are only four bases, a base can be identified with two bits, and you can therefore store sixteen bases as two-bit values in an integer. The idea, then, is to construct a specialized subclass of <span class="code">Seq[Base]</span>, which uses this packed representation.</p>
      <h5>RNA strands class, first version</h5>
      <p><a id="lst-rna1"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;collection.mutable
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;collection.immutable.{<code class="typename">IndexedSeq</code>,&nbsp;<code class="typename">IndexedSeqOps</code>}
  <br>  &nbsp;&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;RNA1&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;groups:&nbsp;<code class="typename">Array[Int]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IndexedSeq[Base]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IndexedSeqOps[Base,&nbsp;IndexedSeq,&nbsp;RNA1]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;RNA1._
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(idx:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(idx&nbsp;&lt;&nbsp;<code class="literal">0</code>&nbsp;||&nbsp;length&nbsp;&lt;=&nbsp;idx)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IndexOutOfBoundsException</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Base.fromInt(groups(idx&nbsp;/&nbsp;N)&nbsp;&gt;&gt;&nbsp;(idx&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)&nbsp;&amp;&nbsp;M)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;className&nbsp;=&nbsp;<code class="quotedstring">"RNA1"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA1&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fromSeq(source.iterator.toSeq)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;newSpecificBuilder:
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">mutable.Builder[Base,&nbsp;RNA1]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterableFactory.newBuilder[<code class="typename">Base</code>].mapResult(fromSeq)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;empty:&nbsp;RNA1&nbsp;=&nbsp;fromSeq(Seq.empty)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;RNA1&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Number&nbsp;of&nbsp;bits&nbsp;necessary&nbsp;to&nbsp;represent&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;S&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Number&nbsp;of&nbsp;groups&nbsp;that&nbsp;fit&nbsp;in&nbsp;an&nbsp;Int</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;N&nbsp;=&nbsp;<code class="literal">32</code>&nbsp;/&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Bitmask&nbsp;to&nbsp;isolate&nbsp;a&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;M&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;&lt;&lt;&nbsp;S)&nbsp;-&nbsp;<code class="literal">1</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fromSeq(buf:&nbsp;<code class="typename">collection.Seq[Base]</code>):&nbsp;RNA1&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;groups&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[Int]</code>((buf.length&nbsp;+&nbsp;N&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;N)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groups(i&nbsp;/&nbsp;N)&nbsp;|=&nbsp;Base.toInt(buf(i))&nbsp;&lt;&lt;&nbsp;(i&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;RNA1(groups,&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(bases:&nbsp;<code class="typename">Base</code>*)&nbsp;=&nbsp;fromSeq(bases)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 25.10 - RNA strands class, first version.</h5>
      <p><a href="#lst-rna1">Listing 25.10</a> presents the first version of this class, which will be refined later. Class <span class="code">RNA1</span> has a constructor that takes an array of <span class="code">Int</span>s as its first argument. This array contains the packed RNA data, with sixteen bases in each element, except for the last array element, which might be partially filled. The second argument, <span class="code">length</span>, specifies the total number of bases on the array (and in the sequence). Class <span class="code">RNA1</span> extends <span class="code">IndexedSeq[Base]</span> and <span class="code">IndexedSeqOps[Base,</span>&nbsp;<span class="code">IndexedSeq,</span>&nbsp;<span class="code">RNA1]</span>. These traits define two abstract methods, <span class="code">length</span> and <span class="code">apply</span>. These need to be implemented in concrete subclasses.</p>
      <p>Class <span class="code">RNA1</span> implements <span class="code">length</span> automatically by defining a parametric field (described in <a href="#sec-uniform-access-principle">Section 10.3</a>) of the same name. It implements the indexing method <span class="code">apply</span> (indexing method) by first extracting an integer value from the <span class="code">groups</span> array, then extracting the correct two-bit number from that integer using right shift (<span class="code">&gt;&gt;</span>) and mask (<span class="code">&amp;</span>). The private constants <span class="code">S</span>, <span class="code">N</span>, and <span class="code">M</span> come from the <span class="code">RNA1</span> companion object. <span class="code">S</span> specifies the size of each packet (<i>i.e.</i>, two); <span class="code">N</span> specifies the number of two-bit packets per integer; and <span class="code">M</span> is a bit mask that isolates the lowest <span class="code">S</span> bits in a word.</p>
      <p>Class <span class="code">RNA1</span> also overrides the <span class="code">fromSpecific</span> and <span class="code">newSpecificBuilder</span> methods, which are used by transformation operations such as <span class="code">filter</span> and <span class="code">take</span>. It implements <span class="code">fromSpecific</span> by forwarding to the <span class="code">fromSeq</span> method of the <span class="code">RNA1</span> companion object. It implements <span class="code">newSpecificBuilder</span> using the default <span class="code">IndexedSeq</span> builder and transforming its result into an <span class="code">RNA1</span> with the <span class="code">mapResult</span> method.</p>
      <p>Note that the constructor of class <span class="code">RNA1</span> is <span class="code">private</span>. This means that clients cannot create <span class="code">RNA1</span> sequences by calling <span class="code">new</span>, which makes sense, because it hides the representation of <span class="code">RNA1</span> sequences in terms of packed arrays from the user. If clients cannot see what the representation details of RNA sequences are, it becomes possible to change these representation details at any point in the future without affecting client code.</p>
      <p>In other words, this design achieves a good decoupling of the interface of RNA sequences and its implementation. However, if constructing an RNA sequence with <span class="code">new</span> is impossible, there must be some other way to create new RNA sequences, else the whole class would be rather useless. In fact there are two alternatives for RNA sequence creation, both provided by the <span class="code">RNA1</span> companion object. The first way is method <span class="code">fromSeq</span>, which converts a given sequence of bases (<i>i.e.</i>, a value of type <span class="code">Seq[Base]</span>) into an instance of class <span class="code">RNA1</span>. The <span class="code">fromSeq</span> method does this by packing all the bases contained in its argument sequence into an array, then calling <span class="code">RNA1</span>'s private constructor with that array and the length of the original sequence as arguments. This makes use of the fact that a private constructor of a class is visible in the class's companion object.</p>
      <p>The second way to create an <span class="code">RNA1</span> value is provided by the <span class="code">apply</span> method in the <span class="code">RNA1</span> object. It takes a variable number of <span class="code">Base</span> arguments and simply forwards them as a sequence to <span class="code">fromSeq</span>.</p>
      <p>Here are the two creation schemes in action:</p> <pre>  scala&gt;&nbsp;RNA1.fromSeq(<code class="typename">List</code>(A,&nbsp;G,&nbsp;U,&nbsp;A))
  <code class="output">res1:&nbsp;RNA1&nbsp;=&nbsp;RNA1(A,&nbsp;G,&nbsp;U,&nbsp;A)</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna1&nbsp;=&nbsp;RNA1(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C)
  <code class="output">rna1:&nbsp;RNA1&nbsp;=&nbsp;RNA1(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C)</code>
</pre>
      <p>When <span class="code">RNA1</span> mixes in <span class="code">IndexedSeqOps</span>, it specifies <span class="code">Base</span>, <span class="code">IndexedSeq</span>, and <span class="code">RNA1</span> as type parameters. The first type parameter establishes <span class="code">Base</span> as the type of elements. The second one selects <span class="code">IndexedSeq</span> as the type constructor to be used by transformation operations that return a collection with a different type of elements. The third type parameter defines the result type to be used by transformation operations that return a collection with the same type of elements.</p>
      <p>Note that the second type parameter is <span class="code">IndexedSeq</span> whereas the third is <span class="code">RNA1</span>. This means that operations like <span class="code">take</span> or <span class="code">filter</span> will return <span class="code">RNA1</span>:</p> <pre>  scala&gt;&nbsp;rna1.take(<code class="literal">3</code>)
  <code class="output">res2:&nbsp;RNA1&nbsp;=&nbsp;RNA1(A,&nbsp;U,&nbsp;G)</code>
  <br>  scala&gt;&nbsp;rna1.filter(_&nbsp;!=&nbsp;U)
  <code class="output">res3:&nbsp;RNA1&nbsp;=&nbsp;RNA1(A,&nbsp;G,&nbsp;G,&nbsp;C)</code>
</pre>
      <p>But operations like <span class="code">map</span> or <span class="code">++</span> will return <span class="code">IndexedSeq</span>:</p> <pre>  scala&gt;&nbsp;rna1.map(base&nbsp;=&gt;&nbsp;base)
  <code class="output">res7:&nbsp;IndexedSeq[Base]&nbsp;=&nbsp;Vector(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C)</code>
  <br>  scala&gt;&nbsp;rna1&nbsp;++&nbsp;rna1
  <code class="output">res8:&nbsp;IndexedSeq[Base]&nbsp;=&nbsp;Vector(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C,&nbsp;A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C)</code>
</pre>
      <p>How should methods like <span class="code">map</span> and <span class="code">++</span> be adapted to RNA strands? The desired behavior is to get back an RNA strand when mapping bases to bases or appending two RNA strands with <span class="code">++</span>. On the other hand, mapping bases to some other type over an RNA strand cannot yield another RNA strand, because the new elements have the wrong type. It must yield a sequence instead. Similarly, appending elements not of type <span class="code">Base</span> to an RNA strand could yield a general sequence, but cannot yield another RNA strand.</p>
      <p>On <span class="code">RNA1</span>, the result of <span class="code">map</span> and <span class="code">++</span> is never an <span class="code">RNA1</span>, even if the element type of the generated collection is <span class="code">Base</span>. To see how to do better, look at the signature of the <span class="code">map</span> method (or of <span class="code">++</span>, which has a similar signature). The <span class="code">map</span> method is originally defined in class <span class="code">scala.collection.IterableOps</span> with the following signature:</p> <pre>  <code class="vem">def</code>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;CC[B]
</pre>
      <p>In the <span class="code">RNA1</span> case, <span class="code">A</span> is the element type of the collection, and <span class="code">CC</span> is the type constructor passed as a second parameter to the <span class="code">IterableOps</span> trait. In the <span class="code">RNA1</span> implementation, the <span class="code">CC</span> type constructor is <span class="code">IndexedSeq</span>. This is why you get <span class="code">IndexedSeq</span> as the result type of <span class="code">map</span>.</p>
      <h5>RNA strands class, second version</h5>
      <p><a id="lst-rna2"></a></p> <pre>  <code class="vem">import</code>&nbsp;scala.collection.{<code class="typename">View</code>,&nbsp;mutable}
  <code class="vem">import</code>&nbsp;scala.collection.immutable.{<code class="typename">IndexedSeq</code>,&nbsp;<code class="typename">IndexedSeqOps</code>}
  <br>  <code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;RNA2&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;groups:&nbsp;<code class="typename">Array[Int]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IndexedSeq[Base]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IndexedSeqOps[Base,&nbsp;IndexedSeq,&nbsp;RNA2]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;RNA2._
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(idx:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;className&nbsp;=&nbsp;<code class="quotedstring">"RNA2"</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(
  &nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA2&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;newSpecificBuilder:
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">mutable.Builder[Base,&nbsp;RNA2]</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;empty:&nbsp;RNA2&nbsp;=&nbsp;<code class="comment">//&nbsp;as&nbsp;before</code>
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;Overload&nbsp;methods&nbsp;to&nbsp;return&nbsp;RNA2</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;appended(base:&nbsp;<code class="typename">Base</code>):&nbsp;RNA2&nbsp;=&nbsp;fromSpecific(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">View.Append</code>(<code class="vem">this</code>,&nbsp;base))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;appendedAll(suffix:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA2&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;concat(suffix)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;concat(suffix:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA2&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;fromSpecific(<code class="vem">this</code>.iterator&nbsp;++&nbsp;suffix.iterator)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;flatMap(f:&nbsp;<code class="typename">Base</code>&nbsp;=&gt;&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA2&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;fromSpecific(<code class="vem">new</code>&nbsp;<code class="typename">View.FlatMap</code>(<code class="vem">this</code>,&nbsp;f))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map(f:&nbsp;<code class="typename">Base</code>&nbsp;=&gt;&nbsp;<code class="typename">Base</code>):&nbsp;RNA2&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;fromSpecific(<code class="vem">new</code>&nbsp;<code class="typename">View.Map</code>(<code class="vem">this</code>,&nbsp;f))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;prepended(base:&nbsp;<code class="typename">Base</code>):&nbsp;RNA2&nbsp;=&nbsp;fromSpecific(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">View.Prepend</code>(base,&nbsp;<code class="vem">this</code>))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;prependedAll(prefix:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA2&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;fromSpecific(prefix.iterator&nbsp;++&nbsp;<code class="vem">this</code>.iterator)
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;symbolic&nbsp;alias&nbsp;for&nbsp;`concat`</code>
  &nbsp;&nbsp;@inline&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">def</code>&nbsp;++&nbsp;(suffix:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA2&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;concat(suffix)
  }
</pre>
      <h5>Listing 25.11 - RNA strands class, second version.</h5>
      <p>To improve this situation, you can overload the methods that return <span class="code">CC[B]</span> and have them return the RNA strand type instead when <span class="code">B</span> is known to be <span class="code">Base</span>. The methods that must be overloaded are <span class="code">appended</span>, <span class="code">appendedAll</span>, <span class="code">concat</span>, <span class="code">flatMap</span>, <span class="code">map</span>, <span class="code">prepended</span>, <span class="code">prependedAll</span>, and <span class="code">++</span>. Class <span class="code">RNA2</span>, shown in <a href="#lst-rna2">Listing 25.11</a>, overloads these methods for RNA strands.</p>
      <p>These methods on this implementation now behave as desired:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;rna2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C)
  <code class="output">rna2:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C)</code>
  <br>  scala&gt;&nbsp;rna1.map(base&nbsp;=&gt;&nbsp;base)
  <code class="output">res2:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C)</code>
  <br>  scala&gt;&nbsp;rna1&nbsp;++&nbsp;rna1
  <code class="output">res3:&nbsp;RNA2&nbsp;=&nbsp;RNA2(A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C,&nbsp;A,&nbsp;U,&nbsp;G,&nbsp;G,&nbsp;C)</code>
</pre>
      <p>This implementation is better than the previous one, but we can still improve a few things. Since our collection is strict, we could take advantage of the better performance offered by strict builders in transformation operations. Also, if we try to convert an <span class="code">Iterable[Base]</span> into an <span class="code">RNA2</span> it fails:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bases:&nbsp;<code class="typename">Iterable[Base]</code>&nbsp;=&nbsp;<code class="typename">List</code>(A,&nbsp;U,&nbsp;C,&nbsp;C)
  <code class="output">bases:&nbsp;Iterable[Base]&nbsp;=&nbsp;List(A,&nbsp;U,&nbsp;C,&nbsp;C)</code>
  <br>  scala&gt;&nbsp;bases.to(RNA2)
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;RNA2.type</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required:&nbsp;scala.collection.Factory[Base,?]</code>
</pre>
      <h5>RNA strands class, final version</h5>
      <p><a id="lst-rna"></a></p> <pre>  <code class="vem">import</code>&nbsp;scala.collection.{<code class="typename">AbstractIterator</code>,
  &nbsp;&nbsp;<code class="typename">SpecificIterableFactory</code>,&nbsp;<code class="typename">StrictOptimizedSeqOps</code>,
  &nbsp;&nbsp;<code class="typename">View</code>,&nbsp;mutable}
  <code class="vem">import</code>&nbsp;scala.collection.immutable.{<code class="typename">IndexedSeq</code>,&nbsp;<code class="typename">IndexedSeqOps</code>}
  <br>  <code class="vem">final</code>&nbsp;<code class="vem">class</code>&nbsp;RNA&nbsp;<code class="vem">private</code>&nbsp;(<code class="vem">val</code>&nbsp;groups:&nbsp;<code class="typename">Array[Int]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;length:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">IndexedSeq[Base]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">IndexedSeqOps[Base,&nbsp;IndexedSeq,&nbsp;RNA]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">StrictOptimizedSeqOps[Base,&nbsp;IndexedSeq,&nbsp;RNA]</code>&nbsp;{&nbsp;rna&nbsp;=&gt;
  <br>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;RNA._
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;Mandatory&nbsp;implementation&nbsp;of&nbsp;`apply`&nbsp;in&nbsp;`IndexedSeqOps`</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(idx:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(idx&nbsp;&lt;&nbsp;<code class="literal">0</code>&nbsp;||&nbsp;length&nbsp;&lt;=&nbsp;idx)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IndexOutOfBoundsException</code>
  &nbsp;&nbsp;&nbsp;&nbsp;Base.fromInt(groups(idx&nbsp;/&nbsp;N)&nbsp;&gt;&gt;&nbsp;(idx&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)&nbsp;&amp;&nbsp;M)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;className&nbsp;=&nbsp;<code class="quotedstring">"RNA"</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;RNA.fromSpecific(source)
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;newSpecificBuilder:
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">mutable.Builder[Base,&nbsp;RNA]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;RNA.newBuilder
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;empty:&nbsp;RNA&nbsp;=&nbsp;RNA.empty
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;Overload&nbsp;methods&nbsp;to&nbsp;return&nbsp;RNA</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;appended(base:&nbsp;<code class="typename">Base</code>):&nbsp;RNA&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(newSpecificBuilder&nbsp;++=&nbsp;<code class="vem">this</code>&nbsp;+=&nbsp;base).result()
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;appendedAll(suffix:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;strictOptimizedConcat(suffix,&nbsp;newSpecificBuilder)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;concat(suffix:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;strictOptimizedConcat(suffix,&nbsp;newSpecificBuilder)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;flatMap(f:&nbsp;<code class="typename">Base</code>&nbsp;=&gt;&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;strictOptimizedFlatMap(newSpecificBuilder,&nbsp;f)
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;continued&nbsp;in&nbsp;Listing&nbsp;25.13...</code>
</pre>
      <h5>Listing 25.12 - RNA strands class, final version (part 1).</h5>
      <p><a id="lst-rna-part-2"></a></p> <pre>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;...continued&nbsp;from&nbsp;Listing&nbsp;25.12</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;map(f:&nbsp;<code class="typename">Base</code>&nbsp;=&gt;&nbsp;<code class="typename">Base</code>):&nbsp;RNA&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strictOptimizedMap(newSpecificBuilder,&nbsp;f)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;prepended(base:&nbsp;<code class="typename">Base</code>):&nbsp;RNA&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newSpecificBuilder&nbsp;+=&nbsp;base&nbsp;++=&nbsp;<code class="vem">this</code>).result()
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;prependedAll(prefix:&nbsp;<code class="typename">Iterable[Base]</code>):&nbsp;RNA&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newSpecificBuilder&nbsp;++=&nbsp;prefix&nbsp;++=&nbsp;<code class="vem">this</code>).result()
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;@inline&nbsp;<code class="vem">final</code>&nbsp;<code class="vem">def</code>&nbsp;++&nbsp;(suffix:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concat(suffix)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Optional&nbsp;re-implementation&nbsp;of&nbsp;iterator,</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;to&nbsp;make&nbsp;it&nbsp;more&nbsp;efficient.</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[Base]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">AbstractIterator[Base]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;i&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;b&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;hasNext:&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;i&nbsp;&lt;&nbsp;rna.length
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;next():&nbsp;<code class="typename">Base</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;<code class="vem">if</code>&nbsp;(i&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;groups(i&nbsp;/&nbsp;N)&nbsp;<code class="vem">else</code>&nbsp;b&nbsp;&gt;&gt;&gt;&nbsp;S
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Base.fromInt(b&nbsp;&amp;&nbsp;M)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;RNA&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">SpecificIterableFactory[Base,&nbsp;RNA]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;S&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;number&nbsp;of&nbsp;bits&nbsp;in&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;M&nbsp;=&nbsp;(<code class="literal">1</code>&nbsp;&lt;&lt;&nbsp;S)&nbsp;-&nbsp;<code class="literal">1</code>&nbsp;<code class="comment">//&nbsp;bitmask&nbsp;to&nbsp;isolate&nbsp;a&nbsp;group</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;N&nbsp;=&nbsp;<code class="literal">32</code>&nbsp;/&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;number&nbsp;of&nbsp;groups&nbsp;in&nbsp;an&nbsp;Int</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fromSeq(buf:&nbsp;<code class="typename">collection.Seq[Base]</code>):&nbsp;RNA&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;groups&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Array[Int]</code>((buf.length&nbsp;+&nbsp;N&nbsp;-&nbsp;<code class="literal">1</code>)&nbsp;/&nbsp;N)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;groups(i&nbsp;/&nbsp;N)&nbsp;|=&nbsp;Base.toInt(buf(i))&nbsp;&lt;&lt;&nbsp;(i&nbsp;<code class="texttt">%</code>&nbsp;N&nbsp;*&nbsp;S)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;RNA(groups,&nbsp;buf.length)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;continued&nbsp;in&nbsp;Listing&nbsp;25.14...</code>
</pre>
      <h5>Listing 25.13 - RNA strands class, final version (part 2).</h5>
      <p><a id="lst-rna-part-3"></a></p> <pre>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;...continued&nbsp;from&nbsp;Listing&nbsp;25.13</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Implement&nbsp;factory&nbsp;methods&nbsp;required&nbsp;by</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;SpecificIterableFactory</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;empty:&nbsp;RNA&nbsp;=&nbsp;fromSeq(Seq.empty)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">mutable.Builder[Base,&nbsp;RNA]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutable.ArrayBuffer.newBuilder[<code class="typename">Base</code>].mapResult(fromSeq)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(it:&nbsp;<code class="typename">IterableOnce[Base]</code>):&nbsp;RNA&nbsp;=&nbsp;it&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;seq:&nbsp;<code class="typename">collection.Seq[Base]</code>&nbsp;=&gt;&nbsp;fromSeq(seq)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;fromSeq(mutable.ArrayBuffer.from(it))
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 25.14 - RNA strands class, final version (part 3).</h5>
      <p>The final version of class <span class="code">RNA</span>, shown in <a href="#lst-rna">Listings 25.12</a> <a href="#lst-rna-part-3">through 25.14</a>, extends the <span class="code">StrictOptimizedSeqOps</span><a id="i-1818148641-1"></a> trait. This trait overrides all transformation operations to take advantage of strict builders. Moreover, this version uses utility operations provided by the <span class="code">StrictOptimizedSeqOps</span> trait, such as <span class="code">strictOptimizedConcat</span>, to make the overloaded transformation methods that return an <span class="code">RNA</span> collection, such as <span class="code">map</span> and <span class="code">++</span>, more efficient.</p>
      <p>To make it easy to convert any collection of bases into an <span class="code">RNA</span>, <span class="code">RNA</span>'s companion object extends <span class="code">SpecificIterableFactory[Base,</span>&nbsp;<span class="code">RNA]</span>.<a id="i-2078710284-1"></a> This makes it possible to use the <span class="code">RNA</span> companion object as a parameter of a <span class="code">to</span> call on a <span class="code">Seq</span>:</p> <pre>  scala&gt;&nbsp;<code class="typename">List</code>(U,&nbsp;A,&nbsp;G,&nbsp;C).to(RNA)
  <code class="output">res0:&nbsp;RNA(U,&nbsp;A,&nbsp;G,&nbsp;C)</code>
</pre>
      <p>Trait <span class="code">SpecificIterableFactory[Base,</span>&nbsp;<span class="code">RNA]</span> defines three abstract methods: <span class="code">empty</span>, <span class="code">newBuilder</span>, and <span class="code">fromSpecific</span>. The <span class="code">RNA</span> object implements these, and the <span class="code">RNA</span> class defines its <span class="code">fromSpecific</span> and <span class="code">newSpecific</span> builder methods in terms of these.</p>
      <p>The discussion so far centered on the minimal amount of definitions needed to define new sequences with methods that obey certain types. But in practice you might also want to add new functionality to your sequences or override existing methods for better efficiency. An example of this is the overridden <span class="code">iterator</span> method in class <span class="code">RNA</span>. The <span class="code">iterator</span> method is an important method in its own right because it implements iterations over collections. Furthermore, many other collection methods are implemented in terms of <span class="code">iterator</span>. So it makes sense to invest some effort optimizing the method's implementation.</p>
      <p>The standard implementation of <span class="code">iterator</span> in <span class="code">IndexedSeq</span> will simply select every <span class="code">i</span>'th element of the collection using <span class="code">apply</span>, where <span class="code">i</span> ranges from 0 to the collection's length minus one. So this standard implementation selects an array element and unpacks a base from it once for every element in an RNA strand. The overriding <span class="code">iterator</span> in class <span class="code">RNA</span> is smarter than that. For every selected array element it immediately applies the given function to all bases contained in it. So the effort for array selection and bit unpacking is much reduced.</p>
      <h4>Prefix maps</h4>
      <p>As a third example you'll learn how to integrate a new kind of mutable map into the collection framework. The idea is to implement a mutable map with <span class="code">String</span> as the type of keys by a "Patricia trie".<a href="#footnotemain25-4">[4]</a> The term <span style="font-style:italic">Patricia</span> is an abbreviation<a id="i732713786-1"></a> for "Practical Algorithm to Retrieve Information Coded in Alphanumeric." The idea is to store a set or a map as a tree where subsequent characters in a search key determines uniquely a descendant tree.</p>
      <p>For instance, a Patricia trie storing the five strings, "<span class="code">abc</span>", "<span class="code">abd</span>", "<span class="code">al</span>", "<span class="code">all</span>", "<span class="code">xy</span>", would look like the tree given in <a href="#fig-patrica">Figure 25.2</a>. To find the node corresponding to the string "abc" in this trie, simply follow the subtree labeled "<span class="code">a</span>", proceed from there to the subtree labeled "<span class="code">b</span>" to finally reach its subtree labeled "<span class="code">c</span>". If the Patricia trie is used as a map, the value that's associated with a key is stored in the nodes that can be reached by the key. If it is a set, you simply store a marker saying that the node is present in the set.</p>
      <p><a id="lst-prefixmap"></a></p> <pre>  <code class="vem">import</code>&nbsp;scala.collection._
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">PrefixMap[A]</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">mutable.Map[String,&nbsp;A]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">mutable.MapOps[String,&nbsp;A,&nbsp;mutable.Map,&nbsp;PrefixMap[A]]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">StrictOptimizedIterableOps</code>
  &nbsp;&nbsp;&nbsp;&nbsp;[(<code class="typename">String</code>,&nbsp;A),&nbsp;<code class="typename">mutable.Iterable</code>,&nbsp;<code class="typename">PrefixMap[A]</code>]&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;suffixes:&nbsp;<code class="typename">immutable.Map[Char,&nbsp;PrefixMap[A]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;immutable.Map.empty
  <br>  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;value:&nbsp;<code class="typename">Option[A]</code>&nbsp;=&nbsp;<code class="typename">None</code>
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;get(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s.isEmpty)&nbsp;value
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;suffixes&nbsp;get&nbsp;(s(<code class="literal">0</code>))&nbsp;flatMap&nbsp;(_.get(s&nbsp;substring&nbsp;<code class="literal">1</code>))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;addOne(kv:&nbsp;(<code class="typename">String</code>,&nbsp;A)):&nbsp;<code class="vem">this</code>.type&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;withPrefix(kv._1).value&nbsp;=&nbsp;<code class="typename">Some</code>(kv._2)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;subtractOne(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="vem">this</code>.type&nbsp;&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s.isEmpty)&nbsp;{&nbsp;<code class="vem">val</code>&nbsp;prev&nbsp;=&nbsp;value;&nbsp;value&nbsp;=&nbsp;<code class="typename">None</code>;&nbsp;prev&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;suffixes&nbsp;get&nbsp;(s(<code class="literal">0</code>))&nbsp;flatMap&nbsp;(_.remove(s&nbsp;substring&nbsp;<code class="literal">1</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;withPrefix(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">PrefixMap[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(s.isEmpty)&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;leading&nbsp;=&nbsp;s(<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffixes&nbsp;get&nbsp;leading&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">None</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffixes&nbsp;=&nbsp;suffixes&nbsp;+&nbsp;(leading&nbsp;-&gt;&nbsp;empty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffixes(leading)&nbsp;withPrefix&nbsp;(s&nbsp;substring&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;continued&nbsp;in&nbsp;Listing&nbsp;25.16...</code>
</pre>
      <h5>Listing 25.15 - An implementation of prefix maps with Patricia tries.</h5>
      <p><a id="lst-prefixmap-continued"></a></p> <pre>  &nbsp;&nbsp;<code class="comment">//&nbsp;...continued&nbsp;from&nbsp;Listing&nbsp;25.15</code>
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;iterator:&nbsp;<code class="typename">Iterator[(String,&nbsp;A)]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">for</code>&nbsp;(v&nbsp;&lt;-&nbsp;value.iterator)&nbsp;<code class="vem">yield</code>&nbsp;(<code class="quotedstring">""</code>,&nbsp;v))&nbsp;++
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">for</code>&nbsp;((chr,&nbsp;m)&nbsp;&lt;-&nbsp;suffixes.iterator;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s,&nbsp;v)&nbsp;&lt;-&nbsp;m.iterator)&nbsp;<code class="vem">yield</code>&nbsp;(chr&nbsp;+:&nbsp;s,&nbsp;v))
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;className&nbsp;=&nbsp;<code class="quotedstring">"PrefixMap"</code>
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;Overload&nbsp;methods&nbsp;to&nbsp;return&nbsp;PrefixMap</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;map[B](f:&nbsp;((<code class="typename">String</code>,&nbsp;A))&nbsp;=&gt;&nbsp;(<code class="typename">String</code>,&nbsp;B)):&nbsp;<code class="typename">PrefixMap[B]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;strictOptimizedMap(PrefixMap.newBuilder[B],&nbsp;f)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;flatMap[B](f:&nbsp;((<code class="typename">String</code>,&nbsp;A))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">IterableOnce[(String,&nbsp;B)]</code>):&nbsp;<code class="typename">PrefixMap[B]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;strictOptimizedFlatMap(PrefixMap.newBuilder[B],&nbsp;f)
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;Override&nbsp;concat&nbsp;to&nbsp;refine&nbsp;its&nbsp;return&nbsp;type</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;concat[B&nbsp;&gt;:&nbsp;A](suffix:
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Iterable[(String,&nbsp;B)]</code>):&nbsp;<code class="typename">PrefixMap[B]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;strictOptimizedConcat(suffix,&nbsp;PrefixMap.newBuilder[B])
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;Members&nbsp;declared&nbsp;in&nbsp;scala.collection.mutable.Clearable</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;clear():&nbsp;<code class="typename">Unit</code>&nbsp;=&nbsp;suffixes&nbsp;=&nbsp;immutable.Map.empty
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;Members&nbsp;declared&nbsp;in&nbsp;scala.collection.IterableOps</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source:&nbsp;<code class="typename">IterableOnce[(String,&nbsp;A)]</code>):&nbsp;<code class="typename">PrefixMap[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;PrefixMap.from(coll)
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">def</code>&nbsp;newSpecificBuilder:
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">mutable.Builder[(String,&nbsp;A),&nbsp;PrefixMap[A]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;PrefixMap.newBuilder
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;empty:&nbsp;<code class="typename">PrefixMap[A]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrefixMap</code>
  }
</pre>
      <h5>Listing 25.16 - An implementation of prefix maps (continued).</h5>
      <div class="figure">
        <a id="fig-patrica"></a>
        <p><img src="patricia160.png" alt="images/patricia160.png"></p>
      </div>
      <h5> Figure 25.2 - An example Patricia trie.</h5>
      <p>Patricia tries support very efficient lookups and updates. Another nice feature is that they support selecting a subcollection by giving a prefix. For instance, in the tree in <a href="#fig-patrica">Figure 25.2</a> you can obtain the sub-collection of all keys that start with an "<span class="code">a</span>" simply by following the "<span class="code">a</span>" link from the root of the tree.</p>
      <p>Based on these ideas we will now walk you through the implementation of a map that's implemented as a Patricia trie. We call the map a <span class="code">PrefixMap</span>, which means that it provides a method <span class="code">withPrefix</span> that selects a submap of all keys starting with a given prefix.</p>
      <p>We'll first define a prefix map with the keys shown in <a href="#fig-patrica">Figure 25.2</a>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;m&nbsp;=&nbsp;<code class="typename">PrefixMap</code>(<code class="quotedstring">"abc"</code>&nbsp;-&gt;&nbsp;<code class="literal">0</code>,&nbsp;<code class="quotedstring">"abd"</code>&nbsp;-&gt;&nbsp;<code class="literal">1</code>,&nbsp;<code class="quotedstring">"al"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>,&nbsp;
  &nbsp;&nbsp;<code class="quotedstring">"all"</code>&nbsp;-&gt;&nbsp;<code class="literal">3</code>,&nbsp;<code class="quotedstring">"xy"</code>&nbsp;-&gt;&nbsp;<code class="literal">4</code>)
  <code class="output">m:&nbsp;PrefixMap[Int]&nbsp;=&nbsp;Map((abc,0),&nbsp;(abd,1),&nbsp;(al,2),&nbsp;(all,3),</code>
  <code class="output">&nbsp;&nbsp;(xy,4))</code>
</pre>
      <p>Then calling <span class="code">withPrefix</span> on <span class="code">m</span> will yield another prefix map:</p> <pre>  scala&gt;&nbsp;m&nbsp;withPrefix&nbsp;<code class="quotedstring">"a"</code>
  <code class="output">res14:&nbsp;PrefixMap[Int]&nbsp;=&nbsp;Map((bc,0),&nbsp;(bd,1),&nbsp;(l,2),&nbsp;(ll,3))</code>
</pre>
      <p><a href="#lst-prefixmap">Listings 25.15</a> <a href="#lst-prefixmap-continued">and 25.16</a> show the definition of <span class="code">PrefixMap</span>. It associates strings with any type of value, so it has a type parameter <span class="code">A</span> for the values of the map. In a pattern you have seen with the RNA strand example, the class extends both <span class="code">mutable.Map</span> and <span class="code">MapOps</span>. Inheriting the implementation class <span class="code">MapOps</span> serves to get the right result type for transformations such as <span class="code">filter</span> and <span class="code">take</span>.</p>
      <p>A prefix map node has two mutable fields: <span class="code">suffixes</span> and <span class="code">value</span>. The <span class="code">value</span> field contains an optional value that's associated with the node. It is initialized to <span class="code">None</span>. The <span class="code">suffixes</span> field contains a map from characters to <span class="code">PrefixMap</span> values. It is initialized to the empty map. You might ask, Why did we pick an immutable map as the implementation type for <span class="code">suffixes</span>? Would not a mutable map been more standard since <span class="code">PrefixMap</span> as a whole is also mutable? The answer is that immutable maps that contain only a few elements are very efficient in both space and execution time.</p>
      <p>For instance, maps that contain fewer than five elements are represented as a single object. By contrast, as described in <a href="#sec-sets-and-maps">Section 17.2</a>, the standard mutable map is a <span class="code">HashMap</span>, which typically occupies around 80 bytes, even if it is empty. So if small collections are common, it's better to pick immutable over mutable. In the case of Patricia tries, we'd expect that most nodes, except the ones at the very top of the tree, would contain only a few successors. So storing these successors in an immutable map is likely to be more efficient.</p>
      <p>Now have a look at the first method that needs to be implemented for a map: <span class="code">get</span>. The algorithm is as follows: To get the value associated with the empty string in a prefix map, simply select the optional <span class="code">value</span> stored in the root of the tree. Otherwise, if the key string is not empty, try to select the submap corresponding to the first character of the string. If that yields a map, follow up by looking up the remainder of the key string after its first character in that map. If the selection fails, the key is not stored in the map, so return with <span class="code">None</span>. The combined selection over an option value is elegantly expressed using <span class="code">flatMap</span>. When applied to an optional value, <span class="code">ov</span>, and a closure, <span class="code">f</span>, which in turn returns an optional value, <span class="code">ov</span>&nbsp;<span class="code">flatMap</span>&nbsp;<span class="code">f</span> will succeed if both <span class="code">ov</span> and <span class="code">f</span> return a defined value. Otherwise <span class="code">ov</span>&nbsp;<span class="code">flatMap</span>&nbsp;<span class="code">f</span> will return <span class="code">None</span>.</p>
      <p>The next two methods to implement for a mutable map are <span class="code">addOne</span> and <span class="code">subtractOne</span>. The <span class="code">subtractOne</span> method is very similar to <span class="code">get</span>, except that before returning any associated value, the field containing that value is set to <span class="code">None</span>. The <span class="code">addOne</span> method first calls <span class="code">withPrefix</span> to navigate to the tree node that needs to be updated, then sets the <span class="code">value</span> field of that node to the given value. The <span class="code">withPrefix</span> method navigates through the tree, creating sub-maps as necessary if some prefix of characters is not yet contained as a path in the tree.</p>
      <p>The last abstract method to implement for a mutable map is <span class="code">iterator</span>.<a id="i1062529325-1"></a> This method needs to produce an iterator that yields all key/value pairs stored in the map. For any given prefix map, this iterator is composed of the following parts: First, if the map contains a defined value, <span class="code">Some(x)</span>, in the <span class="code">value</span> field at its root, then <span class="code">("",</span>&nbsp;<span class="code">x)</span> is the first element returned from the iterator. Furthermore, the iterator needs to traverse the iterators of all submaps stored in the <span class="code">suffixes</span> field, but it needs to add a character in front of every key string returned by those iterators. More precisely, if <span class="code">m</span> is the submap reached from the root through a character <span class="code">chr</span>, and <span class="code">(s,</span>&nbsp;<span class="code">v)</span> is an element returned from <span class="code">m.iterator</span>, then the root's iterator will return <span class="code">(chr</span>&nbsp;<span class="code">+:</span>&nbsp;<span class="code">s,</span>&nbsp;<span class="code">v)</span> instead.</p>
      <p>This logic is implemented quite concisely as a concatenation of two <span class="code">for</span> expressions in the implementation of the <span class="code">iterator</span> method in <a href="#lst-prefixmap">Listing 25.15</a>. The first <span class="code">for</span> expression iterates over <span class="code">value.iterator</span>. This makes use of the fact that <span class="code">Option</span> values define an iterator method that returns either no element, if the option value is <span class="code">None</span>, or exactly one element <span class="code">x</span>, if the option value is <span class="code">Some(x)</span>.</p>
      <p><span class="code">PrefixMap</span> overrides <span class="code">fromSpecific</span> and <span class="code">newSpecificBuilder</span>, to narrow their result type to <span class="code">PrefixMap</span>. The default implementations of these methods return <span class="code">mutable.Map</span> instead of the desired <span class="code">PrefixMap</span>.</p>
      <p><a id="lst-prefix-obj"></a></p> <pre>  <code class="vem">import</code>&nbsp;scala.collection._
  <code class="vem">import</code>&nbsp;scala.language.implicitConversions
  <br>  <code class="vem">object</code>&nbsp;<code class="typename">PrefixMap</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;empty[A]&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">PrefixMap[A]</code>
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;from[A](source:&nbsp;<code class="typename">IterableOnce[(String,&nbsp;A)]</code>):&nbsp;<code class="typename">PrefixMap[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;source&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;pm:&nbsp;<code class="typename">PrefixMap[A]</code>&nbsp;=&gt;&nbsp;pm
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;(newBuilder[A]&nbsp;++=&nbsp;source).result()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[A](kvs:&nbsp;(<code class="typename">String</code>,&nbsp;A)*):&nbsp;<code class="typename">PrefixMap[A]</code>&nbsp;=&nbsp;from(kvs)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder[A]:&nbsp;<code class="typename">mutable.Builder[(String,&nbsp;A),&nbsp;PrefixMap[A]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">mutable.GrowableBuilder[(String,&nbsp;A),&nbsp;PrefixMap[A]]</code>(empty)
  <br>  &nbsp;&nbsp;<code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;toFactory[A](
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self:&nbsp;<code class="vem">this</code>.type):&nbsp;<code class="typename">Factory[(String,&nbsp;A),&nbsp;PrefixMap[A]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Factory[(String,&nbsp;A),&nbsp;PrefixMap[A]]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;fromSpecific(source:
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">IterableOnce[(String,&nbsp;A)]</code>):&nbsp;<code class="typename">PrefixMap[A]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.from(source)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;newBuilder:&nbsp;<code class="typename">mutable.Builder[(String,&nbsp;A),&nbsp;PrefixMap[A]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.newBuilder
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }
</pre>
      <h5>Listing 25.17 - The companion object for prefix maps.</h5>
      <p>We'll now turn to the companion object <span class="code">PrefixMap</span>, which is shown in <a href="#lst-prefix-obj">Listing 25.17</a>. In fact it is not strictly necessary to define this companion object, as class <span class="code">PrefixMap</span> can stand well on its own. The main purpose of object <span class="code">PrefixMap</span> is to define some convenience factory methods. It also defines an implicit conversion to <span class="code">Factory</span><a id="i835909464-1"></a> for a better interoperability with other collections. This conversion is triggered when one writes, for instance, <span class="code">List("foo"</span>&nbsp;<span class="code">-&gt;</span>&nbsp;<span class="code">3).to(PrefixMap)</span>. The <span class="code">to</span> operation takes a <span class="code">Factory</span> as parameter but the <span class="code">PrefixMap</span> companion object does not extend <span class="code">Factory</span> (and it can not because a <span class="code">Factory</span> fixes the type of collection elements, whereas <span class="code">PrefixMap</span> has a polymorphic type of values).</p>
      <p>The two convenience methods are <span class="code">empty</span> and <span class="code">apply</span>. The same methods are present for all other collections in Scala's collection framework so it makes sense to define them here, too. With the two methods, you can write <span class="code">PrefixMap</span> literals like you do for any other collection:</p> <pre>  scala&gt;&nbsp;<code class="typename">PrefixMap</code>(<code class="quotedstring">"hello"</code>&nbsp;-&gt;&nbsp;<code class="literal">5</code>,&nbsp;<code class="quotedstring">"hi"</code>&nbsp;-&gt;&nbsp;<code class="literal">2</code>)
  <code class="output">&nbsp;res0:&nbsp;PrefixMap[Int]&nbsp;=&nbsp;PrefixMap(hello&nbsp;-&gt;&nbsp;5,&nbsp;hi&nbsp;-&gt;&nbsp;2)</code>
  <br>  scala&gt;&nbsp;res0&nbsp;+=&nbsp;<code class="quotedstring">"foo"</code>&nbsp;-&gt;&nbsp;<code class="literal">3</code>
  <code class="output">&nbsp;res1:&nbsp;res0.type&nbsp;=&nbsp;PrefixMap(hello&nbsp;-&gt;&nbsp;5,&nbsp;hi&nbsp;-&gt;&nbsp;2,&nbsp;foo&nbsp;-&gt;&nbsp;3)</code>
</pre>
      <h4>Summary</h4>
      <p>If you want to fully integrate a new collection class into the framework, you need to pay attention to the following points:</p>
      <ol>
        <li>Decide whether the collection should be mutable or immutable. </li>
        <li>Pick the right base traits for the collection. </li>
        <li>Inherit from the right template trait to implement most collection operations. </li>
        <li>Overload desired operations that do not return, by default, a collection as specific as they could. </li>
      </ol>
      <h3>25.3 Conclusion</h3>
      <p>You have now seen how Scala's collections are built and how you can add new kinds of collections. Because of Scala's rich support for abstraction, each new collection type has a large number of methods without having to reimplement them all over again.</p>
      <hr>
      <h4>Footnotes for Chapter 25:</h4>
      <p><a id="footnotemain25-1"></a>[1] Ideally, everything should be defined in one place only, but there are a few exceptions where things needed to be redefined.</p>
      <p><a id="footnotemain25-2"></a>[2] Type constructors were described in <a href="#sec-first-arrays">Section 19.3</a>.</p>
      <p><a id="footnotemain25-3"></a>[3] <span class="code">View</span>s were described in <a href="#sec-views">Section 24.13</a>.</p>
      <p><a id="footnotemain25-4"></a>[4] Morrison, "PATRICIA—Practical Algorithm To Retrieve Information Coded in Alphanumeric" <a href="#patricia">[Mor68]</a></p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-extractors">Chapter 26</a></h2>
      <h1>Extractors</h1>
      <p>By now you have probably grown accustomed to the concise way data can be decomposed and analyzed using pattern matching<a id="i-83872229-1"></a>. This chapter shows you how to generalize this concept further. Until now, constructor patterns were linked to case classes. For instance, <span class="code">Some(x)</span> is a valid pattern because <span class="code">Some</span> is a case class. Sometimes you might wish that you could write patterns like this without creating an associated case class. In fact, you might wish to be able to create your own kinds of patterns. Extractors give you a way to do so<a id="i751564495-1"></a>. This chapter explains what extractors are and how you can use them to define patterns that are decoupled from an object's representation.</p>
      <h3>26.1 An example: extracting email addresses</h3>
      <p>To illustrate the problem extractors solve, imagine that you need to analyze strings that represent email addresses. Given a string, you want to decide whether it is an email address or not, and, if it is, you want to access the user and domain parts of the address. The traditional way to do this uses three helper functions:</p> <pre>  <code class="vem">def</code>&nbsp;isEMail(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Boolean</code>
  <code class="vem">def</code>&nbsp;domain(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">String</code>
  <code class="vem">def</code>&nbsp;user(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">String</code>
</pre>
      <p>With these functions, you could parse a given string <span class="code">s</span> as follows:</p> <pre>  <code class="vem">if</code>&nbsp;(isEMail(s))&nbsp;println(user(s)&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;AT&nbsp;"</code>&nbsp;+&nbsp;domain(s))
  <code class="vem">else</code>&nbsp;println(<code class="quotedstring">"not&nbsp;an&nbsp;email&nbsp;address"</code>)
</pre>
      <p>This works, but is kind of clumsy. What's more, things would become more complicated if you combined several such tests. For instance you might want to find two successive strings in a list that are both email addresses with the same user. You can try this yourself with the access functions defined previously to see what would be involved.</p>
      <p>You saw already in <a href="#chap-case-classes-and-pattern-matching">Chapter 15</a> that pattern matching is ideal for attacking problems like this. Let's assume for the moment that you could match a string with a pattern:</p> <pre>  <code class="typename">EMail</code>(user,&nbsp;domain)
</pre>
      <p>The pattern would match if the string contained an embedded at sign (<span class="code">@</span>). In that case it would bind variable <span class="code">user</span> to the part of the string before the <span class="code">@</span> and variable <span class="code">domain</span> to the part after it. Postulating a pattern like this, the previous expression could be written more clearly like this:</p> <pre>  s&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(user,&nbsp;domain)&nbsp;=&gt;&nbsp;println(user&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;AT&nbsp;"</code>&nbsp;+&nbsp;domain)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"not&nbsp;an&nbsp;email&nbsp;address"</code>)
  }
</pre>
      <p>The more complicated problem of finding two successive email addresses with the same user part would translate to the following pattern:</p> <pre>  ss&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(u1,&nbsp;d1)&nbsp;::&nbsp;<code class="typename">EMail</code>(u2,&nbsp;d2)&nbsp;::&nbsp;_&nbsp;<code class="vem">if</code>&nbsp;(u1&nbsp;==&nbsp;u2)&nbsp;=&gt;&nbsp;...
  &nbsp;&nbsp;...
  }
</pre>
      <p>This is much more legible than anything that could be written with access functions. However, the problem is that strings are not case classes; they do not have a representation that conforms to <span class="code">EMail(user,</span>&nbsp;<span class="code">domain)</span>. This is where Scala's extractors come in: they let you define new patterns for pre-existing types, where the pattern need not follow the internal representation of the type.</p>
      <h3>26.2 Extractors</h3>
      <p>An extractor in Scala is an object that has a method called <span class="code">unapply</span> as one of its members<a id="i1869714895-1"></a>. The purpose of that <span class="code">unapply</span> method is to match a value and take it apart. Often, the extractor object also defines a dual method <span class="code">apply</span> for building values, but this is not required.<a id="i-649058493-1"></a> As an example, <a href="#lst-email-extractor">Listing 26.1</a> shows an extractor object for email addresses: <a id="lst-email-extractor"></a></p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">EMail</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;injection&nbsp;method&nbsp;(optional)</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(user:&nbsp;<code class="typename">String</code>,&nbsp;domain:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;user&nbsp;+&nbsp;<code class="quotedstring">"@"</code>&nbsp;+&nbsp;domain
  <br>  &nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;extraction&nbsp;method&nbsp;(mandatory)</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapply(str:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[(String,&nbsp;String)]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;parts&nbsp;=&nbsp;str&nbsp;split&nbsp;<code class="quotedstring">"@"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(parts.length&nbsp;==&nbsp;<code class="literal">2</code>)&nbsp;<code class="typename">Some</code>(parts(<code class="literal">0</code>),&nbsp;parts(<code class="literal">1</code>))&nbsp;<code class="vem">else</code>&nbsp;<code class="typename">None</code>
  &nbsp;&nbsp;}
  }
</pre>
      <h5>Listing 26.1 - The <span class="code">EMail</span> string extractor object.</h5>
      <p>This object defines both <span class="code">apply</span> and <span class="code">unapply</span> methods. The <span class="code">apply</span> method has the same meaning as always: it turns <span class="code">EMail</span> into an object that can be applied to arguments in parentheses in the same way a method is applied. So you can write <span class="code">EMail("John",</span>&nbsp;<span class="code">"epfl.ch")</span> to construct the string <span class="code">"John@epfl.ch"</span>. To make this more explicit, you could also let <span class="code">EMail</span> inherit from Scala's function type, like this:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">EMail</code>&nbsp;<code class="vem">extends</code>&nbsp;((<code class="typename">String</code>,&nbsp;<code class="typename">String</code>)&nbsp;=&gt;&nbsp;<code class="typename">String</code>)&nbsp;{&nbsp;...&nbsp;}
</pre>
      <div class="note">
        <h4>Note</h4>
        <p>The "<span class="code">(String,</span>&nbsp;<span class="code">String)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">String</span>" portion of the previous object declaration means the same as <span class="code">Function2[String,</span>&nbsp;<span class="code">String,</span>&nbsp;<span class="code">String]</span>, which declares an abstract <span class="code">apply</span> method that <span class="code">EMail</span> implements. As a result of this declaration, you could, for example, pass <span class="code">EMail</span> to a method expecting a <span class="code">Function2[String,</span>&nbsp;<span class="code">String,</span>&nbsp;<span class="code">String]</span>.</p>
      </div>
      <p>The <span class="code">unapply</span> method is what turns <span class="code">EMail</span> into an extractor. In a sense, it reverses the construction process of <span class="code">apply</span>. Where <span class="code">apply</span> takes two strings and forms an email address string out of them, <span class="code">unapply</span> takes an email address and returns potentially two strings: the user and the domain of the address. But <span class="code">unapply</span> must also handle the case where the given string is not an email address. That's why <span class="code">unapply</span> returns an <span class="code">Option</span>-type over pairs of strings. Its result is either <span class="code">Some(user,</span>&nbsp;<span class="code">domain)</span> if the string <span class="code">str</span> is an email address with the given <span class="code">user</span> and <span class="code">domain</span> parts,<a href="#footnotemain26-1">[1]</a> or <span class="code">None</span>, if <span class="code">str</span> is not an email address. Here are some examples:</p> <pre>  unapply(<code class="quotedstring">"John@epfl.ch"</code>)&nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;&nbsp;<code class="typename">Some</code>(<code class="quotedstring">"John"</code>,&nbsp;<code class="quotedstring">"epfl.ch"</code>)
  unapply(<code class="quotedstring">"John&nbsp;Doe"</code>)&nbsp;&nbsp;<code class="rm"><em>equals</em></code>&nbsp;&nbsp;<code class="typename">None</code>
</pre>
      <p>Now, whenever pattern matching encounters a pattern referring to an extractor object, it invokes the extractor's <span class="code">unapply</span> method on the selector expression. For instance, executing the code:</p> <pre>  selectorString&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(user,&nbsp;domain)&nbsp;=&gt;&nbsp;...&nbsp;}
</pre>
      <p>would lead to the call:</p> <pre>  EMail.unapply(selectorString)
</pre>
      <p>As you saw previously, this call to <span class="code">EMail.unapply</span> will return either <span class="code">None</span><a id="i2129711991-1"></a> or <span class="code">Some(u,</span>&nbsp;<span class="code">d)</span><a id="i-467709668-1"></a>, for some values <span class="code">u</span> for the user part of the address and <span class="code">d</span> for the domain part. In the <span class="code">None</span> case, the pattern does not match, and the system tries another pattern or fails with a <span class="code">MatchError</span> exception.<a id="i-2067503209-1"></a> In the <span class="code">Some(u,</span>&nbsp;<span class="code">d)</span> case, the pattern matches and its variables are bound to the elements of the returned value. In the previous match, <span class="code">user</span> would be bound to <span class="code">u</span> and <span class="code">domain</span> would be bound to <span class="code">d</span>.</p>
      <p>In the <span class="code">EMail</span> pattern matching example, the type <span class="code">String</span> of the selector expression, <span class="code">selectorString</span>, conformed to <span class="code">unapply</span>'s argument type (which in the example was also <span class="code">String</span>). This is quite common, but not necessary. It would also be possible to use the <span class="code">EMail</span> extractor to match selector expressions for more general types. For instance, to find out whether an arbitrary value <span class="code">x</span> was an email address string, you could write:</p> <pre>  <code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Any</code>&nbsp;=&nbsp;...
  x&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(user,&nbsp;domain)&nbsp;=&gt;&nbsp;...&nbsp;}
</pre>
      <p>Given this code, the pattern matcher will first check whether the given value <span class="code">x</span> conforms to <span class="code">String</span>, the parameter type of <span class="code">EMail</span>'s unapply method. If it does conform, the value is cast to <span class="code">String</span> and pattern matching proceeds as before. If it does not conform, the pattern fails immediately.</p>
      <p>In object <span class="code">EMail</span>, the <span class="code">apply</span> method is called an <span style="font-style:italic">injection</span>, because it takes some arguments and yields an element of a given set (in our case: the set of strings that are email addresses).<a id="i2031936124-1"></a><a id="i1478477936-1"></a> The <span class="code">unapply</span> method is called an <span style="font-style:italic">extraction</span>, because it takes an element of the same set and extracts some of its parts (in our case: the user and domain substrings)<a id="i-1101999489-1"></a>. Injections and extractions are often grouped together in one object, because then you can use the object's name for both a constructor and a pattern, which simulates the convention for pattern matching with case classes. However, it is also possible to define an extraction in an object without a corresponding injection. The object itself is called an <span style="font-style:italic">extractor</span>, regardless of whether or not it has an <span class="code">apply</span> method.</p>
      <p>If an injection method is included, it should be the dual to the extraction method. For instance, a call of:</p> <pre>  EMail.unapply(EMail.apply(user,&nbsp;domain))
</pre>
      <p>should return:</p> <pre>  <code class="typename">Some</code>(user,&nbsp;domain)
</pre>
      <p><i>i.e.</i>, the same sequence of arguments wrapped in a <span class="code">Some</span>. Going in the other direction means running first the <span class="code">unapply</span> and then the <span class="code">apply</span>, as shown in the following code:</p> <pre>  EMail.unapply(obj)&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Some</code>(u,&nbsp;d)&nbsp;=&gt;&nbsp;EMail.apply(u,&nbsp;d)&nbsp;
  }
</pre>
      <p>In that code, if the match on <span class="code">obj</span> succeeds, you'd expect to get back that same object from the <span class="code">apply</span>. These two conditions for the duality of <span class="code">apply</span> and <span class="code">unapply</span> are good design principles. They are not enforced by Scala, but it's recommended to keep to them when designing your extractors.</p>
      <h3>26.3 Patterns with zero or one variables</h3>
      <p>The <span class="code">unapply</span> method of the previous example returned a pair of element values in the success case. This is easily generalized to patterns of more than two variables. To bind <span class="code">N</span> variables, an <span class="code">unapply</span> would return an <span class="code">N</span>-element tuple, wrapped in a <span class="code">Some</span>.</p>
      <p>The case where a pattern binds just one variable is treated differently, however. There is no one-tuple in Scala. To return just one pattern element, the <span class="code">unapply</span> method simply wraps the element itself in a <span class="code">Some</span>. For example, the extractor object shown in <a href="#lst-twice-extractor">Listing 26.2</a> defines <span class="code">apply</span> and <span class="code">unapply</span> for strings that consist of the same substring appearing twice in a row: <a id="lst-twice-extractor"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Twice</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;s&nbsp;+&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapply(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[String]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;length&nbsp;=&nbsp;s.length&nbsp;/&nbsp;<code class="literal">2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;half&nbsp;=&nbsp;s.substring(<code class="literal">0</code>,&nbsp;length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(half&nbsp;==&nbsp;s.substring(length))&nbsp;<code class="typename">Some</code>(half)&nbsp;<code class="vem">else</code>&nbsp;<code class="typename">None</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 26.2 - The <span class="code">Twice</span> string extractor object.</h5>
      <p>It's also possible that an extractor pattern does not bind any variables. In that case the corresponding <span class="code">unapply</span> method returns a boolean—<span class="code">true</span> for success and <span class="code">false</span> for failure. For instance, the extractor object shown in <a href="#lst-uppercase-extractor">Listing 26.3</a> characterizes strings consisting of all uppercase characters:</p>
      <p><a id="lst-uppercase-extractor"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">UpperCase</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapply(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;s.toUpperCase&nbsp;==&nbsp;s
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 26.3 - The <span class="code">UpperCase</span> string extractor object.</h5>
      <p>This time, the extractor only defines an <span class="code">unapply</span>, but not an <span class="code">apply</span>. It would make no sense to define an <span class="code">apply</span>, as there's nothing to construct.</p>
      <p>The following <span class="code">userTwiceUpper</span> function applies all previously defined extractors together in its pattern matching code:</p> <pre>  <code class="vem">def</code>&nbsp;userTwiceUpper(s:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;s&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(<code class="typename">Twice</code>(x&nbsp;@&nbsp;<code class="typename">UpperCase</code>()),&nbsp;domain)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"match:&nbsp;"</code>&nbsp;+&nbsp;x&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;in&nbsp;domain&nbsp;"</code>&nbsp;+&nbsp;domain
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"no&nbsp;match"</code>
  }
</pre>
      <p>The first pattern of this function matches strings that are email addresses whose user part consists of two occurrences of the same string in uppercase letters. For instance:</p> <pre>  scala&gt;&nbsp;userTwiceUpper(<code class="quotedstring">"DIDI@hotmail.com"</code>)
  <code class="output">res0:&nbsp;String&nbsp;=&nbsp;match:&nbsp;DI&nbsp;in&nbsp;domain&nbsp;hotmail.com</code>
  <br>  scala&gt;&nbsp;userTwiceUpper(<code class="quotedstring">"DIDO@hotmail.com"</code>)
  <code class="output">res1:&nbsp;String&nbsp;=&nbsp;no&nbsp;match</code>
  <br>  scala&gt;&nbsp;userTwiceUpper(<code class="quotedstring">"didi@hotmail.com"</code>)
  <code class="output">res2:&nbsp;String&nbsp;=&nbsp;no&nbsp;match</code>
</pre>
      <p>Note that <span class="code">UpperCase</span> in function <span class="code">userTwiceUpper</span> takes an empty parameter list. This cannot be omitted as otherwise the match would test for equality with the object <span class="code">UpperCase</span>! Note also that, even though <span class="code">UpperCase()</span> itself does not bind any variables, it is still possible to associate a variable with the whole pattern matched by it. To do this, you use the standard scheme of variable binding explained in <a href="#sec-var-binding">Section 15.2</a>: the form <span class="code">x @ UpperCase()</span> associates the variable <span class="code">x</span> with the pattern matched by <span class="code">UpperCase()</span>. For instance, in the first <span class="code">userTwiceUpper</span> invocation above, <span class="code">x</span> was bound to <span class="code">"DI"</span>, because that was the value against which the <span class="code">UpperCase()</span> pattern was matched.</p>
      <h3>26.4 Variable argument extractors</h3>
      <p>The previous extraction methods for email addresses all returned a fixed number of element values. Sometimes, this is not flexible enough. For example, you might want to match on a string representing a domain name, so that every part of the domain is kept in a different sub-pattern. This would let you express patterns such as the following:</p> <pre>  dom&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Domain</code>(<code class="quotedstring">"org"</code>,&nbsp;<code class="quotedstring">"acm"</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"acm.org"</code>)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Domain</code>(<code class="quotedstring">"com"</code>,&nbsp;<code class="quotedstring">"sun"</code>,&nbsp;<code class="quotedstring">"java"</code>)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"java.sun.com"</code>)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Domain</code>(<code class="quotedstring">"net"</code>,&nbsp;_*)&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"a&nbsp;.net&nbsp;domain"</code>)
  }
</pre>
      <p>In this example things were arranged so that domains are expanded in reverse order—from the top-level domain down to the sub-domains. This was done so that you could better profit from sequence patterns. You saw in <a href="#sec-pat-sequences">Section 15.2</a> that a sequence wildcard pattern, <span class="code">_*</span><a id="i-563003136-1"></a>, at the end of an argument list matches any remaining elements in a sequence. This feature is more useful if the top-level domain comes first, because then you can use sequence wildcards to match sub-domains of arbitrary depth.</p>
      <p>The question remains how an extractor can support <span style="font-style:italic">vararg matching</span><a id="i1383700270-1"></a><a id="i1018791428-1"></a><a id="i-1008880962-1"></a> as shown in the previous example, where patterns can have a varying number of sub-patterns. The <span class="code">unapply</span> methods encountered so far are not sufficient, because they each return a fixed number of sub-elements in the success case. To handle this case, Scala lets you define a different extraction method specifically for vararg matching. This method is called <span class="code">unapplySeq</span><a id="i1953385690-1"></a>. To see how it is written, have a look at the <span class="code">Domain</span> extractor, shown in <a href="#lst-domain-extractor">Listing 26.4</a>: <a id="lst-domain-extractor"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Domain</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;injection&nbsp;method&nbsp;(optional)</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(parts:&nbsp;<code class="typename">String</code>*):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.reverse.mkString(<code class="quotedstring">"."</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;The&nbsp;extraction&nbsp;method&nbsp;(mandatory)</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapplySeq(whole:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[Seq[String]]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Some</code>(whole.split(<code class="quotedstring">"\\."</code>).reverse.toSeq)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 26.4 - The <span class="code">Domain</span> string extractor object.</h5>
      <p>The <span class="code">Domain</span> object defines an <span class="code">unapplySeq</span> method that first splits the string into parts separated by periods. This is done using Java's <span class="code">split</span> method on strings, which takes a regular expression as its argument. The result of <span class="code">split</span> is an array of substrings. The result of <span class="code">unapplySeq</span> is then that array with all elements reversed and wrapped in a <span class="code">Some</span>.</p>
      <p>The result type of an <span class="code">unapplySeq</span> must conform to <span class="code">Option[Seq[T]]</span>, where the element type <span class="code">T</span> is arbitrary. As you saw in <a href="#sec-sequences">Section 17.1</a>, <span class="code">Seq</span> is an important class in Scala's collection hierarchy. It's a common superclass of several classes describing different kinds of sequences: <span class="code">List</span>s, <span class="code">Array</span>s, <span class="code">WrappedString</span>, and several others.</p>
      <p>For symmetry, <span class="code">Domain</span> also has an <span class="code">apply</span> method that builds a domain string from a variable argument parameter of domain parts starting with the top-level domain. As always, the <span class="code">apply</span> method is optional.</p>
      <p>You can use the <span class="code">Domain</span> extractor to get more detailed information out of email strings. For instance, to search for an email address named "tom" in some "<span class="code">.com</span>" domain, you could write the following function:</p> <pre>  <code class="vem">def</code>&nbsp;isTomInDotCom(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;s&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EMail</code>(<code class="quotedstring">"tom"</code>,&nbsp;<code class="typename">Domain</code>(<code class="quotedstring">"com"</code>,&nbsp;_*))&nbsp;=&gt;&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  }
</pre>
      <p>This gives the expected results:</p> <pre>  scala&gt;&nbsp;isTomInDotCom(<code class="quotedstring">"tom@sun.com"</code>)
  <code class="output">res3:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;isTomInDotCom(<code class="quotedstring">"peter@sun.com"</code>)
  <code class="output">res4:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;isTomInDotCom(<code class="quotedstring">"tom@acm.org"</code>)
  <code class="output">res5:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>It's also possible to return some fixed elements from an <span class="code">unapplySeq</span> together with the variable part. This is expressed by returning all elements in a tuple, where the variable part comes last, as usual. As an example, <a href="#lst-expanded-email-extractor">Listing 26.5</a> shows a new extractor for emails where the domain part is already expanded into a sequence: <a id="lst-expanded-email-extractor"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">ExpandedEMail</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapplySeq(email:&nbsp;<code class="typename">String</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">Option[(String,&nbsp;Seq[String])]</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;parts&nbsp;=&nbsp;email&nbsp;split&nbsp;<code class="quotedstring">"@"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(parts.length&nbsp;==&nbsp;<code class="literal">2</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Some</code>(parts(<code class="literal">0</code>),&nbsp;parts(<code class="literal">1</code>).split(<code class="quotedstring">"\\."</code>).reverse.toSeq)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">None</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 26.5 - The <span class="code">ExpandedEMail</span> extractor object.</h5>
      <p>The <span class="code">unapplySeq</span> method in <span class="code">ExpandedEMail</span> returns an optional value of a pair (a <span class="code">Tuple2</span>). The first element of the pair is the user part. The second element is a sequence of names representing the domain. You can match on this as usual:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;s&nbsp;=&nbsp;<code class="quotedstring">"tom@support.epfl.ch"</code>
  <code class="output">s:&nbsp;String&nbsp;=&nbsp;tom@support.epfl.ch</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">ExpandedEMail</code>(name,&nbsp;topdom,&nbsp;subdoms&nbsp;@&nbsp;_*)&nbsp;=&nbsp;s
  <code class="output">name:&nbsp;String&nbsp;=&nbsp;tom</code>
  <code class="output">topdom:&nbsp;String&nbsp;=&nbsp;ch</code>
  <code class="output">subdoms:&nbsp;Seq[String]&nbsp;=&nbsp;WrappedArray(epfl,&nbsp;support)</code>
</pre>
      <h3>26.5 Extractors and sequence patterns</h3>
      <p>You saw in <a href="#sec-pat-sequences">Section 15.2</a> that you can access the elements of a list or an array using sequence patterns such as:</p> <pre>  <code class="typename">List</code>()
  <code class="typename">List</code>(x,&nbsp;y,&nbsp;_*)
  <code class="typename">Array</code>(x,&nbsp;<code class="literal">0</code>,&nbsp;<code class="literal">0</code>,&nbsp;_)
</pre>
      <p>In fact, these sequence patterns are all implemented using extractors in the standard Scala library. For instance, patterns of the form <span class="code">List(...)</span> are possible because the <span class="code">scala.List</span> companion object is an extractor that defines an <span class="code">unapplySeq</span> method. <a href="#lst-lists-unapply-seq">Listing 26.6</a> shows the relevant definitions: <a id="lst-lists-unapply-seq"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">List</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply[T](elems:&nbsp;T*)&nbsp;=&nbsp;elems.toList
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;unapplySeq[T](x:&nbsp;<code class="typename">List[T]</code>):&nbsp;<code class="typename">Option[Seq[T]]</code>&nbsp;=&nbsp;<code class="typename">Some</code>(x)
  &nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 26.6 - An extractor that defines an <span class="code">unapplySeq</span> method.</h5>
      <p>The <span class="code">List</span> object contains an <span class="code">apply</span> method that takes a variable number of arguments.<a id="i19484993-3"></a><a id="i1305057997-3"></a> That's what lets you write expressions such as:</p> <pre>  <code class="typename">List</code>()
  <code class="typename">List</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
</pre>
      <p>It also contains an <span class="code">unapplySeq</span> method that returns all elements of the list as a sequence. That's what supports <span class="code">List(...)</span> patterns. Very similar definitions exist in the object <span class="code">scala.Array</span>. These support analogous injections and extractions for arrays.</p>
      <h3>26.6 Extractors versus case classes</h3>
      <p>Even though they are very useful, case classes have one shortcoming: they expose the concrete representation of data. This means that the name of the class in a constructor pattern corresponds to the concrete representation type of the selector object. If a match against<a id="i-910914787-1"></a>:</p> <pre>  <code class="vem">case</code>&nbsp;C(...)
</pre>
      <p>succeeds, you know that the selector expression is an instance of class <span class="code">C</span>.</p>
      <p>Extractors break this link between data representations and patterns. You have seen in the examples in this section that they enable patterns that have nothing to do with the data type of the object that's selected on. This property is called <span style="font-style:italic">representation independence</span>.<a id="i886727311-1"></a> In open systems of large size, representation independence is very important because it allows you to change an implementation type used in a set of components without affecting clients of these components.</p>
      <p>If your component had defined and exported a set of case classes, you'd be stuck with them because client code could already contain pattern matches against these case classes. Renaming some case classes or changing the class hierarchy would affect client code. Extractors do not share this problem, because they represent a layer of indirection between a data representation and the way it is viewed by clients. You could still change a concrete representation of a type, as long as you update all your extractors with it.</p>
      <p>Representation independence is an important advantage of extractors over case classes. On the other hand, case classes also have some advantages of their own over extractors. First, they are much easier to set up and to define, and they require less code. Second, they usually lead to more efficient pattern matches than extractors,<a id="i-2031931761-1"></a> because the Scala compiler can optimize patterns over case classes much better than patterns over extractors. This is because the mechanisms of case classes are fixed, whereas an <span class="code">unapply</span> or <span class="code">unapplySeq</span> method in an extractor could do almost anything. Third, if your case classes inherit from a <span class="code">sealed</span> base class<a id="i-1485759717-2"></a>, the Scala compiler will check your pattern matches for exhaustiveness and will complain if some combination of possible values is not covered by a pattern. No such exhaustiveness checks are available for extractors.</p>
      <p>So which of the two methods should you prefer for your pattern matches? It depends. If you write code for a closed application, case classes are usually preferable because of their advantages in conciseness, speed and static checking. If you decide to change your class hierarchy later, the application needs to be refactored, but this is usually not a problem. On the other hand, if you need to expose a type to unknown clients, extractors might be preferable because they maintain representation independence.</p>
      <p>Fortunately, you need not decide right away. You could always start with case classes and then, if the need arises, change to extractors. Because patterns over extractors and patterns over case classes look exactly the same in Scala, pattern matches in your clients will continue to work.</p>
      <p>Of course, there are also situations where it's clear from the start that the structure of your patterns does not match the representation type of your data. The email addresses discussed in this chapter were one such example. In that case, extractors are the only possible choice.</p>
      <h3>26.7 Regular expressions</h3>
      <p>One particularly useful application area of extractors are regular expressions.<a id="i1678705239-1"></a> Like Java, Scala provides regular expressions through a library, but extractors make it much nicer to interact with them.</p>
      <h4>Forming regular expressions</h4>
      <p>Scala inherits its regular expression syntax from Java, which in turn inherits most of the features of Perl.<a id="i389811529-2"></a> We assume you know that syntax already; if not, there are many accessible tutorials, starting with the Javadoc documentation of class <span class="code">java.util.regex.Pattern</span>. Here are just some examples that should be enough as refreshers:<br></p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> <span class="code">ab?</span> </td>
            <td> An `<span class="code">a</span>', possibly followed by a `<span class="code">b</span>'. </td>
          </tr>
          <tr>
            <td> [1em] <span class="code">\d+</span> </td>
            <td> A number consisting of one or more digits represented by <span class="code">\d</span>. </td>
          </tr>
        </tbody>
      </table>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> <span class="code">[a-dA-D]\w*</span> </td>
            <td> A word starting with a letter between <span class="code">a</span> and <span class="code">d</span> in lower or upper case, followed by a sequence of zero or more "word characters" denoted by <span class="code">\w</span>. (A word character is a letter, digit, or underscore.) </td>
          </tr>
          <tr>
            <td> [1em] <span class="code">(-)?(\d+)(\.\d*)?</span> </td>
            <td> A number consisting of an optional minus sign, followed by one or more digits, optionally followed by a period and zero or more digits. The number contains three <span style="font-style:italic">groups</span>, <i>i.e.</i>, the minus sign, the part before the decimal point, and the fractional part including the decimal point. Groups are enclosed in parentheses. </td>
          </tr>
        </tbody>
      </table>
      <p>Scala's regular expression class resides in package <span class="code">scala.util.matching</span>.</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.util.matching.Regex
</pre>
      <p>A new regular expression value is created by passing a string to the <span class="code">Regex</span> constructor<a id="i78839847-1"></a>. For instance:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Regex</code>(<code class="quotedstring">"(-)?(\\d+)(\\.\\d*)?"</code>)
  <code class="output">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</code>
</pre>
      <p>Note that, compared to the regular expression for decimal numbers given previously, every backslash appears twice in the string above. This is because in Java and Scala a single backslash is an escape character in a string literal, not a regular character that shows up in the string. So instead of `<span class="code">\</span>' you need to write `<span class="code">\\</span>' to get a single backslash in the string.</p>
      <p>If a regular expression contains many backslashes this might be a bit painful to write and to read. Scala's raw strings provide an alternative.<a id="i-2061400628-1"></a><a id="i-1493588176-2"></a> As you saw in <a href="#sec-literals">Section 5.2</a>, a raw string is a sequence of characters between triple quotes. The difference between a raw and a normal string is that all characters in a raw string appear exactly as they are typed. This includes backslashes, which are not treated as escape characters. So you could write equivalently and somewhat more legibly:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Regex</code>(<code class="quotedstring">"""(-)?(\d+)(\.\d*)?"""</code>)
  <code class="output">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</code>
</pre>
      <p>As you can see from the interpreter's output, the generated result value for <span class="code">Decimal</span> is exactly the same as before.</p>
      <p>Another, even shorter way to write a regular expression in Scala is this:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>&nbsp;=&nbsp;<code class="quotedstring">"""(-)?(\d+)(\.\d*)?"""</code>.r
  <code class="output">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</code>
</pre>
      <p>In other words, simply append a <span class="code">.r</span> to a string to obtain a regular expression.<a id="i-208750214-1"></a><a id="i1128222747-1"></a> This is possible because there is a method named <span class="code">r</span> in class <span class="code">StringOps</span>, which converts a string to a regular expression. The method is defined as shown in <a href="#lst-the-r-method">Listing 26.7</a>: <a id="lst-the-r-method"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;scala.runtime
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.util.matching.Regex
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">StringOps</code>(self:&nbsp;<code class="typename">String</code>)&nbsp;...&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;r&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Regex</code>(self)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 26.7 - How the <span class="code">r</span> method is defined in <span class="code">StringOps</span>.</h5>
      <h4>Searching for regular expressions</h4>
      <p>You can search for occurrences of a regular expression in a string using several different operators<a id="i945174444-1"></a><a id="i1535162589-1"></a><a id="i1068388242-1"></a>:</p>
      <p><span class="code">regex</span>&nbsp;<span class="code">findFirstIn</span>&nbsp;<span class="code">str</span></p>
      <p><br> Finds first occurrence of regular expression <span class="code">regex</span> in string <span class="code">str</span>, returning the result in an <span class="code">Option</span> type.</p>
      <p><span class="code">regex</span>&nbsp;<span class="code">findAllIn</span>&nbsp;<span class="code">str</span></p>
      <p><br> Finds all occurrences of regular expression <span class="code">regex</span> in string <span class="code">str</span>, returning the results in an <span class="code">Iterator</span>.</p>
      <p><span class="code">regex</span>&nbsp;<span class="code">findPrefixOf</span>&nbsp;<span class="code">str</span></p>
      <p><br> Finds an occurrence of regular expression <span class="code">regex</span> at the start of string <span class="code">str</span>, returning the result in an <span class="code">Option</span> type.</p>
      <p><br> For instance, you could define the input sequence below and then search decimal numbers in it:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>&nbsp;=&nbsp;<code class="quotedstring">"""(-)?(\d+)(\.\d*)?"""</code>.r
  <code class="output">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;input&nbsp;=&nbsp;<code class="quotedstring">"for&nbsp;-1.0&nbsp;to&nbsp;99&nbsp;by&nbsp;3"</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <code class="output">input:&nbsp;String&nbsp;=&nbsp;for&nbsp;-1.0&nbsp;to&nbsp;99&nbsp;by&nbsp;3</code>
  <br>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(s&nbsp;&lt;-&nbsp;<code class="typename">Decimal</code>&nbsp;findAllIn&nbsp;input)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(s)
  <code class="output">-1.0</code>
  <code class="output">99</code>
  <code class="output">3</code>
  <br>  scala&gt;&nbsp;<code class="typename">Decimal</code>&nbsp;findFirstIn&nbsp;input
  <code class="output">res7:&nbsp;Option[String]&nbsp;=&nbsp;Some(-1.0)</code>
  <br>  scala&gt;&nbsp;<code class="typename">Decimal</code>&nbsp;findPrefixOf&nbsp;input
  <code class="output">res8:&nbsp;Option[String]&nbsp;=&nbsp;None</code>
</pre>
      <h4>Extracting with regular expressions</h4>
      <p>What's more, every regular expression in Scala defines an extractor. The extractor is used to identify substrings that are matched by the groups of the regular expression. For instance, you could decompose a decimal number string as follows:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>(sign,&nbsp;integerpart,&nbsp;decimalpart)&nbsp;=&nbsp;<code class="quotedstring">"-1.23"</code>&nbsp;&nbsp;
  <code class="output">sign:&nbsp;String&nbsp;=&nbsp;-</code>
  <code class="output">integerpart:&nbsp;String&nbsp;=&nbsp;1</code>
  <code class="output">decimalpart:&nbsp;String&nbsp;=&nbsp;.23</code>
</pre>
      <p>In this example, the pattern, <span class="code">Decimal(...)</span>, is used in a <span class="code">val</span> definition, as described in <a href="#sec-patterns-everywhere">Section 15.7</a>. What happens here is that the <span class="code">Decimal</span> regular expression value defines an <span class="code">unapplySeq</span> method. That method matches every string that corresponds to the regular expression syntax for decimal numbers. If the string matches, the parts that correspond to the three groups in the regular expression <span class="code">(-)?(\d+)(\.\d*)?</span> are returned as elements of the pattern and are then matched by the three pattern variables <span class="code">sign</span>, <span class="code">integerpart</span>, and <span class="code">decimalpart</span>. If a group is missing, the element value is set to <span class="code">null</span>, as can be seen in the following example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Decimal</code>(sign,&nbsp;integerpart,&nbsp;decimalpart)&nbsp;=&nbsp;<code class="quotedstring">"1.0"</code>
  <code class="output">sign:&nbsp;String&nbsp;=&nbsp;null</code>
  <code class="output">integerpart:&nbsp;String&nbsp;=&nbsp;1</code>
  <code class="output">decimalpart:&nbsp;String&nbsp;=&nbsp;.0</code>
</pre>
      <p>It's also possible to mix extractors with regular expression searches in a <span class="code">for</span> expression<a id="i1523429976-1"></a>. For instance, the following expression decomposes all decimal numbers it finds in the <span class="code">input</span> string:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(<code class="typename">Decimal</code>(s,&nbsp;i,&nbsp;d)&nbsp;&lt;-&nbsp;<code class="typename">Decimal</code>&nbsp;findAllIn&nbsp;input)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"sign:&nbsp;"</code>&nbsp;+&nbsp;s&nbsp;+&nbsp;<code class="quotedstring">",&nbsp;integer:&nbsp;"</code>&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+&nbsp;<code class="quotedstring">",&nbsp;decimal:&nbsp;"</code>&nbsp;+&nbsp;d)
  <code class="output">sign:&nbsp;-,&nbsp;integer:&nbsp;1,&nbsp;decimal:&nbsp;.0</code>
  <code class="output">sign:&nbsp;null,&nbsp;integer:&nbsp;99,&nbsp;decimal:&nbsp;null</code>
  <code class="output">sign:&nbsp;null,&nbsp;integer:&nbsp;3,&nbsp;decimal:&nbsp;null</code>
</pre>
      <h3>26.8 Conclusion</h3>
      <p>In this chapter you saw how to generalize pattern matching with extractors. Extractors let you define your own kinds of patterns, which need not correspond to the type of the expressions you select on. This gives you more flexibility in the kinds of patterns you can use for matching. In effect it's like having different possible views on the same data. It also gives you a layer between a type's representation and the way clients view it. This lets you do pattern matching while maintaining representation independence, a property which is very useful in large software systems.</p>
      <p>Extractors are one more element in your tool box that let you define flexible library abstractions. They are used heavily in Scala's libraries, for instance, to enable convenient regular expression matching.</p>
      <hr>
      <h4>Footnotes for Chapter 26:</h4>
      <p><a id="footnotemain26-1"></a>[1] As demonstrated here, where <span class="code">Some</span> is applied to the tuple, <span class="code">(user,</span>&nbsp;<span class="code">domain)</span>, you can leave off one pair of parentheses when passing a tuple to a function that takes a single argument. Thus, <span class="code">Some(user,</span>&nbsp;<span class="code">domain)</span> means the same as <span class="code">Some((user,</span>&nbsp;<span class="code">domain))</span>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-annotations">Chapter 27</a></h2>
      <h1>Annotations</h1>
      <p>Annotations are structured information added to program source code. Like comments, they can be sprinkled throughout a program and attached to any variable, method, expression, or other program element. Unlike comments, they have structure, thus making them easier to machine process.</p>
      <p>This chapter shows how to use annotations in Scala. It shows their general syntax and how to use several standard annotations.</p>
      <p>This chapter does not show how to write new annotation processing tools, because it is beyond the scope of this book. <a href="#chap-combining-scala-and-java">Chapter 31</a> shows one technique, but not the only one. Instead, this chapter focuses on how to use annotations, because it is more common to use annotations than to define new annotation processors.</p>
      <h3>27.1 Why have annotations?</h3>
      <p>There are many things you can do with a program other than compiling and running it. Some examples are:</p>
      <ol>
        <li>Automatic generation of documentation as with Scaladoc<a id="i-827321774-1"></a>. </li>
        <li>Pretty printing code so that it matches your preferred style. </li>
        <li>Checking code for common errors such as opening a file but, on some control paths, never closing it. </li>
        <li>Experimental type checking, for example to manage side effects or ensure ownership properties. </li>
      </ol>
      <p>Such tools are called <a href="#g-850220783"><em>meta-programming</em></a> tools, because they are programs that take other programs as input.<a id="i-850220783-1"></a><a id="i544128342-1"></a> Annotations support these tools by letting the programmer sprinkle directives to the tool throughout their source code. Such directives let the tools be more effective than if they could have no user input. For example, annotations can improve the previously listed tools as follows:</p>
      <ol>
        <li>A documentation generator could be instructed to document certain methods as deprecated. </li>
        <li>A pretty printer could be instructed to skip over parts of the program that have been carefully hand formatted. </li>
        <li>A checker for non-closed files could be instructed to ignore a particular file that has been manually verified to be closed. </li>
        <li>A side-effects checker could be instructed to verify that a specified method has no side effects. </li>
      </ol>
      <p>In all of these cases, it would in theory be possible for the programming language to provide ways to insert the extra information. In fact, most of these are directly supported in some language or another. However, there are too many such tools for one language to directly support them all. Further, all of this information is completely ignored by the compiler, which after all just wants to make the code run.</p>
      <p>Scala's philosophy in cases like this is to include the minimum, orthogonal support in the core language such that a wide variety of meta-programming tools can be written. In this case, that minimum support is a system of annotations. The compiler understands just one feature, annotations, but it doesn't attach any meaning to individual annotations. Each meta-programming tool can then define and use its own specific annotations.</p>
      <h3>27.2 Syntax of annotations</h3>
      <p>A typical use of an annotation looks like this:<a id="i526469630-1"></a></p> <pre>  @deprecated&nbsp;<code class="vem">def</code>&nbsp;bigMistake()&nbsp;=&nbsp;<code class="comment">//...</code>
</pre>
      <p>The annotation<a id="i-1632344653-1"></a><a id="i86494153-1"></a> is the <span class="code">@deprecated</span> part, and it applies to the entirety of the <span class="code">bigMistake</span> method (not shown—it's too embarrassing). In this case, the method is being marked as something the author of <span class="code">bigMistake</span> wishes you not to use. Maybe <span class="code">bigMistake</span> will be removed entirely from a future version of the code.</p>
      <p>In the previous example, a method is annotated as <span class="code">@deprecated</span>. Annotations are allowed in other places too. Annotations are allowed on any kind of declaration or definition, including <span class="code">val</span>s, <span class="code">var</span>s, <span class="code">def</span>s, <span class="code">class</span>es, <span class="code">object</span>s, <span class="code">trait</span>s, and <span class="code">type</span>s.<a id="i1935725073-1"></a><a id="i175307031-1"></a><a id="i1767118133-1"></a><a id="i1177206493-1"></a><a id="i911241519-1"></a><a id="i-1756036738-1"></a> The annotation applies to the entirety of the declaration or definition that follows it:</p> <pre>  @deprecated&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">QuickAndDirty</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//...</code>
  }
</pre>
      <p>Annotations can also be applied to an expression<a id="i726662607-1"></a>, as with the <span class="code">@unchecked</span> annotation<a id="i-2035290207-3"></a><a id="i-815574504-3"></a> for pattern matching (see <a href="#chap-case-classes-and-pattern-matching">Chapter 15</a>). To do so, place a colon (<span class="code">:</span>) after the expression and then write the annotation. Syntactically, it looks like the annotation is being used as a type:</p> <pre>  (e:&nbsp;@unchecked)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;non-exhaustive&nbsp;cases...</code>
  }
</pre>
      <p>Finally, annotations can be placed on types. Annotated types are described later in this chapter.</p>
      <p>So far the annotations shown have been simply an at sign followed by an annotation class. Such simple annotations are common and useful, but annotations have a richer general form:<a id="i2008427102-1"></a></p>
      <div style="text-align: center">
        <p><span class="code">@</span><em>annot</em>(<em>exp</em><sub>1</sub>, <em>exp</em><sub>2</sub>, ...)</p>
      </div>
      <p>The <em>annot</em> specifies the class of annotation. All annotations must include that much. The <em>exp</em><a id="i-1204896229-1"></a> parts are arguments to the annotation. For annotations like <span class="code">@deprecated</span> that do not need any arguments, you would normally leave off the parentheses, but you can write <span class="code">@deprecated()</span> if you like. For annotations that do have arguments, place the arguments in parentheses, for example, <span class="code">@serial(1234)</span>.</p>
      <p>The precise form of the arguments you may give to an annotation depends on the particular annotation class. Most annotation processors only let you supply immediate constants such as <span class="code">123</span> or <span class="code">"hello"</span>. The compiler itself supports arbitrary expressions, however, so long as they type check. Some annotation classes can make use of this, for example, to let you refer to other variables that are in scope:</p> <pre>  @cool&nbsp;<code class="vem">val</code>&nbsp;normal&nbsp;=&nbsp;<code class="quotedstring">"Hello"</code>
  @coolerThan(normal)&nbsp;<code class="vem">val</code>&nbsp;fonzy&nbsp;=&nbsp;<code class="quotedstring">"Heeyyy"</code>
</pre>
      <p>Internally, Scala represents an annotation as just a constructor call of an annotation class—replace the `<span class="code">@</span>' by `<span class="code">new</span>' and you have a valid instance creation expression. This means that named and default annotation arguments are supported naturally, because Scala already has named and default arguments for method and constructor<a id="i463927682-1"></a> calls. One slightly tricky bit concerns annotations that conceptually take other annotations as arguments, which are required by some frameworks.<a id="i1452294669-1"></a><a id="i1513606523-1"></a> You cannot write an annotation directly as an argument to an annotation, because annotations are not valid expressions. In such cases you must use `<span class="code">new</span>' instead of `<span class="code">@</span>', as illustrated here:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;annotation._
  <code class="output">import&nbsp;annotation._</code>
  <br>  scala&gt;&nbsp;<code class="vem">class</code>&nbsp;strategy(arg:&nbsp;<code class="typename">Annotation</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Annotation</code>
  <code class="output">defined&nbsp;class&nbsp;strategy</code>
  <br>  scala&gt;&nbsp;<code class="vem">class</code>&nbsp;delayed&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Annotation</code>
  <code class="output">defined&nbsp;class&nbsp;delayed</code>
  <br>  scala&gt;&nbsp;@strategy(@delayed)&nbsp;<code class="vem">def</code>&nbsp;f()&nbsp;=&nbsp;{}&nbsp;
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;illegal&nbsp;start&nbsp;of&nbsp;simple&nbsp;expression</code>
  <code class="output"></code>
  scala&gt;&nbsp;@strategy(<code class="vem">new</code>&nbsp;delayed)&nbsp;<code class="vem">def</code>&nbsp;f()&nbsp;=&nbsp;{}
  <code class="output">f:&nbsp;()Unit</code>
</pre>
      <h3>27.3 Standard annotations</h3>
      <p>Scala includes several standard annotations.<a id="i-178318765-1"></a> They are for features that are used widely enough to merit putting in the language specification, but that are not fundamental enough to merit their own syntax. Over time, there should be a trickle of new annotations that are added to the standard in just the same way.</p>
      <h4>Deprecation</h4>
      <p>Sometimes you write a class or method that you later wish you had not.<a id="i86494153-2"></a> Once it is available, though, code written by other people might call the method. Thus, you cannot simply delete the method, because this would cause other people's code to stop compiling.</p>
      <p>Deprecation lets you gracefully remove a method or class that turns out to be a mistake. You mark the method or class as deprecated, and then anyone who calls that method or class will get a deprecation warning. They had better heed this warning and update their code! The idea is that after a suitable amount of time has passed, you feel safe in assuming that all reasonable clients will have stopped accessing the deprecated class or method and thus that you can safely remove it.</p>
      <p>You mark a method as deprecated simply by writing <span class="code">@deprecated</span> before it. For example:</p> <pre>  @deprecated&nbsp;<code class="vem">def</code>&nbsp;bigMistake()&nbsp;=&nbsp;&nbsp;<code class="comment">//...</code>
</pre>
      <p>Such an annotation will cause the Scala compiler to emit deprecation warnings whenever Scala code accesses the method.</p>
      <p>If you supply a string as an argument to <span class="code">@deprecated</span>, that string will be emitted along with the error message. Use this message to explain to developers what they should use instead of the deprecated method.</p> <pre>  @deprecated(<code class="quotedstring">"use&nbsp;newShinyMethod()&nbsp;instead"</code>)
  <code class="vem">def</code>&nbsp;bigMistake()&nbsp;=&nbsp;&nbsp;<code class="comment">//...</code>
</pre>
      <p>Now any callers will get a message like this:</p> <pre>  $&nbsp;scalac&nbsp;-deprecation&nbsp;Deprecation2.scala&nbsp;
  <code class="output">Deprecation2.scala:33:&nbsp;warning:&nbsp;method&nbsp;bigMistake&nbsp;in&nbsp;object</code>
  <code class="output">Deprecation2&nbsp;is&nbsp;deprecated:&nbsp;use&nbsp;newShinyMethod()&nbsp;instead</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;bigMistake()</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">one&nbsp;warning&nbsp;found</code>
</pre>
      <h4>Volatile fields</h4>
      <p>Concurrent programming does not mix well with shared mutable state. For this reason, the focus of Scala's concurrency support is <span class="code">Future</span>s and a minimum of shared mutable state. See <a href="#chap-futures-and-concurrency">Chapter 32</a> for the details.</p>
      <p>Nonetheless, sometimes programmers want to use mutable state in their concurrent programs. The <span class="code">@volatile</span> annotation<a id="i-882906061-1"></a><a id="i915992882-1"></a> helps in such cases. It informs the compiler that the variable in question will be used by multiple threads. Such variables are implemented so that reads and writes to the variable are slower, but accesses from multiple threads behave more predictably.</p>
      <p>The <span class="code">@volatile</span> keyword gives different guarantees on different platforms. On the Java platform, however, you get the same behavior as if you wrote the field in Java code and marked it with the Java <span class="code">volatile</span> modifier.</p>
      <h4>Binary serialization</h4>
      <p>Many languages include a framework for binary <a href="#g922807280"><em>serialization</em></a>.<a id="i-1448460597-1"></a><a id="i2082703927-1"></a> A serialization framework helps you convert objects into a stream of bytes and <i>vice versa</i>. This is useful if you want to save objects to disk or send them over the network. XML can help with the same goals (see <a href="#chap-working-with-xml">Chapter 28</a>), but it has different trade offs regarding speed, space usage, flexibility, and portability.</p>
      <p>Scala does not have its own serialization framework. Instead, you should use a framework from your underlying platform. What Scala does is provide two annotations that are useful for a variety of frameworks. Also, the Scala compiler for the Java platform interprets these annotations in the Java way (see <a href="#chap-combining-scala-and-java">Chapter 31</a>).</p>
      <p>First, most classes are serializable, but not all. A handle to a socket or GUI window, for example, cannot be serialized. By default, a class is not considered serializable. To make it serializable, you must mix in the <span class="code">scala.Serializable</span> marker trait, which on the JVM is an alias of <span class="code">java.io.Serializable</span>.</p>
      <p>The <span class="code">SerialVersionUID</span> annotation helps deal with serializable classes changing as time goes by. You can attach a serial number to the current version of a class by adding an annotation like<a id="i-744810718-1"></a><a id="i-1236272573-1"></a> <span class="code">@SerialVersionUID(1234)</span>, where <span class="code">1234</span> should be replaced by your serial number of choice. The framework should store this number in the generated byte stream. When you later reload that byte stream and try to convert it to an object, the framework can check that the current version of the class has the same version number as the version in the byte stream. If you want to make a serialization-incompatible change to your class, then you can change the version number. The framework will then automatically refuse to load old instances of the class.</p>
      <p>Scala also provides a <span class="code">@transient</span> annotation<a id="i875595397-1"></a><a id="i2078024116-1"></a> for fields that should not be serialized at all. If you mark a field as <span class="code">@transient</span>, then the framework should not save the field even when the surrounding object is serialized. When the object is loaded, the field will be restored to the default value for the type of the field annotated as <span class="code">@transient</span>.</p>
      <h4>Automatic <span class="code">get</span> and <span class="code">set</span> methods</h4>
      <p>Scala code normally does not need explicit <span class="code">get</span> and <span class="code">set</span> methods for fields, because Scala blends the syntax for field access and method invocation. Some platform-specific frameworks do expect <span class="code">get</span> and <span class="code">set</span> methods, however. For that purpose, Scala provides the <span class="code">@scala.reflect.BeanProperty</span> annotation.<a id="i732073940-1"></a><a id="i1595748955-1"></a><a id="i-1969580643-4"></a><a id="i553650449-3"></a> If you add this annotation to a field, the compiler will automatically generate <span class="code">get</span> and <span class="code">set</span> methods for you. If you annotate a field named <span class="code">crazy</span>, the <span class="code">get</span> method will be named <span class="code">getCrazy</span> and the <span class="code">set</span> method will be named <span class="code">setCrazy</span>.</p>
      <p>The generated <span class="code">get</span> and <span class="code">set</span> methods are only available after a compilation pass completes. Thus, you cannot call these <span class="code">get</span> and <span class="code">set</span> methods from code you compile at the same time as the annotated fields. This should not be a problem in practice, because in Scala code you can access the fields directly. This feature is intended to support frameworks that expect regular <span class="code">get</span> and <span class="code">set</span> methods, and typically you do not compile the framework and the code that uses it at the same time.</p>
      <h4>Tailrec</h4>
      <p>You would typically add the <span class="code">@tailrec</span> annotation to a method that<a id="i726527906-1"></a><a id="i-135595761-1"></a><a id="i-1317428246-1"></a> needs to be tail recursive, for instance because you expect that it would recurse very deeply otherwise. To make sure that the Scala compiler does perform the tail-recursion optimization described in <a href="#sec-tail-recursion">Section 8.9</a> on this method, you can add <span class="code"> @tailrec</span> in front of the method definition. If the optimization cannot be performed, you will then get a warning together with an explanation of the reasons.</p>
      <h4>Unchecked</h4>
      <p>The <span class="code">@unchecked</span> annotation is interpreted by the compiler during<a id="i-2035290207-4"></a><a id="i-815574504-4"></a> pattern matches. It tells the compiler not to worry if the <span class="code">match</span> expression seems to leave out some cases. See <a href="#sec-sealed-classes">Section 15.5</a> for details.</p>
      <h4>Native methods</h4>
      <p>The <span class="code">@native</span> annotation informs the compiler that a method's<a id="i-1241002280-1"></a><a id="i2091795679-1"></a><a id="i1448620333-1"></a> implementation is supplied by the runtime rather than in Scala code. The compiler will toggle the appropriate flags in the output, and it will be up to the developer to supply the implementation using a mechanism such as the Java Native Interface (JNI).<a id="i555287182-1"></a><a id="i73605-1"></a></p>
      <p>When using the <span class="code">@native</span> annotation, a method body must be supplied, but it will not be emitted into the output. For example, here is how to declare that method <span class="code">beginCountdown</span> will be supplied by the runtime:</p> <pre>  @native
  <code class="vem">def</code>&nbsp;beginCountdown()&nbsp;=&nbsp;{}
</pre>
      <h3>27.4 Conclusion</h3>
      <p>This chapter described the platform-independent aspects of annotations that you will most commonly need to know about. First of all it covered the syntax of annotations, because using annotations is far more common than defining new ones. Second it showed how to use several annotations that are supported by the standard Scala compiler, including <span class="code">@deprecated</span>, <span class="code">@volatile</span>, <span class="code">@serializable</span>, <span class="code">@BeanProperty</span>, <span class="code">@tailrec</span>, and <span class="code">@unchecked</span>.</p>
      <p><a href="#chap-combining-scala-and-java">Chapter 31</a> gives additional, Java-specific information on annotations. It covers annotations only available when targeting Java, additional meanings of standard annotations when targeting Java, how to interoperate with Java-based annotations, and how to use Java-based mechanisms to define and process annotations in Scala.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-working-with-xml">Chapter 28</a></h2>
      <h1>Working with XML</h1>
      <p>This chapter introduces Scala's support for XML.<a id="i87031-1"></a> After discussing semi-structured data<a id="i-408699718-1"></a><a id="i-158920554-1"></a> in general, it shows the essential functionality in Scala for manipulating XML: how to make nodes with XML literals, how to save and load XML to files, and how to take apart XML nodes using query methods and pattern matching. This chapter is just a brief introduction to what is possible with XML, but it shows enough to get you started.</p>
      <h3>28.1 Semi-structured data</h3>
      <p>XML is a form of <a href="#g-408699718"><em>semi-structured data</em></a>. It is more structured than plain strings, because it organizes the contents of the data into a tree. Plain XML is less structured than the objects of a programming language, though, as it admits free-form text between tags and it lacks a type system.<a href="#footnotemain28-1">[1]</a></p>
      <p>Semi-structured data is very helpful any time you need to serialize program data for saving in a file or shipping across a network. Instead of converting structured data all the way down to bytes, you convert it to and from semi-structured data. You then use pre-existing library routines to convert between semi-structured data and binary data, saving your time for more important problems.</p>
      <p>There are many forms of semi-structured data, but XML is the most widely used on the Internet. There are XML tools on most operating systems, and most programming languages have XML libraries available. Its popularity is self-reinforcing. The more tools and libraries are developed in response to XML's popularity, the more likely software engineers are to choose XML as part of their formats. If you write software that communicates over the Internet, then sooner or later you will need to interact with some service that speaks XML.</p>
      <p>For all of these reasons, Scala includes special support for processing XML. This chapter shows you Scala's support for constructing XML, processing it with regular methods, and processing it with Scala's pattern matching. In addition to these nuts and bolts, the chapter shows along the way several common idioms for using XML in Scala.</p>
      <h3>28.2 XML overview</h3>
      <p>XML is built out of two basic elements,<a id="i-84923540-1"></a><a id="i-1968563942-1"></a> text<a id="i599729872-1"></a><a id="i-891684874-1"></a> and tags.<a id="i599725500-1"></a><a id="i-1699783286-1"></a><a href="#footnotemain28-2">[2]</a> Text is, as usual, any sequence of characters. Tags, written like <span class="code">&lt;pod&gt;</span>, consist of a less-than sign, an alphanumeric label, and a greater than sign. Tags can be <em>start</em> or <em>end</em> tags. An end tag looks just like a start tag except that it has a slash just before the tag's label, like this: <span class="code">&lt;/pod&gt;</span>.</p>
      <p>Start and end tags must match each other, just like parentheses. Any start tag must eventually be followed by an end tag with the same label. Thus the following is illegal:</p> <pre>  //&nbsp;Illegal&nbsp;XML
  One&nbsp;&lt;pod&gt;,&nbsp;two&nbsp;&lt;pod&gt;,&nbsp;three&nbsp;&lt;pod&gt;&nbsp;zoo
</pre>
      <p>Further, the contents of any two matching tags must itself be valid XML. You cannot have two pairs of matching tags overlap each other:</p> <pre>  //&nbsp;Also&nbsp;illegal
  &lt;pod&gt;Three&nbsp;&lt;peas&gt;&nbsp;in&nbsp;the&nbsp;&lt;/pod&gt;&lt;/peas&gt;
</pre>
      <p>You could, however, write it like this:</p> <pre>  &lt;pod&gt;Three&nbsp;&lt;peas&gt;&lt;/peas&gt;&nbsp;in&nbsp;the&nbsp;&lt;/pod&gt;
</pre>
      <p>Since tags are required to match in this way, XML is structured as nested <em>elements</em>. Each pair of matching start and end tags forms an element, and elements may be nested within each other. In the above example, the entirety of <span class="code">&lt;pod&gt;Three</span>&nbsp;<span class="code">&lt;peas&gt;&lt;/peas&gt;</span>&nbsp;<span class="code">in</span>&nbsp;<span class="code">the</span>&nbsp;<span class="code">&lt;/pod&gt;</span> is an element, and <span class="code">&lt;peas&gt;&lt;/peas&gt;</span> is an element nested within it.</p>
      <p>Those are the basics. Two other things you should know are, first, there is a shorthand notation for a start tag followed immediately by its matching end tag. Simply write one tag with a slash put after the tag's label. Such a tag comprises an <em>empty element</em>. Using an empty element, the previous example could just as well be written as follows:</p> <pre>  &lt;pod&gt;Three&nbsp;&lt;peas/&gt;&nbsp;in&nbsp;the&nbsp;&lt;/pod&gt;
</pre>
      <p>Second, start tags can have <em>attributes</em> attached to them. An attribute is a name-value pair written with an equals sign in the middle.<a id="i-1944660140-1"></a><a id="i2120320186-1"></a> The attribute name itself is plain, unstructured text, and the value is surrounded by either double quotes (<span class="code">""</span>) or single quotes (<span class="code">"</span>). Attributes look like this:</p> <pre>  &lt;pod&nbsp;peas="3"&nbsp;strings="true"/&gt;
</pre>
      <h3>28.3 XML literals</h3>
      <p>Scala lets you type in XML as a <a href="#g182460591">literal</a> anywhere that an expression is valid.<a id="i-598913593-1"></a><a id="i-1924909791-1"></a> Simply type a start tag and then continue writing XML content. The compiler will go into an XML-input mode and will read content as XML until it sees the end tag matching the start tag you began with:</p> <pre>  scala&gt;&nbsp;&lt;a&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;is&nbsp;some&nbsp;XML.
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here&nbsp;is&nbsp;a&nbsp;tag:&nbsp;&lt;atag/&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;
  <code class="output">res0:&nbsp;scala.xml.Elem&nbsp;=</code>
  <code class="output">&lt;a&gt;</code>
  <code class="output">&nbsp;&nbsp;This&nbsp;is&nbsp;some&nbsp;XML.</code>
  <code class="output">&nbsp;&nbsp;Here&nbsp;is&nbsp;a&nbsp;tag:&nbsp;&lt;atag/&gt;</code>
  <code class="output">&lt;/a&gt;</code>
</pre>
      <p>The result of this expression is of type <span class="code">Elem</span>, meaning it is an XML element with a label ("<span class="code">a</span>") and children ("<span class="code">This</span>&nbsp;<span class="code">is</span>&nbsp;<span class="code">some</span>&nbsp;<span class="code">XML</span>...," <i>etc.</i>).<a id="i583597511-1"></a> Some other important XML classes are:</p>
      <ul>
        <li>Class <span class="code">Node</span> is the abstract superclass of all XML node classes.<a id="i1729641978-1"></a> </li>
        <li>Class <span class="code">Text</span> is a node holding just text. For example, the "stuff" part of <span class="code">&lt;a&gt;stuff&lt;/a&gt;</span> is of class <span class="code">Text</span>.<a id="i1739516731-1"></a> </li>
        <li>Class <span class="code">NodeSeq</span> holds a sequence of nodes. Many methods in the XML library process <span class="code">NodeSeq</span>s in places you might expect them to process individual <span class="code">Node</span>s. You can still use such methods with individual nodes, however, since <span class="code">Node</span> extends from <span class="code">NodeSeq</span>. This may sound weird, but it works out well for XML. You can think of an individual <span class="code">Node</span> as a one-element <span class="code">NodeSeq</span>.<a id="i808041077-1"></a> </li>
      </ul>
      <p>You are not restricted to writing out the exact XML you want, character for character. You can evaluate Scala code in the middle of an XML literal by using curly braces (<span class="code">{}</span>) as an escape.<a id="i1212676591-1"></a><a id="i544063905-1"></a> Here is a simple example:</p> <pre>  scala&gt;&nbsp;&lt;a&gt;&nbsp;{<code class="quotedstring">"hello"</code>&nbsp;+&nbsp;<code class="quotedstring">",&nbsp;world"</code>}&nbsp;&lt;/a&gt;
  <code class="output">res1:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;a&gt;&nbsp;hello,&nbsp;world&nbsp;&lt;/a&gt;</code>
</pre>
      <p>A braces escape can include arbitrary Scala content, including further XML literals. Thus, as the nesting level increases, your code can switch back and forth between XML and ordinary Scala code. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;yearMade&nbsp;=&nbsp;<code class="literal">1955</code>
  <code class="output">yearMade:&nbsp;Int&nbsp;=&nbsp;1955</code>
  <br>  scala&gt;&nbsp;&nbsp;&lt;a&gt;&nbsp;{&nbsp;<code class="vem">if</code>&nbsp;(yearMade&nbsp;&lt;&nbsp;<code class="literal">2000</code>)&nbsp;&lt;old&gt;{yearMade}&lt;/old&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="typename">xml.NodeSeq.Empty</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;
  <code class="output">res2:&nbsp;scala.xml.Elem&nbsp;=</code>
  <code class="output">&lt;a&gt;&nbsp;&lt;old&gt;1955&lt;/old&gt;</code>
  <code class="output">&nbsp;&lt;/a&gt;</code>
</pre>
      <p>If the code inside the curly braces evaluates to either an XML node or a sequence of XML nodes, those nodes are inserted directly as is. In the above example, if <span class="code">yearMade</span> is less than 2000, it is wrapped in <span class="code">&lt;old&gt;</span> tags and added to the <span class="code">&lt;a&gt;</span> element. Otherwise, nothing is added. Note in the above example that "nothing" as an XML node is denoted with <span class="code">xml.NodeSeq.Empty</span>.</p>
      <p>An expression inside a brace escape does not have to evaluate to an XML node. It can evaluate to any Scala value. In such a case, the result is converted to a string and inserted as a text node:</p> <pre>  scala&gt;&nbsp;&lt;a&gt;&nbsp;{<code class="literal">3</code>&nbsp;+&nbsp;<code class="literal">4</code>}&nbsp;&lt;/a&gt;
  <code class="output">res3:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;a&gt;&nbsp;7&nbsp;&lt;/a&gt;</code>
</pre>
      <p>Any <span class="code">&lt;</span>, <span class="code">&gt;</span>, and <span class="code">&amp;</span> characters in the text will be escaped if you print the node back out:</p> <pre>  scala&gt;&nbsp;&lt;a&gt;&nbsp;{<code class="quotedstring">"&lt;/a&gt;potential&nbsp;security&nbsp;hole&lt;a&gt;"</code>}&nbsp;&lt;/a&gt;
  <code class="output">res4:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;a&gt;&nbsp;&amp;lt;/a&amp;gt;potential&nbsp;security&nbsp;</code>
  <code class="output">hole&amp;lt;a&amp;gt;&nbsp;&lt;/a&gt;</code>
</pre>
      <p>To contrast, if you create XML with low-level string operations, you will run into traps such as the following:</p> <pre>  scala&gt;&nbsp;<code class="quotedstring">"&lt;a&gt;"</code>&nbsp;+&nbsp;<code class="quotedstring">"&lt;/a&gt;potential&nbsp;security&nbsp;hole&lt;a&gt;"</code>&nbsp;+&nbsp;<code class="quotedstring">"&lt;/a&gt;"</code>
  <code class="output">res5:&nbsp;String&nbsp;=&nbsp;&lt;a&gt;&lt;/a&gt;potential&nbsp;security&nbsp;hole&lt;a&gt;&lt;/a&gt;</code>
</pre>
      <p>What happens here is that a user-supplied string has included XML tags of its own, in this case <span class="code">&lt;/a&gt;</span> and <span class="code">&lt;a&gt;</span>. This behavior can allow some nasty surprises for the original programmer, because it allows the user to affect the resulting XML tree outside of the space provided for the user inside the <span class="code">&lt;a&gt;</span> element. You can prevent this entire class of problems by always constructing XML using XML literals, not string appends.</p>
      <h3>28.4 Serialization</h3>
      <p>You have now seen enough of Scala's XML support to write the first part of a serializer: conversion from internal data structures to XML.<a id="i-426160987-1"></a><a id="i-1549258323-1"></a> All you need for this are XML literals and their brace escapes.</p>
      <p>As an example, suppose you are implementing a database to keep track of your extensive collection of vintage Coca-Cola thermometers. You might make the following internal class to hold entries in the catalog:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">CCTherm</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;description:&nbsp;<code class="typename">String</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;yearMade:&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;dateObtained:&nbsp;<code class="typename">String</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;bookPrice:&nbsp;<code class="typename">Int</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;in&nbsp;US&nbsp;cents</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;purchasePrice:&nbsp;<code class="typename">Int</code>&nbsp;&nbsp;<code class="comment">//&nbsp;in&nbsp;US&nbsp;cents</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;condition:&nbsp;<code class="typename">Int</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;1&nbsp;to&nbsp;10</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;description
  }
</pre>
      <p>This is a straightforward, data-heavy class that holds various pieces of information such as when the thermometer was made, when you got it, and how much you paid for it.</p>
      <p>To convert instances of this class to XML, simply add a <span class="code">toXML</span> method that uses XML literals and brace escapes, like this:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">CCTherm</code>&nbsp;{
  &nbsp;&nbsp;...
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;toXML&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;{description}&lt;/description&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;{yearMade}&lt;/yearMade&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;{dateObtained}&lt;/dateObtained&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;{bookPrice}&lt;/bookPrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;{purchasePrice}&lt;/purchasePrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;{condition}&lt;/condition&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;
  }
</pre>
      <p>Here is the method in action:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;therm&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">CCTherm</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;description&nbsp;=&nbsp;<code class="quotedstring">"hot&nbsp;dog&nbsp;#5"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;yearMade&nbsp;=&nbsp;<code class="literal">1952</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;dateObtained&nbsp;=&nbsp;<code class="quotedstring">"March&nbsp;14,&nbsp;2006"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;bookPrice&nbsp;=&nbsp;<code class="literal">2199</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;purchasePrice&nbsp;=&nbsp;<code class="literal">500</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;condition&nbsp;=&nbsp;<code class="literal">9</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">therm:&nbsp;CCTherm&nbsp;=&nbsp;hot&nbsp;dog&nbsp;#5</code>
  <br>  scala&gt;&nbsp;therm.toXML
  <code class="output">res6:&nbsp;scala.xml.Elem&nbsp;=</code>
  <code class="output">&lt;cctherm&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;</code>
</pre>
      <div class="note">
        <h4>Note</h4> The "<span class="code">new</span>&nbsp;<span class="code">CCTherm</span>" expression in the previous example works even though <span class="code">CCTherm</span> is an abstract class, because this syntax actually instantiates an anonymous subclass of <span class="code">CCTherm</span>. Anonymous classes were described in <a href="#sec-val-init">Section 20.5</a>.
      </div>
      <p>By the way, if you want to include a curly brace (`<span class="code">{</span>' or `<span class="code">}</span>') as XML text, as opposed to using them to escape to Scala code, simply write two curly braces in a row:</p> <pre>  scala&gt;&nbsp;&lt;a&gt;&nbsp;{{{{brace&nbsp;yourself!}}}}&nbsp;&lt;/a&gt;
  <code class="output">res7:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;a&gt;&nbsp;{{brace&nbsp;yourself!}}&nbsp;&lt;/a&gt;</code>
</pre>
      <h3>28.5 Taking XML apart</h3>
      <p>Among the many methods available for the XML classes, there are three in particular that you should be aware of. They allow you to take apart XML without thinking too much about the precise way XML is represented in Scala. These methods are based on the XPath language for processing XML.<a id="i83750045-1"></a><a id="i1385250650-1"></a> As is common in Scala, you can write them directly in Scala code instead of needing to invoke an external tool.</p>
      <p><b>Extracting text.</b> By calling the <span class="code">text</span> method on any XML node you retrieve all of the text within that node, minus any element tags:<a id="i-620325929-1"></a><a id="i-892340276-1"></a></p> <pre>  scala&gt;&nbsp;&lt;a&gt;Sounds&nbsp;&lt;tag/&gt;&nbsp;good&lt;/a&gt;.text
  <code class="output">res8:&nbsp;String&nbsp;=&nbsp;Sounds&nbsp;&nbsp;good</code>
</pre>
      <p>Any encoded characters are decoded automatically:</p> <pre>  scala&gt;&nbsp;&lt;a&gt;&nbsp;input&nbsp;---&amp;gt;&nbsp;output&nbsp;&lt;/a&gt;.text
  <code class="output">res9:&nbsp;String&nbsp;=&nbsp;"&nbsp;input&nbsp;---&gt;&nbsp;output&nbsp;"</code>
</pre>
      <p><b>Extracting sub-elements.</b> If you want to find a sub-element by tag name, simply call <span class="code">\</span> with the name of the tag:</p> <pre>  scala&gt;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;\&nbsp;<code class="quotedstring">"b"</code>
  <code class="output">res10:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;NodeSeq(&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;)</code>
</pre>
      <p>You can do a "deep search" and look through sub-sub-elements, <i>etc.</i>, by using <span class="code">\\</span> instead of the <span class="code">\</span> operator:<a id="i1322432817-1"></a><a id="i32859236-1"></a><a id="i583597511-2"></a></p> <pre>  scala&gt;&nbsp;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;\&nbsp;<code class="quotedstring">"c"</code>
  <code class="output">res11:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;NodeSeq()</code>
  <br>  scala&gt;&nbsp;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;\\&nbsp;<code class="quotedstring">"c"</code>
  <code class="output">res12:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;NodeSeq(&lt;c&gt;hello&lt;/c&gt;)</code>
  <br>  scala&gt;&nbsp;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;\&nbsp;<code class="quotedstring">"a"</code>
  <code class="output">res13:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;NodeSeq()</code>
  <br>  scala&gt;&nbsp;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;\\&nbsp;<code class="quotedstring">"a"</code>
  <code class="output">res14:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;</code>
  <code class="output">NodeSeq(&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;)</code>
</pre>
      <div class="note">
        <h4>Note</h4>
        <p>Scala uses <span class="code">\</span> and <span class="code">\\</span> instead of XPath's <span class="code">/</span> and <span class="code">//</span>. The reason is that <span class="code">//</span> starts a comment in Scala! Thus, some other symbol has to be used, and using the other kind of slashes works well.</p>
      </div>
      <p><b>Extracting attributes.</b> You can extract tag attributes using the same <span class="code">\</span> and <span class="code">\\</span> methods.<a id="i-1944660140-2"></a><a id="i2120320186-2"></a> Simply put an at sign (<span class="code">@</span>) before the attribute name:<a id="i-1417487143-1"></a><a id="i-2110526308-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;joe&nbsp;=&nbsp;&lt;employee
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name=<code class="quotedstring">"Joe"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rank=<code class="quotedstring">"code&nbsp;monkey"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serial=<code class="quotedstring">"123"</code>/&gt;
  <code class="output">joe:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;employee&nbsp;name="Joe"&nbsp;rank="code&nbsp;monkey"</code>
  <code class="output">&nbsp;serial="123"/&gt;</code>
  <br>  scala&gt;&nbsp;&nbsp;joe&nbsp;\&nbsp;<code class="quotedstring">"@name"</code>
  <code class="output">res15:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;Joe</code>
  <br>  scala&gt;&nbsp;&nbsp;joe&nbsp;\&nbsp;<code class="quotedstring">"@serial"</code>
  <code class="output">res16:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;123</code>
</pre>
      <h3>28.6 Deserialization</h3>
      <p>Using the previous methods for taking XML apart, you can now write the dual of a serializer, a parser from XML back into your internal data structures.<a id="i-1744729332-1"></a><a id="i1294189452-1"></a> For example, you can parse back a <span class="code">CCTherm</span> instance by using the following code:</p> <pre>  <code class="vem">def</code>&nbsp;fromXML(node:&nbsp;<code class="typename">scala.xml.Node</code>):&nbsp;<code class="typename">CCTherm</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">CCTherm</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;description&nbsp;&nbsp;&nbsp;=&nbsp;(node&nbsp;\&nbsp;<code class="quotedstring">"description"</code>).text
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;yearMade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(node&nbsp;\&nbsp;<code class="quotedstring">"yearMade"</code>).text.toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;dateObtained&nbsp;&nbsp;=&nbsp;(node&nbsp;\&nbsp;<code class="quotedstring">"dateObtained"</code>).text
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;bookPrice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(node&nbsp;\&nbsp;<code class="quotedstring">"bookPrice"</code>).text.toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;purchasePrice&nbsp;=&nbsp;(node&nbsp;\&nbsp;<code class="quotedstring">"purchasePrice"</code>).text.toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;condition&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(node&nbsp;\&nbsp;<code class="quotedstring">"condition"</code>).text.toInt
  &nbsp;&nbsp;}
</pre>
      <p>This code searches through an input XML node, named <span class="code">node</span>, to find each of the six pieces of data needed to specify a <span class="code">CCTherm</span>. The data that is text is extracted with <span class="code">.text</span> and left as is. Here is this method in action:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;node&nbsp;=&nbsp;therm.toXML
  <code class="output">node:&nbsp;scala.xml.Elem&nbsp;=</code>
  <code class="output">&lt;cctherm&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;</code>
  <br>  scala&gt;&nbsp;fromXML(node)
  <code class="output">res17:&nbsp;CCTherm&nbsp;=&nbsp;hot&nbsp;dog&nbsp;#5</code>
</pre>
      <h3>28.7 Loading and saving</h3>
      <p>There is one last part needed to write a data serializer: conversion between XML and streams of bytes. This last part is the easiest, because there are library routines that will do it all for you. You simply have to call the right routine on the right data.</p>
      <p>To convert XML to a string, all you need is <span class="code">toString</span>. The presence of a workable <span class="code">toString</span> is why you can experiment with XML in the Scala shell. However, it is better to use a library routine and convert all the way to bytes. That way, the resulting XML can include a directive that specifies which character encoding was used. If you encode the string to bytes yourself, then the onus is on you to keep track of the character encoding.<a id="i1598423906-1"></a><a id="i1840683213-1"></a></p>
      <p>To convert from XML to a file of bytes, you can use the <span class="code">XML.save</span> command.<a id="i-2053547351-1"></a><a id="i1587478341-1"></a> You must specify a file name and a node to be saved:</p> <pre>  scala.xml.XML.save(<code class="quotedstring">"therm1.xml"</code>,&nbsp;node)
</pre>
      <p>After running the above command, the resulting file <span class="texttt">therm1.xml</span> looks like the following:</p> <pre>  &lt;?xml&nbsp;version='1.0'&nbsp;encoding='UTF-8'?&gt;
  &lt;cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;
</pre>
      <p>Loading is simpler than saving, because the file includes everything the loader needs to know. Simply call <span class="code">XML.loadFile</span> on a file name:<a id="i1775530286-1"></a><a id="i1708565962-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;loadnode&nbsp;=&nbsp;xml.XML.loadFile(<code class="quotedstring">"therm1.xml"</code>)
  <code class="output">loadnode:&nbsp;scala.xml.Elem&nbsp;=</code>
  <code class="output">&lt;cctherm&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;</code>
  <br>  scala&gt;&nbsp;fromXML(loadnode)
  <code class="output">res14:&nbsp;CCTherm&nbsp;=&nbsp;hot&nbsp;dog&nbsp;#5</code>
</pre>
      <p>Those are the basic methods you need. There are many variations on these loading and saving methods, including methods for reading and writing to various kinds of readers, writers, input and output streams.</p>
      <h3>28.8 Pattern matching on XML</h3>
      <p>So far you have seen how to dissect XML using <span class="code">text</span> and the XPath-like methods, <span class="code">\</span> and <span class="code">\\</span>.<a id="i1974282179-1"></a><a id="i1884986778-1"></a> These are good when you know exactly what kind of XML structure you are taking apart. Sometimes, though, there are a few possible structures the XML could have. Maybe there are multiple kinds of records within the data, for example because you have extended your thermometer collection to include clocks and sandwich plates. Maybe you simply want to skip over any white space between tags. Whatever the reason, you can use the pattern matcher to sift through the possibilities.</p>
      <p>An XML pattern looks just like an XML literal. The main difference is that if you insert a <span class="code">{}</span> escape, then the code inside the <span class="code">{}</span> is not an expression but a pattern.<a id="i-2088304360-1"></a><a id="i1428654986-1"></a><a id="i428757728-1"></a> A pattern embedded in <span class="code">{}</span> can use the full Scala pattern language, including binding new variables, performing type tests, and ignoring content using the <span class="code">_</span> and <span class="code">_*</span> patterns. Here is a simple example:</p> <pre>  <code class="vem">def</code>&nbsp;proc(node:&nbsp;<code class="typename">scala.xml.Node</code>):&nbsp;<code class="typename">String</code>&nbsp;=
  &nbsp;&nbsp;node&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;&lt;a&gt;{contents}&lt;/a&gt;&nbsp;=&gt;&nbsp;<code class="quotedstring">"It's&nbsp;an&nbsp;a:&nbsp;"</code>&nbsp;+&nbsp;contents
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;&lt;b&gt;{contents}&lt;/b&gt;&nbsp;=&gt;&nbsp;<code class="quotedstring">"It's&nbsp;a&nbsp;b:&nbsp;"</code>&nbsp;+&nbsp;contents
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="quotedstring">"It's&nbsp;something&nbsp;else."</code>
  &nbsp;&nbsp;}
</pre>
      <p>This function has a pattern match with three cases. The first case looks for an <span class="code">&lt;a&gt;</span> element whose contents consist of a single sub-node. It binds those contents to a variable named <span class="code">contents</span> and then evaluates the code to the right of the associated right arrow (<span class="code">=&gt;</span>). The second case does the same thing but looks for a <span class="code">&lt;b&gt;</span> instead of an <span class="code">&lt;a&gt;</span>, and the third case matches anything not matched by any other case. Here is the function in use:</p> <pre>  scala&gt;&nbsp;proc(&lt;a&gt;apple&lt;/a&gt;)
  <code class="output">res18:&nbsp;String&nbsp;=&nbsp;It's&nbsp;an&nbsp;a:&nbsp;apple</code>
  scala&gt;&nbsp;proc(&lt;b&gt;banana&lt;/b&gt;)
  <code class="output">res19:&nbsp;String&nbsp;=&nbsp;It's&nbsp;a&nbsp;b:&nbsp;banana</code>
  scala&gt;&nbsp;proc(&lt;c&gt;cherry&lt;/c&gt;)
  <code class="output">res20:&nbsp;String&nbsp;=&nbsp;It's&nbsp;something&nbsp;else.</code>
</pre>
      <p>Most likely this function is not exactly what you want, because it looks precisely for contents consisting of a single sub-node within the <span class="code">&lt;a&gt;</span> or <span class="code">&lt;b&gt;</span>. Thus it will fail to match in cases like the following:</p> <pre>  scala&gt;&nbsp;proc(&lt;a&gt;a&nbsp;&lt;em&gt;red&lt;/em&gt;&nbsp;apple&lt;/a&gt;)
  <code class="output">res21:&nbsp;String&nbsp;=&nbsp;It's&nbsp;something&nbsp;else.</code>
  scala&gt;&nbsp;proc(&lt;a/&gt;)
  <code class="output">res22:&nbsp;String&nbsp;=&nbsp;It's&nbsp;something&nbsp;else.</code>
</pre>
      <p>If you want the function to match in cases like these, you can match against a sequence of nodes instead of a single one. The pattern for "any sequence" of XML nodes is written `<span class="code">_*</span>'.<a id="i521514024-1"></a> Visually, this sequence looks like the wildcard pattern (<span class="code">_</span>) followed by a regex-style Kleene star (<span class="code">*</span>). Here is the updated function that matches a sequence of sub-elements instead of a single sub-element:</p> <pre>  <code class="vem">def</code>&nbsp;proc(node:&nbsp;<code class="typename">scala.xml.Node</code>):&nbsp;<code class="typename">String</code>&nbsp;=
  &nbsp;&nbsp;node&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;&lt;a&gt;{contents&nbsp;@&nbsp;_*}&lt;/a&gt;&nbsp;=&gt;&nbsp;<code class="quotedstring">"It's&nbsp;an&nbsp;a:&nbsp;"</code>&nbsp;+&nbsp;contents
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;&lt;b&gt;{contents&nbsp;@&nbsp;_*}&lt;/b&gt;&nbsp;=&gt;&nbsp;<code class="quotedstring">"It's&nbsp;a&nbsp;b:&nbsp;"</code>&nbsp;+&nbsp;contents
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="quotedstring">"It's&nbsp;something&nbsp;else."</code>
  &nbsp;&nbsp;}
</pre>
      <p>Notice that the result of the <span class="code">_*</span> is bound to the <span class="code">contents</span> variable by using the <span class="code">@</span> pattern described in <a href="#sec-var-binding">Section 15.2</a>. Here is the new version in action:</p> <pre>  scala&gt;&nbsp;proc(&lt;a&gt;a&nbsp;&lt;em&gt;red&lt;/em&gt;&nbsp;apple&lt;/a&gt;)
  <code class="output">res23:&nbsp;String&nbsp;=&nbsp;It's&nbsp;an&nbsp;a:&nbsp;ArrayBuffer(a&nbsp;,&nbsp;&lt;em&gt;red&lt;/em&gt;,&nbsp;&nbsp;</code>
  <code class="output">apple)</code>
  scala&gt;&nbsp;proc(&lt;a/&gt;)
  <code class="output">res24:&nbsp;String&nbsp;=&nbsp;It's&nbsp;an&nbsp;a:&nbsp;WrappedArray()</code>
</pre>
      <p>As a final tip, be aware that XML patterns work very nicely with <span class="code">for</span> expressions as a way to iterate through some parts of an XML tree while ignoring other parts.<a id="i-96590517-1"></a> For example, suppose you wish to skip over the white space between records in the following XML structure:</p> <pre>  <code class="vem">val</code>&nbsp;catalog&nbsp;=
  &nbsp;&nbsp;&lt;catalog&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;Sprite&nbsp;Boy&lt;/description&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1964&lt;/yearMade&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;April&nbsp;28,&nbsp;2003&lt;/dateObtained&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;1695&lt;/bookPrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;595&lt;/purchasePrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;5&lt;/condition&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;
  &nbsp;&nbsp;&lt;/catalog&gt;
</pre>
      <p>Visually, it looks like there are two nodes inside the <span class="code">&lt;catalog&gt;</span> element. Actually, though, there are five. There is white space before, after, and between the two elements! If you do not consider this white space, you might incorrectly process the thermometer records as follows:</p> <pre>  catalog&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;&lt;catalog&gt;{therms&nbsp;@&nbsp;_*}&lt;/catalog&gt;&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(therm&nbsp;&lt;-&nbsp;therms)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"processing:&nbsp;"</code>&nbsp;+&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(therm&nbsp;\&nbsp;<code class="quotedstring">"description"</code>).text)
  }
</pre> <pre>  <code class="output">processing:&nbsp;</code>
  <code class="output">processing:&nbsp;hot&nbsp;dog&nbsp;#5</code>
  <code class="output">processing:&nbsp;</code>
  <code class="output">processing:&nbsp;Sprite&nbsp;Boy</code>
  <code class="output">processing:&nbsp;</code>
</pre>
      <p>Notice all of the lines that try to process white space as if it were a true thermometer record. What you would really like to do is ignore the white space and process only those sub-nodes that are inside a <span class="code">&lt;cctherm&gt;</span> element. You can describe this subset using the pattern <span class="code">&lt;cctherm&gt;{_*}&lt;/cctherm&gt;</span>, and you can restrict the <span class="code">for</span> expression to iterating over items that match that pattern:</p> <pre>  catalog&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;&lt;catalog&gt;{therms&nbsp;@&nbsp;_*}&lt;/catalog&gt;&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(therm&nbsp;@&nbsp;&lt;cctherm&gt;{_*}&lt;/cctherm&gt;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;therms)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"processing:&nbsp;"</code>&nbsp;+&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(therm&nbsp;\&nbsp;<code class="quotedstring">"description"</code>).text)
  }
</pre> <pre>  <code class="output">processing:&nbsp;hot&nbsp;dog&nbsp;#5</code>
  <code class="output">processing:&nbsp;Sprite&nbsp;Boy</code>
</pre>
      <h3>28.9 Conclusion</h3>
      <p>This chapter has only scratched the surface of what you can do with XML. There are many other extensions, libraries, and tools you could learn about, some customized for Scala, some made for Java but usable in Scala, and some language-neutral. What you should walk away from this chapter with is how to use semi-structured data for interchange, and how to access semi-structured data via Scala's XML support.</p>
      <hr>
      <h4>Footnotes for Chapter 28:</h4>
      <p><a id="footnotemain28-1"></a>[1] There are type systems for XML, such as XML Schemas, but they are beyond the scope of this book.</p>
      <p><a id="footnotemain28-2"></a>[2] The full story is more complicated, but this is enough to be effective with XML.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-modular-programming-using-objects">Chapter 29</a></h2>
      <h1>Modular Programming Using Objects</h1>
      <p>In <a href="#chap-a-scalable-language">Chapter 1</a>, we claimed that one way Scala is a scalable language is that you can use the same techniques to construct small as well as large programs. So far in this book we've focused primarily on <em>programming in the small</em><a id="i-908480700-1"></a>: designing and implementing the smaller program pieces out of which you can construct a larger program.<a href="#footnotemain29-1">[1]</a> The other side of the story is <em>programming in the large</em><a id="i-915286664-1"></a>: organizing and assembling the smaller pieces into larger programs, applications, or systems. We touched on this subject when we discussed packages and access modifiers in <a href="#chap-packages-and-imports">Chapter 13</a>. In short, packages and access modifiers enable you to<a id="i-1777778106-1"></a> organize a large program using packages as <em>modules</em>, where a module is a "smaller program piece" with a well defined interface and a hidden implementation.<a id="i1227433863-1"></a></p>
      <p>While the division of programs into packages is already quite helpful, it is limited because it provides no way to abstract. You cannot reconfigure a package two different ways within the same program, and you cannot inherit between packages. A package always includes one precise list of contents, and that list is fixed until you change the code.</p>
      <p>In this chapter, we'll discuss how you can use Scala's object-oriented features to make a program more modular.<a id="i1528987536-1"></a> We'll first show how a simple singleton object can be used as a module.<a id="i1060016990-1"></a> Then we'll explain how you can use traits and classes as abstractions over modules. These abstractions can be reconfigured into multiple modules, even multiple times within the same program. Finally, we'll show a pragmatic technique for using traits to divide a module across multiple files.</p>
      <h3>29.1 The problem</h3>
      <p>As a program grows in size, it becomes increasingly important to organize it in a modular way. First, being able to compile different modules that make up the system separately helps different teams work independently.<a id="i1145716472-1"></a> In addition, being able to unplug one implementation of a module and plug in another is useful, because it allows different configurations of a system to be used in different contexts, such as unit testing on a developer's desktop, integration testing, staging, and deployment.<a id="i324568938-1"></a></p>
      <p>For example, you may have an application that uses a database and a message service. As you write code, you may want to run unit tests on your desktop that use mock versions of both the database and message service, which simulate these services sufficiently for testing without needing to talk across the network to a shared resource. During integration testing, you may want to use a mock message service but a live developer database. During staging and certainly during deployment, your organization will likely want to use live versions of both the database and message service.</p>
      <p>Any technique that aims to facilitate this kind of modularity needs to provide a few essentials. First, there should be a module construct that provides a good separation of interface and implementation. Second, there should be a way to replace one module with another that has the same interface without changing or recompiling the modules that depend on the replaced one. Lastly, there should be a way to wire modules together. This wiring task can be thought of as <em>configuring</em> the system.<a id="i2145337984-1"></a></p>
      <p>One approach to solving this problem is <em>dependency injection</em><a id="i10210882-1"></a><a id="i1768195241-1"></a>, a technique supported on the Java platform by frameworks such as Spring<a id="i844238763-1"></a> and Guice,<a id="i69159613-1"></a> which are popular in the enterprise Java community.<a href="#footnotemain29-2">[2]</a> Spring, for example, essentially allows you to represent the interface of a module as a Java interface and implementations of the module as Java classes. You can specify dependencies between modules and "wire" an application together via external XML configuration files.<a id="i1866586400-1"></a> Although you can use Spring with Scala and thereby use Spring's approach to achieving system-level modularity of your Scala programs, with Scala you have some alternatives enabled by the language itself. In the remainder of this chapter, we'll show how to use objects as modules to achieve the desired "in the large" modularity without using an external framework.</p>
      <h3>29.2 A recipe application</h3>
      <p>Imagine you are building an enterprise web application that will allow users to manage recipes. You want to partition the software into layers, including a <em>domain layer</em> and an <em>application layer</em>.<a id="i701062634-1"></a><a id="i-679595592-1"></a> In the domain layer, you'll define <em>domain objects</em>, which will capture business concepts and rules, as well as encapsulate state that will be persisted to an external relational database. In the application layer, you'll provide an API organized in terms of the services the application offers to clients (including the user interface layer). The application layer will implement these services by coordinating tasks and delegating the work to the objects of the domain layer.<a href="#footnotemain29-3">[3]</a></p>
      <p>You want to be able to plug in real or mock versions of certain objects in each of these layers, so that you can more easily write unit tests for your application. To achieve this goal, you can treat the objects you want to mock as modules. In Scala, there is no need for objects to be "small" things, no need to use some other kind of construct for "big" things like modules. One of the ways Scala is a scalable language is that the same constructs are used for structures both small and large.<a id="i-885663216-2"></a><a id="i741587120-2"></a></p>
      <p>For example, since one of the "things" you want to mock in the domain layer is the object that represents the relational database, you'll make that one of the modules. In the application layer, you'll treat a "database browser" object as a module. The database will hold all of the recipes that a person has collected. The browser will help search and browse that database, for example, to find every recipe that includes an ingredient you have on hand.</p>
      <p>The first thing to do is to model foods and recipes. To keep things simple, a food will just have a name, as shown in <a href="#lst-food-entity">Listing 29.1</a>. A recipe will have a name, a list of ingredients, and some instructions, as shown in <a href="#lst-recipe-entity">Listing 29.2</a>.</p>
      <p><a id="lst-food-entity"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.recipe
  <br>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Food</code>(<code class="vem">val</code>&nbsp;name:&nbsp;<code class="typename">String</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;name
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.1 - A simple <span class="code">Food</span> entity class.</h5>
      <p><a id="lst-recipe-entity"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.recipe
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Recipe</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;name:&nbsp;<code class="typename">String</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;ingredients:&nbsp;<code class="typename">List[Food]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;instructions:&nbsp;<code class="typename">String</code>
  &nbsp;&nbsp;)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;name
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.2 - Simple <span class="code">Recipe</span> entity class.</h5>
      <p>The <span class="code">Food</span> and <span class="code">Recipe</span> classes shown in <a href="#lst-food-entity">Listings 29.1</a> <a href="#lst-recipe-entity">and 29.2</a> represent <em>entities</em> that will be persisted in the database.<a id="i-2102114367-1"></a><a id="i728984841-1"></a><a href="#footnotemain29-4">[4]</a> <a href="#lst-example-foods-recipe">Listing 29.3</a> shows some singleton instances of these classes, which can be used when writing tests.<a id="i181822064-1"></a><a id="i534212600-1"></a></p>
      <p><a id="lst-example-foods-recipe"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.recipe
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Apple</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>(<code class="quotedstring">"Apple"</code>)
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Orange</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>(<code class="quotedstring">"Orange"</code>)
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Cream</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>(<code class="quotedstring">"Cream"</code>)
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Sugar</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>(<code class="quotedstring">"Sugar"</code>)
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">FruitSalad</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Recipe</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"fruit&nbsp;salad"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Orange</code>,&nbsp;<code class="typename">Cream</code>,&nbsp;<code class="typename">Sugar</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Stir&nbsp;it&nbsp;all&nbsp;together."</code>
  &nbsp;&nbsp;)
</pre>
      <h5>Listing 29.3 - <span class="code">Food</span> and <span class="code">Recipe</span> examples for use in tests.</h5>
      <p><a id="lst-mock-implementations"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.recipe
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">SimpleDatabase</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allFoods&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Orange</code>,&nbsp;<code class="typename">Cream</code>,&nbsp;<code class="typename">Sugar</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;foodNamed(name:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[Food]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allFoods.find(_.name&nbsp;==&nbsp;name)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allRecipes:&nbsp;<code class="typename">List[Recipe]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">FruitSalad</code>)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">SimpleBrowser</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;recipesUsing(food:&nbsp;<code class="typename">Food</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleDatabase.allRecipes.filter(recipe&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recipe.ingredients.contains(food))
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.4 - Mock database and browser modules.</h5>
      <p>Scala uses objects for modules, so you can start modularizing your program by making two singleton<a id="i-1006990674-1"></a><a id="i955954873-1"></a><a id="i-536383362-1"></a> objects to serve as mock implementations of the database and browser modules during testing. Because it is a mock, the database module is backed by a simple in-memory list. Implementations of these objects are shown in <a href="#lst-mock-implementations">Listing 29.4</a>. You can use this database and browser as follows:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;apple&nbsp;=&nbsp;SimpleDatabase.foodNamed(<code class="quotedstring">"Apple"</code>).get
  <code class="output">apple:&nbsp;Food&nbsp;=&nbsp;Apple</code>
  <br>  scala&gt;&nbsp;SimpleBrowser.recipesUsing(apple)
  <code class="output">res0:&nbsp;List[Recipe]&nbsp;=&nbsp;List(fruit&nbsp;salad)</code>
</pre>
      <p>To make things a little more interesting, suppose the database sorts foods into categories. To implement this, you can add a <span class="code">FoodCategory</span> class and a list of all categories in the database, as shown in <a href="#lst-categories-added">Listing 29.5</a>. Notice in this example that the <span class="code">private</span> keyword, so useful for implementing classes, is also useful for implementing modules.<a id="i-107999758-1"></a> Items marked <span class="code">private</span> are part of the implementation of a module, and thus are particularly easy to change without affecting other modules.</p>
      <p>At this point, many more facilities could be added, but you get the idea. Programs can be divided into singleton objects, which you can think of as modules. This is not big news, but it becomes very useful when you consider abstraction (which we'll cover next).</p>
      <p><a id="lst-categories-added"></a></p> <pre>  <code class="vem">package</code>&nbsp;org.stairwaybook.recipe
  <br>  <code class="vem">object</code>&nbsp;<code class="typename">SimpleDatabase</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;allFoods&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Orange</code>,&nbsp;<code class="typename">Cream</code>,&nbsp;<code class="typename">Sugar</code>)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;foodNamed(name:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Option[Food]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;allFoods.find(_.name&nbsp;==&nbsp;name)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;allRecipes:&nbsp;<code class="typename">List[Recipe]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">FruitSalad</code>)
  <br>  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">FoodCategory</code>(name:&nbsp;<code class="typename">String</code>,&nbsp;foods:&nbsp;<code class="typename">List[Food]</code>)
  <br>  &nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;categories&nbsp;=&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">FoodCategory</code>(<code class="quotedstring">"fruits"</code>,&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Orange</code>)),
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">FoodCategory</code>(<code class="quotedstring">"misc"</code>,&nbsp;<code class="typename">List</code>(<code class="typename">Cream</code>,&nbsp;<code class="typename">Sugar</code>)))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;allCategories&nbsp;=&nbsp;categories
  }
  <br>  <code class="vem">object</code>&nbsp;<code class="typename">SimpleBrowser</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;recipesUsing(food:&nbsp;<code class="typename">Food</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;SimpleDatabase.allRecipes.filter(recipe&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recipe.ingredients.contains(food))
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;displayCategory(category:&nbsp;<code class="typename">SimpleDatabase.FoodCategory</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(category)
  &nbsp;&nbsp;}
  }
</pre>
      <h5>Listing 29.5 - Database and browser modules with categories added.</h5>
      <h3>29.3 Abstraction</h3>
      <p>Although the examples shown so far did manage to partition your application into separate database and browser modules, the design is not yet very "modular." The problem is that there is essentially a "hard link" from the browser module to the database modules:</p> <pre>  SimpleDatabase.allRecipes.filter(recipe&nbsp;=&gt;&nbsp;...
</pre>
      <p>Because the <span class="code">SimpleBrowser</span> module mentions the <span class="code">SimpleDatabase</span> module by name, you won't be able to plug in a different implementation of the database module without modifying and recompiling the browser module. In addition, although there's no hard link from the <span class="code">SimpleDatabase</span> module to the <span class="code">SimpleBrowser</span> module,<a href="#footnotemain29-5">[5]</a> there's no clear way to enable the user interface layer, for example, to be configured to use different implementations of the browser module.</p>
      <p>When making these modules more pluggable, however, it is important to avoid duplicating code, because much code can likely be shared by different implementations of the same module. For example, suppose you want the same code base to support multiple recipe databases, and you want to be able to create a separate browser for each of these databases. You would like to reuse the browser code for each of the instances, because the only thing different about the browsers is which database they refer to. Except for the database implementation, the rest of the code can be reused character for character. How can the program be arranged to minimize repetitive code? How can the code be made reconfigurable, so that you can configure it using either database implementation?</p>
      <p>The answer is a familiar one: If a module is an object, then a template for a module is a class. Just like a class describes the common parts of all its instances, a class can describe the parts of a module that are common to all of its possible configurations.</p>
      <p><a id="lst-browser-as-class"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Browser</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;database:&nbsp;<code class="typename">Database</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;recipesUsing(food:&nbsp;<code class="typename">Food</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;database.allRecipes.filter(recipe&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recipe.ingredients.contains(food))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;displayCategory(category:&nbsp;<code class="typename">database.FoodCategory</code>)&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(category)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.6 - A <span class="code">Browser</span> class with an abstract database <span class="code">val</span>.</h5>
      <p>The browser definition therefore becomes a class, instead of an object, and the database to use is specified as an abstract member of the class, as shown in <a href="#lst-browser-as-class">Listing 29.6</a>. The database also becomes a class, including as much as possible that is common between all databases, and declaring the missing parts that a database must define. In this case, all database modules must define methods for <span class="code">allFoods</span>, <span class="code">allRecipes</span>, and <span class="code">allCategories</span>, but since they can use an arbitrary definition, the methods must be left abstract in the <span class="code">Database</span> class. The <span class="code">foodNamed</span> method, by contrast, can be defined in the abstract <span class="code">Database</span> class, as shown in <a href="#lst-database-as-class">Listing 29.7</a>.</p>
      <p><a id="lst-database-as-class"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Database</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allFoods:&nbsp;<code class="typename">List[Food]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allRecipes:&nbsp;<code class="typename">List[Recipe]</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;foodNamed(name:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allFoods.find(f&nbsp;=&gt;&nbsp;f.name&nbsp;==&nbsp;name)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">FoodCategory</code>(name:&nbsp;<code class="typename">String</code>,&nbsp;foods:&nbsp;<code class="typename">List[Food]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allCategories:&nbsp;<code class="typename">List[FoodCategory]</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.7 - A <span class="code">Database</span> class with abstract methods.</h5>
      <p>The <span class="code">SimpleDatabase</span> object must be updated to inherit from the abstract <span class="code">Database</span> class, as shown in <a href="#lst-new-simple-database">Listing 29.8</a>. <a id="lst-new-simple-database"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">SimpleDatabase</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Database</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allFoods&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Orange</code>,&nbsp;<code class="typename">Cream</code>,&nbsp;<code class="typename">Sugar</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allRecipes:&nbsp;<code class="typename">List[Recipe]</code>&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">FruitSalad</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;categories&nbsp;=&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">FoodCategory</code>(<code class="quotedstring">"fruits"</code>,&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Orange</code>)),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">FoodCategory</code>(<code class="quotedstring">"misc"</code>,&nbsp;<code class="typename">List</code>(<code class="typename">Cream</code>,&nbsp;<code class="typename">Sugar</code>)))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allCategories&nbsp;=&nbsp;categories
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.8 - The <span class="code">SimpleDatabase</span> object as a <span class="code">Database</span> subclass.</h5>
      <p>Then, a specific browser module is made by instantiating the <span class="code">Browser</span> class and specifying which database to use, as shown in <a href="#lst-new-simple-browser">Listing 29.9</a>.</p>
      <p><a id="lst-new-simple-browser"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">SimpleBrowser</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Browser</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;database&nbsp;=&nbsp;<code class="typename">SimpleDatabase</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.9 - The <span class="code">SimpleBrowser</span> object as a <span class="code">Browser</span> subclass.</h5>
      <p>You can use these more pluggable modules the same as before:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;apple&nbsp;=&nbsp;SimpleDatabase.foodNamed(<code class="quotedstring">"Apple"</code>).get
  <code class="output">apple:&nbsp;Food&nbsp;=&nbsp;Apple</code>
  <br>  scala&gt;&nbsp;SimpleBrowser.recipesUsing(apple)
  <code class="output">res1:&nbsp;List[Recipe]&nbsp;=&nbsp;List(fruit&nbsp;salad)</code>
</pre>
      <p>Now, however, you can create a second mock database, and use the same browser class with it, as shown in <a href="#lst-student-database">Listing 29.10</a>: <a id="lst-student-database"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">StudentDatabase</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Database</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">FrozenFood</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>(<code class="quotedstring">"FrozenFood"</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">HeatItUp</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Recipe</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"heat&nbsp;it&nbsp;up"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="typename">FrozenFood</code>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Microwave&nbsp;the&nbsp;'food'&nbsp;for&nbsp;10&nbsp;minutes."</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allFoods&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">FrozenFood</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allRecipes&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">HeatItUp</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allCategories&nbsp;=&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">FoodCategory</code>(<code class="quotedstring">"edible"</code>,&nbsp;<code class="typename">List</code>(<code class="typename">FrozenFood</code>)))
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">StudentBrowser</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Browser</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;database&nbsp;=&nbsp;<code class="typename">StudentDatabase</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.10 - A student database and browser.</h5>
      <h3 id="sec-modules-traits">29.4 Splitting modules into traits</h3>
      <p>Often a module is too large to fit comfortably into a single file. When that happens, you can use traits to split a module into separate files.<a id="i-865710043-2"></a> For example, suppose you wanted to move categorization code out of the main <span class="code">Database</span> file and into its own. You could create a trait for the code as shown in (<a href="#lst-trait-food-categories">Listing 29.11</a>). <a id="lst-trait-food-categories"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">FoodCategories</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">FoodCategory</code>(name:&nbsp;<code class="typename">String</code>,&nbsp;foods:&nbsp;<code class="typename">List[Food]</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allCategories:&nbsp;<code class="typename">List[FoodCategory]</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.11 - A trait for food categories.</h5>
      <p>Now class <span class="code">Database</span> can mix in the <span class="code">FoodCategories</span> trait instead of defining <span class="code">FoodCategory</span> and <span class="code">allCategories</span> itself, as shown in <a href="#lst-database-mixes-in">Listing 29.12</a>: <a id="lst-database-mixes-in"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Database</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">FoodCategories</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allFoods:&nbsp;<code class="typename">List[Food]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allRecipes:&nbsp;<code class="typename">List[Recipe]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;foodNamed(name:&nbsp;<code class="typename">String</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allFoods.find(f&nbsp;=&gt;&nbsp;f.name&nbsp;==&nbsp;name)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.12 - A <span class="code">Database</span> class that mixes in the <span class="code">FoodCategories</span> trait.</h5>
      <p>You might try and divide <span class="code">SimpleDatabase</span> into two traits, one for foods and one for recipes. This would allow you to define <span class="code">SimpleDatabase</span> as shown in <a href="#lst-simple-traits">Listing 29.13</a>: <a id="lst-simple-traits"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">SimpleDatabase</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Database</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">SimpleFoods</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">SimpleRecipes</code>
</pre>
      <h5>Listing 29.13 - A <span class="code">SimpleDatabase</span> object composed solely of mixins.</h5>
      <p>The <span class="code">SimpleFoods</span> trait could look as shown in <a href="#lst-simple-foods-trait">Listing 29.14</a>: <a id="lst-simple-foods-trait"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">SimpleFoods</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Pear</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Food</code>(<code class="quotedstring">"Pear"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allFoods&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Pear</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allCategories&nbsp;=&nbsp;<code class="typename">Nil</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.14 - A <span class="code">SimpleFoods</span> trait.</h5>
      <p>So far so good, but unfortunately, a problem arises if you try to define a <span class="code">SimpleRecipe</span>s trait like this:</p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">SimpleRecipes</code>&nbsp;{&nbsp;<code class="comment">//&nbsp;Does&nbsp;not&nbsp;compile</code>
  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">FruitSalad</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Recipe</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"fruit&nbsp;salad"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Pear</code>),&nbsp;&nbsp;<code class="comment">//&nbsp;Uh&nbsp;oh</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Mix&nbsp;it&nbsp;all&nbsp;together."</code>
  &nbsp;&nbsp;)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;allRecipes&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">FruitSalad</code>)
  }
</pre>
      <p>The problem is that <span class="code">Pear</span> is located in a different trait from the one that uses it, so it is out of scope. The compiler has no idea that <span class="code">SimpleRecipes</span> is only ever mixed together with <span class="code">SimpleFoods</span>.</p>
      <p>However, there is a way you can tell this to the compiler. Scala provides the <a href="#g-1749196914"><em>self type</em></a> for precisely this situation.<a id="i979629307-1"></a><a id="i-560124499-1"></a><a id="i-178750838-1"></a> Technically, a self type is an assumed type for <span class="code">this</span> whenever <span class="code">this</span> is mentioned within the class.<a id="i-1139406016-1"></a><a id="i1634645853-1"></a> Pragmatically, a self type specifies the requirements on any concrete class the trait is mixed into. If you have a trait that is only ever used when mixed in with another trait or traits, then you can specify that those other traits should be assumed. In the present case, it is enough to specify a self type of <span class="code">SimpleFoods</span>, as shown in <a href="#lst-simple-recipes-trait">Listing 29.15</a>: <a id="lst-simple-recipes-trait"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">SimpleRecipes</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>:&nbsp;<code class="typename">SimpleFoods</code>&nbsp;=&gt;
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">FruitSalad</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Recipe</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"fruit&nbsp;salad"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(<code class="typename">Apple</code>,&nbsp;<code class="typename">Pear</code>),&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;Now&nbsp;Pear&nbsp;is&nbsp;in&nbsp;scope</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"Mix&nbsp;it&nbsp;all&nbsp;together."</code>
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;allRecipes&nbsp;=&nbsp;<code class="typename">List</code>(<code class="typename">FruitSalad</code>)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.15 - A <span class="code">SimpleRecipes</span> trait with a self type.</h5>
      <p>Given the new self type, <span class="code">Pear</span> is now available. Implicitly, the reference to <span class="code">Pear</span> is thought of as <span class="code">this.Pear</span>. This is safe, because any <em>concrete</em> class that mixes in <span class="code">SimpleRecipes</span> must also be a subtype of <span class="code">SimpleFoods</span>, which means that <span class="code">Pear</span> will be a member. Abstract subclasses and traits do not have to follow this restriction, but since they cannot be instantiated with <span class="code">new</span>, there is no risk that the <span class="code">this.Pear</span> reference will fail.</p>
      <h3>29.5 Runtime linking</h3>
      <p>Scala modules can be linked together at runtime, and you can decide which modules will link to which depending on runtime computations.<a id="i775929709-1"></a><a id="i1259075515-1"></a> For example, <a href="#lst-got-apples">Listing 29.16</a> shows a small program that chooses a database at runtime and then prints out all the apple recipes in it: <a id="lst-got-apples"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">GotApples</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;db:&nbsp;<code class="typename">Database</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>(args(<code class="literal">0</code>)&nbsp;==&nbsp;<code class="quotedstring">"student"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">StudentDatabase</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">SimpleDatabase</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;browser&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Browser</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;database&nbsp;=&nbsp;db
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;apple&nbsp;=&nbsp;SimpleDatabase.foodNamed(<code class="quotedstring">"Apple"</code>).get
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>(recipe&nbsp;&lt;-&nbsp;browser.recipesUsing(apple))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(recipe)
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.16 - An app that dynamically selects a module implementation.</h5>
      <p>Now, if you use the simple database, you will find a recipe for fruit salad. If you use the student database, you will find no recipes at all using apples:</p> <pre>  $&nbsp;scala&nbsp;<code class="typename">GotApples</code>&nbsp;simple
  <code class="output">fruit&nbsp;salad</code>
  $&nbsp;scala&nbsp;<code class="typename">GotApples</code>&nbsp;student
  $
</pre>
      <div class="aside">
        <h3>Configuring with Scala code</h3>
        <p>You may wonder if you are not backsliding to the hard links problem of the original examples in this chapter, because the <span class="code">GotApples</span> object shown in <a href="#lst-got-apples">Listing 29.16</a> contains hard links to both <span class="code">StudentDatabase</span> and <span class="code">SimpleDatabase</span>. The difference here is that the hard links are localized in one file that can be replaced.<a id="i475125994-1"></a><a id="i-578074568-1"></a></p>
        <p>Every modular application needs some way to specify the actual module implementations to use in a particular situation. This act of "configuring" the application will by definition involve the naming of concrete module implementations. For example, in a Spring application, you configure by naming implementations in an external XML file.<a id="i872568577-1"></a><a id="i-1798539574-1"></a> In Scala, you can configure via Scala code itself. One advantage to using Scala source over XML for configuration is that the process of running your configuration file through the Scala compiler should uncover any misspellings in it prior to its actual use.</p>
      </div>
      <h3 id="sec-tracking-module-instances">29.6 Tracking module instances</h3>
      <p>Despite using the same code, the different browser and database modules created in the previous section really are separate modules. This means that each module has its own contents, including any nested classes. <span class="code">FoodCategory</span> in <span class="code">SimpleDatabase</span>, for example, is a different class from <span class="code">FoodCategory</span> in <span class="code">StudentDatabase</span>!<a id="i-677980410-10"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;category&nbsp;=&nbsp;StudentDatabase.allCategories.head
  <code class="output">category:&nbsp;StudentDatabase.FoodCategory&nbsp;=&nbsp;</code>
  <code class="output">FoodCategory(edible,List(FrozenFood))</code>
  <br>  scala&gt;&nbsp;SimpleBrowser.displayCategory(category)
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;StudentDatabase.FoodCategory</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required:&nbsp;SimpleBrowser.database.FoodCategory</code>
  <code class="output"></code>
</pre>
      <p>If instead you prefer all <span class="code">FoodCategory</span>s to be the same, you can accomplish this by moving the definition of <span class="code">FoodCategory</span> outside of any class or trait. The choice is yours, but as it is written, each <span class="code">Database</span> gets its own, unique <span class="code">FoodCategory</span> class.</p>
      <p>Since the two <span class="code">FoodCategory</span> classes shown in this example really are different, the compiler is correct to complain. Sometimes, though, you may encounter a case where two types are the same but the compiler can't verify it. You will see the compiler complaining that two types are not the same, even though you as the programmer know they are.</p>
      <p>In such cases you can often fix the problem using <em>singleton types</em>. For example, in the <span class="code">GotApples</span> program, the type checker does not know that <span class="code">db</span> and <span class="code">browser.database</span> are the same. This will cause type errors if you try to pass categories between the two objects:<a id="i-677980410-11"></a></p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">GotApples</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;same&nbsp;definitions...</code>
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(category&nbsp;&lt;-&nbsp;db.allCategories)
  &nbsp;&nbsp;&nbsp;&nbsp;browser.displayCategory(category)
  &nbsp;&nbsp;<code class="comment">//&nbsp;...</code>
  }
  <code class="output">GotApples2.scala:14:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;db.FoodCategory</code>
  <code class="output">&nbsp;required:&nbsp;browser.database.FoodCategory</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;browser.displayCategory(category)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
  <code class="output">one&nbsp;error&nbsp;found</code>
</pre>
      <p>To avoid this error, you need to inform the type checker that they are the same object.<a id="i-677980410-12"></a> You can do this by changing the definition of <span class="code">browser.database</span> as shown in <a href="#lst-db-type">Listing 29.17</a>: <a id="lst-db-type"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;browser&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Browser</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;database:&nbsp;db.type&nbsp;=&nbsp;db
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 29.17 - Using a singleton type.</h5>
      <p>This definition is the same as before except that <span class="code">database</span> has the<a id="i-1431142691-1"></a> funny-looking type <span class="code">db.type</span>. The "<span class="code">.type</span>" on the end means that this is a <em>singleton type</em>.<a id="i-108236764-2"></a><a id="i-1108021686-1"></a> A singleton type is extremely specific and holds only one object; in this case, whichever object is referred to by <span class="code">db</span>. Usually such types are too specific to be useful, which is why the compiler is reluctant to insert them automatically. In this case, though, the singleton type allows the compiler to know that <span class="code">db</span> and <span class="code">browser.database</span> are the same object—enough information to eliminate the type error.</p>
      <h3>29.7 Conclusion</h3>
      <p>This chapter has shown how to use Scala's objects as modules. In addition to simple static modules, this approach gives you a variety of ways to create abstract, reconfigurable modules. There are actually even more abstraction techniques than shown, since anything that works on a class also works on a class used to implement a module. As always, how much of this power you use should be a matter of taste.</p>
      <p>Modules are part of programming in the large, and thus are hard to experiment with. You need a large program before it really makes a difference. Nonetheless, after reading this chapter you know which Scala features to think about when you want to program in a modular style. Think about these techniques when you write your own large programs and recognize these coding patterns when you see them in other people's code.</p>
      <hr>
      <h4>Footnotes for Chapter 29:</h4>
      <p><a id="footnotemain29-1"></a>[1] This terminology was introduced in DeRemer, <i>et. al.</i>, "Programming-in-the-large versus programming-in-the-small." <a href="#deremer-large-small">[DeR75]</a><a id="i1056566638-1"></a></p>
      <p><a id="footnotemain29-2"></a>[2] Fowler,<a id="i-110883654-1"></a> "Inversion of control containers and the dependency injection pattern." <a href="#fowler-dependency">[Fow04]</a></p>
      <p><a id="footnotemain29-3"></a>[3] The naming of these layers follows that of Evans, <em>Domain-Driven Design</em>. <a href="#evans-domain-driven-design">[Eva03]</a><a id="i-1668052528-1"></a><a id="i-1497241897-1"></a></p>
      <p><a id="footnotemain29-4"></a>[4] These entity classes are simplified to keep the example uncluttered with too much real-world detail. But transforming these classes into entities that could be persisted with Hibernate<a id="i1100003378-1"></a> or the Java Persistence Architecture,<a id="i-1968727662-1"></a> for example, would require only a few modifications, such as adding a private <span class="code">Long</span> <span class="code">id</span> field and a no-arg constructor, placing <span class="code">scala.reflect.BeanProperty</span> annotations on the fields, specifying appropriate mappings via annotations or a separate XML file, and so on.<a id="i-146150294-1"></a></p>
      <p><a id="footnotemain29-5"></a>[5] This is good, because each of these architectural layers should depend only on layers below them.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-object-equality">Chapter 30</a></h2>
      <h1>Object Equality</h1>
      <p>Comparing two values for equality is ubiquitous in programming. It is also more tricky than it looks at first glance. This chapter looks at object equality in detail and gives some recommendations to consider when you design your own equality tests.</p>
      <h3>30.1 Equality in Scala</h3>
      <p>As mentioned in <a href="#sec-impl-primitives">Section 11.2</a>, the definition of equality is different in Scala and Java. Java has two equality comparisons: the <span class="code">==</span> operator,<a id="i-2046772853-1"></a><a id="i-1785676493-1"></a> which is the natural equality for value types and object identity for reference types, and the <span class="code">equals</span> method, which is (user-defined) canonical equality for reference types.<a id="i-342464093-2"></a> This convention is problematic because the more natural symbol, <span class="code">==</span>, does not always correspond to the natural notion of equality. When programming in Java, a common pitfall for beginners is to compare objects with <span class="code">==</span> when they should be compared with <span class="code">equals</span>. For instance, comparing two strings <span class="code">x</span> and <span class="code">y</span> using "<span class="code">x</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">y</span>" might yield <span class="code">false</span> in Java, even if <span class="code">x</span> and <span class="code">y</span> have exactly the same characters in the same order.</p>
      <p>Scala also has an equality method signifying object identity, but it is not used much. That kind of equality, written "<span class="code">x</span>&nbsp;<span class="code">eq</span>&nbsp;<span class="code">y</span>", is true if <span class="code">x</span> and <span class="code">y</span> reference the same object.<a id="i-795280463-3"></a><a id="i2030434891-3"></a><a id="i1544052809-3"></a><a id="i-644344128-1"></a> The <span class="code">==</span> equality<a id="i-1583721442-3"></a><a id="i1095465388-3"></a> is reserved in Scala for the "natural" equality of each type. For value types, <span class="code">==</span> is value comparison, just like in Java. For reference types, <span class="code">==</span> is the same as <span class="code">equals</span> in Scala. You can redefine the behavior of <span class="code">==</span> for new types by overriding the <span class="code">equals</span> method, which is always inherited from class <span class="code">Any</span>. The inherited <span class="code">equals</span>, which takes effect unless overridden, is object identity, as is the case in Java. So <span class="code">equals</span> (and with it, <span class="code">==</span>) is by default the same as <span class="code">eq</span>, but you can change its behavior by overriding the <span class="code">equals</span> method in the classes you define. It is not possible to override <span class="code">==</span> directly, as it is defined as a final method in class <span class="code">Any</span>. That is, Scala treats <span class="code">==</span> as if it were defined as follows in class <span class="code">Any</span>:</p> <pre>  <code class="vem">final</code>&nbsp;<code class="vem">def</code>&nbsp;==&nbsp;(that:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(<code class="vem">null</code>&nbsp;eq&nbsp;<code class="vem">this</code>)&nbsp;{<code class="vem">null</code>&nbsp;eq&nbsp;that}&nbsp;<code class="vem">else</code>&nbsp;{<code class="vem">this</code>&nbsp;equals&nbsp;that}
</pre>
      <h3 id="sec-writing-an-equality-method">30.2 Writing an equality method</h3>
      <p>How should the <span class="code">equals</span> method be defined? It turns out that writing a correct equality method is surprisingly difficult in object-oriented languages. In fact, after studying a large body of Java code, the authors of a 2007 paper concluded that almost all implementations of <span class="code">equals</span> methods are faulty.<a href="#footnotemain30-1">[1]</a> This is problematic because equality is at the basis of many other things. For one, a faulty equality method for a type <span class="code">C</span> might mean that you cannot reliably put an object of type <span class="code">C</span> in a collection.</p>
      <p>For example, you might have two elements, <span class="code">elem1</span> and <span class="code">elem2</span>, of type <span class="code">C</span> which are equal (<i>i.e.</i>, "<span class="code">elem1</span>&nbsp;<span class="code">equals</span>&nbsp;<span class="code">elem2</span>" yields <span class="code">true</span>). Nevertheless, with commonly occurring faulty implementations of the <span class="code">equals</span> method, you could still see behavior like the following:</p> <pre>  <code class="vem">var</code>&nbsp;hashSet:&nbsp;<code class="typename">Set[C]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">collection.immutable.HashSet</code>
  hashSet&nbsp;+=&nbsp;elem1
  hashSet&nbsp;contains&nbsp;elem2&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;returns&nbsp;false!</code>
</pre>
      <p>Here are four common pitfalls<a href="#footnotemain30-2">[2]</a> that can cause inconsistent behavior when overriding <span class="code">equals</span>:</p>
      <ol>
        <li>Defining <span class="code">equals</span> with the wrong signature. </li>
        <li>Changing <span class="code">equals</span> without also changing <span class="code">hashCode</span>. </li>
        <li>Defining <span class="code">equals</span> in terms of mutable fields. </li>
        <li>Failing to define <span class="code">equals</span> as an equivalence relation. </li>
      </ol>
      <p>These four pitfalls are discussed in the remainder of this section.</p>
      <h4>Pitfall #1: Defining <span class="code">equals</span> with the wrong signature</h4>
      <p>Consider adding an equality method to the following class of simple points:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{&nbsp;...&nbsp;}
</pre>
      <p>A seemingly obvious but wrong way would be to define it like this:</p> <pre>  <code class="comment">//&nbsp;An&nbsp;utterly&nbsp;wrong&nbsp;definition&nbsp;of&nbsp;equals</code>
  <code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Point</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;other.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;other.y
</pre>
      <p>What's wrong with this method? At first glance, it seems to work OK:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p1,&nbsp;p2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p1:&nbsp;Point&nbsp;=&nbsp;Point@37d7d90f</code>
  <code class="output">p2:&nbsp;Point&nbsp;=&nbsp;Point@3beb846d</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;q&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">2</code>,&nbsp;<code class="literal">3</code>)
  <code class="output">q:&nbsp;Point&nbsp;=&nbsp;Point@e0cf182</code>
  <br>  scala&gt;&nbsp;p1&nbsp;equals&nbsp;p2
  <code class="output">res0:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;p1&nbsp;equals&nbsp;q
  <code class="output">res1:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>However, trouble starts once you start putting points into a collection:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="output">import&nbsp;scala.collection.mutable</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;coll&nbsp;=&nbsp;<code class="typename">mutable.HashSet</code>(p1)
  <code class="output">coll:&nbsp;scala.collection.mutable.HashSet[Point]&nbsp;=&nbsp;</code>
  <code class="output">Set(Point@37d7d90f)</code>
  <br>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p2
  <code class="output">res2:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>How to explain that <span class="code">coll</span> does not contain <span class="code">p2</span>, even though <span class="code">p1</span> was added to it, and <span class="code">p1</span> and <span class="code">p2</span> are equal objects? The reason becomes clear in the following interaction, where the precise type of one of the compared points is masked. Define <span class="code">p2a</span> as an alias of <span class="code">p2</span>, but with type <span class="code">Any</span> instead of <span class="code">Point</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p2a:&nbsp;<code class="typename">Any</code>&nbsp;=&nbsp;p2
  <code class="output">p2a:&nbsp;Any&nbsp;=&nbsp;Point@3beb846d</code>
</pre>
      <p>Now, were you to repeat the first comparison, but with the alias <span class="code">p2a</span> instead of <span class="code">p2</span>, you would get:</p> <pre>  scala&gt;&nbsp;p1&nbsp;equals&nbsp;p2a
  <code class="output">res3:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>What went wrong? The version of <span class="code">equals</span> given previously does not override the standard method <span class="code">equals</span> because its type is different. Here is the type of the <span class="code">equals</span> method as it is defined in the root class <span class="code">Any</span>:<a href="#footnotemain30-3">[3]</a></p> <pre>  <code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>
</pre>
      <p>Because the <span class="code">equals</span> method in <span class="code">Point</span> takes a <span class="code">Point</span> instead of an <span class="code">Any</span> as an argument, it does not override <span class="code">equals</span> in <span class="code">Any</span>.<a id="i1623576437-1"></a> Instead, it is just an overloaded alternative. Now, overloading in Scala and in Java is resolved by the static type of the argument, not the run-time type. So as long as the static type of the argument is <span class="code">Point</span>, the <span class="code">equals</span> method in <span class="code">Point</span> is called. However, once the static argument is of type <span class="code">Any</span>, the <span class="code">equals</span> method in <span class="code">Any</span> is called instead. This method has not been overridden, so it is still implemented by comparing object identity.</p>
      <p>That's why the comparison "<span class="code">p1</span>&nbsp;<span class="code">equals</span>&nbsp;<span class="code">p2a</span>" yields <span class="code">false</span> even though points <span class="code">p1</span> and <span class="code">p2a</span> have the same <span class="code">x</span> and <span class="code">y</span> values. That's also why the <span class="code">contains</span> method in <span class="code">HashSet</span> returned <span class="code">false</span>. Since that method operates on generic sets, it calls the generic <span class="code">equals</span> method in <span class="code">Object</span> instead of the overloaded variant in <span class="code">Point</span>. Here's a better <span class="code">equals</span> method:</p> <pre>  <code class="comment">//&nbsp;A&nbsp;better&nbsp;definition,&nbsp;but&nbsp;still&nbsp;not&nbsp;perfect</code>
  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;that.y
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  }
</pre>
      <p>Now <span class="code">equals</span> has the correct type. It takes a value of type <span class="code">Any</span> as parameter and it yields a <span class="code">Boolean</span> result. The implementation of this method uses a pattern match.<a id="i-1742228676-1"></a> It first tests whether the <span class="code">other</span> object is also of type <span class="code">Point</span>. If it is, it compares the coordinates of the two points and returns the result. Otherwise the result is <span class="code">false</span>.</p>
      <p>A related pitfall is to define <span class="code">==</span> with a wrong signature. Normally, if you try to redefine <span class="code">==</span> with the correct signature, which takes an argument of type <span class="code">Any</span>, the compiler will give you an error because you try to override a <span class="code">final</span> method of type <span class="code">Any</span>.</p>
      <p>Newcomers to Scala sometimes make two errors at once: They try to override <span class="code">==</span> <span style="font-style:italic">and</span> they give it the wrong signature. For instance:</p> <pre>  <code class="vem">def</code>&nbsp;==(other:&nbsp;<code class="typename">Point</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;Don't&nbsp;do&nbsp;this!</code>
</pre>
      <p>In this case, the user-defined <span class="code">==</span> method is treated as an overloaded variant of the same-named method class <span class="code">Any</span> and the program compiles. However, the behavior of the program would be just as dubious as if you had defined <span class="code">equals</span> with the wrong signature.</p>
      <h4>Pitfall #2: Changing <span class="code">equals</span> without also changing <span class="code">hashCode</span></h4>
      <p>We'll continue to use the example from pitfall #1. If you repeat the comparison of <span class="code">p1</span> and <span class="code">p2a</span> with the latest definition of <span class="code">Point</span>, you will get <span class="code">true</span>, as expected.<a id="i-579193195-1"></a> However, if you repeat the <span class="code">HashSet.contains</span> test, you will probably still get <span class="code">false</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p1,&nbsp;p2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p1:&nbsp;Point&nbsp;=&nbsp;Point@122c1533</code>
  <code class="output">p2:&nbsp;Point&nbsp;=&nbsp;Point@c23d097</code>
  <br>  scala&gt;&nbsp;<code class="typename">collection.mutable.HashSet</code>(p1)&nbsp;contains&nbsp;p2
  <code class="output">res4:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>But this outcome is not 100% certain. You might also get <span class="code">true</span> from the experiment. If you do, you can try with some other points with coordinates 1 and 2. Eventually, you'll get one that is not contained in the set. What goes wrong here is that <span class="code">Point</span> redefined <span class="code">equals</span> without also redefining <span class="code">hashCode</span>.</p>
      <p>Note that the collection in the example here is a <span class="code">HashSet</span>. This means elements of the collection are put in "hash buckets" determined by their hash code. The <span class="code">contains</span> test first determines a hash bucket to look in and then compares the given elements with all elements in that bucket. Now, the last version of class <span class="code">Point</span> did redefine <span class="code">equals</span>, but it did not redefine <span class="code">hashCode</span> at the same time. So <span class="code">hashCode</span> is still what it was in its version in class <span class="code">AnyRef</span>: some transformation of the address of the allocated object.</p>
      <p>The hash codes of <span class="code">p1</span> and <span class="code">p2</span> are almost certainly different, even though the fields of both points are the same. Different hash codes mean, with high probability, different hash buckets in the set. The <span class="code">contains</span> test will look for a matching element in the bucket which corresponds to <span class="code">p2</span>'s hash code. In most cases, point <span class="code">p1</span> will be in another bucket, so it will never be found. <span class="code">p1</span> and <span class="code">p2</span> might also end up by chance in the same hash bucket. In that case the test would return <span class="code">true</span>. The problem is that the last implementation of <span class="code">Point</span><a id="i668953714-1"></a> violated the contract on <span class="code">hashCode</span> as defined for class <span class="code">Any</span>:<a href="#footnotemain30-4">[4]</a></p>
      <p><span style="font-style:italic">If two objects are equal according to the <span class="code">equals</span> method, then calling the <span class="code">hashCode</span> method on each of the two objects must produce the same integer result.</span></p>
      <p>In fact, it's well known in Java that <span class="code">hashCode</span> and <span class="code">equals</span> should always be redefined together. Furthermore, <span class="code">hashCode</span> may only depend on fields that <span class="code">equals</span> depends on. For the <span class="code">Point</span> class, the following would be a suitable definition of <span class="code">hashCode</span>:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(x,&nbsp;y).##
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;that.y&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>&nbsp;
  &nbsp;&nbsp;}
  }
</pre>
      <p>This is just one of many possible implementations of <span class="code">hashCode</span>. Recall that the <span class="code">##</span> method is a shorthand for computing hash codes that works for primitive values, reference types, and <span class="code">null</span>. When invoked on a collection or a tuple, it computes a mixed hash that is sensitive to the hash codes of all the elements in the collection. We'll provide more guidance on writing <span class="code">hashCode</span> later in this chapter.</p>
      <p>Adding <span class="code">hashCode</span> fixes the problems of equality when defining classes like <span class="code">Point</span>; however, there are other trouble spots to watch out for.</p>
      <h4>Pitfall #3: Defining <span class="code">equals</span> in terms of mutable fields</h4>
      <p>Consider the following slight variation of class <span class="code">Point</span>:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">var</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">var</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{&nbsp;<code class="comment">//&nbsp;Problematic</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(x,&nbsp;y).##
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;that.y&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>&nbsp;
  &nbsp;&nbsp;}
  }
</pre>
      <p>The only difference is that the fields <span class="code">x</span> and <span class="code">y</span> are now <span class="code">var</span>s instead of <span class="code">val</span>s.<a id="i-1325523688-1"></a> The <span class="code">equals</span> and <span class="code">hashCode</span> methods are now defined in terms of these mutable fields, so their results change when the fields change. This can have strange effects once you put points in collections:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p:&nbsp;Point&nbsp;=&nbsp;Point@5428bd62</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;coll&nbsp;=&nbsp;<code class="typename">collection.mutable.HashSet</code>(p)
  <code class="output">coll:&nbsp;scala.collection.mutable.HashSet[Point]&nbsp;=&nbsp;</code>
  <code class="output">Set(Point@5428bd62)</code>
  <br>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p
  <code class="output">res5:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>Now, if you change a field in point <span class="code">p</span>, does the collection still contain the point? We'll try it:</p> <pre>  scala&gt;&nbsp;p.x&nbsp;+=&nbsp;<code class="literal">1</code>
  <br>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p
  <code class="output">res7:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>This looks strange. Where did <span class="code">p</span> go? More strangeness results if you check whether the iterator of the set contains <span class="code">p</span>:</p> <pre>  scala&gt;&nbsp;coll.iterator&nbsp;contains&nbsp;p
  <code class="output">res8:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>So here's a set that does not contain <span class="code">p</span>, yet <span class="code">p</span> is among the elements of the set! What happened is that after the change to the <span class="code">x</span> field, the point <span class="code">p</span> ended up in the wrong hash bucket of the set <span class="code">coll</span>. That is, its original hash bucket no longer corresponded to the new value of its hash code. In a manner of speaking, point <span class="code">p</span> "dropped out of sight" in the set <span class="code">coll</span> even though it still belonged to its elements.</p>
      <p>The lesson to be drawn from this example is that when <span class="code">equals</span> and <span class="code">hashCode</span> depend on mutable state, it causes problems for potential users. If you put such objects into collections, you have to be careful to never modify the depended-on state, and this is tricky. If you need a comparison that takes the current state of an object into account, you should usually name it something else, not <span class="code">equals</span>.</p>
      <p>Considering the last definition of <span class="code">Point</span>, it would have been preferable to omit a redefinition of <span class="code">hashCode</span> and name the comparison method <span class="code">equalContents</span> or some other name different from <span class="code">equals</span>. <span class="code">Point</span> would then have inherited the default implementation of <span class="code">equals</span> and <span class="code">hashCode</span>; <span class="code">p</span> would have stayed locatable in <span class="code">coll</span> even after the modification to its <span class="code">x</span> field.</p>
      <h4>Pitfall #4: Failing to define <span class="code">equals</span> as an equivalence relation</h4>
      <p>The contract of the <span class="code">equals</span> method in <span class="code">scala.Any</span> specifies that <span class="code">equals</span> must<a id="i358320206-1"></a> implement an equivalence relation on non-<span class="code">null</span> objects:<a href="#footnotemain30-5">[5]</a></p>
      <div style="font-style:italic">
        <ul>
          <li>It is <span style="font-style:italic">reflexive</span>: For any non-null value <span class="code">x</span> , the expression <span class="code">x.equals(x)</span> should return <span class="code">true</span>. </li>
          <li>It is <span style="font-style:italic">symmetric</span>: For any non-null values <span class="code">x</span> and <span class="code">y</span>, <span class="code">x.equals(y)</span> should return <span class="code">true</span> if and only if <span class="code">y.equals(x)</span> returns <span class="code">true</span>. </li>
          <li>It is <span style="font-style:italic">transitive</span>: For any non-null values <span class="code">x</span>, <span class="code">y</span>, and <span class="code">z</span>, if <span class="code">x.equals(y)</span> returns <span class="code">true</span> and <span class="code">y.equals(z)</span> returns <span class="code">true</span>, then <span class="code">x.equals(z)</span> should return <span class="code">true</span>. </li>
          <li>It is <span style="font-style:italic">consistent</span>: For any non-null values <span class="code">x</span> and <span class="code">y</span>, multiple invocations of <span class="code">x.equals(y)</span> should consistently return <span class="code">true</span> or consistently return <span class="code">false</span>, provided no information used in equals comparisons on the objects is modified. </li>
          <li>For any non-null value <span class="code">x</span>, <span class="code">x.equals(null)</span> should return <span class="code">false</span>.<a id="i-677123658-1"></a> </li>
        </ul>
      </div>
      <p>The definition of <span class="code">equals</span> developed for class <span class="code">Point</span> up to now satisfies the contract for <span class="code">equals</span>. However, things become more complicated once subclasses are considered. Say there is a subclass <span class="code">ColoredPoint</span> of <span class="code">Point</span> that adds a field <span class="code">color</span> of type <span class="code">Color</span>. Assume <span class="code">Color</span> is defined as an enumeration, as presented in <a href="#sec-enums">Section 20.9</a>:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Color</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Enumeration</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;<code class="typename">Red</code>,&nbsp;<code class="typename">Orange</code>,&nbsp;<code class="typename">Yellow</code>,&nbsp;<code class="typename">Green</code>,&nbsp;<code class="typename">Blue</code>,&nbsp;<code class="typename">Indigo</code>,&nbsp;<code class="typename">Violet</code>&nbsp;=&nbsp;<code class="typename">Value</code>
  }
</pre>
      <p><span class="code">ColoredPoint</span> overrides <span class="code">equals</span> to take the new <span class="code">color</span> field into account:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ColoredPoint</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">Color.Value</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Point</code>(x,&nbsp;y)&nbsp;{&nbsp;<code class="comment">//&nbsp;Problem:&nbsp;equals&nbsp;not&nbsp;symmetric</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">ColoredPoint</code>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.color&nbsp;==&nbsp;that.color&nbsp;&amp;&amp;&nbsp;<code class="vem">super</code>.equals(that)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>
      <p>This is what many programmers would likely write.<a id="i-591223748-1"></a> Note that in this case, class <span class="code">ColoredPoint</span> need not override <span class="code">hashCode</span>. Because the new definition of <span class="code">equals</span> on <span class="code">ColoredPoint</span> is stricter than the overridden definition in <span class="code">Point</span> (meaning it equates fewer pairs of objects), the contract for <span class="code">hashCode</span> stays valid. If two colored points are equal, they must have the same coordinates, so their hash codes are guaranteed to be equal as well.</p>
      <p>Taking the class <span class="code">ColoredPoint</span> by itself, its definition of <span class="code">equals</span> looks OK. However, the contract for <span class="code">equals</span> is broken once points and colored points are mixed. Consider:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p:&nbsp;Point&nbsp;=&nbsp;Point@5428bd62</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;cp&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ColoredPoint</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="typename">Color.Red</code>)
  <code class="output">cp:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@5428bd62</code>
  <br>  scala&gt;&nbsp;p&nbsp;equals&nbsp;cp
  <code class="output">res9:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;cp&nbsp;equals&nbsp;p
  <code class="output">res10:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>The comparison "<span class="code">p</span>&nbsp;<span class="code">equals</span>&nbsp;<span class="code">cp</span>" invokes <span class="code">p</span>'s <span class="code">equals</span> method, which is defined in class <span class="code">Point</span>. This method only takes into account the coordinates of the two points. Consequently, the comparison yields <span class="code">true</span>. On the other hand, the comparison "<span class="code">cp</span>&nbsp;<span class="code">equals</span>&nbsp;<span class="code">p</span>" invokes <span class="code">cp</span>'s <span class="code">equals</span> method, which is defined in class <span class="code">ColoredPoint</span>. This method returns <span class="code">false</span> because <span class="code">p</span> is not a <span class="code">ColoredPoint</span>. So the relation defined by <span class="code">equals</span> is not symmetric.</p>
      <p>The loss in symmetry can have unexpected consequences for collections. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="typename">collection.mutable.HashSet[Point]</code>(p)&nbsp;contains&nbsp;cp
  <code class="output">res11:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;<code class="typename">collection.mutable.HashSet[Point]</code>(cp)&nbsp;contains&nbsp;p
  <code class="output">res12:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>Even though <span class="code">p</span> and <span class="code">cp</span> are equal, one <span class="code">contains</span> test succeeds whereas the other one fails:</p>
      <p>How can you change the definition of <span class="code">equals</span> so that it becomes symmetric? Essentially there are two ways. You can either make the relation more general or more strict. Making it more general means that a pair of two objects, <span class="code">x</span> and <span class="code">y</span>, is taken to be equal if either comparing <span class="code">x</span> with <span class="code">y</span> or comparing <span class="code">y</span> with <span class="code">x</span> yields <span class="code">true</span>. Here's code that does this:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ColoredPoint</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">Color.Value</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Point</code>(x,&nbsp;y)&nbsp;{&nbsp;<code class="comment">//&nbsp;Problem:&nbsp;equals&nbsp;not&nbsp;transitive</code>
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">ColoredPoint</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">this</code>.color&nbsp;==&nbsp;that.color)&nbsp;&amp;&amp;&nbsp;<code class="vem">super</code>.equals(that)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;equals&nbsp;<code class="vem">this</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>
      <p>The new definition of <span class="code">equals</span> in <span class="code">ColoredPoint</span> has one more case than the old one: If the <span class="code">other</span> object is a <span class="code">Point</span> but not a <span class="code">ColoredPoint</span>, the method forwards to the <span class="code">equals</span> method of <span class="code">Point</span>. This has the desired effect of making <span class="code">equals</span> symmetric. Now, both "<span class="code">cp</span>&nbsp;<span class="code">equals</span>&nbsp;<span class="code">p</span>" and "<span class="code">p</span>&nbsp;<span class="code">equals</span>&nbsp;<span class="code">cp</span>" result in <span class="code">true</span>. However, the contract for <span class="code">equals</span> is still broken. The problem is that the new relation is no longer transitive!</p>
      <p>Here's a sequence of statements that demonstrates this. Define a point and two colored points of different colors, all at the same position:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;redp&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ColoredPoint</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="typename">Color.Red</code>)
  <code class="output">redp:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@5428bd62</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;bluep&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ColoredPoint</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="typename">Color.Blue</code>)
  <code class="output">bluep:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@5428bd62</code>
</pre>
      <p>Taken individually, <span class="code">redp</span> is equal to <span class="code">p</span> and <span class="code">p</span> is equal to <span class="code">bluep</span>:</p> <pre>  scala&gt;&nbsp;redp&nbsp;==&nbsp;p
  <code class="output">res13:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;p&nbsp;==&nbsp;bluep
  <code class="output">res14:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>However, comparing <span class="code">redp</span> and <span class="code">bluep</span> yields <span class="code">false</span>:</p> <pre>  scala&gt;&nbsp;redp&nbsp;==&nbsp;bluep
  <code class="output">res15:&nbsp;Boolean&nbsp;=&nbsp;false</code>
</pre>
      <p>Hence, the transitivity clause of the <span class="code">equals</span>'s contract is violated.</p>
      <p>Making the <span class="code">equals</span> relation more general seems to lead to a dead end. We'll try to make it stricter instead. One way to make <span class="code">equals</span> stricter is to always treat objects of different classes as different. This could be achieved by modifying the <span class="code">equals</span> methods in classes <span class="code">Point</span> and <span class="code">ColoredPoint</span>. In class <span class="code">Point</span>, you could add an extra comparison that checks whether the run-time class of the other <span class="code">Point</span> is exactly the same as this <span class="code">Point</span>'s class:</p> <pre>  <code class="comment">//&nbsp;A&nbsp;technically&nbsp;valid,&nbsp;but&nbsp;unsatisfying,&nbsp;equals&nbsp;method</code>
  <code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(x,&nbsp;y).##
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.y&nbsp;==&nbsp;that.y&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.getClass&nbsp;==&nbsp;that.getClass
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>
      <p>You can then revert class <span class="code">ColoredPoint</span>'s implementation back to the version that previously had violated the symmetry requirement:<a href="#footnotemain30-6">[6]</a></p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ColoredPoint</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">Color.Value</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Point</code>(x,&nbsp;y)&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">ColoredPoint</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">this</code>.color&nbsp;==&nbsp;that.color)&nbsp;&amp;&amp;&nbsp;<code class="vem">super</code>.equals(that)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>
      <p>Here, an instance of class <span class="code">Point</span> is considered to be equal to some other instance of the same class, only if the objects have the same coordinates and they have the same run-time class, meaning <span class="code">getClass</span> on either object returns the same value. The new definitions satisfy symmetry and transitivity because now every comparison between objects of different classes yields <span class="code">false</span>. So a colored point can never be equal to a point. This convention looks reasonable, but one could argue that the new definition is too strict.</p>
      <p>Consider the following slightly roundabout way to define a point at coordinates <span class="code">(1,</span>&nbsp;<span class="code">2)</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;pAnon&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">1</code>)&nbsp;{&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;}
  <code class="output">pAnon:&nbsp;Point&nbsp;=&nbsp;$anon$1@5428bd62</code>
</pre>
      <p>Is <span class="code">pAnon</span> equal to <span class="code">p</span>? The answer is no because the <span class="code">java.lang.Class</span> objects associated with <span class="code">p</span> and <span class="code">pAnon</span> are different. For <span class="code">p</span> it is <span class="code">Point</span>, whereas for <span class="code">pAnon</span> it is an anonymous subclass of <span class="code">Point</span>.<a id="i-8484895-1"></a> But clearly, <span class="code">pAnon</span> is just another point at coordinates <span class="code">(1,</span>&nbsp;<span class="code">2)</span>. It does not seem reasonable to treat it as being different from <span class="code">p</span>.</p>
      <p>So it seems we are stuck. Is there a sane way to redefine equality on several levels of the class hierarchy while keeping its contract? In fact, there is such a way, but it requires one more method to redefine together with <span class="code">equals</span> and <span class="code">hashCode</span>. The idea is that as soon as a class redefines <span class="code">equals</span> (and <span class="code">hashCode</span>), it should also explicitly state that objects of this class are never equal to objects of some superclass that implement a different equality method. This is achieved by adding a method <span class="code">canEqual</span> to every class that redefines <span class="code">equals</span>. Here's the method's signature:</p> <pre>  <code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>
</pre>
      <p>The method should return <span class="code">true</span> if the <span class="code">other</span> object is an instance of the class in which <span class="code">canEqual</span> is (re)defined, <span class="code">false</span> otherwise. It is called from <span class="code">equals</span> to make sure that the objects are comparable both ways. <a href="#lst-satisfying-equals">Listing 30.1</a> shows a new (and final) implementation of class <span class="code">Point</span> along these lines: <a id="lst-satisfying-equals"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Point</code>(<code class="vem">val</code>&nbsp;x:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;y:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(x,&nbsp;y).##
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Point</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="vem">this</code>.x&nbsp;==&nbsp;that.x)&nbsp;&amp;&amp;&nbsp;(<code class="vem">this</code>.y&nbsp;==&nbsp;that.y)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other.isInstanceOf[<code class="typename">Point</code>]
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 30.1 - A superclass <span class="code">equals</span> method that calls <span class="code">canEqual</span>.</h5>
      <p>The <span class="code">equals</span> method in this version of class <span class="code">Point</span> contains the additional requirement that the other object <em>can equal</em> this one, as determined by the <span class="code">canEqual</span> method. The implementation of <span class="code">canEqual</span> in <span class="code">Point</span> states that all instances of <span class="code">Point</span> can be equal.</p>
      <p><a href="#lst-subclass-can-equal">Listing 30.2</a> shows the corresponding implementation of <span class="code">ColoredPoint</span>. <a id="lst-subclass-can-equal"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ColoredPoint</code>(x:&nbsp;<code class="typename">Int</code>,&nbsp;y:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;color:&nbsp;<code class="typename">Color.Value</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Point</code>(x,&nbsp;y)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode&nbsp;=&nbsp;(<code class="vem">super</code>.hashCode,&nbsp;color).##
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">ColoredPoint</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">super</code>.equals(that)&nbsp;&amp;&amp;&nbsp;<code class="vem">this</code>.color&nbsp;==&nbsp;that.color
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.isInstanceOf[<code class="typename">ColoredPoint</code>]
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 30.2 - A subclass <span class="code">equals</span> method that calls <span class="code">canEqual</span>.</h5>
      <p>It can be shown that the new definition of <span class="code">Point</span> and <span class="code">ColoredPoint</span> keeps the contract of <span class="code">equals</span>. Equality is symmetric and transitive. Comparing a <span class="code">Point</span> to a <span class="code">ColoredPoint</span> always yields <span class="code">false</span>. Indeed, for any point <span class="code">p</span> and colored point <span class="code">cp</span>, "<span class="code">p</span>&nbsp;<span class="code">equals</span>&nbsp;<span class="code">cp</span>" will return <span class="code">false</span> because "<span class="code">cp</span>&nbsp;<span class="code">canEqual</span>&nbsp;<span class="code">p</span>" will return <span class="code">false</span>. The reverse comparison, "<span class="code">cp</span>&nbsp;<span class="code">equals</span>&nbsp;<span class="code">p</span>", will also return <span class="code">false</span> because <span class="code">p</span> is not a <span class="code">ColoredPoint</span>, so the first pattern match in the body of <span class="code">equals</span> in <span class="code">ColoredPoint</span> will fail.</p>
      <p>On the other hand, instances of different subclasses of <span class="code">Point</span> can be equal, as long as none of the classes redefines the equality method. For instance, with the new class definitions, the comparison of <span class="code">p</span> and <span class="code">pAnon</span> would yield true. Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;p&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  <code class="output">p:&nbsp;Point&nbsp;=&nbsp;Point@5428bd62</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;cp&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ColoredPoint</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="typename">Color.Indigo</code>)
  <code class="output">cp:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@e6230d8f</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;pAnon&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Point</code>(<code class="literal">1</code>,&nbsp;<code class="literal">1</code>)&nbsp;{&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;y&nbsp;=&nbsp;<code class="literal">2</code>&nbsp;}
  <code class="output">pAnon:&nbsp;Point&nbsp;=&nbsp;$anon$1@5428bd62</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;coll&nbsp;=&nbsp;<code class="typename">List</code>(p)
  <code class="output">coll:&nbsp;List[Point]&nbsp;=&nbsp;List(Point@5428bd62)</code>
  <br>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p&nbsp;
  <code class="output">res16:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;cp
  <code class="output">res17:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;pAnon
  <code class="output">res18:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>These examples demonstrate that if a superclass <span class="code">equals</span> implementation defines and calls <span class="code">canEqual</span>, then programmers who implement subclasses can decide whether or not their subclasses may be equal to instances of the superclass. Because <span class="code">ColoredPoint</span> overrides <span class="code">canEqual</span>, for example, a colored point may never be equal to a plain-old point. But because the anonymous subclass referenced from <span class="code">pAnon</span> does not override <span class="code">canEqual</span>, its instance can be equal to a <span class="code">Point</span> instance.</p>
      <p>One potential criticism of the <span class="code">canEqual</span> approach is that it violates the Liskov Substitution Principle<a id="i1527452340-1"></a>. For example, the technique of implementing <span class="code">equals</span> by comparing run-time classes, which led to the inability to define a subclass whose instances can equal instances of the superclass, has been described as a violation of the LSP.<a href="#footnotemain30-7">[7]</a> The LSP states you should be able to use (substitute) a subclass instance where a superclass instance is required.</p>
      <p>In the previous example, however, "coll contains cp" returned <span class="code">false</span> even though <span class="code">cp</span>'s <span class="code">x</span> and <span class="code">y</span> values matched those of the point in the collection. Thus, it may seem like a violation of the LSP because you can't use a <span class="code">ColoredPoint</span> here where a <span class="code">Point</span> is expected. We believe this is the wrong interpretation, because the LSP doesn't require that a subclass behaves identically to its superclass, just that it behaves in a way that fulfills the contract of its superclass.</p>
      <p>The problem with writing an <span class="code">equals</span> method that compares run-time classes is not that it violates the LSP, but that it doesn't give you a way to create a subclass whose instances can equal superclass instances. For example, had we used the run-time class technique in the previous example, "<span class="code">coll</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">pAnon</span>" would have returned <span class="code">false</span>, and that's not what we wanted. By contrast, we really did want "<span class="code">coll</span>&nbsp;<span class="code">contains</span>&nbsp;<span class="code">cp</span>" to return <span class="code">false</span>, because by overriding <span class="code">equals</span> in <span class="code">ColoredPoint</span>, we were basically saying that an indigo-colored point at coordinates (1, 2) is <em>not the same thing</em> as an uncolored point at (1, 2). Thus, in the previous example we were able to pass two different <span class="code">Point</span> subclass instances to the collection's <span class="code">contains</span> method, and we got back two different answers, both correct.</p>
      <h3>30.3 Defining equality for parameterized types</h3>
      <p>The <span class="code">equals</span> methods in the previous examples all started with a pattern match that tested whether the type of the operand conformed to the type of the class containing the <span class="code">equals</span> method.<a id="i511396682-1"></a> When classes are parameterized, this scheme needs to be adapted a little bit.</p>
      <p>As an example, consider binary trees. The class hierarchy shown in <a href="#lst-binary-tree">Listing 30.3</a> defines an abstract class <span class="code">Tree</span> for a binary tree, with two alternative implementations: an <span class="code">EmptyTree</span> object and a <span class="code">Branch</span> class representing non-empty trees. A non-empty tree is made up of some element <span class="code">elem</span>, and a <span class="code">left</span> and <span class="code">right</span> child tree. The type of its element is given by a type parameter <span class="code">T</span>.</p>
      <p><a id="lst-binary-tree"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Tree[+T]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem:&nbsp;T
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;left:&nbsp;<code class="typename">Tree[T]</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;right:&nbsp;<code class="typename">Tree[T]</code>
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">EmptyTree</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree[Nothing]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;elem&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">NoSuchElementException</code>(<code class="quotedstring">"EmptyTree.elem"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;left&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">NoSuchElementException</code>(<code class="quotedstring">"EmptyTree.left"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;right&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">NoSuchElementException</code>(<code class="quotedstring">"EmptyTree.right"</code>)
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Branch[+T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;elem:&nbsp;T,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;left:&nbsp;<code class="typename">Tree[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;right:&nbsp;<code class="typename">Tree[T]</code>
  &nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree[T]</code>
</pre>
      <h5>Listing 30.3 - Hierarchy for binary trees.</h5>
      <p>We'll now add <span class="code">equals</span> and <span class="code">hashCode</span> methods to these classes. For class <span class="code">Tree</span> itself there's nothing to do because we assume that these methods are implemented separately for each implementation of the abstract class. For object <span class="code">EmptyTree</span>, there's still nothing to do because the default implementations of <span class="code">equals</span> and <span class="code">hashCode</span> that <span class="code">EmptyTree</span> inherits from <span class="code">AnyRef</span> work just fine. After all, an <span class="code">EmptyTree</span> is only equal to itself, so equality should be reference equality, which is what's inherited from <span class="code">AnyRef</span>.</p>
      <p>But adding <span class="code">equals</span> and <span class="code">hashCode</span> to <span class="code">Branch</span> requires some work. A <span class="code">Branch</span> value should only be equal to other <span class="code">Branch</span> values, and only if the two values have equal <span class="code">elem</span>, <span class="code">left</span> and <span class="code">right</span> fields. It's natural to apply the schema for <span class="code">equals</span> that was developed in the previous sections of this chapter. This would give you:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Branch[T]</code>(
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;elem:&nbsp;T,
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;left:&nbsp;<code class="typename">Tree[T]</code>,
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;right:&nbsp;<code class="typename">Tree[T]</code>
  )&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree[T]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[T]</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.left&nbsp;==&nbsp;that.left&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.right&nbsp;==&nbsp;that.right
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;}
  }
</pre>
      <p>Compiling this example, however, gives an indication that "<span class="code">unchecked</span>" warnings occurred. Compiling again with the <span class="code">-unchecked</span> option reveals the following problem:<a id="i-1285804133-1"></a></p> <pre>  &nbsp;$&nbsp;fsc&nbsp;-unchecked&nbsp;Tree.scala
  <code class="output">Tree.scala:14:&nbsp;warning:&nbsp;non&nbsp;variable&nbsp;type-argument&nbsp;T&nbsp;in&nbsp;type&nbsp;</code>
  <code class="output">pattern&nbsp;is&nbsp;unchecked&nbsp;since&nbsp;it&nbsp;is&nbsp;eliminated&nbsp;by&nbsp;erasure</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;that:&nbsp;Branch[T]&nbsp;=&gt;&nbsp;this.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>As the warning says, there is a pattern match against a <span class="code">Branch[T]</span> type, yet the system can only check that the <span class="code">other</span> reference is (some kind of) <span class="code">Branch</span>; it cannot check that the element type of the tree is <span class="code">T</span>. You encountered in <a href="#chap-type-parameterization">Chapter 19</a> the reason for this: Element types of parameterized types are eliminated by the compiler's erasure phase; they are not available to be inspected at run-time.<a id="i-237149939-1"></a><a id="i101369192-1"></a><a id="i-735891161-1"></a></p>
      <p>So what can you do? Fortunately, it turns out that you need not necessarily check that two <span class="code">Branch</span>es have the same element types when comparing them. It's quite possible that two <span class="code">Branch</span>es with different element types are equal, as long as their fields are the same. A simple example of this would be the <span class="code">Branch</span> that consists of a single <span class="code">Nil</span> element and two empty subtrees. It's plausible to consider any two such <span class="code">Branch</span>es to be equal, no matter what static types they have:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;b1&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Branch[List[String]]</code>(<code class="typename">Nil</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">EmptyTree</code>,&nbsp;<code class="typename">EmptyTree</code>)
  <code class="output">b1:&nbsp;Branch[List[String]]&nbsp;=&nbsp;Branch@9d5fa4f</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;b2&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Branch[List[Int]]</code>(<code class="typename">Nil</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">EmptyTree</code>,&nbsp;<code class="typename">EmptyTree</code>)
  <code class="output">b2:&nbsp;Branch[List[Int]]&nbsp;=&nbsp;Branch@56cdfc29</code>
  <br>  scala&gt;&nbsp;b1&nbsp;==&nbsp;b2
  <code class="output">res19:&nbsp;Boolean&nbsp;=&nbsp;true</code>
</pre>
      <p>The positive result of the comparison above was obtained with the implementation of <span class="code">equals</span> on <span class="code">Branch</span> shown previously. This demonstrates that the element type of the <span class="code">Branch</span> was not checked—if it had been checked, the result would have been <span class="code">false</span>.</p>
      <p>We can disagree on which of the two possible outcomes of the comparison would be more natural. In the end, this depends on the mental model of how classes are represented. In a model where type-parameters are present only at compile-time, it's natural to consider the two <span class="code">Branch</span> values <span class="code">b1</span> and <span class="code">b2</span> to be equal. In an alternative model where a type parameter forms part of an object's value, it's equally natural to consider them different. Since Scala adopts the type erasure model, type parameters are not preserved at run time, so that <span class="code">b1</span> and <span class="code">b2</span> are naturally considered to be equal.</p>
      <p>There's only a tiny change needed to formulate an <span class="code">equals</span> method that does not produce an <span class="code">unchecked</span> warning. Instead of an element type <span class="code">T</span>, use a lower case letter, such as <span class="code">t</span>:</p> <pre>  <code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[t]</code>&nbsp;=&gt;&nbsp;<code class="vem">this</code>.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.left&nbsp;==&nbsp;that.left&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.right&nbsp;==&nbsp;that.right
</pre>
      <p>Recall from <a href="#sec-kinds-of-patterns">Section 15.2</a> that a type parameter in a pattern starting with a lower-case letter represents an unknown type. Now the pattern match:</p> <pre>  <code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[t]</code>&nbsp;=&gt;&nbsp;
</pre>
      <p>will succeed for <span class="code">Branch</span> values of any type. The type parameter <span class="code">t</span> represents the unknown element type of the <span class="code">Branch</span>. It can also be replaced by an underscore, as in the following case, which is equivalent to the previous one:</p> <pre>  <code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[_]</code>&nbsp;=&gt;
</pre>
      <p>The only thing that remains is to define for class <span class="code">Branch</span> the other two methods, <span class="code">hashCode</span> and <span class="code">canEqual</span>, which go with <span class="code">equals</span>. Here's a possible implementation of <span class="code">hashCode</span>:</p> <pre>  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(elem,&nbsp;left,&nbsp;right).##
</pre>
      <p>This is only one of many possible implementations. As shown previously, the principle is to take <span class="code">hashCode</span> values of all fields and combine them. Here's an implementation of method <span class="code">canEqual</span> in class <span class="code">Branch</span>:</p> <pre>  <code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[_]</code>&nbsp;=&gt;&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  }
</pre>
      <p>The implementation of the <span class="code">canEqual</span> method used a typed pattern match. It would also be possible to formulate it with <span class="code">isInstanceOf</span>:</p> <pre>  <code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other.isInstanceOf[<code class="typename">Branch[_]</code>]
</pre>
      <p>If you feel like nit-picking—and we encourage you to do so!—you might wonder what the occurrence of the underscore in the type above signifies. After all, <span class="code">Branch[_]</span> is technically a type parameter of a method, not a type pattern. So how is it possible to leave some parts of it undefined?<a id="i1628802775-1"></a></p>
      <p>The answer to this question is discussed in the next chapter. <span class="code">Branch[_]</span> is shorthand for a so-called <span style="font-style:italic">wildcard type</span>,<a id="i1056209851-1"></a><a id="i165566131-1"></a> which is, roughly speaking, a type with some unknown parts in it. So even though technically the underscore stands for two different things in a pattern match and in a type parameter of a method call, in essence, the meaning is the same: It lets you label something that is unknown. The final version of <span class="code">Branch</span> is shown in <a href="#lst-a-good-branch">Listing 30.4</a>.</p>
      <p><a id="lst-a-good-branch"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Branch[T]</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;elem:&nbsp;T,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;left:&nbsp;<code class="typename">Tree[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;right:&nbsp;<code class="typename">Tree[T]</code>
  &nbsp;&nbsp;)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Tree[T]</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Branch[_]</code>&nbsp;=&gt;&nbsp;(that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.left&nbsp;==&nbsp;that.left&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">this</code>.right&nbsp;==&nbsp;that.right
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>)&nbsp;=&nbsp;other.isInstanceOf[<code class="typename">Branch[_]</code>]
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(elem,&nbsp;left,&nbsp;right).##
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 30.4 - A parameterized type with <span class="code">equals</span> and <span class="code">hashCode</span>.</h5>
      <h3>30.4 Recipes for <span class="code">equals</span> and <span class="code">hashCode</span></h3>
      <p>In this section, we'll provide step-by-step recipes for creating <span class="code">equals</span> and <span class="code">hashCode</span> methods that should suffice for most situations. As an illustration, we'll use the methods of class <span class="code">Rational</span>, shown in <a href="#lst-rational-equals-hashcode">Listing 30.5</a>.</p>
      <p>To create this class, we removed the mathematical operator methods from the version of class <span class="code">Rational</span> shown in <a href="#lst-overloaded-methods">Listing 6.5</a> <a href="#lst-overloaded-methods">here</a>. We also made a minor enhancement to <span class="code">toString</span>, and modified the initializers of <span class="code">numer</span> and <span class="code">denom</span> to normalize all fractions to have a positive denominator (<i>i.e.</i>, to transform <sup>1</sup>/<sub>-2</sub> to <sup>-1</sup>/<sub>2</sub>).</p>
      <h4>Recipe for <span class="code">equals</span></h4>
      <p>Here's the recipe for overriding <span class="code">equals</span>:<a id="i-145701109-1"></a></p>
      <ol>
        <li>To override <span class="code">equals</span> in a non-final class, create a <span class="code">canEqual</span> method. If the inherited definition of <span class="code">equals</span> is from <span class="code">AnyRef</span> (that is, <span class="code">equals</span> was not redefined higher up in the class hierarchy), the definition of <span class="code">canEqual</span> should be new; otherwise, it will override a previous definition of a method with the same name. The only exception to this requirement is for final classes that redefine the <span class="code">equals</span> method inherited from <span class="code">AnyRef</span>. For them the subclass anomalies described in <a href="#sec-writing-an-equality-method">Section 30.2</a> cannot arise; consequently they need not define <span class="code">canEqual</span>. The type of object passed to <span class="code">canEqual</span> should be <span class="code">Any</span>: <pre>  <code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
</pre> </li>
        <li> The <span class="code">canEqual</span> method should yield <span class="code">true</span> if the argument object is an instance of the current class (<i>i.e.</i>, the class in which <span class="code">canEqual</span> is defined), and <span class="code">false</span> otherwise: <pre>  other.isInstanceOf[<code class="typename">Rational</code>]
</pre> </li>
        <li>In the <span class="code">equals</span> method, make sure you declare the type of the object passed as an <span class="code">Any</span>: <pre>  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
</pre> </li>
        <li> Write the body of the <span class="code">equals</span> method as a single <span class="code">match</span> expression. The selector of the <span class="code">match</span> should be the object passed to <span class="code">equals</span>: <pre>  other&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;...</code>
  }
</pre> </li>
        <li> The <span class="code">match</span> expression should have two cases. The first case should declare a typed pattern for the type of the class on which you're defining the <span class="code">equals</span> method: <pre>  <code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Rational</code>&nbsp;=&gt;
</pre> </li>
        <li> In the body of this case, write an expression that logical-ands together the individual expressions that must be true for the objects to be equal. If the <span class="code">equals</span> method you are overriding is not that of <span class="code">AnyRef</span>, you will most likely want to include an invocation of the superclass's <span class="code">equals</span> method: <pre>  <code class="vem">super</code>.equals(that)&nbsp;&amp;&amp;
</pre> <p>If you are defining <span class="code">equals</span> for a class that first introduced <span class="code">canEqual</span>, you should invoke <span class="code">canEqual</span> on the argument to the equality method, passing <span class="code">this</span> as the argument:</p> <pre>  (that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;
</pre> <p>Overriding redefinitions of <span class="code">equals</span> should also include the <span class="code">canEqual</span> invocation, unless they contain a call to <span class="code">super.equals</span>. In the latter case, the <span class="code">canEqual</span> test will already be done by the superclass call. Lastly, for each field relevant to equality, verify that the field in this object is equal to the corresponding field in the passed object:</p> <pre>  numer&nbsp;==&nbsp;that.numer&nbsp;&amp;&amp;
  denom&nbsp;==&nbsp;that.denom
</pre> </li>
        <li> For the second case, use a wildcard pattern that yields false: <pre>  <code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
</pre> </li>
      </ol>
      <p>If you adhere to this recipe for <span class="code">equals</span>, equality is guaranteed to be an equivalence relation, as is required by the <span class="code">equals</span> contract.</p>
      <p><a id="lst-rational-equals-hashcode"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Rational</code>(n:&nbsp;<code class="typename">Int</code>,&nbsp;d:&nbsp;<code class="typename">Int</code>)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<code class="literal">0</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;numer&nbsp;=&nbsp;(<code class="vem">if</code>&nbsp;(d&nbsp;&lt;&nbsp;<code class="literal">0</code>)&nbsp;-n&nbsp;<code class="vem">else</code>&nbsp;n)&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;denom&nbsp;=&nbsp;d.abs&nbsp;/&nbsp;g
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;gcd(a:&nbsp;<code class="typename">Int</code>,&nbsp;b:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(b&nbsp;==&nbsp;<code class="literal">0</code>)&nbsp;a&nbsp;<code class="vem">else</code>&nbsp;gcd(b,&nbsp;a&nbsp;<code class="texttt">%</code>&nbsp;b)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;equals(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other&nbsp;<code class="vem">match</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;that:&nbsp;<code class="typename">Rational</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(that&nbsp;canEqual&nbsp;<code class="vem">this</code>)&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;==&nbsp;that.numer&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;==&nbsp;that.denom
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="vem">false</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;canEqual(other:&nbsp;<code class="typename">Any</code>):&nbsp;<code class="typename">Boolean</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.isInstanceOf[<code class="typename">Rational</code>]
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(numer,&nbsp;denom).##
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(denom&nbsp;==&nbsp;<code class="literal">1</code>)&nbsp;numer.toString&nbsp;<code class="vem">else</code>&nbsp;s<code class="quotedstring">"$numer/$denom"</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 30.5 - Class <span class="code">Rational</span> with <span class="code">equals</span> and <span class="code">hashCode</span>.</h5>
      <h4>Recipe for <span class="code">hashCode</span></h4>
      <p>For <span class="code">hashCode</span>, you can usually achieve satisfactory results if you use the following recipe, which<a id="i-1457981337-1"></a> is similar to a recipe recommended for Java classes in <em>Effective Java</em>.<a href="#footnotemain30-8">[8]</a> Include in the calculation each field in your object that is used to determine equality in the <span class="code">equals</span> method (the "relevant" fields). Make a tuple containing the values of all those fields. Then, invoke <span class="code">##</span> on the resulting tuple.</p>
      <p>For example, to implement the hash code for an object that has five relevant fields named <span class="code">a</span>, <span class="code">b</span>, <span class="code">c</span>, <span class="code">d</span>, and <span class="code">e</span>, you would write:</p> <pre>  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e).##
</pre>
      <p>If the <span class="code">equals</span> method invokes <span class="code">super.equals(that)</span> as part of its calculation, you should start your <span class="code">hashCode</span> calculation with an invocation of <span class="code">super.hashCode</span>. For example, had <span class="code">Rational</span>'s <span class="code">equals</span> method invoked <span class="code">super.equals(that)</span>, its <span class="code">hashCode</span> would have been:</p> <pre>  <code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(<code class="vem">super</code>.hashCode,&nbsp;numer,&nbsp;denom).##
</pre>
      <p>One thing to keep in mind as you write <span class="code">hashCode</span> methods using this approach is that your hash code will only be as good as the hash codes you build out of it, namely the hash codes you obtain by calling <span class="code">hashCode</span> on the relevant fields of your object. Sometimes you may need to do something extra besides just calling <span class="code">hashCode</span> on the field to get a useful hash code for that field. For example, if one of your fields is a collection, you probably want a hash code for that field that is based on all the elements contained in the collection. If the field is a <span class="code">Vector</span>, <span class="code">List</span>, <span class="code">Set</span>, <span class="code">Map</span>, or tuple, you can simply include it in the list of items you are hashing over, because <span class="code">equals</span> and <span class="code">hashCode</span> are overridden in those classes to take into account the contained elements. However the same is not true for <span class="code">Array</span>s, which do not take elements into account when calculating a hash code. Thus for an array, you should treat each element of the array like an individual field of your object, calling <span class="code">##</span> on each element explicitly or passing the array to one of the <span class="code">hashCode</span> methods in singleton object <span class="code">java.util.Arrays</span>.</p>
      <p>Lastly, if you find that a particular hash code calculation is harming the performance of your program, consider caching the hash code. If the object is immutable, you can calculate the hash code when the object is created and store it in a field. You can do this by simply overriding <span class="code">hashCode</span> with a <span class="code">val</span> instead of a <span class="code">def</span>, like this:<a id="i1757872331-1"></a></p> <pre>  <code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;hashCode:&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;(numer,&nbsp;denom).##
</pre>
      <p>This approach trades off memory for computation time, because each instance of the immutable class will have one more field to hold the cached hash code value.</p>
      <h3>30.5 Conclusion</h3>
      <p>In retrospect, defining a correct implementation of <span class="code">equals</span> has been surprisingly subtle. You must be careful about the type signature; you must override <span class="code">hashCode</span>; you should avoid dependencies on mutable state; and you should implement and use a <span class="code">canEqual</span> method if your class is non-final.</p>
      <p>Given how difficult it is to implement a correct equality method, you might prefer to define your classes of comparable objects as case classes. That way, the Scala compiler will add <span class="code">equals</span> and <span class="code">hashCode</span> methods with the right properties automatically.</p>
      <hr>
      <h4>Footnotes for Chapter 30:</h4>
      <p><a id="footnotemain30-1"></a>[1] Vaziri, <i>et. al.</i>, "Declarative Object Identity Using Relation Types" <a href="#vaziri-tip-2007">[Vaz07]</a></p>
      <p><a id="footnotemain30-2"></a>[2] All but the third pitfall are described in the context of Java in the book, <em>Effective Java Second Edition</em>, by Joshua Bloch.<a id="i-64318620-1"></a><a id="i186753339-1"></a> <a href="#bloch-effective-java">[Blo08]</a></p>
      <p><a id="footnotemain30-3"></a>[3] If you write a lot of Java, you might expect the argument to this method to be type <span class="code">Object</span> instead of type <span class="code">Any</span>. Don't worry about it; it is the same <span class="code">equals</span> method. The compiler simply makes it appear to have type <span class="code">Any</span>.</p>
      <p><a id="footnotemain30-4"></a>[4] The text of <span class="code">Any</span>'s <span class="code">hashCode</span> contract is inspired by the Javadoc documentation of class <span class="code">java.lang.Object</span>.</p>
      <p><a id="footnotemain30-5"></a>[5] As with <span class="code">hashCode</span>, <span class="code">Any</span>'s <span class="code">equals</span> method contract is based on <span class="code">java.lang.Object</span>'s <span class="code">equals</span> method contract.</p>
      <p><a id="footnotemain30-6"></a>[6] Given the new implementation of <span class="code">equals</span> in <span class="code">Point</span>, this version of <span class="code">ColoredPoint</span> no longer violates the symmetry requirement.</p>
      <p><a id="footnotemain30-7"></a>[7] Bloch, <em>Effective Java Second Edition</em>, p. 39 <a href="#bloch-effective-java">[Blo08]</a><a id="i-64318620-2"></a><a id="i166435877-1"></a></p>
      <p><a id="footnotemain30-8"></a>[8] Bloch, <em>Effective Java Second Edition</em>. <a href="#bloch-effective-java">[Blo08]</a><a id="i-64318620-3"></a><a id="i166435877-2"></a></p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-combining-scala-and-java">Chapter 31</a></h2>
      <h1>Combining Scala and Java</h1>
      <p>Scala code is often used in tandem with large Java programs and frameworks.<a id="i373161214-1"></a><a id="i1128780868-2"></a> Since Scala is highly compatible with Java, most of the time you can combine the languages without worrying very much. For example, standard frameworks, such as Swing, Servlets, and JUnit, are known to work just fine with Scala. Nonetheless, from time to time, you will run into some issue combining Java and Scala.</p>
      <p>This chapter describes two aspects of combining Java and Scala. First, it discusses how Scala is translated to Java, which is especially important if you call Scala code from Java. Second, it discusses the use of Java annotations in Scala, an important feature if you want to use Scala with an existing Java framework.</p>
      <h3>31.1 Using Scala from Java</h3>
      <p>Most of the time you can think of Scala at the source code level. However, you will have a richer understanding of how the system works if you know something about its translation. Further, if you call Scala code from Java, you will need to know what Scala code looks like from a Java point of view.</p>
      <h4>General rules</h4>
      <p>Scala is implemented as a translation to standard Java bytecodes<a id="i-1806853862-1"></a>. As much as possible, Scala features map directly onto the equivalent Java features. For example, Scala classes, methods, strings, and exceptions are all compiled to the same in Java bytecode as their Java counterparts.</p>
      <p>To make this happen required an occasional hard choice in the design of Scala. For example, it might have been nice to resolve overloaded methods at run time, using run-time types, rather than at compile time. Such a design would break with Java's, however, making it much trickier to mesh Java and Scala. In this case, Scala stays with Java's overloading resolution, and thus Scala methods and method calls can map directly to Java methods and method calls.</p>
      <p>Scala has its own design for other features. For example, traits have no equivalent in Java. Similarly, while both Scala and Java have generic types, the details of the two systems clash. For language features like these, Scala code cannot be mapped directly to a Java construct, so it must be encoded using some combination of the structures Java does have.</p>
      <p>For these features that are mapped indirectly, the encoding is not fixed. There is an ongoing effort to make the translations as simple as possible so, by the time you read this, some details may be different than at the time of writing. You can find out what translation your current Scala compiler uses by examining the "<span class="texttt">.class</span>" files with tools like <span class="texttt">javap</span>.</p>
      <p>Those are the general rules. Consider now some special cases.</p>
      <h4>Value types</h4>
      <p>A value type like <span class="code">Int</span> can be translated in two different ways to Java.<a id="i840866566-1"></a> Whenever possible, the compiler translates a Scala <span class="code">Int</span> to a Java <span class="code">int</span> to get better performance.<a id="i884498802-4"></a> Sometimes this is not possible, though, because the compiler is not sure whether it is translating an <span class="code">Int</span> or some other data type. For example, a particular <span class="code">Array[Any]</span> might hold only <span class="code">Int</span>s, but the compiler has no way to be sure.</p>
      <p>In such cases, where the compiler is unsure whether an object is a value type or not, the compiler uses objects and relies on wrapper classes. For example, wrapper classes such as <span class="code">java.lang.Integer</span> allow a value type to be wrapped inside a Java object and thereby manipulated by code that needs objects.<a href="#footnotemain31-1">[1]</a></p>
      <h4>Singleton objects</h4>
      <p>Java has no exact equivalent to a singleton object, but it does have static methods.<a id="i-1734369148-1"></a> The Scala translation of singleton objects uses a combination of static and instance methods.<a id="i-855208314-1"></a> For every Scala singleton object, the compiler will create a Java class for the object with a dollar sign added to the end. For a singleton object named <span class="code">App</span>, the compiler produces a Java class named <span class="code">App$</span>. This class has all the methods and fields of the Scala singleton object. The Java class also has a single static field named <span class="code">MODULE$</span> to hold the one instance of the class that is created at run time.</p>
      <p>As a full example, suppose you compile the following singleton object:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">App</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"Hello,&nbsp;world!"</code>)
  &nbsp;&nbsp;}
  }
</pre>
      <p>Scala will generate a Java <span class="code">App$</span> class with the following fields and methods:</p> <pre>  $&nbsp;javap&nbsp;<code class="typename">App</code>$
  <code class="output">Compiled&nbsp;from&nbsp;"App.scala"</code>
  <code class="output">public&nbsp;final&nbsp;class&nbsp;App$&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;App$&nbsp;MODULE$;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;{};</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;main(java.lang.String[]);</code>
  <code class="output">}</code>
</pre>
      <p>That's the translation for the general case. An important special case is if you have a "standalone" singleton object, one which does not come with a class of the same name. For example, you might have a singleton object named <span class="code">App</span>, and not have any class named <span class="code">App</span>. In that case, the compiler will create a Java class named <span class="code">App</span> that has a static forwarder method for each method of the Scala singleton object:</p> <pre>  $&nbsp;javap&nbsp;<code class="typename">App</code>
  <code class="output">Compiled&nbsp;from&nbsp;"App.scala"</code>
  <code class="output">public&nbsp;class&nbsp;App&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(java.lang.String[]);</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;App();</code>
  <code class="output">}</code>
</pre>
      <p>To contrast, if you did have a class named <span class="code">App</span>, Scala would create a corresponding Java <span class="code">App</span> class to hold the members of the <span class="code">App</span> class you defined. In that case it would not add any forwarding methods for the same-named singleton object, and Java code would have to access the singleton via the <span class="code">MODULE$</span> field.</p>
      <h4>Traits as interfaces</h4>
      <p>Compiling any trait creates a Java interface of the same name.<a id="i286095114-1"></a><a id="i1983011802-1"></a> This interface is usable as a Java type, and it lets you call methods on Scala objects through variables of that type.</p>
      <p>Implementing a trait in Java is another story. In the general case it is not practical; however, one special case is important. If you make a Scala trait that includes only abstract methods, then that trait will be translated directly to a Java interface with no other code to worry about. Essentially this means that you can write a Java interface in Scala syntax if you like.</p>
      <h3 id="sec-annotations">31.2 Annotations</h3>
      <p>Scala's general annotations system is discussed in <a href="#chap-annotations">Chapter 27</a>. This section discusses Java-specific aspects of annotations.<a id="i-311881081-1"></a></p>
      <h4>Additional effects from standard annotations</h4>
      <p>Several annotations cause the compiler to emit extra information when targeting the Java platform. When the compiler sees such an annotation, it first processes it according to the general Scala rules, and then it does something extra for Java.</p>
      <p><b>Deprecation</b> For any method or class marked <span class="code">@deprecated</span>,<a id="i-1632344653-2"></a> the compiler will add Java's own deprecation annotation to the emitted code. Because of this, Java compilers can issue deprecation warnings when Java code accesses deprecated Scala methods.</p>
      <p><b>Volatile fields</b> Likewise, any field marked <span class="code">@volatile</span><a id="i-882906061-2"></a> in Scala is given the Java <span class="code">volatile</span> modifier in the emitted code. Thus, volatile fields in Scala behave exactly according to Java's semantics, and accesses to volatile fields are sequenced precisely according to the rules specified for volatile fields in the Java memory model.</p>
      <p><b>Serialization</b></p>
      <p>Scala's two standard serialization annotations are all translated to Java equivalents. A <span class="code">@serializable</span><a id="i-534731536-1"></a><a id="i-897281643-1"></a> class has Java's <span class="code">Serializable</span> interface added to it. A <span class="code">@SerialVersionUID(1234L)</span> annotation is converted to the following Java field definition:</p> <pre>  <code class="comment">//&nbsp;Java&nbsp;serial&nbsp;version&nbsp;marker</code>
  <code class="vem">private</code>&nbsp;<code class="vem">final</code>&nbsp;static&nbsp;long&nbsp;<code class="typename">SerialVersionUID</code>&nbsp;=&nbsp;<code class="literal">1234L</code>
</pre>
      <p>Any variable marked <span class="code">@transient</span> is given the Java <span class="code">transient</span> modifier.</p>
      <h4>Exceptions thrown</h4>
      <p>Scala does not check that thrown exceptions are caught.<a id="i-767472144-1"></a> That is, Scala has no equivalent to Java's <span class="code">throws</span> declarations on methods.<a id="i1515336401-1"></a><a id="i993633856-1"></a><a id="i1490895901-2"></a> All Scala methods are translated to Java methods that declare no thrown exceptions.<a href="#footnotemain31-2">[2]</a></p>
      <p>The reason this feature is omitted from Scala is that the Java experience with it has not been purely positive. Because annotating methods with <span class="code">throws</span> clauses is a heavy burden, too many developers write code that swallows and drops exceptions, just to get the code to compile without adding all those <span class="code">throws</span> clauses. They may intend to improve the exception handling later, but experience shows that all too often time-pressed programmers will never come back and add proper exception handling. The twisted result is that this well-intentioned feature often ends up making code <em>less</em> reliable. A large amount of production Java code swallows and hides runtime exceptions, and the reason it does so is to satisfy the compiler.</p>
      <p>Sometimes when interfacing to Java, however, you may need to write Scala code that has Java-friendly annotations describing which exceptions your methods may throw. For example, each method in an RMI remote interface is required to mention <span class="code">java.io.RemoteException</span> in its <span class="code">throws</span> clause. Thus, if you wish to write an RMI remote interface as a Scala trait with abstract methods, you would need to list <span class="code">RemoteException</span> in the <span class="code">throws</span> clauses for those methods. To accomplish this, all you have to do is mark your methods with <span class="code">@throws</span><a id="i-1229583646-1"></a><a id="i1626806115-1"></a> annotations. For example, the Scala class shown in <a href="#lst-throws-clause">Listing 31.1</a> has a method marked as throwing <span class="code">IOException</span>.</p>
      <p><a id="lst-throws-clause"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;java.io._
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Reader</code>(fname:&nbsp;<code class="typename">String</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">private</code>&nbsp;<code class="vem">val</code>&nbsp;in&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BufferedReader</code>(<code class="vem">new</code>&nbsp;<code class="typename">FileReader</code>(fname))
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;@throws(classOf[<code class="typename">IOException</code>])
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;read()&nbsp;=&nbsp;in.read()
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 31.1 - A Scala method that declares a Java <span class="code">throws</span> clause.</h5>
      <p>Here is how it looks from Java:<a id="i1433885554-1"></a><a id="i385195690-1"></a></p> <pre>  $&nbsp;javap&nbsp;Reader
  <code class="output">Compiled&nbsp;from&nbsp;"Reader.scala"</code>
  <code class="output">public&nbsp;class&nbsp;Reader&nbsp;{</code>
  <code class="output">&nbsp;&nbsp;public&nbsp;int&nbsp;read()&nbsp;throws&nbsp;java.io.IOException;</code>
  <code class="output">&nbsp;&nbsp;public&nbsp;Reader(java.lang.String);</code>
  <code class="output">}</code>
</pre>
      <p>Note that the <span class="code">read</span> method indicates with a Java <span class="code">throws</span> clause that it may throw an <span class="code">IOException</span>.</p>
      <h4>Java annotations</h4>
      <p>Existing annotations from Java frameworks can be used directly in Scala code. Any Java framework will see the annotations you write just as if you were writing in Java.</p>
      <p>A wide variety of Java packages use annotations. As an example, consider JUnit 4.<a id="i70981870-1"></a> JUnit is a framework for writing and running automated tests. The latest version, JUnit 4, uses annotations to indicate which parts of your code are tests. The idea is that you write a lot of tests for your code, and then you run those tests whenever you change the source code. That way, if your changes add a new bug, one of the tests will fail and you will find out immediately.</p>
      <p>Writing a test is easy. You simply write a method in a top-level class that exercises your code, and you use an annotation to mark the method as a test. It looks like this:</p> <pre>  <code class="vem">import</code>&nbsp;org.junit.Test
  <code class="vem">import</code>&nbsp;org.junit.Assert.assertEquals
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">SetTest</code>&nbsp;{
  <br>  &nbsp;&nbsp;@<code class="typename">Test</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;testMultiAdd&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;set&nbsp;=&nbsp;<code class="typename">Set</code>()&nbsp;+&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;<code class="literal">2</code>&nbsp;+&nbsp;<code class="literal">3</code>&nbsp;+&nbsp;<code class="literal">1</code>&nbsp;+&nbsp;<code class="literal">2</code>&nbsp;+&nbsp;<code class="literal">3</code>
  &nbsp;&nbsp;&nbsp;&nbsp;assertEquals(<code class="literal">3</code>,&nbsp;set.size)
  &nbsp;&nbsp;}
  }
</pre>
      <p>The <span class="code">testMultiAdd</span> method is a test. This test adds multiple items to a set and makes sure that each is added only once. The <span class="code">assertEquals</span> method, which comes as part of the JUnit API, checks that its two arguments are equal. If they are different, then the test fails. In this case, the test verifies that repeatedly adding the same numbers does not increase the size of a set.</p>
      <p>The test is marked using the annotation <span class="code">org.junit.Test</span>. Note that this annotation has been imported, so it can be referred to as simply <span class="code">@Test</span> instead of the more cumbersome <span class="code">@org.junit.Test</span>.<a id="i-1737029383-1"></a><a id="i-380372540-1"></a></p>
      <p>That's all there is to it. The test can be run using any JUnit test runner. Here it is being run with the command-line test runner:</p> <pre>  $&nbsp;scala&nbsp;-cp&nbsp;junit-4.3.<code class="literal">1.</code>jar:.&nbsp;<code class="typename">org.junit.runner.JUnitCore</code>&nbsp;<code class="typename">SetTest</code>
  <code class="output">JUnit&nbsp;version&nbsp;4.3.1</code>
  <code class="output">.</code>
  <code class="output">Time:&nbsp;0.023</code>
  <code class="output"></code>
  <code class="output">OK&nbsp;(1&nbsp;test)</code>
</pre>
      <h4>Writing your own annotations</h4>
      <p>To make an annotation that is visible to Java reflection,<a id="i-244877014-1"></a> you must use<a id="i-1366299605-1"></a> Java notation and compile it with <span class="code">javac</span><a id="i-1137870217-1"></a>. For this use case, writing the annotation in Scala does not seem helpful, so the standard compiler does not support it. The reasoning is that the Scala support would inevitably fall short of the full possibilities of Java annotations, and further, Scala will probably one day have its own reflection, in which case you would want to access Scala annotations with Scala reflection.</p>
      <p>Here is an example annotation:</p> <pre>  import&nbsp;java.lang.annotation.*;&nbsp;//&nbsp;This&nbsp;is&nbsp;Java
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.METHOD)
  public&nbsp;@interface&nbsp;Ignore&nbsp;{&nbsp;}
</pre>
      <p>After compiling the above with <span class="code">javac</span>, you can use the annotation as follows:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">Tests</code>&nbsp;{
  &nbsp;&nbsp;@<code class="typename">Ignore</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;testData&nbsp;=&nbsp;<code class="typename">List</code>(<code class="literal">0</code>,&nbsp;<code class="literal">1</code>,&nbsp;-<code class="literal">1</code>,&nbsp;<code class="literal">5</code>,&nbsp;-<code class="literal">5</code>)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;test1&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;assert(testData&nbsp;==&nbsp;(testData.head&nbsp;::&nbsp;testData.tail))
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;test2&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;assert(testData.contains(testData.head))
  &nbsp;&nbsp;}
  }
</pre>
      <p>In this example, <span class="code">test1</span> and <span class="code">test2</span> are supposed to be test methods, but <span class="code">testData</span> should be ignored even though its name starts with "test".</p>
      <p>To see when these annotations are present, you can use the Java reflection APIs. Here is sample code to show how it works:</p> <pre>  <code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;method&nbsp;&lt;-&nbsp;Tests.getClass.getMethods
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;method.getName.startsWith(<code class="quotedstring">"test"</code>)
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;method.getAnnotation(classOf[<code class="typename">Ignore</code>])&nbsp;==&nbsp;<code class="vem">null</code>
  }&nbsp;{
  &nbsp;&nbsp;println(<code class="quotedstring">"found&nbsp;a&nbsp;test&nbsp;method:&nbsp;"</code>&nbsp;+&nbsp;method)
  }
</pre>
      <p>Here, the reflective methods <span class="code">getClass</span> and <span class="code">getMethods</span> are used to inspect all the fields of the input object's class. These are normal reflection methods. The annotation-specific part is the use of method <span class="code">getAnnotation</span>. Many reflection objects have a <span class="code">getAnnotation</span> method for searching for annotations of a specific type. In this case, the code looks for an annotation of our new <span class="code">Ignore</span> type. Since this is a Java API, success is indicated by whether the result is <span class="code">null</span> or an actual annotation object.</p>
      <p>Here is the code in action:</p> <pre>  $&nbsp;javac&nbsp;Ignore.java
  $&nbsp;scalac&nbsp;Tests.scala
  $&nbsp;scalac&nbsp;FindTests.scala
  $&nbsp;scala&nbsp;<code class="typename">FindTests</code>
  <code class="output">found&nbsp;a&nbsp;test&nbsp;method:&nbsp;public&nbsp;void&nbsp;Tests$.test2()</code>
  <code class="output">found&nbsp;a&nbsp;test&nbsp;method:&nbsp;public&nbsp;void&nbsp;Tests$.test1()</code>
</pre>
      <p>As an aside, notice that the methods are in class <span class="code">Tests$</span> instead of class <span class="code">Tests</span> when viewed with Java reflection. As described at the beginning of the chapter, the implementation of a Scala singleton object is placed in a Java class with a dollar sign added to the end of its name. In this case, the implementation of <span class="code">Tests</span> is in the Java class <span class="code">Tests$</span>.</p>
      <p>Be aware that when you use Java annotations you have to work within their limitations. For example, you can only use constants, not expressions, in the arguments to annotations. You can support <span class="code">@serial(1234)</span> but not <span class="code">@serial(x * 2)</span>, because <span class="code">x</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2</span> is not a constant.</p>
      <h3 id="sec-wildcard-types">31.3 Wildcard types</h3>
      <p>All Java types have a Scala equivalent.<a id="i1056209851-2"></a><a id="i165566131-2"></a> This is necessary so that Scala code can access any legal Java class. Most of the time the translation is straightforward. <span class="code">Pattern</span> in Java is <span class="code">Pattern</span> in Scala, and <span class="code">Iterator&lt;Component&gt;</span> in Java is <span class="code">Iterator[Component]</span> in Scala. For some cases, though, the Scala types you have seen so far are not enough. What can be done with Java wildcard types such as <span class="code">Iterator&lt;?&gt;</span> or <span class="code">Iterator&lt;?</span>&nbsp;<span class="code">extends</span>&nbsp;<span class="code">Component&gt;</span>? What can be done about raw types like <span class="code">Iterator</span>, where the type parameter is omitted? For Java wildcard types and raw types, Scala uses an extra kind of type<a id="i414933374-2"></a><a id="i1163979645-2"></a><a id="i-119763145-1"></a><a id="i-315542260-1"></a> also called a <a href="#g836624832"><em>wildcard type</em></a>.</p>
      <p>Wildcard types are written using <em>placeholder syntax</em>, just like the shorthand function literals described in <a href="#sec-placeholder-syntax">Section 8.5</a>.<a id="i-1194775874-1"></a> In the shorthand for function literals, you can use an underscore (<span class="code">_</span>) in place of an expression; for example, <span class="code">(_</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span> is the same as <span class="code">(x</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1)</span>. Wildcard types use the same idea, only for types instead of expressions. If you write <span class="code">Iterator[_]</span>, then the underscore is replacing a type. Such a type represents an <span class="code">Iterator</span> where the element type is not known.</p>
      <p>You can also insert upper and lower bounds when using this placeholder syntax. Simply add the bound after the underscore, using the same <span class="code">&lt;:</span> syntax used with type parameters (<a href="#sec-upper-bounds">Section 19.8</a> and <a href="#sec-lower-bounds">Section 19.5</a>). For example, the type <span class="code">Iterator[_</span>&nbsp;<span class="code">&lt;:</span>&nbsp;<span class="code">Component]</span> is an iterator where the element type is not known, but whatever type it is, it must be a subtype of <span class="code">Component</span>.</p>
      <p>That's how you write a wildcard type, but how do you use it? In simple cases, you can ignore the wildcard and call methods on the base type. For example, suppose you had the following Java class:</p> <pre>  //&nbsp;This&nbsp;is&nbsp;a&nbsp;Java&nbsp;class&nbsp;with&nbsp;wildcards
  import&nbsp;java.util.*;
  public&nbsp;class&nbsp;Wild&nbsp;{
  &nbsp;&nbsp;public&nbsp;Collection&lt;?&gt;&nbsp;contents()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;Collection&lt;String&gt;&nbsp;stuff&nbsp;=&nbsp;new&nbsp;Vector&lt;String&gt;();
  &nbsp;&nbsp;&nbsp;&nbsp;stuff.add("a");
  &nbsp;&nbsp;&nbsp;&nbsp;stuff.add("b");
  &nbsp;&nbsp;&nbsp;&nbsp;stuff.add("see");
  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stuff;
  &nbsp;&nbsp;}
  }
</pre>
      <p>If you access this in Scala code you will see that it has a wildcard type:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;contents&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">Wild</code>).contents
  <code class="output">contents:&nbsp;java.util.Collection[_]&nbsp;=&nbsp;[a,&nbsp;b,&nbsp;see]</code>
</pre>
      <p>If you want to find out how many elements are in this collection, you can simply ignore the wildcard part and call the <span class="code">size</span> method as normal:</p> <pre>  scala&gt;&nbsp;contents.size()
  <code class="output">res0:&nbsp;Int&nbsp;=&nbsp;3</code>
</pre>
      <p>In more complicated cases, wildcard types can be more awkward. Since the wildcard type has no name, there is no way to use it in two separate places. For example, suppose you wanted to create a mutable Scala set and initialize it with the elements of <span class="code">contents</span>:</p> <pre>  <code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="vem">val</code>&nbsp;iter&nbsp;=&nbsp;(<code class="vem">new</code>&nbsp;<code class="typename">Wild</code>).contents.iterator
  <code class="vem">val</code>&nbsp;set&nbsp;=&nbsp;mutable.Set.empty[???]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;what&nbsp;type&nbsp;goes&nbsp;here?</code>
  <code class="vem">while</code>&nbsp;(iter.hasMore)
  &nbsp;&nbsp;set&nbsp;+=&nbsp;iter.next()
</pre>
      <p>A problem occurs on the third line. There is no way to name the type of elements in the Java collection, so you cannot write down a satisfactory type for <span class="code">set</span>. To work around this kind of problem, here are two tricks you should consider:</p>
      <ol>
        <li>When passing a wildcard type into a method, give a parameter to the method for the placeholder. You now have a name for the type that you can use as many times as you like. </li>
        <li>Instead of returning wildcard type from a method, return an object that has abstract members for each of the placeholder types. (See <a href="#chap-abstract-members">Chapter 20</a> for information on abstract members.) </li>
      </ol>
      <p>Using these two tricks together, the previous code can be written as follows:</p> <pre>  <code class="vem">import</code>&nbsp;scala.collection.mutable
  <code class="vem">import</code>&nbsp;java.util.Collection
  <br>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">SetAndType</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Elem</code>
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;set:&nbsp;<code class="typename">mutable.Set[Elem]</code>
  }
  <br>  <code class="vem">def</code>&nbsp;javaSet2ScalaSet[T](jset:&nbsp;<code class="typename">Collection[T]</code>):&nbsp;<code class="typename">SetAndType</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;sset&nbsp;=&nbsp;mutable.Set.empty[T]&nbsp;&nbsp;<code class="comment">//&nbsp;now&nbsp;T&nbsp;can&nbsp;be&nbsp;named!</code>
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;iter&nbsp;=&nbsp;jset.iterator
  &nbsp;&nbsp;<code class="vem">while</code>&nbsp;(iter.hasNext)
  &nbsp;&nbsp;&nbsp;&nbsp;sset&nbsp;+=&nbsp;iter.next()
  <br>  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">SetAndType</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">type</code>&nbsp;<code class="typename">Elem</code>&nbsp;=&nbsp;T
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;set&nbsp;=&nbsp;sset
  &nbsp;&nbsp;}
  }
</pre>
      <p>You can see why Scala code normally does not use wildcard types. To do anything sophisticated with them, you tend to convert them to use abstract members. So you may as well use abstract members to begin with.</p>
      <h3>31.4 Compiling Scala and Java together</h3>
      <p>Usually<a id="i990690315-1"></a><a id="i82401984-1"></a><a id="i18472490-1"></a> when you compile Scala code that depends on Java code, you first build the Java code to class files. You then build the Scala code, putting the Java code's class files on the classpath. However, this approach doesn't work if the Java code has references back into the Scala code. In such a case, no matter which order you compile the code, one side or the other will have unsatisfied external references. These situations are not uncommon; all it takes is a mostly Java project where you replace one Java source file with a Scala source file.</p>
      <p>To support such builds, Scala allows compiling against Java source code as well as Java class files. All you have to do is put the Java source files on the command line as if they were Scala files. The Scala compiler won't compile those Java files, but it will scan them to see what they contain. To use this facility, you first compile the Scala code using Java source files, and then compile the Java code using Scala class files.</p>
      <p>Here is a typical sequence of commands:</p> <pre>  $&nbsp;scalac&nbsp;-d&nbsp;bin&nbsp;InventoryAnalysis.scala&nbsp;InventoryItem.java&nbsp;\
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inventory.java
  $&nbsp;javac&nbsp;-cp&nbsp;bin&nbsp;-d&nbsp;bin&nbsp;Inventory.java&nbsp;InventoryItem.java&nbsp;\
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InventoryManagement.java&nbsp;
  $&nbsp;scala&nbsp;-cp&nbsp;bin&nbsp;InventoryManagement
  <code class="output">Most&nbsp;expensive&nbsp;item&nbsp;=&nbsp;sprocket($4.99)</code>
</pre>
      <h3 id="sec-java-8-and-scala-212">31.5 Java 8 integration</h3>
      <p>Java 8<a id="i-2083218982-1"></a> added a few improvements to the<a id="i88737196-2"></a> Java language and bytecodes that Scala takes advantage of starting with its 2.12 release.<a href="#footnotemain31-3">[3]</a> By exploiting new features of Java 8, the Scala compiler can generate smaller class and jar files and improve the binary compatibility<a id="i-1391235183-1"></a> of traits.</p>
      <h4>Lambda expressions and "SAM" types</h4>
      <p>From the Scala programmer's perspective, the most visible Java 8-related enhancement in Scala 2.12 is that Scala function literals can be used<a id="i-1629064105-1"></a> like Java 8 <span class="textit">lambda expressions</span><a id="i-758602307-1"></a><a id="i1059833762-1"></a> as a more concise form for anonymous class instance expressions. To pass behavior into a method prior to Java 8, Java programmers often defined anonymous inner class instances, like this:</p> <pre>  JButton&nbsp;button&nbsp;=&nbsp;new&nbsp;JButton();&nbsp;//&nbsp;This&nbsp;is&nbsp;Java
  button.addActionListener(
  &nbsp;&nbsp;new&nbsp;ActionListener()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;actionPerformed(ActionEvent&nbsp;event)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("pressed!");
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  );
</pre>
      <p>In this example, an anonymous instance of <span class="code">ActionListener</span> is created and passed to the <span class="code">addActionListener</span> of a Swing <span class="code">JButton</span>. When a user clicks on the button, Swing will invoke the <span class="code">actionPerformed</span> method on this instance, which will print <span class="code">"pressed!"</span>.</p>
      <p>In Java 8, a lambda expression can be used anywhere an instance of a class or interface that contains just a single abstract method (SAM) is required.<a id="i701753824-1"></a> <span class="code">ActionListener</span> is such an interface, because it contains a single abstract method, <span class="code">actionPerformed</span>. Thus a lambda expression can be used to register an action listener on a Swing button. Here's an example:</p> <pre>  JButton&nbsp;button&nbsp;=&nbsp;new&nbsp;JButton();&nbsp;//&nbsp;This&nbsp;is&nbsp;Java&nbsp;8
  button.addActionListener(
  &nbsp;&nbsp;event&nbsp;-&gt;&nbsp;System.out.println("pressed!")
  );
</pre>
      <p>In Scala, you could also use an anonymous inner class instance in the same situation, but you might prefer to use a function literal, like this:</p> <pre>  <code class="vem">val</code>&nbsp;button&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">JButton</code>
  button.addActionListener(&nbsp;
  &nbsp;&nbsp;_&nbsp;=&gt;&nbsp;println(<code class="quotedstring">"pressed!"</code>)
  )
</pre>
      <p>As you have already seen in <a href="#sec-implicit-conversions">Section 21.1</a>, you could support such a coding style by defining an implicit conversion from the <span class="code">ActionEvent</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Unit</span> function type to <span class="code">ActionListener</span>.</p>
      <p>Scala enables a function literal to be used in this case even in the absence of such an implicit conversion. As with Java 8, Scala will allow a function type to be used where an instance of a class or trait declaring a single abstract method (SAM) is required. This will work with any SAM in Scala versions 2.12 and later. For example, you might define a trait, <span class="code">Increaser</span>, with a single abstract method, <span class="code">increase</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Increaser</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;increase(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">defined&nbsp;trait&nbsp;Increaser</code>
</pre>
      <p>You could then define a method that takes an <span class="code">Increaser</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">def</code>&nbsp;increaseOne(increaser:&nbsp;<code class="typename">Increaser</code>):&nbsp;<code class="typename">Int</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increaser.increase(<code class="literal">1</code>)
  <code class="output">increaseOne:&nbsp;(increaser:&nbsp;Increaser)Int</code>
</pre>
      <p>To invoke your new method, you could pass in an anonymous instance of trait <span class="code">Increaser</span>, like this:</p> <pre>  scala&gt;&nbsp;increaseOne(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Increaser</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;increase(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;i&nbsp;+&nbsp;<code class="literal">7</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <code class="output">res0:&nbsp;Int&nbsp;=&nbsp;8</code>
</pre>
      <p>In Scala 2.12, however, you could alternatively just use a function literal, because <span class="code">Increaser</span> is a SAM type:</p> <pre>  scala&gt;&nbsp;increaseOne(i&nbsp;=&gt;&nbsp;i&nbsp;+&nbsp;<code class="literal">7</code>)&nbsp;<code class="comment">//&nbsp;Scala&nbsp;2.12</code>
  <code class="output">res1:&nbsp;Int&nbsp;=&nbsp;8</code>
</pre>
      <h4>Using Java 8 <span class="code">Stream</span>s from Scala</h4>
      <p>Java's Stream is a functional data structure that offers<a id="i-1435343948-1"></a><a id="i2022123097-1"></a> a <span class="code">map</span> method taking a <span class="code">java.util.function.IntUnaryOperator</span>. From Scala you can invoke <span class="code">Stream.map</span> to increment each element of an <span class="code">Array</span>, like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;java.util.function.IntUnaryOperator
  <code class="output">import&nbsp;java.util.function.IntUnaryOperator</code>
  <br>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;java.util.Arrays
  <code class="output">import&nbsp;java.util.Arrays</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stream&nbsp;=&nbsp;Arrays.stream(<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>))
  <code class="output">stream:&nbsp;java.util.stream.IntStream&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;stream.map(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">IntUnaryOperator</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;applyAsInt(i:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Int</code>&nbsp;=&nbsp;i&nbsp;+&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).toArray
  <code class="output">res3:&nbsp;Array[Int]&nbsp;=&nbsp;Array(2,&nbsp;3,&nbsp;4)</code>
</pre>
      <p>Because <span class="code">IntUnaryOperator</span> is a SAM type, however, in Scala 2.12 and later you could also invoke it more concisely with a function literal:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stream&nbsp;=&nbsp;Arrays.stream(<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>))
  <code class="output">stream:&nbsp;java.util.stream.IntStream&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;stream.map(i&nbsp;=&gt;&nbsp;i&nbsp;+&nbsp;<code class="literal">1</code>).toArray&nbsp;<code class="comment">//&nbsp;Scala&nbsp;2.12</code>
  <code class="output">res4:&nbsp;Array[Int]&nbsp;=&nbsp;Array(2,&nbsp;3,&nbsp;4)</code>
</pre>
      <p>Note that only function <span class="textit">literals</span> will be adapted to SAM types, not arbitrary expressions that have a function type. For example, consider the following <span class="code">val</span>, <span class="code">f</span>, which has type <span class="code">Int</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Int</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;(i:&nbsp;<code class="typename">Int</code>)&nbsp;=&gt;&nbsp;i&nbsp;+&nbsp;<code class="literal">1</code>
  <code class="output">f:&nbsp;Int&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;...</code>
</pre>
      <p>Although <span class="code">f</span> has the same type as the function literal passed to <span class="code">stream.map</span> previously, you can't use <span class="code">f</span> where an <span class="code">IntUnaryOperator</span> is required:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stream&nbsp;=&nbsp;Arrays.stream(<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>))
  <code class="output">stream:&nbsp;java.util.stream.IntStream&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;stream.map(f).toArray
  <code class="output">&lt;console&gt;:16:&nbsp;error:&nbsp;type&nbsp;mismatch;</code>
  <code class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Int&nbsp;=&gt;&nbsp;Int</code>
  <code class="output">&nbsp;required:&nbsp;java.util.function.IntUnaryOperator</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream.map(f).toArray</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>To use <span class="code">f</span>, you can explicitly call it using a function literal, like this:</p> <pre>  scala&gt;&nbsp;stream.map(i&nbsp;=&gt;&nbsp;f(i)).toArray
  <code class="output">res5:&nbsp;Array[Int]&nbsp;=&nbsp;Array(2,&nbsp;3,&nbsp;4)</code>
</pre>
      <p>Or, you could annotate <span class="code">f</span> with <span class="code">IntUnaryOperator</span>, the type expected by <span class="code">Stream.map</span>, when you define <span class="code">f</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;f:&nbsp;<code class="typename">IntUnaryOperator</code>&nbsp;=&nbsp;i&nbsp;=&gt;&nbsp;i&nbsp;+&nbsp;<code class="literal">1</code>
  <code class="output">f:&nbsp;java.util.function.IntUnaryOperator&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;stream&nbsp;=&nbsp;Arrays.stream(<code class="typename">Array</code>(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>,&nbsp;<code class="literal">3</code>))
  <code class="output">stream:&nbsp;java.util.stream.IntStream&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;stream.map(f).toArray
  <code class="output">res6:&nbsp;Array[Int]&nbsp;=&nbsp;Array(2,&nbsp;3,&nbsp;4)</code>
</pre>
      <p>With Scala 2.12 and Java 8, you can also invoke methods compiled with Scala from Java, passing Scala function types using Java lambda expressions. Although Scala function types are defined as traits that include concrete methods, Scala, starting with version 2.12, compiles traits to Java interfaces with <span class="textit">default methods</span>,<a id="i-520965298-1"></a><a id="i1435359027-1"></a> a new feature of Java 8. As a result, Scala function types appear to Java as SAMs.</p>
      <h3>31.6 Conclusion</h3>
      <p>Most of the time, you can ignore how Scala is implemented, and simply write and run your code. But sometimes it is nice to "look under the hood," so this chapter has gone into three aspects of Scala's implementation on the Java platform: What the translation looks like, how Scala and Java annotations work together, and how Scala's wildcard types let you access Java wildcard types. It also covered using Java's concurrency primitives from Scala and compiling combined Scala and Java projects. These topics are important whenever you use Scala and Java together.</p>
      <hr>
      <h4>Footnotes for Chapter 31:</h4>
      <p><a id="footnotemain31-1"></a>[1] The implementation of value types was discussed in detail in <a href="#sec-impl-primitives">Section 11.2</a>.</p>
      <p><a id="footnotemain31-2"></a>[2] The reason it all works is that the Java bytecode verifier does not check the declarations anyway! The Java compiler checks, but not the verifier.</p>
      <p><a id="footnotemain31-3"></a>[3] Starting with 2.12, Scala <span class="textit">requires</span> Java 8 so that it can take advantage of Java 8 features.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-futures-and-concurrency">Chapter 32</a></h2>
      <h1>Futures and Concurrency</h1>
      <p>One consequence of the proliferation of multicore processors has been an increased interest in concurrency. Java provides concurrency support built around shared memory and locking. Although this support is sufficient, this approach turns out to be quite difficult to get right in practice.<a id="i-1261817322-1"></a><a id="i-503567600-1"></a><a id="i-2146835927-1"></a> Scala's standard library offers an alternative that avoids these difficulties by focusing on asynchronous transformations of immutable state: the <span class="code">Future</span>.</p>
      <p>Although Java also offers a <span class="code">Future</span>, it is very different from Scala's. Both represent the result of an asynchronous computation, but Java's <span class="code">Future</span> requires that you access the result via a blocking <span class="code">get</span> method. Although you can call <span class="code">isDone</span> to find out if a Java <span class="code">Future</span> has completed before calling <span class="code">get</span>, thereby avoiding any blocking, you must wait until the Java <span class="code">Future</span> has completed before proceeding with any computation that uses the result.</p>
      <p>By contrast, you can specify transformations on a Scala <span class="code">Future</span> whether it has completed or not. Each transformation results in a new <span class="code">Future</span> representing the asynchronous result of the original <span class="code">Future</span> transformed by the function. The thread that performs the computation is determined by an implicitly provided <span class="textit">execution context</span>. This allows you to describe asynchronous computations as a series of transformations of immutable values, with no need to reason about shared memory and locks.</p>
      <h3>32.1 Trouble in paradise</h3>
      <p>On the Java platform, each object is associated with a logical <em>monitor</em>,<a id="i-328798631-1"></a> which can be used to control multi-threaded access to data. To use this model, you decide what data will be shared by multiple threads and mark as "synchronized" sections of the code that access, or control access to, the shared data. The Java runtime employs a locking mechanism to ensure that only one thread at a time enters synchronized sections guarded by the same lock, thereby enabling you to orchestrate multi-threaded access to the shared data.<a id="i2035919517-1"></a></p>
      <p>For compatibility's sake, Scala provides access to Java's concurrency primitives. The <span class="code">wait</span>, <span class="code">notify</span>, and <span class="code">notifyAll</span> methods can be called in Scala, and they have the same meaning as in Java. Scala doesn't technically have a <span class="code">synchronized</span> keyword, but it includes a predefined <span class="code">synchronized</span> method that can be called as follows:</p> <pre>  <code class="vem">var</code>&nbsp;counter&nbsp;=&nbsp;<code class="literal">0</code>
  synchronized&nbsp;{
  &nbsp;&nbsp;<code class="comment">//&nbsp;One&nbsp;thread&nbsp;in&nbsp;here&nbsp;at&nbsp;a&nbsp;time</code>
  &nbsp;&nbsp;counter&nbsp;=&nbsp;counter&nbsp;+&nbsp;<code class="literal">1</code>
  }
</pre>
      <p>Unfortunately, programmers have found it very difficult to reliably build robust multi-threaded applications using the shared data and locks model, especially as applications grow in size and complexity. The problem is that at each point in the program, you must reason about what data you are modifying or accessing that might be modified or accessed by other threads, and what locks are being held. At each method call, you must reason about what locks it will try to hold and convince yourself that it will not deadlock while<a id="i503639951-2"></a> trying to obtain them. Compounding the problem, the locks you reason about are not fixed at compile time, because the program is free to create new locks at run time as it progresses.</p>
      <p>Making things worse, testing is not reliable with multi-threaded code.<a id="i-670497952-1"></a> Since threads are non-deterministic, you might successfully test a program one thousand times—and the program could still go wrong the first time it runs on a customer's machine. With shared data and locks, you must get the program correct through reason alone.</p>
      <p>Moreover, you can't solve the problem by over-synchronizing either. It can be just as problematic to synchronize everything as it is to synchronize nothing. Although new lock operations may remove possibilities for race conditions, they simultaneously add possibilities for deadlocks. A correct lock-using program must have neither race conditions nor deadlocks, so you cannot play it safe by overdoing it in either direction.</p>
      <p>The <span class="code">java.util.concurrent</span> library provides higher level abstractions for concurrent programming.<a id="i-1522908125-1"></a> Using the concurrency utilities makes multi-threaded programming far less error prone than rolling your own abstractions with Java's low-level synchronization primitives. Nevertheless, the concurrent utilities are also based on the shared data and locks model, and as a result, do not solve the fundamental difficulties of using that model.<a id="i1837693870-1"></a><a id="i1225979037-1"></a><a id="i1954917920-1"></a></p>
      <h3>32.2 Asynchronous execution and <span class="code">Try</span>s</h3>
      <p>Although not a silver bullet, Scala's <span class="code">Future</span> offers one way to deal with<a id="i634201779-1"></a> concurrency that can reduce, and often eliminate, the need to reason about shared data and locks. When you invoke a Scala method, it performs a computation "while you wait" and returns a result. If that result is a <span class="code">Future</span>, the <span class="code">Future</span> represents another computation to be performed asynchronously, often by a completely different thread. As a result, many operations on <span class="code">Future</span> require an implicit <span class="textit">execution context</span> that provides a strategy for executing functions asynchronously. For example, if you try to create a future via the <span class="code">Future.apply</span> factory method<a id="i2121330216-1"></a><a id="i-702563230-1"></a> without providing an implicit execution context, an instance of <span class="code">scala.concurrent.ExecutionContext</span>,<a id="i-89859177-1"></a> you'll get a compiler error:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.concurrent.Future
  <code class="output">import&nbsp;scala.concurrent.Future</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  <code class="output">&lt;console&gt;:11:&nbsp;error:&nbsp;Cannot&nbsp;find&nbsp;an&nbsp;implicit&nbsp;ExecutionContext.</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;You&nbsp;might&nbsp;pass&nbsp;an&nbsp;(implicit&nbsp;ec:&nbsp;ExecutionContext)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;parameter&nbsp;to&nbsp;your&nbsp;method&nbsp;or&nbsp;import</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;scala.concurrent.ExecutionContext.Implicits.global.</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;fut&nbsp;=&nbsp;Future&nbsp;{&nbsp;Thread.sleep(10000);&nbsp;21&nbsp;+&nbsp;21&nbsp;}</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>The error message gives you one way to solve the problem: importing a global execution context provided by Scala itself. On the JVM, the global execution context uses a thread pool.<a href="#footnotemain32-1">[1]</a> Once you bring an implicit execution context into scope, you can create a future:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.concurrent.ExecutionContext.Implicits.global
  <code class="output">import&nbsp;scala.concurrent.ExecutionContext.Implicits.global</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  <code class="output">fut:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
</pre>
      <p>The future created in the previous example asynchronously executes the block of code, using the <span class="code">global</span> execution context, then completes with the value 42. Once it starts execution, that thread will sleep for ten seconds. Thus this future will take at least ten seconds to complete.</p>
      <p>Two methods on <span class="code">Future</span> allow you to poll: <span class="code">isCompleted</span> and <span class="code">value</span>. When invoked on a future that has not yet completed, <span class="code">isCompleted</span> will return <span class="code">false</span> and <span class="code">value</span> will return <span class="code">None</span>.</p> <pre>  scala&gt;&nbsp;fut.isCompleted
  <code class="output">res0:&nbsp;Boolean&nbsp;=&nbsp;false</code>
  <br>  scala&gt;&nbsp;fut.value
  <code class="output">res1:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;None</code>
</pre>
      <p>Once the future completes (in this case, after at least ten seconds has gone by), <span class="code">isCompleted</span> will return <span class="code">true</span> and <span class="code">value</span> will return a <span class="code">Some</span>:<a id="i-1388404182-1"></a><a id="i1126777268-1"></a><a id="i217604474-1"></a><a id="i971355780-1"></a></p> <pre>  scala&gt;&nbsp;fut.isCompleted
  <code class="output">res2:&nbsp;Boolean&nbsp;=&nbsp;true</code>
  <br>  scala&gt;&nbsp;fut.value
  <code class="output">res3:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(42))</code>
</pre>
      <p>The option returned by <span class="code">value</span> contains a <span class="code">Try</span>. As shown in <a href="#fig-try-hierarchy">Figure 32.1</a>, a <span class="code">Try</span> is either a <span class="code">Success</span>, which contains a value of type <span class="code">T</span>, or a <span class="code">Failure</span>, which contains an exception (an instance of <span class="code">java.lang.Throwable</span>). The purpose of <span class="code">Try</span> is to provide for asynchronous computations what the <span class="code">try</span> expression provides for synchronous computations: It allows you to deal with the possibility that the computation will complete abruptly with an exception rather than return a result.<a href="#footnotemain32-2">[2]</a></p>
      <div class="figure">
        <a id="fig-try-hierarchy"></a>
        <p><img src="tryHierarchy85.png" alt="images/tryHierarchy85.png"></p>
      </div>
      <h5> Figure 32.1 - Class hierarchy for <span class="code">Try</span>.<a id="i532116857-1"></a><a id="i1073460856-1"></a></h5>
      <p>For synchronous computations you can use <span class="code">try</span>/<span class="code">catch</span> to ensure that a thread that invokes a method catches and handles exceptions thrown by the method. For asynchronous computations, however, the thread that initiates the computation often moves on to other tasks. Later if that asynchronous computation fails with an exception, the original thread is no longer able to handle the exception in a <span class="code">catch</span> clause. Thus when working with a <span class="code">Future</span> representing an asynchronous activity, you use <span class="code">Try</span> to deal with the possibility that the activity fails to yield a value and instead completes abruptly with an exception. Here's an example that shows what happens when an asynchronous activity fails:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">21</code>&nbsp;/&nbsp;<code class="literal">0</code>&nbsp;}
  <code class="output">fut:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;fut.value
  <code class="output">res4:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;None</code>
</pre>
      <p>Then, after ten seconds:</p> <pre>  scala&gt;&nbsp;fut.value
  <code class="output">res5:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Some(Failure(java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero))</code>
</pre>
      <h3>32.3 Working with <span class="code">Future</span>s</h3>
      <p>Scala's <span class="code">Future</span> allows you to specify transformations on <span class="code">Future</span> results and obtain a <span class="textit">new future</span> that represents the composition of the two asynchronous computations: the original and the transformation.</p>
      <h4>Transforming <span class="code">Future</span>s with <span class="code">map</span></h4>
      <p>The most fundamental such operation is <span class="code">map</span>.<a id="i-1389984145-1"></a><a id="i1273958009-1"></a> Instead of blocking then continuing with another computation, you can just <span class="code">map</span> the next computation onto the future. The result will be a new future that represents the original asynchronously computed result transformed asynchronously by the function passed to <span class="code">map</span>.</p>
      <p>For example, the following future will complete after ten seconds:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  <code class="output">fut:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
</pre>
      <p>Mapping this future with a function that increments by one will yield another future. This new future will represent a computation consisting of the original addition followed by the subsequent increment:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;result&nbsp;=&nbsp;fut.map(x&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<code class="literal">1</code>)
  <code class="output">result:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;result.value
  <code class="output">res5:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;None</code>
</pre>
      <p>Once the original future completes and the function has been applied to its result, the future returned by <span class="code">map</span> will complete:</p> <pre>  scala&gt;&nbsp;result.value
  <code class="output">res6:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(43))</code>
</pre>
      <p>Note that the operations performed in this example—the future creation, the 21 + 21 sum calculation, and the 42 + 1 increment—may be performed by three different threads.</p>
      <h4>Transforming <span class="code">Future</span>s with <span class="code">for</span> expressions</h4>
      <p>Because Scala's future also declares a <span class="code">flatMap</span> method,<a id="i-212724097-1"></a><a id="i1700331144-1"></a> you can transform futures using a <span class="code">for</span> expression.<a id="i-1506494671-1"></a> For example, consider the following two futures that will, after ten seconds, produce 42 and 46:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut1&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  <code class="output">fut1:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut2&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">23</code>&nbsp;+&nbsp;<code class="literal">23</code>&nbsp;}
  <code class="output">fut2:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
</pre>
      <p>Given these two futures, you can obtain a new future representing the asynchronous sum of their results like this:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&lt;-&nbsp;fut1
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&lt;-&nbsp;fut2
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">yield</code>&nbsp;x&nbsp;+&nbsp;y
  <code class="output">res7:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
</pre>
      <p>Once the original futures have completed, and the subsequent sum completes, you'll be able to see the result:</p> <pre>  scala&gt;&nbsp;res7.value
  <code class="output">res8:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(88))</code>
</pre>
      <p>Because <span class="code">for</span> expressions serialize their transformations,<a href="#footnotemain32-3">[3]</a> if you don't create the futures before the <span class="code">for</span> expression, they won't run in parallel. For example, although the previous <span class="code">for</span> expression requires around ten seconds to complete, the following <span class="code">for</span> expression requires at least twenty seconds:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&lt;-&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&lt;-&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">23</code>&nbsp;+&nbsp;<code class="literal">23</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<code class="vem">yield</code>&nbsp;x&nbsp;+&nbsp;y
  <code class="output">res9:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;res9.value
  <code class="output">res27:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;None</code>
  <br>  scala&gt;&nbsp;<code class="comment">//&nbsp;Will&nbsp;need&nbsp;at&nbsp;least&nbsp;20&nbsp;seconds&nbsp;to&nbsp;complete</code>
  <br>  scala&gt;&nbsp;res9.value
  <code class="output">res28:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(88))</code>
</pre>
      <h4>Creating the <span class="code">Future</span>: <span class="code">Future.failed</span>, <span class="code">Future.successful</span>, <span class="code">Future.fromTry</span>, and <span class="code">Promise</span>s</h4>
      <p>Besides the <span class="code">apply</span> method, used in earlier examples to create futures, the <span class="code">Future</span> companion object also includes three factory methods for creating already-completed futures: <span class="code">successful</span>, <span class="code">failed</span>, and <span class="code">fromTry</span>. These factory methods do not require an <span class="code">ExecutionContext</span>.<a id="i1338824042-1"></a><a id="i-1310847346-1"></a></p>
      <p>The <span class="code">successful</span> factory method creates a future that has already succeeded:</p> <pre>  scala&gt;&nbsp;Future.successful&nbsp;{&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  res2:&nbsp;<code class="typename">scala.concurrent.Future[Int]</code>&nbsp;=&nbsp;...
</pre>
      <p>The <span class="code">failed</span><a id="i1043356583-1"></a><a id="i329824497-1"></a> method creates a future that has already failed:</p> <pre>  scala&gt;&nbsp;Future.failed(<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"bummer!"</code>))
  res3:&nbsp;<code class="typename">scala.concurrent.Future[Nothing]</code>&nbsp;=&nbsp;...
</pre>
      <p>The <span class="code">fromTry</span> method<a id="i359181829-1"></a><a id="i-987153563-1"></a> creates an already completed future from a <span class="code">Try</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.util.{<code class="typename">Success</code>,<code class="typename">Failure</code>}
  <code class="vem">import</code>&nbsp;scala.util.{<code class="typename">Success</code>,&nbsp;<code class="typename">Failure</code>}
  <br>  scala&gt;&nbsp;Future.fromTry(<code class="typename">Success</code>&nbsp;{&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;})&nbsp;
  res4:&nbsp;<code class="typename">scala.concurrent.Future[Int]</code>&nbsp;=&nbsp;...
  <br>  scala&gt;&nbsp;Future.fromTry(<code class="typename">Failure</code>(<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"bummer!"</code>)))&nbsp;
  res5:&nbsp;<code class="typename">scala.concurrent.Future[Nothing]</code>&nbsp;=&nbsp;...
</pre>
      <p>The most general way to create a future is to use a <span class="code">Promise</span>. Given a promise<a id="i515731113-1"></a> you can obtain a future that is controlled by the promise. The future will complete when you complete the promise. Here's an example:<a id="i2130471540-1"></a><a id="i-1314558614-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;pro&nbsp;=&nbsp;<code class="typename">Promise[Int]</code>
  <code class="output">pro:&nbsp;scala.concurrent.Promise[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut&nbsp;=&nbsp;pro.future
  <code class="output">fut:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;fut.value
  <code class="output">res8:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;None</code>
</pre>
      <p>You can complete the promise with methods named <span class="code">success</span>,<a id="i-1996854080-1"></a><a id="i-623661142-1"></a> <span class="code">failure</span>, and <span class="code">complete</span>. These methods on <span class="code">Promise</span> are similar to those described previously for constructing already completed futures. For example, the <span class="code">success</span> method will complete the future successfully:</p> <pre>  scala&gt;&nbsp;pro.success(<code class="literal">42</code>)
  <code class="output">res9:&nbsp;pro.type&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;fut.value
  <code class="output">res10:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(42))</code>
</pre>
      <p>The <span class="code">failure</span> method<a id="i726772761-1"></a><a id="i-2044691727-1"></a> takes an exception that will cause the future to fail with that exception. The <span class="code">complete</span> method<a id="i172934974-1"></a><a id="i1338121824-1"></a> takes a <span class="code">Try</span>. A <span class="code">completeWith</span> method,<a id="i689370776-1"></a><a id="i-909785018-1"></a> which takes a future, also exists; the promise's future will thereafter mirror the completion status of the future you passed to <span class="code">completeWith</span>.</p>
      <h4>Filtering: <span class="code">filter</span> and <span class="code">collect</span></h4>
      <p>Scala's future offers two methods, <span class="code">filter</span> and <span class="code">collect</span>, that allow you to ensure a property holds true about a future value. The <span class="code">filter</span> method<a id="i1823852756-1"></a><a id="i1364617591-1"></a> validates the future result, leaving it the same if it is valid. Here's an example that ensures an <span class="code">Int</span> is positive:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="literal">42</code>&nbsp;}
  <code class="output">fut:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;valid&nbsp;=&nbsp;fut.filter(res&nbsp;=&gt;&nbsp;res&nbsp;&gt;&nbsp;<code class="literal">0</code>)
  <code class="output">valid:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;valid.value
  <code class="output">res0:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(42))</code>
</pre>
      <p>If the future value is not valid, the future returned by <span class="code">filter</span> will fail with a <span class="code">NoSuchElementException</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;invalid&nbsp;=&nbsp;fut.filter(res&nbsp;=&gt;&nbsp;res&nbsp;&lt;&nbsp;<code class="literal">0</code>)
  <code class="output">invalid:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;invalid.value
  <code class="output">res1:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Failure(java.util.NoSuchElementException:</code>
  <code class="output">&nbsp;&nbsp;Future.filter&nbsp;predicate&nbsp;is&nbsp;not&nbsp;satisfied))</code>
</pre>
      <p>Because <span class="code">Future</span> also offers a <span class="code">withFilter</span> method,<a id="i-1671672129-1"></a><a id="i-1286210351-1"></a> you can perform the same operation with <span class="code">for</span> expression filters:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;valid&nbsp;=&nbsp;<code class="vem">for</code>&nbsp;(res&nbsp;&lt;-&nbsp;fut&nbsp;<code class="vem">if</code>&nbsp;res&nbsp;&gt;&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">yield</code>&nbsp;res
  <code class="output">valid:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;valid.value
  <code class="output">res2:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(42))</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;invalid&nbsp;=&nbsp;<code class="vem">for</code>&nbsp;(res&nbsp;&lt;-&nbsp;fut&nbsp;<code class="vem">if</code>&nbsp;res&nbsp;&lt;&nbsp;<code class="literal">0</code>)&nbsp;<code class="vem">yield</code>&nbsp;res
  <code class="output">invalid:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;invalid.value
  <code class="output">res3:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Failure(java.util.NoSuchElementException:</code>
  <code class="output">&nbsp;&nbsp;Future.filter&nbsp;predicate&nbsp;is&nbsp;not&nbsp;satisfied))</code>
</pre>
      <p><span class="code">Future</span>'s <span class="code">collect</span> method<a id="i160873094-1"></a><a id="i-557339295-1"></a> allows you to validate the future value and transform it in one operation. If the partial function passed to <span class="code">collect</span> is defined at the future result, the future returned by <span class="code">collect</span> will succeed with that value transformed by the function:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;valid&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fut&nbsp;collect&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;res&nbsp;<code class="vem">if</code>&nbsp;res&nbsp;&gt;&nbsp;<code class="literal">0</code>&nbsp;=&gt;&nbsp;res&nbsp;+&nbsp;<code class="literal">46</code>&nbsp;}
  <code class="output">valid:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;valid.value
  <code class="output">res17:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(88))</code>
</pre>
      <p>Otherwise, the future will fail with <span class="code">NoSuchElementException</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;invalid&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fut&nbsp;collect&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;res&nbsp;<code class="vem">if</code>&nbsp;res&nbsp;&lt;&nbsp;<code class="literal">0</code>&nbsp;=&gt;&nbsp;res&nbsp;+&nbsp;<code class="literal">46</code>&nbsp;}
  <code class="output">invalid:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;invalid.value
  <code class="output">res18:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Failure(java.util.NoSuchElementException:</code>
  <code class="output">&nbsp;&nbsp;Future.collect&nbsp;partial&nbsp;function&nbsp;is&nbsp;not&nbsp;defined&nbsp;at:&nbsp;42))</code>
</pre>
      <h4>Dealing with failure: <span class="code">failed</span>, <span class="code">fallbackTo</span>, <span class="code">recover</span>, and <span class="code">recoverWith</span></h4>
      <p>Scala's future provides ways to work with futures that fail, including <span class="code">failed</span>, <span class="code">fallbackTo</span>, <span class="code">recover</span>, and <span class="code">recoverWith</span>. The <span class="code">failed</span> method<a id="i2053859225-1"></a><a id="i1132575058-1"></a> will transform a failed future of any type into a successful <span class="code">Future[Throwable]</span> that holds onto the exception that caused the failure. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;failure&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="literal">42</code>&nbsp;/&nbsp;<code class="literal">0</code>&nbsp;}
  <code class="output">failure:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;failure.value
  <code class="output">res23:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Failure(java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero))</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;expectedFailure&nbsp;=&nbsp;failure.failed
  <code class="output">expectedFailure:&nbsp;scala.concurrent.Future[Throwable]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;expectedFailure.value
  <code class="output">res25:&nbsp;Option[scala.util.Try[Throwable]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Success(java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero))</code>
</pre>
      <p>If the future on which the <span class="code">failed</span> method is called ultimately succeeds, the future returned by <span class="code">failed</span> will itself fail with a <span class="code">NoSuchElementException</span>. The <span class="code">failed</span> method is appropriate, therefore, only when you expect that the future will fail. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;success&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="literal">42</code>&nbsp;/&nbsp;<code class="literal">1</code>&nbsp;}
  <code class="output">success:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;success.value
  <code class="output">res21:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(42))</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;unexpectedSuccess&nbsp;=&nbsp;success.failed
  <code class="output">unexpectedSuccess:&nbsp;scala.concurrent.Future[Throwable]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;unexpectedSuccess.value
  <code class="output">res26:&nbsp;Option[scala.util.Try[Throwable]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Failure(java.util.NoSuchElementException:</code>
  <code class="output">&nbsp;&nbsp;Future.failed&nbsp;not&nbsp;completed&nbsp;with&nbsp;a&nbsp;throwable.))</code>
</pre>
      <p>The <span class="code">fallbackTo</span> method<a id="i-17509287-1"></a><a id="i-431989870-1"></a> allows you to provide an alternate future to use in case the future on which you invoke <span class="code">fallbackTo</span> fails. Here's an example in which a failed future falls back to a successful future:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fallback&nbsp;=&nbsp;failure.fallbackTo(success)
  <code class="output">fallback:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;fallback.value
  <code class="output">res27:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(42))</code>
</pre>
      <p>If the original future on which <span class="code">fallbackTo</span> is invoked fails, a failure of the future passed to <span class="code">fallbackTo</span> is essentially ignored. The future returned by <span class="code">fallbackTo</span> will fail with the initial exception. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;failedFallback&nbsp;=&nbsp;failure.fallbackTo(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="vem">val</code>&nbsp;res&nbsp;=&nbsp;<code class="literal">42</code>;&nbsp;require(res&nbsp;&lt;&nbsp;<code class="literal">0</code>);&nbsp;res&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <code class="output">failedFallback:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;failedFallback.value
  <code class="output">res28:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Failure(java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero))</code>
</pre>
      <p>The <span class="code">recover</span> method<a id="i-152382784-1"></a><a id="i-724473753-1"></a> allows you to transform a failed future into a successful one, allowing a successful future's result to pass through unchanged. For example, on a future that fails with <span class="code">ArithmeticException</span>, you can use the <span class="code">recover</span> method to transform the failure into a success, like this:</p> <pre>  &nbsp;scala&gt;&nbsp;<code class="vem">val</code>&nbsp;recovered&nbsp;=&nbsp;failedFallback&nbsp;recover&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">ArithmeticException</code>&nbsp;=&gt;&nbsp;-<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">&nbsp;recovered:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  &nbsp;scala&gt;&nbsp;recovered.value
  <code class="output">res32:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(-1))</code>
</pre>
      <p>If the original future doesn't fail, the future returned by <span class="code">recover</span> will complete with the same value:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;unrecovered&nbsp;=&nbsp;fallback&nbsp;recover&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">ArithmeticException</code>&nbsp;=&gt;&nbsp;-<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">unrecovered:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;unrecovered.value
  <code class="output">res33:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(42))</code>
</pre>
      <p>Similarly, if the partial function passed to <span class="code">recover</span> isn't defined at the exception with which the original future ultimately fails, that original failure will pass through:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;alsoUnrecovered&nbsp;=&nbsp;failedFallback&nbsp;recover&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">IllegalArgumentException</code>&nbsp;=&gt;&nbsp;-<code class="literal">2</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">alsoUnrecovered:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;alsoUnrecovered.value
  <code class="output">res34:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Failure(java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero))</code>
</pre>
      <p>The <span class="code">recoverWith</span> method<a id="i-1242555994-1"></a><a id="i-1046291647-1"></a> is similar to <span class="code">recover</span>, except instead of recovering to a value like <span class="code">recover</span>, the <span class="code">recoverWith</span> method allows you to recover to a future value. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;alsoRecovered&nbsp;=&nbsp;failedFallback&nbsp;recoverWith&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">ArithmeticException</code>&nbsp;=&gt;&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="literal">42</code>&nbsp;+&nbsp;<code class="literal">46</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">alsoRecovered:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;alsoRecovered.value
  <code class="output">res35:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(88))</code>
</pre>
      <p>As with <span class="code">recover</span>, if either the original future doesn't fail, or the partial function passed to <span class="code">recoverWith</span> isn't defined at the exception the original future ultimately fails with, the original success (or failure) will pass through to the future returned by <span class="code">recoverWith</span>.</p>
      <h4>Mapping both possibilities: <span class="code">transform</span></h4>
      <p><span class="code">Future</span>'s <span class="code">transform</span> method<a id="i1345650888-1"></a><a id="i1282076639-1"></a> accepts two functions with which to transform a future: one to use in case of success and the other in case of failure:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;first&nbsp;=&nbsp;success.transform(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&gt;&nbsp;res&nbsp;*&nbsp;-<code class="literal">1</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex&nbsp;=&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"see&nbsp;cause"</code>,&nbsp;ex)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <code class="output">first:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
</pre>
      <p>If the future succeeds, the first function is used:</p> <pre>  scala&gt;&nbsp;first.value
  <code class="output">res42:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(-42))</code>
</pre>
      <p>If the future fails, the second function is used:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;second&nbsp;=&nbsp;failure.transform(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&gt;&nbsp;res&nbsp;*&nbsp;-<code class="literal">1</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex&nbsp;=&gt;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"see&nbsp;cause"</code>,&nbsp;ex)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <code class="output">second:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;second.value
  <code class="output">res43:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Failure(java.lang.Exception:&nbsp;see&nbsp;cause))</code>
</pre>
      <p>Note that with the <span class="code">transform</span> method shown in the previous examples, you can't change a successful future into a failed one, nor can you change a failed future into a successful one. To make this kind of transformation easier, Scala 2.12 introduced an alternate overloaded form of <span class="code">transform</span> that<a id="i88737196-3"></a> takes a function from <span class="code">Try</span> to <span class="code">Try</span>. Here are some examples:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;firstCase&nbsp;=&nbsp;success.transform&nbsp;{&nbsp;<code class="comment">//&nbsp;Scala&nbsp;2.12</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(res)&nbsp;=&gt;&nbsp;<code class="typename">Success</code>(res&nbsp;*&nbsp;-<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Failure</code>(ex)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Failure</code>(<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"see&nbsp;cause"</code>,&nbsp;ex))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  first:&nbsp;<code class="typename">scala.concurrent.Future[Int]</code>&nbsp;=&nbsp;...
  <br>  scala&gt;&nbsp;firstCase.value
  <code class="output">res6:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(-42))</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;secondCase&nbsp;=&nbsp;failure.transform&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(res)&nbsp;=&gt;&nbsp;<code class="typename">Success</code>(res&nbsp;*&nbsp;-<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Failure</code>(ex)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Failure</code>(<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(<code class="quotedstring">"see&nbsp;cause"</code>,&nbsp;ex))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">secondCase:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;secondCase.value
  <code class="output">res8:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  &nbsp;&nbsp;&nbsp;<code class="typename">Some</code>(<code class="typename">Failure</code>(<code class="typename">java.lang.Exception</code>:&nbsp;see&nbsp;cause))
</pre>
      <p>Here's an example of using the new <span class="code">transform</span> method to transform a failure into a success:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;nonNegative&nbsp;=&nbsp;failure.transform&nbsp;{&nbsp;<code class="comment">//&nbsp;Scala&nbsp;2.12</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(res)&nbsp;=&gt;&nbsp;<code class="typename">Success</code>(res.abs&nbsp;+&nbsp;<code class="literal">1</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Failure</code>(_)&nbsp;=&gt;&nbsp;<code class="typename">Success</code>(<code class="literal">0</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">nonNegative:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;nonNegative.value
  <code class="output">res11:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(0))</code>
</pre>
      <h4>Combining futures: <span class="code">zip</span>, <span class="code">Future.foldLeft</span>, <span class="code">Future.reduceLeft</span>, <span class="code">Future.sequence</span>, and <span class="code">Future.traverse</span></h4>
      <p><span class="code">Future</span> and its companion object offer methods that allow you to combine multiple futures. The <span class="code">zip</span> method<a id="i-1389589174-1"></a><a id="i-576155948-1"></a> will transform two successful futures into a future tuple of both values. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;zippedSuccess&nbsp;=&nbsp;success&nbsp;zip&nbsp;recovered
  <code class="output">zippedSuccess:&nbsp;scala.concurrent.Future[(Int,&nbsp;Int)]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;zippedSuccess.value
  <code class="output">res46:&nbsp;Option[scala.util.Try[(Int,&nbsp;Int)]]&nbsp;=</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Some</code>(<code class="typename">Success</code>((<code class="literal">42</code>,-<code class="literal">1</code>)))
</pre>
      <p>If either of the futures fail, however, the future returned by <span class="code">zip</span> will also fail with the same exception:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;zippedFailure&nbsp;=&nbsp;success&nbsp;zip&nbsp;failure
  <code class="output">zippedFailure:&nbsp;scala.concurrent.Future[(Int,&nbsp;Int)]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;zippedFailure.value
  <code class="output">res48:&nbsp;Option[scala.util.Try[(Int,&nbsp;Int)]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Failure(java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero))</code>
</pre>
      <p>If both futures fail, the failed future that results will contain the exception stored in the initial future, the one on which <span class="code">zip</span> was invoked.</p>
      <p><span class="code">Future</span>'s companion object offers a <span class="code">foldLeft</span> method<a id="i-1316728868-1"></a><a id="i-946155748-1"></a> that allows you to accumulate a result across an <span class="code">Iterable</span> collection of futures, yielding a future result. If all futures in the collection succeed, the resulting future will succeed with the accumulated result. If any future in the collection fails, the resulting future will fail. If multiple futures fail, the result will fail with the same exception with which the first future (earliest in the <span class="code">Iterable</span> collection) fails. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fortyTwo&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  <code class="output">fortyTwo:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fortySix&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="literal">23</code>&nbsp;+&nbsp;<code class="literal">23</code>&nbsp;}
  <code class="output">fortySix:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;futureNums&nbsp;=&nbsp;<code class="typename">List</code>(fortyTwo,&nbsp;fortySix)
  <code class="output">futureNums:&nbsp;List[scala.concurrent.Future[Int]]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;folded&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Future.foldLeft(futureNums)(<code class="literal">0</code>)&nbsp;{&nbsp;(acc,&nbsp;num)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc&nbsp;+&nbsp;num
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">folded:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;folded.value
  <code class="output">res53:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(88))</code>
</pre>
      <p>The <span class="code">Future.reduceLeft</span> method<a id="i-728492073-1"></a><a id="i-465887423-1"></a> performs a fold without a zero, using the initial future result as the start value. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;reduced&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Future.reduceLeft(futureNums)&nbsp;{&nbsp;(acc,&nbsp;num)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc&nbsp;+&nbsp;num
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">reduced:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;reduced.value
  <code class="output">res54:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(88))</code>
</pre>
      <p>If you pass an empty collection to <span class="code">reduce</span>, the resulting future will fail with a <span class="code">NoSuchElementException</span>.</p>
      <p>The <span class="code">Future.sequence</span> method<a id="i1360532195-1"></a><a id="i-1604674187-1"></a> transforms a <span class="code">TraversableOnce</span> collection of futures into a future <span class="code">TraversableOnce</span> of values. For instance, in the following example, <span class="code">sequence</span> is used to transform a <span class="code">List[Future[Int]]</span> to a <span class="code">Future[List[Int]]</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;futureList&nbsp;=&nbsp;Future.sequence(futureNums)
  <code class="output">futureList:&nbsp;scala.concurrent.Future[List[Int]]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;futureList.value
  <code class="output">res55:&nbsp;Option[scala.util.Try[List[Int]]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;Some(Success(List(42,&nbsp;46)))</code>
</pre>
      <p>The <span class="code">Future.traverse</span> method<a id="i-551617710-1"></a><a id="i-1636098202-1"></a> will change a <span class="code">TraversableOnce</span> of any element type into a <span class="code">TraversableOnce</span> of futures and "sequence" that into a future <span class="code">TraversableOnce</span> of values. For example, here a <span class="code">List[Int]</span> is transformed into a <span class="code">Future[List[Int]]</span> by <span class="code">Future.traverse</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;traversed&nbsp;=
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Future.traverse(List(1,&nbsp;2,&nbsp;3))&nbsp;{&nbsp;i&nbsp;=&gt;&nbsp;Future(i)&nbsp;}</code>
  <code class="output">traversed:&nbsp;scala.concurrent.Future[List[Int]]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;traversed.value
  <code class="output">res58:&nbsp;Option[scala.util.Try[List[Int]]]&nbsp;=&nbsp;</code>
  <code class="output">&nbsp;&nbsp;Some(Success(List(1,&nbsp;2,&nbsp;3)))</code>
</pre>
      <h4>Performing side-effects: <span class="code">foreach</span>, <span class="code">onComplete</span>, and <span class="code">andThen</span></h4>
      <p>Sometimes you may need to perform a side effect after a future completes. <span class="code">Future</span> provides several methods for this purpose. The most basic method is <span class="code">foreach</span>, which will perform a side effect if a future completes successfully.<a id="i1188146899-1"></a><a id="i776534149-1"></a> For instance, in the following example a <span class="code">println</span> is not executed in the case of a failed future, just a successful future:</p> <pre>  scala&gt;&nbsp;failure.foreach(ex&nbsp;=&gt;&nbsp;println(ex))
  <br>  scala&gt;&nbsp;success.foreach(res&nbsp;=&gt;&nbsp;println(res))
  <code class="output">42</code>
</pre>
      <p>Since <span class="code">for</span> without <span class="code">yield</span> will rewrite to an invocation of <span class="code">foreach</span>, you can also accomplish the same effect using <span class="code">for</span> expressions:</p> <pre>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(res&nbsp;&lt;-&nbsp;failure)&nbsp;println(res)
  <br>  scala&gt;&nbsp;<code class="vem">for</code>&nbsp;(res&nbsp;&lt;-&nbsp;success)&nbsp;println(res)
  <code class="output">42</code>
</pre>
      <p><span class="code">Future</span> also offers two methods for registering "callback" functions. The <span class="code">onComplete</span> method will be executed whether the future ultimately succeeds or fails.<a id="i-1956458092-1"></a><a id="i1655500727-1"></a> The function will be passed a <span class="code">Try</span>—a <span class="code">Success</span> holding the result if the future succeeded, else a <span class="code">Failure</span> holding the exception that caused the future to fail. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.util.{<code class="typename">Success</code>,&nbsp;<code class="typename">Failure</code>}
  <code class="output">import&nbsp;scala.util.{Success,&nbsp;Failure}</code>
  <br>  scala&gt;&nbsp;success&nbsp;onComplete&nbsp;{
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Success(res)&nbsp;=&gt;&nbsp;println(res)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Failure(ex)&nbsp;=&gt;&nbsp;println(ex)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code>
  <code class="output">42</code>
  <br>  scala&gt;&nbsp;failure&nbsp;onComplete&nbsp;{
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Success(res)&nbsp;=&gt;&nbsp;println(res)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Failure(ex)&nbsp;=&gt;&nbsp;println(ex)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code>
  <code class="output">java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero</code>
</pre>
      <p><span class="code">Future</span> does not guarantee any order of execution for callback functions registered with <span class="code">onComplete</span>. If you want to enforce an order for callback functions, you must use <span class="code">andThen</span> instead.<a id="i-522076688-1"></a><a id="i-886602953-1"></a> The <span class="code">andThen</span> method returns a new future that mirrors (succeeds or fails in the same way as) the original future on which you invoke <span class="code">andThen</span>, but it does not complete until the callback function has been fully executed:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;newFuture&nbsp;=&nbsp;success&nbsp;andThen&nbsp;{
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Success(res)&nbsp;=&gt;&nbsp;println(res)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Failure(ex)&nbsp;=&gt;&nbsp;println(ex)</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code>
  <code class="output">42</code>
  <code class="output">newFuture:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;newFuture.value
  <code class="output">res76:&nbsp;Option[scala.util.Try[Int]]&nbsp;=&nbsp;Some(Success(42))</code>
</pre>
      <p>Note that if a callback function passed to <span class="code">andThen</span> throws an exception when executed, that exception will not be propagated to subsequent callbacks or reported via the resulting future.</p>
      <h4>Other methods added in 2.12: <span class="code">flatten</span>, <span class="code">zipWith</span>, and <span class="code">transformWith</span></h4>
      <p>The <span class="code">flatten</span> method,<a id="i-1187330208-1"></a><a id="i1701496775-1"></a> added in 2.12, transforms a <span class="code">Future</span> nested inside another <span class="code">Future</span> into a <span class="code">Future</span> of the nested type. For example, <span class="code">flatten</span> can transform a <span class="code">Future[Future[Int]]</span> into a <span class="code">Future[Int]</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;nestedFuture&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="literal">42</code>&nbsp;}&nbsp;}
  <code class="output">nestedFuture:&nbsp;Future[Future[Int]]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;flattened&nbsp;=&nbsp;nestedFuture.flatten&nbsp;<code class="comment">//&nbsp;Scala&nbsp;2.12</code>
  <code class="output">flattened:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;Future(Success(42))</code>
</pre>
      <p>The <span class="code">zipWith</span> method, added in 2.12, essentially zips two <span class="code">Future</span>s together, then performs a <span class="code">map</span> on the resulting tuple. Here's an example of the two-step process, a <span class="code">zip</span> followed by a <span class="code">map</span>:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;futNum&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  <code class="output">futNum:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;futStr&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="quotedstring">"ans"</code>&nbsp;+&nbsp;<code class="quotedstring">"wer"</code>&nbsp;}
  <code class="output">futStr:&nbsp;scala.concurrent.Future[String]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;zipped&nbsp;=&nbsp;futNum&nbsp;zip&nbsp;futStr
  <code class="output">zipped:&nbsp;scala.concurrent.Future[(Int,&nbsp;String)]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;mapped&nbsp;=&nbsp;zipped&nbsp;map&nbsp;{
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;(num,&nbsp;str)&nbsp;=&gt;&nbsp;s"$num&nbsp;is&nbsp;the&nbsp;$str"&nbsp;</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code>
  <code class="output">mapped:&nbsp;scala.concurrent.Future[String]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;mapped.value
  <code class="output">res2:&nbsp;Option[scala.util.Try[String]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Some(Success(42&nbsp;is&nbsp;the&nbsp;answer))</code>
</pre>
      <p>The <span class="code">zipWith</span> method allows you to perform the same operation in one step:<a id="i996770531-1"></a><a id="i-62204252-1"></a></p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut&nbsp;=&nbsp;futNum.zipWith(futStr)&nbsp;{&nbsp;<code class="comment">//&nbsp;Scala&nbsp;2.12</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;(num,&nbsp;str)&nbsp;=&gt;&nbsp;s<code class="quotedstring">"$num&nbsp;is&nbsp;the&nbsp;$str"</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">zipWithed:&nbsp;scala.concurrent.Future[String]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;fut.value
  <code class="output">res3:&nbsp;Option[scala.util.Try[String]]&nbsp;=</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;Some(Success(42&nbsp;is&nbsp;the&nbsp;answer))</code>
</pre>
      <p><span class="code">Future</span> also gained a <span class="code">transformWith</span> method in Scala 2.12, which allows you to transform a future using a function from <span class="code">Try</span> to <span class="code">Future</span>.<a id="i-488373330-1"></a><a id="i968615609-1"></a> Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;flipped&nbsp;=&nbsp;success.transformWith&nbsp;{&nbsp;<code class="comment">//&nbsp;Scala&nbsp;2.12</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(res)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="vem">throw</code>&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Exception</code>(res.toString)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Failure</code>(ex)&nbsp;=&gt;&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <code class="output">flipped:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;flipped.value
  <code class="output">res5:&nbsp;Option[scala.util.Try[Int]]&nbsp;=</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Some</code>(<code class="typename">Failure</code>(<code class="typename">java.lang.Exception</code>:&nbsp;<code class="literal">42</code>))
</pre>
      <p>The <span class="code">transformWith</span> method is similar to the new, overloaded <span class="code">transform</span> method added in Scala 2.12, except instead of yielding a <span class="code">Try</span> in your passed function as in <span class="code">transform</span>, <span class="code">transformWith</span> allows you to yield a future.</p>
      <h3>32.4 Testing with <span class="code">Future</span>s</h3>
      <p>One advantage of Scala's futures is that they help you avoid blocking. On most JVM implementations, after creating just a few thousand threads, the cost of context switching between threads will degrade performance to an unnacceptable level. By avoiding blocking, you can keep the finite number of threads you decide to work with busy. Nevertheless, Scala does allow you to block on a future result when you need to. Scala's <span class="code">Await</span> object facilitates blocking to wait for future results. Here's an example:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.concurrent.Await
  <code class="output">import&nbsp;scala.concurrent.Await</code>
  <br>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;scala.concurrent.duration._
  <code class="output">import&nbsp;scala.concurrent.duration._</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  <code class="output">fut:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;x&nbsp;=&nbsp;Await.result(fut,&nbsp;<code class="literal">15.</code>seconds)&nbsp;<code class="comment">//&nbsp;blocks</code>
  <code class="output">x:&nbsp;Int&nbsp;=&nbsp;42</code>
</pre>
      <p><span class="code">Await.result</span> takes a <span class="code">Future</span> and a <span class="code">Duration</span>. The <span class="code">Duration</span> indicates how long <span class="code">Await.result</span> should wait for a <span class="code">Future</span> to complete before timing out. In this example, fifteen seconds was specified for the <span class="code">Duration</span>. Thus the <span class="code">Await.result</span> method should not time out before the future completes with its eventual value, 42.</p>
      <p>One place where blocking has been generally accepted is in tests of asynchronous code. Now that the <span class="code">Await.result</span> has returned, you can perform a computation using that result, such as an assertion in a test:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest.matchers.should.Matchers._
  <code class="vem">import</code>&nbsp;org.scalatest.matchers.should.Matchers._
  <br>  scala&gt;&nbsp;x&nbsp;should&nbsp;be&nbsp;(<code class="literal">42</code>)
  <code class="output">res0:&nbsp;org.scalatest.Assertion&nbsp;=&nbsp;Succeeded</code>
</pre>
      <p>Alternatively, you can use blocking constructs provided by ScalaTest's trait <span class="code">ScalaFutures</span>. For example, the <span class="code">futureValue</span> method, implicitly added to <span class="code">Future</span> by <span class="code">ScalaFutures</span>, will block until the future completes. If the future fails, <span class="code">futureValue</span> will throw a <span class="code">TestFailedException</span> describing the problem. If the future succeeds, <span class="code">futureValue</span> will return the successful result of the future so you can perform assertions on that value:</p> <pre>  scala&gt;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest.concurrent.ScalaFutures._
  <code class="output">import&nbsp;org.scalatest.concurrent.ScalaFutures._</code>
  <br>  scala&gt;&nbsp;<code class="vem">val</code>&nbsp;fut&nbsp;=&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;Thread.sleep(<code class="literal">10000</code>);&nbsp;<code class="literal">21</code>&nbsp;+&nbsp;<code class="literal">21</code>&nbsp;}
  <code class="output">fut:&nbsp;scala.concurrent.Future[Int]&nbsp;=&nbsp;...</code>
  <br>  scala&gt;&nbsp;fut.futureValue&nbsp;should&nbsp;be&nbsp;(<code class="literal">42</code>)&nbsp;<code class="comment">//&nbsp;futureValue&nbsp;blocks</code>
  <code class="output">res1:&nbsp;org.scalatest.Assertion&nbsp;=&nbsp;Succeeded</code>
</pre>
      <p>While blocking in tests is often fine, ScalaTest 3.0 adds "async" testing styles that allow you to test futures without blocking. Given a future, instead of blocking and performing assertions on the result, you can map assertions directly onto that future and return the resulting <span class="code">Future[Assertion]</span> to ScalaTest. An example is shown in <a href="#lst-scalatest-future-assertion">Listing 32.1</a>. When the future assertion completes, ScalaTest will fire events (test succeeded, test failed, <i>etc.</i>) to the test reporter asynchronously.</p>
      <p><a id="lst-scalatest-future-assertion"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;org.scalatest.funspec.AsyncFunSpec
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.concurrent.Future
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">AddSpec</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">AsyncFunSpec</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;addSoon(addends:&nbsp;<code class="typename">Int</code>*):&nbsp;<code class="typename">Future[Int]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Future</code>&nbsp;{&nbsp;addends.sum&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;describe(<code class="quotedstring">"addSoon"</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it(<code class="quotedstring">"will&nbsp;eventually&nbsp;compute&nbsp;a&nbsp;sum&nbsp;of&nbsp;passed&nbsp;Ints"</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;futureSum:&nbsp;<code class="typename">Future[Int]</code>&nbsp;=&nbsp;addSoon(<code class="literal">1</code>,&nbsp;<code class="literal">2</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;You&nbsp;can&nbsp;map&nbsp;assertions&nbsp;onto&nbsp;a&nbsp;Future,&nbsp;then&nbsp;return</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;the&nbsp;resulting&nbsp;Future[Assertion]&nbsp;to&nbsp;ScalaTest:</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;futureSum&nbsp;map&nbsp;{&nbsp;sum&nbsp;=&gt;&nbsp;assert(sum&nbsp;==&nbsp;<code class="literal">3</code>)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 32.1 - Returning a future assertion to ScalaTest.</h5>
      <p>The async testing use case illustrates a general principle for working with futures: Once in "future space," try to stay in future space. Don't block on a future then continue the computation with the result. Stay asynchronous by performing a series of transformations, each of which returns a new future to transform. To get results out of future space, register side effects to be performed asynchronously once futures complete. This approach will help you make maximum use of your threads.</p>
      <h3>32.5 Conclusion</h3>
      <p>Concurrent programming gives you great power. It lets you simplify your code and take advantage of multiple processors. It's unfortunate that the most widely used concurrency primitives, threads, locks, and monitors, are such a minefield of deadlocks and race conditions. Futures provide a way out of that minefield, letting you write concurrent programs without as great a risk of deadlocks and race conditions. This chapter has introduced several fundamental constructs for working with futures in Scala, including how to create futures, how to transform them, and how to test them, among other nuts and bolts. It then showed you how to use these constructs as part of a general futures style.</p>
      <hr>
      <h4>Footnotes for Chapter 32:</h4>
      <p><a id="footnotemain32-1"></a>[1] On Scala.js,<a id="i-827373807-2"></a> the global execution context places tasks on the JavaScript event queue.</p>
      <p><a id="footnotemain32-2"></a>[2] Note that the Java <span class="code">Future</span> also has a way to deal with the potential of an exception being thrown by the asynchronous computation: its <span class="code">get</span> method will throw that exception wrapped in an <span class="code">ExecutionException</span>.</p>
      <p><a id="footnotemain32-3"></a>[3] The <span class="code">for</span> expression shown in this example will be rewritten as a call to <span class="code">fut1.flatMap</span> passing in a function that calls <span class="code">fut2.map</span>: <span class="code">fut1.flatMap(x</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">fut2.map(y</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y))</span>.</p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-combinator-parsing">Chapter 33</a></h2>
      <h1>Combinator Parsing</h1>
      <p>Occasionally, you may need to process a small, special-purpose language.<a id="i1395246279-1"></a> For example, you may need to read configuration files for your software, and you want to make them easier to modify by hand than XML. Alternatively, maybe you want to support an input language in your program, such as search terms with boolean operators (computer, find me a movie "with `space ships' and without `love stories"'). Whatever the reason, you are going to need a <em>parser</em>.<a id="i-792967116-1"></a> You need a way to convert the input language into some data structure your software can process.</p>
      <p>Essentially, you have only a few choices. One choice is to roll your own parser (and lexical analyzer). If you are not an expert, this is hard. If you are an expert, it is still time consuming.</p>
      <p>An alternative choice is to use a parser generator.<a id="i-1495136757-1"></a> There exist quite a few of these generators. Some of the better known are Yacc and Bison for parsers written in C and ANTLR for parsers written in Java.<a id="i-606539021-1"></a><a id="i2747784-1"></a><a id="i64194507-1"></a><a id="i62435725-1"></a><a id="i-679763866-1"></a> You'll probably also need a scanner generator such as Lex, Flex, or JFlex to go with it.<a id="i76287-1"></a><a id="i2192409-1"></a><a id="i70532963-1"></a><a id="i-693168286-1"></a> This might be the best solution, except for a couple of inconveniences. You need to learn new tools, including their—sometimes obscure—error messages. You also need to figure out how to connect the output of these tools to your program. This might limit the choice of your programming language, and complicate your tool chain.</p>
      <p>This chapter presents a third alternative. Instead of using the standalone domain specific language of a parser generator, you will use an <span style="font-style:italic">internal domain specific language</span>, or internal DSL for short.<a id="i-1137790491-1"></a> The internal DSL will consist of a library of <span style="font-style:italic">parser combinators</span>—functions and operators defined in Scala that will serve as building blocks for parsers.<a id="i-2095840458-1"></a> These building blocks will map one to one to the constructions of a context-free grammar, to make them easy to understand.<a id="i-581215934-1"></a></p>
      <p>This chapter introduces only one language feature that was not explained before: <span class="code">this</span> aliasing, in <a href="#sec-this-aliasing">Section 33.6</a>. The chapter does, however, heavily use several other features that were explained in previous chapters. Among others, parameterized types, abstract types, functions as objects, operator overloading, by-name parameters, and implicit conversions all play important roles. The chapter shows how these language elements can be combined in the design of a very high-level library.</p>
      <p>The concepts explained in this chapter tend to be a bit more advanced than previous chapters. If you have a good grounding in compiler construction, you'll profit from it reading this chapter, because it will help you put things better in perspective. However, the only prerequisite for understanding this chapter is that you know about regular and context-free grammars. If you don't, the material in this chapter can also safely be skipped.</p>
      <h3 id="sec-arith">33.1 Example: Arithmetic expressions</h3>
      <p>We'll start with an example. Say you want to construct a parser for arithmetic expressions consisting of floating-point numbers, parentheses, and the binary operators <span class="code">+</span>, <span class="code">-</span>, <span class="code">*</span>, and <span class="code">/</span>. The first step is always to write down a grammar for the language to be parsed. Here's the grammar for arithmetic expressions:</p>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr>
              <td> <span style="font-style:italic">expr</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">term</span> &nbsp;\{<span class="code">"+"</span>&nbsp; <span style="font-style:italic">term</span> &nbsp;|&nbsp; <span class="code">"-"</span> &nbsp;<span style="font-style:italic">term</span>\}. </td>
            </tr>
            <tr>
              <td> <span style="font-style:italic">term</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">factor</span> &nbsp;\{<span class="code">"*"</span>&nbsp; <span style="font-style:italic">factor</span> &nbsp;|&nbsp; <span class="code">"/"</span> &nbsp;<span style="font-style:italic">factor</span>\}. </td>
            </tr>
            <tr>
              <td> <span style="font-style:italic">factor</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">floatingPointNumber</span> &nbsp;|&nbsp; <span class="code">"("</span>&nbsp; <span style="font-style:italic">expr</span> &nbsp;<span class="code">")"</span>. </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>Here, | denotes alternative productions, and \{ ... \} denotes repetition (zero or more times). And although there's no use of it in this example, [ ... ] denotes an optional occurrence.</p>
      <p>This context-free grammar defines formally a language of arithmetic expressions. Every expression (represented by <em>expr</em>) is a <em>term</em>, which can be followed by a sequence of <span class="code">+</span> or <span class="code">-</span> operators and further <em>term</em>s. A <em>term</em> is a <em>factor</em>, possibly followed by a sequence of <span class="code">*</span> or <span class="code">/</span> operators and further <em>factor</em>s. A <em>factor</em> is either a numeric literal or an expression in parentheses. Note that the grammar already encodes the relative precedence of operators. For instance, <span class="code">*</span> binds more tightly than <span class="code">+</span>, because a <span class="code">*</span> operation gives a <em>term</em>, whereas a <span class="code">+</span> operation gives an <em>expr</em>, and <em>expr</em>s can contain <em>term</em>s but a <em>term</em> can contain an <em>expr</em> only when the latter is enclosed in parentheses.</p>
      <p>Now that you have defined the grammar, what's next? If you use Scala's combinator parsers, you are basically done! You only need to perform some systematic text replacements and wrap the parser in a class, as shown in <a href="#lst-expression-parser">Listing 33.1</a>: <a id="lst-expression-parser"></a></p> <pre>  <code class="vem">import</code>&nbsp;scala.util.parsing.combinator._
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">Arith</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">JavaTokenParsers</code>&nbsp;{&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;expr:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;term<code style="font-size:large">~</code>rep(<code class="quotedstring">"+"</code><code style="font-size:large">~</code>term&nbsp;|&nbsp;<code class="quotedstring">"-"</code><code style="font-size:large">~</code>term)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;term:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;factor<code style="font-size:large">~</code>rep(<code class="quotedstring">"*"</code><code style="font-size:large">~</code>factor&nbsp;|&nbsp;<code class="quotedstring">"/"</code><code style="font-size:large">~</code>factor)
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;factor:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;floatingPointNumber&nbsp;|&nbsp;<code class="quotedstring">"("</code><code style="font-size:large">~</code>expr<code style="font-size:large">~</code><code class="quotedstring">")"</code>
  }
</pre>
      <h5>Listing 33.1 - An arithmetic expression parser.</h5>
      <p>The parsers for arithmetic expressions are contained in a class that inherits from the trait <span class="code">JavaTokenParsers</span>.<a id="i-585361525-1"></a> This trait provides the basic machinery for writing a parser and also provides some primitive parsers that recognize some word classes: identifiers, string literals and numbers. In the example in <a href="#lst-expression-parser">Listing 33.1</a> you need only the primitive <span class="code">floatingPointNumber</span> parser, which is inherited from this trait.<a id="i1891349662-1"></a><a id="i-63210921-1"></a></p>
      <p>The three definitions in class <span class="code">Arith</span> represent the productions for arithmetic expressions. As you can see, they follow very closely the productions of the context-free grammar. In fact, you could generate this part automatically from the context-free grammar, by performing a number of simple text replacements:</p>
      <ol>
        <li>Every production becomes a method, so you need to prefix it with <span class="code">def</span>. </li>
        <li> The result type of each method is <span class="code">Parser[Any]</span>, so you need to change the ::= symbol to "<span class="code">:</span>&nbsp;<span class="code">Parser[Any]</span>&nbsp;<span class="code">=</span>". You'll find out later in this chapter what the type <span class="code">Parser[Any]</span> signifies, and also how to make it more precise. </li>
        <li> In the grammar, sequential composition was implicit, but in the program it is expressed by an explicit operator: <span class="code"><span style="font-size:large">~</span></span>. So you need to insert a <span class="code"><span style="font-size:large">~</span></span> between every two consecutive symbols of a production. In the example in <a href="#lst-expression-parser">Listing 33.1</a> we chose not to write any spaces around the <span class="code"><span style="font-size:large">~</span></span> operator. That way, the parser code keeps closely to the visual appearance of the grammar—it just replaces spaces by <span class="code"><span style="font-size:large">~</span></span> characters. </li>
        <li> Repetition is expressed <span class="code">rep(</span> ... <span class="code">)</span> instead of \{ ... \}. Analogously (though not shown in the example), option is expressed <span class="code">opt(</span> ... <span class="code">)</span> instead of [ ... ]. </li>
        <li> The period (.) at the end of each production is omitted—you can, however, write a semicolon (<span class="code">;</span>) if you prefer. </li>
      </ol>
      <p>That's all there is to it. The resulting class <span class="code">Arith</span> defines three parsers, <span class="code">expr</span>, <span class="code">term</span> and <span class="code">factor</span>, which can be used to parse arithmetic expressions and their parts.</p>
      <h3>33.2 Running your parser</h3>
      <p>You can exercise your parser with the following small program:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">ParseExpr</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Arith</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<code class="quotedstring">"input&nbsp;:&nbsp;"</code>&nbsp;+&nbsp;args(<code class="literal">0</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(parseAll(expr,&nbsp;args(<code class="literal">0</code>)))
  &nbsp;&nbsp;}
  }
</pre>
      <p>The <span class="code">ParseExpr</span> object defines a <span class="code">main</span> method that parses the first command-line argument passed to it. It prints the original input argument, and then prints its parsed version. Parsing is done by the expression:</p> <pre>  parseAll(expr,&nbsp;input)
</pre>
      <p>This expression applies the parser, <span class="code">expr</span>, to the given <span class="code">input</span>. It expects that all of the input matches, <i>i.e.</i>, that there are no characters trailing a parsed expression. There's also a method <span class="code">parse</span>, which allows you to parse an input prefix, leaving some remainder unread.</p>
      <p>You can run the arithmetic parser with the following command:</p> <pre>  $&nbsp;scala&nbsp;ParseExpr&nbsp;"2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7)"
  <code class="output">input:&nbsp;2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7)</code>
  <code class="output">[1.12]&nbsp;parsed:&nbsp;((2<code style="font-size:large">~</code>List((*<code style="font-size:large">~</code>(((<code style="font-size:large">~</code>((3<code style="font-size:large">~</code>List())<code style="font-size:large">~</code>List((+</code>
  <code class="output"><code style="font-size:large">~</code>(7<code style="font-size:large">~</code>List())))))<code style="font-size:large">~</code>)))))<code style="font-size:large">~</code>List())</code>
</pre>
      <p>The output tells you that the parser successfully analyzed the input string up to position [1.12]. That means the first line and the twelfth column—in other words, the whole input string—was parsed. Disregard for the moment the result after "<span class="code">parsed:</span>". It is not very useful, and you will find out later how to get more specific parser results.</p>
      <p>You can also try to introduce some input string that is not a legal expression. For instance, you could write one closing parenthesis too many:</p> <pre>  $&nbsp;scala&nbsp;ParseExpr&nbsp;"2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7))"
  <code class="output">input:&nbsp;2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7))</code>
  <code class="output">[1.12]&nbsp;failure:&nbsp;`-'&nbsp;expected&nbsp;but&nbsp;`)'&nbsp;found</code>
  <code class="output"></code>
  <code class="output">2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7))</code>
  <code class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</code>
</pre>
      <p>Here, the <span class="code">expr</span> parser parsed everything until the final closing parenthesis, which does not form part of the arithmetic expression. The <span class="code">parseAll</span> method then issued an error message, which said that it expected a <span class="code">-</span> operator at the point of the closing parenthesis. You'll find out later in this chapter why it produced this particular error message, and how you can improve it.</p>
      <h3>33.3 Basic regular expression parsers</h3>
      <p>The parser for arithmetic expressions made use of another parser, named <span class="code">floatingPointNumber</span>. This parser, which was inherited from <span class="code">Arith</span>'s supertrait, <span class="code">JavaTokenParsers</span>, recognizes a floating point number in the format of Java. But what do you do if you need to parse numbers in a format that's a bit different from Java's? In this situation, you can use a <em>regular expression parser</em>.</p>
      <p>The idea is that you can use any regular expression as a parser.<a id="i-2139156663-1"></a> The regular expression parses all strings that it can match. Its result is the parsed string. For instance, the regular expression parser shown in <a href="#lst-regular-expression-parser">Listing 33.2</a> describes Java's identifiers: <a id="lst-regular-expression-parser"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">MyParsers</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">RegexParsers</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;ident:&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;<code class="quotedstring">"""[a-zA-Z_]\w*"""</code>.r
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 33.2 - A regular expression parser for Java identifiers.</h5>
      <p>The <span class="code">MyParsers</span> object of <a href="#lst-regular-expression-parser">Listing 33.2</a> inherits from trait <span class="code">RegexParsers</span>, whereas <span class="code">Arith</span> inherited from <span class="code">JavaTokenParsers</span>.<a id="i519257659-1"></a> Scala's parsing combinators are arranged in a hierarchy of traits, which are all contained in package <span class="code">scala.util.parsing.combinator</span>. The top-level trait is <span class="code">Parsers</span>, which defines a very general parsing framework for all sorts of input. One level below is trait <span class="code">RegexParsers</span>, which requires that the input is a sequence of characters and provides for regular expression parsing. Even more specialized is trait <span class="code">JavaTokenParsers</span>, which implements parsers for basic classes of words (or <span style="font-style:italic">tokens</span>) as they are defined in Java.</p>
      <h3>33.4 Another example: JSON</h3>
      <p>JSON, the JavaScript Object Notation, is a popular data interchange format.<a id="i2286824-1"></a> In this section, we'll show you how to write a parser for it. Here's a grammar that describes the syntax of JSON:</p>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr>
              <td> <span style="font-style:italic">value</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">obj</span> &nbsp;|&nbsp; <span style="font-style:italic">arr</span> &nbsp;|&nbsp; <span style="font-style:italic">stringLiteral</span> &nbsp;| </td>
            </tr>
            <tr>
              <td> </td>
              <td> </td>
              <td> <span style="font-style:italic">floatingPointNumber</span> &nbsp;| </td>
            </tr>
            <tr>
              <td> </td>
              <td> </td>
              <td> <span class="code">"null"</span> &nbsp;|&nbsp; <span class="code">"true"</span> &nbsp;|&nbsp; <span class="code">"false"</span>. </td>
            </tr>
            <tr>
              <td> <span style="font-style:italic">obj</span> </td>
              <td> ::= </td>
              <td> <span class="code">"{"</span> &nbsp;[<span style="font-style:italic">members</span>]&nbsp; <span class="code">"}"</span>. </td>
            </tr>
            <tr>
              <td> <span style="font-style:italic">arr</span> </td>
              <td> ::= </td>
              <td> <span class="code">"["</span> &nbsp;[<span style="font-style:italic">values</span>]&nbsp; <span class="code">"]"</span>. </td>
            </tr>
            <tr>
              <td> <span style="font-style:italic">members</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">member</span> &nbsp;\{<span class="code">","</span>&nbsp; <span style="font-style:italic">member</span>\}. </td>
            </tr>
            <tr>
              <td> <span style="font-style:italic">member</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">stringLiteral</span> &nbsp;<span class="code">":"</span>&nbsp; <span style="font-style:italic">value</span>. </td>
            </tr>
            <tr>
              <td> <span style="font-style:italic">values</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">value</span> &nbsp;\{<span class="code">","</span>&nbsp; <span style="font-style:italic">value</span>\}. </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>A JSON value is an object, array, string, number, or one of the three reserved words <span class="code">null</span>, <span class="code">true</span>, or <span class="code">false</span>. A JSON object is a (possibly empty) sequence of members separated by commas and enclosed in braces. Each member is a string/value pair where the string and the value are separated by a colon. Finally, a JSON array is a sequence of values separated by commas and enclosed in square brackets. As an example, <a href="#lst-JSON-data">Listing 33.3</a> contains an address-book formatted as a JSON object. <a id="lst-JSON-data"></a></p> <pre>  &nbsp;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"address&nbsp;book"</code>:&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"name"</code>:&nbsp;<code class="quotedstring">"John&nbsp;Smith"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"address"</code>:&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"street"</code>:&nbsp;<code class="quotedstring">"10&nbsp;Market&nbsp;Street"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"city"</code>&nbsp;&nbsp;:&nbsp;<code class="quotedstring">"San&nbsp;Francisco,&nbsp;CA"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"zip"</code>&nbsp;&nbsp;&nbsp;:&nbsp;<code class="literal">94111</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"phone&nbsp;numbers"</code>:&nbsp;[
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"408&nbsp;338-4238"</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"408&nbsp;111-6892"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 33.3 - Data in JSON format.</h5>
      <p>Parsing such data is straightforward when using Scala's parser combinators. The complete parser is shown in <a href="#lst-JSON-parser">Listing 33.4</a>. This parser follows the same structure as the arithmetic expression parser. It is again a straightforward mapping of the productions of the JSON grammar. The productions use one shortcut that simplifies the grammar: The <span class="code">repsep</span> combinator parses a (possibly empty) sequence of terms that are separated by a given separator string. For instance, in the example in <a href="#lst-JSON-parser">Listing 33.4</a>, <span class="code">repsep(member,</span>&nbsp;<span class="code">",")</span> parses a comma-separated sequence of <span class="code">member</span> terms. Otherwise, the productions in the parser correspond exactly to the productions in the grammar, as was the case for the arithmetic expression parsers. <a id="lst-JSON-parser"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.util.parsing.combinator._
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;JSON&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">JavaTokenParsers</code>&nbsp;{&nbsp;&nbsp;&nbsp;
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;value&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;obj&nbsp;|&nbsp;arr&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringLiteral&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;floatingPointNumber&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"null"</code>&nbsp;|&nbsp;<code class="quotedstring">"true"</code>&nbsp;|&nbsp;<code class="quotedstring">"false"</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;obj&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>repsep(member,&nbsp;<code class="quotedstring">","</code>)<code style="font-size:large">~</code><code class="quotedstring">"}"</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;arr&nbsp;&nbsp;&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;<code class="quotedstring">"["</code><code style="font-size:large">~</code>repsep(value,&nbsp;<code class="quotedstring">","</code>)<code style="font-size:large">~</code><code class="quotedstring">"]"</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;member:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;stringLiteral<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>value
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 33.4 - A simple JSON parser.</h5>
      <p>To try out the JSON parsers, we'll change the framework a bit, so that the parser operates on a file instead of on the command line:</p> <pre>  <code class="vem">import</code>&nbsp;java.io.FileReader
  <br>  <code class="vem">object</code>&nbsp;<code class="typename">ParseJSON</code>&nbsp;<code class="vem">extends</code>&nbsp;JSON&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;main(args:&nbsp;<code class="typename">Array[String]</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;reader&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">FileReader</code>(args(<code class="literal">0</code>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(parseAll(value,&nbsp;reader))
  &nbsp;&nbsp;}
  }
</pre>
      <p>The <span class="code">main</span> method in this program first creates a <span class="code">FileReader</span> object.<a id="i1651665815-1"></a> It then parses the characters returned by that reader according to the <span class="code">value</span> production of the JSON grammar. Note that <span class="code">parseAll</span> and <span class="code">parse</span> exist in overloaded variants: both can take a character sequence or alternatively an input reader as second argument.</p>
      <p>If you store the "address book" object shown in <a href="#lst-JSON-data">Listing 33.3</a> into a file named <span class="code">address-book.json</span> and run the <span class="code">ParseJSON</span> program on it, you should get:</p> <pre>  $&nbsp;scala&nbsp;ParseJSON&nbsp;address-book.json
  <code class="output">[13.4]&nbsp;parsed:&nbsp;(({<code style="font-size:large">~</code>List((("address&nbsp;book"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>(({<code style="font-size:large">~</code>List(((</code>
  <code class="output">"name"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>"John&nbsp;Smith"),&nbsp;(("address"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>(({<code style="font-size:large">~</code>List(((</code>
  <code class="output">"street"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>"10&nbsp;Market&nbsp;Street"),&nbsp;(("city"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>"San&nbsp;Francisco</code>
  <code class="output">,CA"),&nbsp;(("zip"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>94111)))<code style="font-size:large">~</code>})),&nbsp;(("phone&nbsp;numbers"<code style="font-size:large">~</code>:)<code style="font-size:large">~</code>(([<code style="font-size:large">~</code></code>
  <code class="output">List("408&nbsp;338-4238",&nbsp;"408&nbsp;111-6892"))<code style="font-size:large">~</code>]))))<code style="font-size:large">~</code>}))))<code style="font-size:large">~</code>})</code>
</pre>
      <h3>33.5 Parser output</h3>
      <p>The <span class="code">ParseJSON</span> program successfully parsed the JSON address book. However, the parser output looks strange. It seems to be a sequence composed of bits and pieces of the input glued together with lists and <span class="code"><span style="font-size:large">~</span></span> combinations. This output is not very useful. It is less readable for humans than the input, but it is also too disorganized to be easily analyzable by a computer. It's time to do something about this.</p>
      <p>To figure out what to do, you need to know first what the individual parsers in the combinator frameworks return as a result (provided they succeed in parsing the input). Here are the rules:</p>
      <ol>
        <li> Each parser written as a string (such as: <span class="code">"{"</span> or <span class="code">":"</span> or <span class="code">"null"</span>) returns the parsed string itself. </li>
        <li> Regular expression parsers such as <span class="code">"""[a-zA-Z_]\w*""".r</span> also return the parsed string itself. The same holds for regular expression parsers such as <span class="code">stringLiteral</span> or <span class="code">floatingPointNumber</span>, which are inherited from trait <span class="code">JavaTokenParsers</span>.<a id="i-826062925-1"></a><a id="i1891349662-2"></a> </li>
        <li> A sequential composition <span class="code">P<span style="font-size:large">~</span>Q</span> returns the results of both <span class="code">P</span> and of <span class="code">Q</span>. These results are returned in an instance of a case class that is also written <span class="code"><span style="font-size:large">~</span></span>. So if <span class="code">P</span> returns <span class="code">"true"</span> and <span class="code">Q</span> returns <span class="code">"?"</span>, then the sequential composition <span class="code">P<span style="font-size:large">~</span>Q</span> returns <span class="code"><span style="font-size:large">~</span>("true",</span>&nbsp;<span class="code">"?")</span>, which prints as <span class="code">(true<span style="font-size:large">~</span>?)</span>. </li>
        <li> An alternative composition <span class="code">P</span>&nbsp;<span class="code">|</span>&nbsp;<span class="code">Q</span> returns the result of either <span class="code">P</span> or <span class="code">Q</span>, whichever one succeeds. </li>
        <li> A repetition <span class="code">rep(P)</span> or <span class="code">repsep(P,</span>&nbsp;<span class="code">separator)</span> returns a list of the results of all runs of <span class="code">P</span>. </li>
        <li> An option <span class="code">opt(P)</span> returns an instance of Scala's <span class="code">Option</span> type. It returns <span class="code">Some(R)</span> if <span class="code">P</span> succeeds with result <span class="code">R</span> and <span class="code">None</span> if <span class="code">P</span> fails. </li>
      </ol>
      <p>With these rules you can now deduce <span style="font-style:italic">why</span> the parser output appeared as it did in the previous examples. However, the output is still not very convenient. It would be much better to map a JSON object into an internal Scala representation that represents the meaning of the JSON value. A more natural representation would be as follows:</p>
      <ul>
        <li> A JSON object is represented as a Scala map of type <span class="code">Map[String,</span> <span class="code">Any]</span>. Every member is represented as a key/value binding in the map. </li>
        <li> A JSON array is represented as a Scala list of type <span class="code">List[Any]</span>. </li>
        <li> A JSON string is represented as a Scala <span class="code">String</span>. </li>
        <li> A JSON numeric literal is represented as a Scala <span class="code">Double</span>. </li>
        <li> The values <span class="code">true</span>, <span class="code">false</span>, and <span class="code">null</span> are represented as the Scala values with the same names. </li>
      </ul>
      <p>To produce this representation, you need to make use of one more combination form for parsers: <span class="code">^^</span>.<a id="i1109178044-1"></a></p>
      <p>The <span class="code">^^</span> operator <span style="font-style:italic">transforms</span> the result of a parser. Expressions using this operator have the form <span class="code">P</span>&nbsp;<span class="code">^^</span>&nbsp;<span class="code">f</span> where <span class="code">P</span> is a parser and <span class="code">f</span> is a function. <span class="code">P</span>&nbsp;<span class="code">^^</span>&nbsp;<span class="code">f</span> parses the same sentences as just <span class="code">P</span>. Whenever <span class="code">P</span> returns with some result <span class="code">R</span>, the result of <span class="code">P</span>&nbsp;<span class="code">^^</span>&nbsp;<span class="code">f</span> is <span class="code">f(R)</span>.</p>
      <p>As an example, here is a parser that parses a floating point number and converts it to a Scala value of type <span class="code">Double</span>:</p> <pre>  floatingPointNumber&nbsp;^^&nbsp;(_.toDouble)
</pre>
      <p>And here is a parser that parses the string <span class="code">"true"</span> and returns Scala's boolean <span class="code">true</span> value:</p> <pre>  <code class="quotedstring">"true"</code>&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<code class="vem">true</code>)
</pre>
      <p>Now for more advanced transformations. Here's a new version of a parser for JSON objects that returns a Scala <span class="code">Map</span>:</p> <pre>  <code class="vem">def</code>&nbsp;obj:&nbsp;<code class="typename">Parser[Map[String,&nbsp;Any]]</code>&nbsp;=&nbsp;<code class="comment">//&nbsp;Can&nbsp;be&nbsp;improved</code>
  &nbsp;&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>repsep(member,&nbsp;<code class="quotedstring">","</code>)<code style="font-size:large">~</code><code class="quotedstring">"}"</code>&nbsp;^^&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>ms<code style="font-size:large">~</code><code class="quotedstring">"}"</code>&nbsp;=&gt;&nbsp;<code class="typename">Map</code>()&nbsp;++&nbsp;ms&nbsp;}
</pre>
      <p>Remember that the <span class="code"><span style="font-size:large">~</span></span> operator produces as its result an instance of a case class with the same name: <span class="code"><span style="font-size:large">~</span></span>. Here's a definition of that class—it's an inner class of trait <span class="code">Parsers</span>:<a id="i-1259402311-1"></a></p> <pre>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code style="font-size:large">~</code>[+A,&nbsp;+B](x:&nbsp;A,&nbsp;y:&nbsp;B)&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;<code class="quotedstring">"("</code>&nbsp;+&nbsp;x&nbsp;+&nbsp;<code class="quotedstring">"<code style="font-size:large">~</code>"</code>&nbsp;+&nbsp;y&nbsp;+&nbsp;<code class="quotedstring">")"</code>
  }
</pre>
      <p>The name of the class is intentionally the same as the name of the sequence combinator method, <span class="code"><span style="font-size:large">~</span></span>. That way, you can match parser results with patterns that follow the same structure as the parsers themselves. For instance, the pattern <span class="code">"{"<span style="font-size:large">~</span>ms<span style="font-size:large">~</span>"}"</span> matches a result string <span class="code">"{"</span> followed by a result variable <span class="code">ms</span>, which is followed in turn by a result string <span class="code">"}"</span>. This pattern corresponds exactly to what is returned by the parser on the left of the <span class="code">^^</span>. In its desugared versions where the <span class="code"><span style="font-size:large">~</span></span> operator comes first, the same pattern reads <span class="code"><span style="font-size:large">~</span>(<span style="font-size:large">~</span>("{",</span>&nbsp;<span class="code">ms),</span>&nbsp;<span class="code">"}")</span>, but this is much less legible.</p>
      <p>The purpose of the <span class="code">"{"<span style="font-size:large">~</span>ms<span style="font-size:large">~</span>"}"</span> pattern is to strip off the braces so that you can get at the list of members resulting from the <span class="code">repsep(member,</span>&nbsp;<span class="code">",")</span> parser. In cases like these there is also an alternative that avoids producing unnecessary parser results that are immediately discarded by the pattern match. The alternative makes use of the <span class="code"><span style="font-size:large">~</span>&gt;</span> and <span class="code">&lt;<span style="font-size:large">~</span></span> parser combinators.<a id="i1302279396-1"></a><a id="i1234233109-1"></a><a id="i-1808209135-1"></a> Both express sequential composition like <span class="code"><span style="font-size:large">~</span></span>, but <span class="code"><span style="font-size:large">~</span>&gt;</span> keeps only the result of its right operand, whereas <span class="code">&lt;<span style="font-size:large">~</span></span> keeps only the result of its left operand. Using these combinators, the JSON object parser can be expressed more succinctly:</p> <pre>  <code class="vem">def</code>&nbsp;obj:&nbsp;<code class="typename">Parser[Map[String,&nbsp;Any]]</code>&nbsp;=
  &nbsp;&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>&gt;&nbsp;repsep(member,&nbsp;<code class="quotedstring">","</code>)&nbsp;&lt;<code style="font-size:large">~</code><code class="quotedstring">"}"</code>&nbsp;^^&nbsp;(<code class="typename">Map</code>()&nbsp;++&nbsp;_)
</pre>
      <p><a href="#lst-JSON1">Listing 33.5</a> shows a full JSON parser that returns meaningful results. If you run this parser on the <span class="code">address-book.json</span> file, you will get the following result (after adding some newlines and indentation):</p> <pre>  $&nbsp;scala&nbsp;JSON1Test&nbsp;address-book.json
  [14.1]&nbsp;parsed:&nbsp;Map(
  &nbsp;&nbsp;address&nbsp;book&nbsp;-&gt;&nbsp;Map(
  &nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;-&gt;&nbsp;John&nbsp;Smith,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;address&nbsp;-&gt;&nbsp;Map(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;street&nbsp;-&gt;&nbsp;10&nbsp;Market&nbsp;Street,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city&nbsp;-&gt;&nbsp;San&nbsp;Francisco,&nbsp;CA,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zip&nbsp;-&gt;&nbsp;94111),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;phone&nbsp;numbers&nbsp;-&gt;&nbsp;List(408&nbsp;338-4238,&nbsp;408&nbsp;111-6892)
  &nbsp;&nbsp;)
  )
</pre>
      <p>This is all you need to know in order to get started writing your own parsers. As an aide to memory, <a href="#table-parser-combinators">Table 33.1</a> lists the parser combinators that were discussed so far.</p>
      <p><a id="lst-JSON1"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.util.parsing.combinator._
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;JSON1&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">JavaTokenParsers</code>&nbsp;{&nbsp;&nbsp;&nbsp;
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;obj:&nbsp;<code class="typename">Parser[Map[String,&nbsp;Any]]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"{"</code><code style="font-size:large">~</code>&gt;&nbsp;repsep(member,&nbsp;<code class="quotedstring">","</code>)&nbsp;&lt;<code style="font-size:large">~</code><code class="quotedstring">"}"</code>&nbsp;^^&nbsp;(<code class="typename">Map</code>()&nbsp;++&nbsp;_)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;arr:&nbsp;<code class="typename">Parser[List[Any]]</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"["</code><code style="font-size:large">~</code>&gt;&nbsp;repsep(value,&nbsp;<code class="quotedstring">","</code>)&nbsp;&lt;<code style="font-size:large">~</code><code class="quotedstring">"]"</code>&nbsp;
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;member:&nbsp;<code class="typename">Parser[(String,&nbsp;Any)]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringLiteral<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>value&nbsp;^^&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;name<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>value&nbsp;=&gt;&nbsp;(name,&nbsp;value)&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;value:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;arr&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;stringLiteral
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;floatingPointNumber&nbsp;^^&nbsp;(_.toDouble)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<code class="quotedstring">"null"</code>&nbsp;&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<code class="vem">null</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<code class="quotedstring">"true"</code>&nbsp;&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<code class="vem">true</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<code class="quotedstring">"false"</code>&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<code class="vem">false</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 33.5 - A full JSON parser that returns meaningful results.</h5>
      <p><a id="table-parser-combinators"></a></p>
      <h5>Table 33.1 - Summary of parser combinators</h5>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr class="topline ">
              <td> <span class="code"><span class="quotedstring">"..."</span></span> </td>
              <td> literal </td>
            </tr>
            <tr>
              <td> <span class="code"><span class="quotedstring">"..."</span>.r</span> </td>
              <td> regular expression </td>
            </tr>
            <tr>
              <td> <span class="code">P<span style="font-size:large">~</span>Q</span> </td>
              <td> sequential composition </td>
            </tr>
            <tr>
              <td> <span class="code">P</span>&nbsp;<span class="code">&lt;<span style="font-size:large">~</span></span>&nbsp;<span class="code">Q,</span>&nbsp;<span class="code">P</span>&nbsp;<span class="code"><span style="font-size:large">~</span>&gt;</span>&nbsp;<span class="code">Q</span> </td>
              <td> sequential composition; keep left/right only </td>
            </tr>
            <tr>
              <td> <span class="code">P</span>&nbsp;<span class="code">|</span>&nbsp;<span class="code">Q</span> </td>
              <td> alternative </td>
            </tr>
            <tr>
              <td> <span class="code">opt(P)</span> </td>
              <td> option </td>
            </tr>
            <tr>
              <td> <span class="code">rep(P)</span> </td>
              <td> repetition </td>
            </tr>
            <tr>
              <td> <span class="code">repsep(P,</span>&nbsp;<span class="code">Q)</span> </td>
              <td> interleaved repetition </td>
            </tr>
            <tr class="bottomline">
              <td> <span class="code">P</span>&nbsp;<span class="code">^^</span>&nbsp;<span class="code">f</span> </td>
              <td> result conversion </td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="aside">
        <h3>Turning off semicolon inference</h3>
        <p>Note that the body of the <span class="code">value</span> parser in <a href="#lst-JSON1">Listing 33.5</a> is enclosed in parentheses. This is a little trick to disable semicolon inference in parser expressions. You saw in <a href="#sec-semicolon-inf">Section 4.2</a> that Scala assumes there's a semicolon between any two lines that can be separate statements<a id="i-615670524-1"></a><a id="i561868586-1"></a> syntactically, unless the first line ends in an infix operator, or the two lines are enclosed in parentheses or square brackets. Now, you could have written the <span class="code">|</span> operator at the end of the each alternative instead of at the beginning of the following one, like this:</p> <pre>  <code class="vem">def</code>&nbsp;value:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;obj&nbsp;|
  &nbsp;&nbsp;arr&nbsp;|
  &nbsp;&nbsp;stringLiteral&nbsp;|
  &nbsp;&nbsp;...
</pre>
        <p>In that case, no parentheses around the body of the <span class="code">value</span> parser would have been required. However, some people prefer to see the <span class="code">|</span> operator at the beginning of the second alternative rather than at the end of the first. Normally, this would lead to an unwanted semicolon between the two lines, like this:</p> <pre>  &nbsp;&nbsp;obj;&nbsp;&nbsp;<code class="comment">//&nbsp;semicolon&nbsp;implicitly&nbsp;inserted</code>
  |&nbsp;arr
</pre>
        <p>The semicolon changes the structure of the code, causing it to fail compilation. Putting the whole expression in parentheses avoids the semicolon and makes the code compile correctly.</p>
      </div>
      <h4>Symbolic versus alphanumeric names</h4>
      <p>Many of the parser combinators in <a href="#table-parser-combinators">Table 33.1</a> use symbolic names. This has both advantages and disadvantages. On the minus side, symbolic names take time to learn. Users who are unfamiliar with Scala's combinator parsing libraries are probably mystified what <span class="code"><span style="font-size:large">~</span></span>, <span class="code"><span style="font-size:large">~</span>&gt;</span>, or <span class="code">^^</span> mean. On the plus side, symbolic names are short, and can be chosen to have the "right" precedences and associativities. For instance, the parser combinators <span class="code"><span style="font-size:large">~</span></span>, <span class="code">^^</span>, and <span class="code">|</span> are chosen intentionally in decreasing order of precedence. A typical grammar production is composed of alternatives that have a parsing part and a transformation part. The parsing part usually contains several sequential items separated by <span class="code"><span style="font-size:large">~</span></span> operators. With the chosen precedences of <span class="code"><span style="font-size:large">~</span></span>, <span class="code">^^</span>, and <span class="code">|</span> you can write such a grammar production without needing any parentheses.</p>
      <p>Furthermore, symbolic operators take less visual real estate than alphabetic ones. That's important for a parser because it lets you concentrate on the grammar at hand, instead of the combinators themselves. To see the difference, imagine for a moment that sequential composition (<span class="code"><span style="font-size:large">~</span></span>) was called <span class="code">andThen</span> and alternative (<span class="code">|</span>) was called <span class="code">orElse</span>. The arithmetic expression parsers in <a href="#lst-expression-parser">Listing 33.1</a> <a href="#lst-expression-parser">here</a> would look as follows:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">ArithHypothetical</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">JavaTokenParsers</code>&nbsp;{&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;expr:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;&nbsp;&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;term&nbsp;andThen&nbsp;rep((<code class="quotedstring">"+"</code>&nbsp;andThen&nbsp;term)&nbsp;orElse&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="quotedstring">"-"</code>&nbsp;andThen&nbsp;term))
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;term:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;&nbsp;&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;factor&nbsp;andThen&nbsp;rep((<code class="quotedstring">"*"</code>&nbsp;andThen&nbsp;factor)&nbsp;orElse&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<code class="quotedstring">"/"</code>&nbsp;andThen&nbsp;factor))
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;factor:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;floatingPointNumber&nbsp;orElse&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;(<code class="quotedstring">"("</code>&nbsp;andThen&nbsp;expr&nbsp;andThen&nbsp;<code class="quotedstring">")"</code>)
  }
</pre>
      <p>You notice that the code becomes much longer, and that it's hard to "see" the grammar among all those operators and parentheses. On the other hand, somebody new to combinator parsing could probably figure out better what the code is supposed to do.</p>
      <div class="aside">
        <h3>Choosing between symbolic and alphabetic names</h3>
        <p>As guidelines for choosing between symbolic and alphabetic names we recommend the following:<a id="i-252867623-1"></a><a id="i760884015-1"></a><a id="i27050837-1"></a><a id="i-1245815134-1"></a></p>
        <ul>
          <li> Use symbolic names in cases where they already have a universally established meaning. For instance, nobody would recommend writing <span class="code">add</span> instead of <span class="code">+</span> for numeric addition. </li>
          <li> Otherwise, give preference to alphabetic names if you want your code to be understandable to casual readers. </li>
          <li> You can still choose symbolic names for domain-specific libraries, if this gives clear advantages in legibility and you do not expect anyway that a casual reader without a firm grounding in the domain would be able to understand the code immediately. </li>
        </ul>
        <p>In the case of parser combinators we are looking at a highly domain-specific language, which casual readers may have trouble understanding even with alphabetic names. Furthermore, symbolic names give clear advantages in legibility for the expert. So we believe their use is warranted in this application.</p>
      </div>
      <h3>33.6 Implementing combinator parsers</h3>
      <p>The previous sections have shown that Scala's combinator parsers provide a convenient means for constructing your own parsers. Since they are nothing more than a Scala library, they fit seamlessly into your Scala programs. So it's very easy to combine a parser with some code that processes the results it delivers, or to rig a parser so that it takes its input from some specific source (say, a file, a string, or a character array).</p>
      <p>How is this achieved? In the rest of this chapter you'll take a look "under the hood" of the combinator parser library. You'll see what a parser is, and how the primitive parsers and parser combinators encountered in previous sections are implemented. You can safely skip these parts if all you want to do is write some simple combinator parsers. On the other hand, reading the rest of this chapter should give you a deeper understanding of combinator parsers in particular, and of the design principles of a combinator domain-specific language in general.</p>
      <p>The core of Scala's combinator parsing framework is contained in the trait <span class="code">scala.util.parsing.combinator.Parsers</span>.<a id="i1073514242-1"></a> This trait defines the <span class="code">Parser</span> type as well as all fundamental combinators. Except where stated explicitly otherwise, the definitions explained in the following two subsections all reside in this trait. That is, they are assumed to be contained in a trait definition that starts as follows:</p> <pre>  <code class="vem">package</code>&nbsp;scala.util.parsing.combinator
  <code class="vem">trait</code>&nbsp;<code class="typename">Parsers</code>&nbsp;{
  &nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;code&nbsp;goes&nbsp;here&nbsp;unless&nbsp;otherwise&nbsp;stated</code>
  }
</pre>
      <p>A <span class="code">Parser</span> is in essence just a function from some input type to a parse result. As a first approximation, the type could be written as follows:</p> <pre>  <code class="vem">type</code>&nbsp;<code class="typename">Parser[T]</code>&nbsp;=&nbsp;<code class="typename">Input</code>&nbsp;=&gt;&nbsp;<code class="typename">ParseResult[T]</code>
</pre>
      <h4>Parser input</h4>
      <p>Sometimes, a parser reads a stream of tokens instead of a raw sequence of characters. A separate lexical analyzer is then used to convert a stream of raw characters into a stream of tokens.<a id="i262352408-1"></a> The type of parser inputs is defined as follows:</p> <pre>  <code class="vem">type</code>&nbsp;<code class="typename">Input</code>&nbsp;=&nbsp;<code class="typename">Reader[Elem]</code>&nbsp;&nbsp;&nbsp;
</pre>
      <p>The class <span class="code">Reader</span> comes from the package <span class="code">scala.util.parsing.input</span>.<a id="i1984859131-1"></a> It is similar to a <span class="code">Stream</span>, but also keeps track of the positions of all the elements it reads. The type <span class="code">Elem</span> represents individual input elements.<a id="i-2008629102-1"></a> It is an abstract type member of the <span class="code">Parsers</span> trait:</p> <pre>  <code class="vem">type</code>&nbsp;<code class="typename">Elem</code>
</pre>
      <p>This means that subclasses and subtraits of <span class="code">Parsers</span> need to instantiate class <span class="code">Elem</span> to the type of input elements that are being parsed. For instance, <span class="code">RegexParsers</span> and <span class="code">JavaTokenParsers</span> fix <span class="code">Elem</span> to be equal to <span class="code">Char</span>. But it would also be possible to set <span class="code">Elem</span> to some other type, such as the type of tokens returned from a separate lexer.</p>
      <h4>Parser results</h4>
      <p>A parser might either succeed or fail on some given input. Consequently class <span class="code">ParseResult</span> has two subclasses for representing success and failure:<a id="i-27560472-1"></a></p> <pre>  <code class="vem">sealed</code>&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ParseResult[+T]</code>&nbsp;
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Success[T]</code>(result:&nbsp;T,&nbsp;in:&nbsp;<code class="typename">Input</code>)&nbsp;
  &nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ParseResult[T]</code>
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Failure</code>(msg:&nbsp;<code class="typename">String</code>,&nbsp;in:&nbsp;<code class="typename">Input</code>)&nbsp;
  &nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ParseResult[Nothing]</code>
</pre>
      <p>The <span class="code">Success</span> case carries the result returned from the parser in its <span class="code">result</span> parameter.<a id="i240639739-1"></a> The type of parser results is arbitrary; that's why <span class="code">ParseResult</span>, <span class="code">Success</span>, and <span class="code">Parser</span> are all parameterized with a type parameter <span class="code">T</span>. The type parameter represents the kinds of results returned by a given parser.<a id="i-370701594-1"></a> <span class="code">Success</span> also takes a second parameter, <span class="code">in</span>, which refers to the input immediately following the part that the parser consumed. This field is needed for chaining parsers, so that one parser can operate after another. Note that this is a purely functional approach to parsing.<a id="i-1568373391-1"></a> Input is not read as a side effect, but it is kept in a stream. A parser analyzes some part of the input stream, and then returns the remaining part in its result.</p>
      <p>The other subclass of <span class="code">ParseResult</span> is <span class="code">Failure</span>.<a id="i1670336322-1"></a> This class takes as a parameter a message that describes why the parser failed. Like <span class="code">Success</span>, <span class="code">Failure</span> also takes the remaining input stream as a second parameter. This is needed not for chaining (the parser won't continue after a failure), but to position the error message at the correct place in the input stream.</p>
      <p>Note that parse results are defined to be covariant in the type parameter <span class="code">T</span>. That is, a parser returning <span class="code">String</span>s as result, say, is compatible with a parser returning <span class="code">AnyRef</span>s.</p>
      <h4>The <span class="code">Parser</span> class</h4>
      <p>The previous characterization of parsers as functions from inputs to parse results was a bit oversimplified. The previous examples showed that parsers also implement <span style="font-style:italic">methods</span> such as <span class="code"><span style="font-size:large">~</span></span> for sequential composition of two parsers and <span class="code">|</span> for their alternative composition. So <span class="code">Parser</span> is in reality a class that inherits from the function type <span class="code">Input</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">ParseResult[T]</span> and additionally defines these methods:</p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Parser[+T]</code>&nbsp;<code class="vem">extends</code>&nbsp;(<code class="typename">Input</code>&nbsp;=&gt;&nbsp;<code class="typename">ParseResult[T]</code>)&nbsp;
  {&nbsp;p&nbsp;=&gt;
  &nbsp;&nbsp;<code class="comment">//&nbsp;An&nbsp;unspecified&nbsp;method&nbsp;that&nbsp;defines&nbsp;</code>
  &nbsp;&nbsp;<code class="comment">//&nbsp;the&nbsp;behavior&nbsp;of&nbsp;this&nbsp;parser.</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>):&nbsp;<code class="typename">ParseResult[T]</code>
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code style="font-size:large">~</code>&nbsp;...
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;|&nbsp;...
  &nbsp;&nbsp;...
  }
</pre>
      <p>Since parsers are (<i>i.e.</i>, inherit from) functions, they need to define an <span class="code">apply</span> method. You see an abstract <span class="code">apply</span> method in class <span class="code">Parser</span>, but this is just for documentation, as the same method is in any case inherited from the parent type <span class="code">Input</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">ParseResult[T]</span> (recall that this type is an abbreviation for <span class="code">scala.Function1[Input,</span>&nbsp;<span class="code">ParseResult[T]]</span>). The <span class="code">apply</span> method still needs to be implemented in the individual parsers that inherit from the abstract <span class="code">Parser</span> class. These parsers will be discussed after the following section on <span class="code">this</span> aliasing.</p>
      <h4>Aliasing <span class="code">this</span></h4>
      <p><a id="sec-this-aliasing"></a></p>
      <p>The body of the <span class="code">Parser</span> class starts with a curious expression:<a id="i-206823911-1"></a></p> <pre>  <code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Parser[+T]</code>&nbsp;<code class="vem">extends</code>&nbsp;...&nbsp;{&nbsp;p&nbsp;=&gt;
</pre>
      <p>A clause such as "<span class="code">id</span>&nbsp;<span class="code">=&gt;</span>" immediately after the opening brace of a class template defines the identifier <span class="code">id</span> as an alias<a id="i427194646-1"></a><a id="i198894-1"></a> for <span class="code">this</span> in the class. It's as if you had written:</p> <pre>  <code class="vem">val</code>&nbsp;id&nbsp;=&nbsp;<code class="vem">this</code>
</pre>
      <p>in the class body, except that the Scala compiler knows that <span class="code">id</span> is an alias for <span class="code">this</span>. For instance, you could access an object-private member <span class="code">m</span> of the class using either <span class="code">id.m</span> or <span class="code">this.m</span>; the two are completely equivalent. The first expression would not compile if <span class="code">id</span> were just defined as a <span class="code">val</span> with <span class="code">this</span> as its right hand side, because in that case the Scala compiler would treat <span class="code">id</span> as a normal identifier.</p>
      <p>You saw syntax like this in <a href="#sec-modules-traits">Section 29.4</a>, where it was used to give a <a href="#g-1749196914">self type</a> to a trait. Aliasing can also be a good abbreviation when you need to access the <span class="code">this</span> of an outer class. Here's an example:</p> <pre>  <code class="vem">class</code>&nbsp;<code class="typename">Outer</code>&nbsp;{&nbsp;outer&nbsp;=&gt;
  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Inner</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(Outer.this&nbsp;eq&nbsp;outer)&nbsp;<code class="comment">//&nbsp;prints:&nbsp;true</code>
  &nbsp;&nbsp;}
  }
</pre>
      <p>The example defines two nested classes, <span class="code">Outer</span> and <span class="code">Inner</span>. Inside <span class="code">Inner</span> the <span class="code">this</span> value of the <span class="code">Outer</span> class is referred to twice, using different expressions. The first expression shows the Java way of doing things: You can prefix the reserved word <span class="code">this</span> with the name of an outer class and a period; such an expression then refers to the <span class="code">this</span> of the outer class. The second expression shows the alternative that Scala gives you. By introducing an alias named <span class="code">outer</span> for <span class="code">this</span> in class <span class="code">Outer</span>, you can refer to this alias directly also in inner classes.<a id="i1909060649-1"></a> The Scala way is more concise, and can also improve clarity, if you choose the name of the alias well. You'll see examples of this <a href="#sec-parsers-seq">here</a> and <a href="#sec-parsers-alt">here</a>.</p>
      <h4>Single-token parsers</h4>
      <p>Trait <span class="code">Parsers</span> defines a generic parser <span class="code">elem</span> that can be used to parse any single token:</p> <pre>  <code class="vem">def</code>&nbsp;elem(kind:&nbsp;<code class="typename">String</code>,&nbsp;p:&nbsp;<code class="typename">Elem</code>&nbsp;=&gt;&nbsp;<code class="typename">Boolean</code>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[Elem]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(p(in.first))&nbsp;<code class="typename">Success</code>(in.first,&nbsp;in.rest)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="typename">Failure</code>(kind&nbsp;+&nbsp;<code class="quotedstring">"&nbsp;expected"</code>,&nbsp;in)
  &nbsp;&nbsp;}
</pre>
      <p>This parser takes two parameters: a <span class="code">kind</span> string describing what kind of token should be parsed and a predicate <span class="code">p</span> on <span class="code">Elem</span>s, which indicates whether an element fits the class of tokens to be parsed.</p>
      <p>When applying the parser <span class="code">elem(kind,</span>&nbsp;<span class="code">p)</span> to some input <span class="code">in</span>, the first element of the input stream is tested with predicate <span class="code">p</span>. If <span class="code">p</span> returns <span class="code">true</span>, the parser succeeds. Its result is the element itself, and its remaining input is the input stream starting just after the element that was parsed. On the other hand, if <span class="code">p</span> returns <span class="code">false</span>, the parser fails with an error message that indicates what kind of token was expected.</p>
      <h4>Sequential composition</h4>
      <p><a id="sec-parsers-seq"></a></p>
      <p>The <span class="code">elem</span> parser only consumes a single element. To parse more interesting phrases, you can string parsers together with the sequential composition operator <span class="code"><span style="font-size:large">~</span></span>.<a id="i-1259402311-2"></a> As you have seen before, <span class="code">P<span style="font-size:large">~</span>Q</span> is a parser that applies first the <span class="code">P</span> parser to a given input string. Then, if <span class="code">P</span> succeeds, the <span class="code">Q</span> parser is applied to the input that's left after <span class="code">P</span> has done its job.</p>
      <p>The <span class="code"><span style="font-size:large">~</span></span> combinator is implemented as a method in class <span class="code">Parser</span>. Its definition is shown in <a href="#lst-tilde-combinator">Listing 33.6</a>. The method is a member of the <span class="code">Parser</span> class. Inside this class, <span class="code">p</span> is specified by the "<span class="code">p</span>&nbsp;<span class="code">=&gt;</span>" part as an alias of <span class="code">this</span>, so <span class="code">p</span> designates the left operand (or: receiver) of <span class="code"><span style="font-size:large">~</span></span>. Its right operand is represented by parameter <span class="code">q</span>. Now, if <span class="code">p<span style="font-size:large">~</span>q</span> is run on some input <span class="code">in</span>, first <span class="code">p</span> is run on <span class="code">in</span> and the result is analyzed in a pattern match. If <span class="code">p</span> succeeds, <span class="code">q</span> is run on the remaining input <span class="code">in1</span>. If <span class="code">q</span> also succeeds, the parser as a whole succeeds. Its result is a <span class="code"><span style="font-size:large">~</span></span> object containing both the result of <span class="code">p</span> (<i>i.e.</i>, <span class="code">x</span>) and the result of <span class="code">q</span> (<i>i.e.</i>, <span class="code">y</span>). On the other hand, if either <span class="code">p</span> or <span class="code">q</span> fails the result of <span class="code">p<span style="font-size:large">~</span>q</span> is the <span class="code">Failure</span> object returned by <span class="code">p</span> or <span class="code">q</span>. <a id="lst-tilde-combinator"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">abstract</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Parser[+T]</code>&nbsp;...&nbsp;{&nbsp;p&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;<code style="font-size:large">~</code>&nbsp;[U](q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[U]</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[T<code style="font-size:large">~</code>U]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;p(in)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(x,&nbsp;in1)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q(in1)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(y,&nbsp;in2)&nbsp;=&gt;&nbsp;<code class="typename">Success</code>(<code class="vem">new</code>&nbsp;<code style="font-size:large">~</code>(x,&nbsp;y),&nbsp;in2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;failure&nbsp;=&gt;&nbsp;failure
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;failure&nbsp;=&gt;&nbsp;failure
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
</pre>
      <h5>Listing 33.6 - The <span style="font-size:large">~</span> combinator method.</h5>
      <p>The result type of <span class="code"><span style="font-size:large">~</span></span> is a parser that returns an instance of the case class <span class="code"><span style="font-size:large">~</span></span> with elements of types <span class="code">T</span> and <span class="code">U</span>. The type expression <span class="code">T<span style="font-size:large">~</span>U</span> is just a more legible shorthand for the parameterized type <span class="code"><span style="font-size:large">~</span>[T,</span>&nbsp;<span class="code">U]</span>. Generally, Scala always interprets a binary type operation such as <span class="code">A</span>&nbsp;<span class="code">op</span>&nbsp;<span class="code">B</span>, as the parameterized type <span class="code">op[A,</span>&nbsp;<span class="code">B]</span>. This is analogous to the situation for patterns, where a binary pattern <span class="code">P</span>&nbsp;<span class="code">op</span>&nbsp;<span class="code">Q</span> is also interpreted as an application, <i>i.e.</i>, <span class="code">op(P,</span>&nbsp;<span class="code">Q)</span>.</p>
      <p>The other two sequential composition operators, <span class="code">&lt;<span style="font-size:large">~</span></span> and <span class="code"><span style="font-size:large">~</span>&gt;</span>, could be defined just like <span class="code"><span style="font-size:large">~</span></span>, only with some small adjustment in how the result is computed.<a id="i1302279396-2"></a><a id="i1234233109-2"></a> A more elegant technique, though, is to define them in terms of <span class="code"><span style="font-size:large">~</span></span> as follows:</p> <pre>  <code class="vem">def</code>&nbsp;&lt;<code style="font-size:large">~</code>&nbsp;[U](q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[U]</code>):&nbsp;<code class="typename">Parser[T]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;(p<code style="font-size:large">~</code>q)&nbsp;^^&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;x<code style="font-size:large">~</code>y&nbsp;=&gt;&nbsp;x&nbsp;}
  <code class="vem">def</code>&nbsp;<code style="font-size:large">~</code>&gt;&nbsp;[U](q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[U]</code>):&nbsp;<code class="typename">Parser[U]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;(p<code style="font-size:large">~</code>q)&nbsp;^^&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;x<code style="font-size:large">~</code>y&nbsp;=&gt;&nbsp;y&nbsp;}
</pre>
      <h4>Alternative composition</h4>
      <p><a id="sec-parsers-alt"></a></p>
      <p>An alternative composition <span class="code">P</span>&nbsp;<span class="code">|</span>&nbsp;<span class="code">Q</span> applies either <span class="code">P</span> or <span class="code">Q</span> to a given input.<a id="i1608533927-1"></a> It first tries <span class="code">P</span>. If <span class="code">P</span> succeeds, the whole parser succeeds with the result of <span class="code">P</span>. Otherwise, if <span class="code">P</span> fails, then <span class="code">Q</span> is tried <span style="font-style:italic">on the same input</span> as <span class="code">P</span>. The result of <span class="code">Q</span> is then the result of the whole parser.</p>
      <p>Here is a definition of <span class="code">|</span> as a method of class <span class="code">Parser</span>:</p> <pre>  <code class="vem">def</code>&nbsp;|&nbsp;(q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[T]</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[T]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;p(in)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;s1&nbsp;@&nbsp;<code class="typename">Success</code>(_,&nbsp;_)&nbsp;=&gt;&nbsp;s1
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;failure&nbsp;=&gt;&nbsp;q(in)&nbsp;
  &nbsp;&nbsp;}
  }
</pre>
      <p>Note that if <span class="code">P</span> and <span class="code">Q</span> both fail, then the failure message is determined by <span class="code">Q</span>. This subtle choice is discussed later, in <a href="#sec-combinator-errors">Section 33.9</a>.</p>
      <h4>Dealing with recursion</h4>
      <p>Note that the <span class="code">q</span> parameter in methods <span class="code"><span style="font-size:large">~</span></span> and <span class="code">|</span> is by-name—its type is preceded by <span class="code">=&gt;</span>.<a id="i999036029-1"></a> This means that the actual parser argument will be evaluated only when <span class="code">q</span> is needed, which should only be the case after <span class="code">p</span> has run. This makes it possible to write recursive parsers like the following one which parses a number enclosed by arbitrarily many parentheses:</p> <pre>  <code class="vem">def</code>&nbsp;parens&nbsp;=&nbsp;floatingPointNumber&nbsp;|&nbsp;<code class="quotedstring">"("</code><code style="font-size:large">~</code>parens<code style="font-size:large">~</code><code class="quotedstring">")"</code>&nbsp;
</pre>
      <p>If <span class="code">|</span> and <span class="code"><span style="font-size:large">~</span></span> took <a href="#g-430862780"><em>by-value parameters</em></a>, this definition would<a id="i267370507-1"></a><a id="i-471844177-1"></a> immediately cause a stack overflow without reading anything, because the value of <span class="code">parens</span> occurs in the middle of its right-hand side.</p>
      <h4>Result conversion</h4>
      <p>The last method of class <span class="code">Parser</span> converts a parser's result. The parser <span class="code">P</span>&nbsp;<span class="code">^^</span>&nbsp;<span class="code">f</span> succeeds exactly when <span class="code">P</span> succeeds. In that case it returns <span class="code">P</span>'s result converted using the function <span class="code">f</span>. Here is the implementation of this method:</p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;^^&nbsp;[U](f:&nbsp;T&nbsp;=&gt;&nbsp;U):&nbsp;<code class="typename">Parser[U]</code>&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[U]</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;p(in)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(x,&nbsp;in1)&nbsp;=&gt;&nbsp;<code class="typename">Success</code>(f(x),&nbsp;in1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;failure&nbsp;=&gt;&nbsp;failure
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;Parser</code>
</pre>
      <h4>Parsers that don't read any input</h4>
      <p>There are also two parsers that do not consume any input: <span class="code">success</span> and <span class="code">failure</span>. The parser <span class="code">success(result)</span> always succeeds with the given <span class="code">result</span>. The parser <span class="code">failure(msg)</span> always fails with error message <span class="code">msg</span>. Both are implemented as methods in trait <span class="code">Parsers</span>, the outer trait that also contains class <span class="code">Parser</span>:</p> <pre>  <code class="vem">def</code>&nbsp;success[T](v:&nbsp;T)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[T]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;<code class="typename">Success</code>(v,&nbsp;in)
  }
  <code class="vem">def</code>&nbsp;failure(msg:&nbsp;<code class="typename">String</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[Nothing]</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;<code class="typename">Failure</code>(msg,&nbsp;in)
  }
</pre>
      <h4>Option and repetition</h4>
      <p>Also defined in trait <span class="code">Parsers</span> are the option and repetition combinators <span class="code">opt</span>, <span class="code">rep</span>, and <span class="code">repsep</span>.<a id="i1073514242-2"></a><a id="i1251140526-1"></a><a id="i476382634-1"></a><a id="i1315224406-1"></a> They are all implemented in terms of sequential composition, alternative, and result conversion:</p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;opt[T](p:&nbsp;=&gt;&nbsp;<code class="typename">Parser[T]</code>):&nbsp;<code class="typename">Parser[Option[T]]</code>&nbsp;=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;^^&nbsp;<code class="typename">Some</code>(_)&nbsp;&nbsp;
  &nbsp;&nbsp;|&nbsp;success(<code class="typename">None</code>)
  &nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;rep[T](p:&nbsp;=&gt;&nbsp;<code class="typename">Parser[T]</code>):&nbsp;<code class="typename">Parser[List[T]]</code>&nbsp;=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;p<code style="font-size:large">~</code>rep(p)&nbsp;^^&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;x<code style="font-size:large">~</code>xs&nbsp;=&gt;&nbsp;x&nbsp;::&nbsp;xs&nbsp;}&nbsp;&nbsp;
  &nbsp;&nbsp;|&nbsp;success(<code class="typename">List</code>())
  &nbsp;&nbsp;)
  <br>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;repsep[T](p:&nbsp;=&gt;&nbsp;<code class="typename">Parser[T]</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q:&nbsp;=&gt;&nbsp;<code class="typename">Parser[Any]</code>):&nbsp;<code class="typename">Parser[List[T]]</code>&nbsp;=&nbsp;(
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;p<code style="font-size:large">~</code>rep(q<code style="font-size:large">~</code>&gt;&nbsp;p)&nbsp;^^&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;r<code style="font-size:large">~</code>rs&nbsp;=&gt;&nbsp;r&nbsp;::&nbsp;rs&nbsp;}&nbsp;&nbsp;
  &nbsp;&nbsp;|&nbsp;success(<code class="typename">List</code>())
  &nbsp;&nbsp;)
  <br>  }&nbsp;<code class="comment">//&nbsp;end&nbsp;Parsers</code>
</pre>
      <h3>33.7 String literals and regular expressions</h3>
      <p>The parsers you saw so far made use of string literals and regular expressions to parse single words. The support for these comes from <span class="code">RegexParsers</span>, a subtrait of <span class="code">Parsers</span>:<a id="i519257659-2"></a></p> <pre>  <code class="vem">trait</code>&nbsp;<code class="typename">RegexParsers</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Parsers</code>&nbsp;{&nbsp;
</pre>
      <p>This trait is more specialized than trait <span class="code">Parsers</span> in that it only works for inputs that are sequences of characters:</p> <pre>  <code class="vem">type</code>&nbsp;<code class="typename">Elem</code>&nbsp;=&nbsp;<code class="typename">Char</code>
</pre>
      <p>It defines two methods, <span class="code">literal</span> and <span class="code">regex</span>, with the following signatures:</p> <pre>  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;literal(s:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;...
  <code class="vem">implicit</code>&nbsp;<code class="vem">def</code>&nbsp;regex(r:&nbsp;<code class="typename">Regex</code>):&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;...
</pre>
      <p>Note that both methods have an <span class="code">implicit</span> modifier, so they are automatically applied whenever a <span class="code">String</span> or <span class="code">Regex</span> is given but a <span class="code">Parser</span> is expected.<a id="i1803313949-1"></a><a id="i961731205-1"></a> That's why you can write string literals and regular expressions directly in a grammar, without having to wrap them with one of these methods. For instance, the parser <span class="code">"("<span style="font-size:large">~</span>expr<span style="font-size:large">~</span>")"</span> will be automatically expanded to <span class="code">literal("(")<span style="font-size:large">~</span>expr<span style="font-size:large">~</span>literal(")")</span>.</p>
      <p>The <span class="code">RegexParsers</span> trait also takes care of handling white space between symbols. To do this, it calls a method named <span class="code">handleWhiteSpace</span> before running a <span class="code">literal</span> or <span class="code">regex</span> parser. The <span class="code">handleWhiteSpace</span> method skips the longest input sequence that conforms to the <span class="code">whiteSpace</span> regular expression, which is defined by default as follows:</p> <pre>  &nbsp;&nbsp;<code class="vem">protected</code>&nbsp;<code class="vem">val</code>&nbsp;whiteSpace&nbsp;=&nbsp;<code class="quotedstring">"""\s+"""</code>.r
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;RegexParsers</code>
</pre>
      <p>If you prefer a different treatment of white space, you can override the <span class="code">whiteSpace</span> <span class="code">val</span>. For instance, if you want white space not to be skipped at all, you can override <span class="code">whiteSpace</span> with the empty regular expression:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">MyParsers</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">RegexParsers</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">val</code>&nbsp;whiteSpace&nbsp;=&nbsp;<code class="quotedstring">""</code>.r
  &nbsp;&nbsp;...
  }
</pre>
      <h3>33.8 Lexing and parsing</h3>
      <p>The task of syntax analysis is often split into two phases. The <span style="font-style:italic"> lexer</span> phase recognizes individual words in the input and classifies them into some <span style="font-style:italic">token</span> classes. This phase is also called <span style="font-style:italic"> lexical analysis</span>. This is followed by a <span style="font-style:italic">syntactical analysis</span> phase that analyzes sequences of tokens.<a id="i1371644930-1"></a><a id="i1779690801-1"></a> Syntactical analysis is also sometimes just called parsing, even though this is slightly imprecise, as lexical analysis can also be regarded as a parsing problem.</p>
      <p>The <span class="code">Parsers</span> trait as described in the previous section can be used for either phase, because its input elements are of the abstract type <span class="code">Elem</span>. For lexical analysis, <span class="code">Elem</span> would be instantiated to <span class="code">Char</span>, meaning the individual characters that make up a word are being parsed. The syntactical analyzer would in turn instantiate <span class="code">Elem</span> to the type of token returned by the lexer.</p>
      <p>Scala's parsing combinators provide several utility classes for lexical and syntactic analysis. These are contained in two sub-packages, one for each kind of analysis:</p> <pre>  scala.util.parsing.combinator.lexical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  scala.util.parsing.combinator.syntactical&nbsp;&nbsp;&nbsp;
</pre>
      <p>If you want to split your parser into a separate lexer and syntactical analyzer, you should consult the Scaladoc documentation for these packages. But for simple parsers, the regular expression based approach shown previously in this chapter is usually sufficient.</p>
      <h3 id="sec-combinator-errors">33.9 Error reporting</h3>
      <p>There's one final topic that was not covered yet: how does the parser issue an error message? Error reporting for parsers is somewhat of a black art. One problem is that when a parser rejects some input, it generally has encountered many different failures.<a id="i1725890298-1"></a> Each alternative parse must have failed, and recursively so at each choice point. Which of the usually numerous failures should be emitted as error message to the user?</p>
      <p>Scala's parsing library implements a simple heuristic: among all failures, the one that occurred at the latest position in the input is chosen. In other words, the parser picks the longest prefix that is still valid and issues an error message that describes why parsing the prefix could not be continued further. If there are several failure points at that latest position, the one that was visited last is chosen.</p>
      <p>For instance, consider running the JSON parser on a faulty address book which starts with the line:</p> <pre>  {&nbsp;<code class="quotedstring">"name"</code>:&nbsp;<code class="typename">John</code>,
</pre>
      <p>The longest legal prefix of this phrase is "<span class="code">{</span>&nbsp;<span class="code">"name":</span>&nbsp;<span class="code"></span>". So the JSON parser will flag the word <span class="code">John</span> as an error. The JSON parser expects a value at this point, but <span class="code">John</span> is an identifier, which does not count as a value (presumably, the author of the document had forgotten to enclose the name in quotation marks). The error message issued by the parser for this document is:</p> <pre>  [<code class="literal">1.13</code>]&nbsp;failure:&nbsp;<code class="quotedstring">"false"</code>&nbsp;expected&nbsp;but&nbsp;identifier&nbsp;<code class="typename">John</code>&nbsp;found
  <br>  &nbsp;&nbsp;{&nbsp;<code class="quotedstring">"name"</code>:&nbsp;<code class="typename">John</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre>
      <p>The part that "false" was expected comes from the fact that <span class="code">"false"</span> is the last alternative of the production for <span class="code">value</span> in the JSON grammar. So this was the last failure at this point. Users who know the JSON grammar in detail can reconstruct the error message, but for non-experts this error message is probably surprising and can also be quite misleading.</p>
      <p>A better error message can be engineered by adding a "catch-all" failure point as last alternative of a <span class="code">value</span> production:</p> <pre>  <code class="vem">def</code>&nbsp;value:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=
  &nbsp;&nbsp;obj&nbsp;|&nbsp;arr&nbsp;|&nbsp;stringLit&nbsp;|&nbsp;floatingPointNumber&nbsp;|&nbsp;<code class="quotedstring">"null"</code>&nbsp;|
  &nbsp;&nbsp;<code class="quotedstring">"true"</code>&nbsp;|&nbsp;<code class="quotedstring">"false"</code>&nbsp;|&nbsp;failure(<code class="quotedstring">"illegal&nbsp;start&nbsp;of&nbsp;value"</code>)
</pre>
      <p>This addition does not change the set of inputs that are accepted as valid documents. What it does is improve the error messages, because now it will be the explicitly added <span class="code">failure</span> that comes as last alternative and therefore gets reported:</p> <pre>  [<code class="literal">1.13</code>]&nbsp;failure:&nbsp;illegal&nbsp;start&nbsp;of&nbsp;value
  <br>  &nbsp;&nbsp;{&nbsp;<code class="quotedstring">"name"</code>:&nbsp;<code class="typename">John</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre>
      <p>The implementation of the "latest possible" scheme of error reporting uses a field named <span class="code">lastFailure</span> in trait <span class="code">Parsers</span> to mark the failure that occurred at the latest position in the input:</p> <pre>  <code class="vem">var</code>&nbsp;lastFailure:&nbsp;<code class="typename">Option[Failure]</code>&nbsp;=&nbsp;<code class="typename">None</code>
</pre>
      <p>The field is initialized to <span class="code">None</span>. It is updated in the constructor of the <span class="code">Failure</span> class:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Failure</code>(msg:&nbsp;<code class="typename">String</code>,&nbsp;in:&nbsp;<code class="typename">Input</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ParseResult[Nothing]</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(lastFailure.isDefined&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastFailure.get.in.pos&nbsp;&lt;=&nbsp;in.pos)
  &nbsp;&nbsp;&nbsp;&nbsp;lastFailure&nbsp;=&nbsp;<code class="typename">Some</code>(<code class="vem">this</code>)
  }
</pre>
      <p>The field is read by the <span class="code">phrase</span> method, which emits the final error message if the parser failed. Here is the implementation of <span class="code">phrase</span> in trait <span class="code">Parsers</span>:</p> <pre>  <code class="vem">def</code>&nbsp;phrase[T](p:&nbsp;<code class="typename">Parser[T]</code>)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Parser[T]</code>&nbsp;{
  &nbsp;&nbsp;lastFailure&nbsp;=&nbsp;<code class="typename">None</code>
  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;apply(in:&nbsp;<code class="typename">Input</code>)&nbsp;=&nbsp;p(in)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;s&nbsp;@&nbsp;<code class="typename">Success</code>(out,&nbsp;in1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(in1.atEnd)&nbsp;s&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>&nbsp;<code class="typename">Failure</code>(<code class="quotedstring">"end&nbsp;of&nbsp;input&nbsp;expected"</code>,&nbsp;in1)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;f&nbsp;:&nbsp;<code class="typename">Failure</code>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastFailure
  &nbsp;&nbsp;}
  }
</pre>
      <p>The <span class="code">phrase</span> method runs its argument parser <span class="code">p</span>. If <span class="code">p</span> succeeds with a completely consumed input, the success result of <span class="code">p</span> is returned. If <span class="code">p</span> succeeds but the input is not read completely, a failure with message "end of input expected" is returned. If <span class="code">p</span> fails, the failure or error stored in <span class="code">lastFailure</span> is returned. Note that the treatment of <span class="code">lastFailure</span> is non-functional; it is updated as a side effect by the constructor of <span class="code">Failure</span> and by the <span class="code">phrase</span> method itself. A functional version of the same scheme would be possible, but it would require threading the <span class="code">lastFailure</span> value through every parser result, no matter whether this result is a <span class="code">Success</span> or a <span class="code">Failure</span>.</p>
      <h3>33.10 Backtracking versus LL(1)</h3>
      <p>The parser combinators employ <span style="font-style:italic">backtracking</span> to choose between different parsers in an alternative.<a id="i426003614-1"></a> In an expression <span class="code">P</span>&nbsp;<span class="code">|</span>&nbsp;<span class="code">Q</span>, if <span class="code">P</span> fails, then <span class="code">Q</span> is run on the same input as <span class="code">P</span>.<a id="i-2138187530-1"></a> This happens even if <span class="code">P</span> has parsed some tokens before failing. In this case the same tokens will be parsed again by <span class="code">Q</span>.</p>
      <p>Backtracking imposes only a few restrictions on how to formulate a grammar so that it can be parsed. Essentially, you just need to avoid left-recursive productions. A production such as:</p>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr>
              <td> <span style="font-style:italic">expr</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">expr</span> &nbsp;<span class="code">"+"</span>&nbsp; <span style="font-style:italic">term</span> &nbsp;|&nbsp; <span style="font-style:italic">term</span>. </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>will always fail because <span class="code">expr</span> immediately calls itself and thus never progresses any further.<a href="#footnotemain33-1">[1]</a> On the other hand, backtracking is potentially costly because the same input can be parsed several times. Consider for instance the production:</p>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr>
              <td> <span style="font-style:italic">expr</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">term</span> &nbsp;<span class="code">"+"</span>&nbsp; <span style="font-style:italic">expr</span> &nbsp;|&nbsp; <span style="font-style:italic">term</span>. </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>What happens if the <span class="code">expr</span> parser is applied to an input such as <span class="code">(1</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2)</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">3</span> which constitutes a legal term? The first alternative would be tried, and would fail when matching the <span class="code">+</span> sign. Then the second alternative would be tried on the same term and this would succeed. In the end the term ended up being parsed twice.</p>
      <p>It is often possible to modify the grammar so that backtracking can be avoided. For instance, in the case of arithmetic expressions, either one of the following productions would work:</p>
      <div style="text-align: center">
        <table style="border-collapse: collapse">
          <tbody>
            <tr>
              <td> <span style="font-style:italic">expr</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">term</span> &nbsp;[<span class="code">"+"</span>&nbsp; <span style="font-style:italic">expr</span>]. </td>
            </tr>
            <tr>
              <td> <span style="font-style:italic">expr</span> </td>
              <td> ::= </td>
              <td> <span style="font-style:italic">term</span> &nbsp;\{<span class="code">"+"</span>&nbsp; <span style="font-style:italic">term</span>\}. </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>Many languages admit so-called "LL(1)" grammars.<a href="#footnotemain33-2">[2]</a> When a combinator parser is formed from such a grammar, it will never backtrack, <i>i.e.</i>, the input position will never be reset to an earlier value. For instance, the grammars for arithmetic expressions and JSON terms earlier in this chapter are both LL(1), so the backtracking capabilities of the parser combinator framework are never exercised for inputs from these languages.</p>
      <p>The combinator parsing framework allows you to express the expectation that a grammar is LL(1) explicitly, using a new operator <span class="code"><span style="font-size:large">~</span>!</span>.<a id="i1119621308-1"></a> This operator is like sequential composition <span class="code"><span style="font-size:large">~</span></span> but it will never backtrack to "un-read" input elements that have already been parsed. Using this operator, the productions in the arithmetic expression parser could alternatively be written as follows:</p> <pre>  <code class="vem">def</code>&nbsp;expr&nbsp;&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;term&nbsp;<code style="font-size:large">~</code>!&nbsp;rep(<code class="quotedstring">"+"</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;term&nbsp;|&nbsp;<code class="quotedstring">"-"</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;term)
  <code class="vem">def</code>&nbsp;term&nbsp;&nbsp;:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;factor&nbsp;<code style="font-size:large">~</code>!&nbsp;rep(<code class="quotedstring">"*"</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;factor&nbsp;|&nbsp;<code class="quotedstring">"/"</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;factor)
  <code class="vem">def</code>&nbsp;factor:&nbsp;<code class="typename">Parser[Any]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="quotedstring">"("</code>&nbsp;<code style="font-size:large">~</code>!&nbsp;expr&nbsp;<code style="font-size:large">~</code>!&nbsp;<code class="quotedstring">")"</code>&nbsp;|&nbsp;floatingPointNumber
</pre>
      <p>One advantage of an LL(1) parser is that it can use a simpler input technique. Input can be read sequentially, and input elements can be discarded once they are read. That's another reason why LL(1) parsers are usually more efficient than backtracking parsers.<a id="i-1119687476-1"></a></p>
      <h3>33.11 Conclusion</h3>
      <p>You have now seen all the essential elements of Scala's combinator parsing framework. It's surprisingly little code for something that's genuinely useful. With the framework you can construct parsers for a large class of context-free grammars. The framework lets you get started quickly, but it is also customizable to new kinds of grammars and input methods. Being a Scala library, it integrates seamlessly with the rest of the language. So it's easy to integrate a combinator parser in a larger Scala program.</p>
      <p>One downside of combinator parsers is that they are not very efficient, at least not when compared with parsers generated from special purpose tools such as Yacc or Bison. There are two reasons for this. First, the backtracking method used by combinator parsing is itself not very efficient. Depending on the grammar and the parse input, it might yield an exponential slow-down due to repeated backtracking. This can be fixed by making the grammar LL(1) and by using the committed sequential composition operator, <span class="code"><span style="font-size:large">~</span>!</span>.</p>
      <p>The second problem affecting the performance of combinator parsers is that they mix parser construction and input analysis in the same set of operations. In effect, a parser is generated anew for each input that's parsed.</p>
      <p>This problem can be overcome, but it requires a different implementation of the parser combinator framework. In an optimizing framework, a parser would no longer be represented as a function from inputs to parse results. Instead, it would be represented as a tree, where every construction step was represented as a case class. For instance, sequential composition could be represented by a case class <span class="code">Seq</span>, alternative by <span class="code">Alt</span>, and so on. The "outermost" parser method, <span class="code">phrase</span>, could then take this symbolic representation of a parser and convert it to highly efficient parsing tables, using standard parser generator algorithms.</p>
      <p>What's nice about all this is that from a user perspective nothing changes compared to plain combinator parsers. Users still write parsers in terms of <span class="code">ident</span>, <span class="code">floatingPointNumber</span>, <span class="code"><span style="font-size:large">~</span></span>, <span class="code">|</span>, and so on. They need not be aware that these methods generate a symbolic representation of a parser instead of a parser function. Since the <span class="code">phrase</span> combinator converts these representations into real parsers, everything works as before.</p>
      <p>The advantage of this scheme with respect to performance is two-fold. First, you can now factor out parser construction from input analysis. If you were to write:</p> <pre>  <code class="vem">val</code>&nbsp;jsonParser&nbsp;=&nbsp;phrase(value)
</pre>
      <p>and then apply <span class="code">jsonParser</span> to several different inputs, the <span class="code">jsonParser</span> would be constructed only once, not every time an input is read.</p>
      <p>Second, the parser generation can use efficient parsing algorithms such as LALR(1).<a id="i-572333127-1"></a><a href="#footnotemain33-3">[3]</a> These algorithms usually lead to much faster parsers than parsers that operate with backtracking.</p>
      <p>At present, such an optimizing parser generator has not yet been written for Scala. But it would be perfectly possible to do so. If someone contributes such a generator, it will be easy to integrate into the standard Scala library. Even postulating that such a generator will exist at some point in the future, however, there are reasons for keeping the current parser combinator framework around. It is much easier to understand and to adapt than a parser generator, and the difference in speed would often not matter in practice, unless you want to parse very large inputs.</p>
      <hr>
      <h4>Footnotes for Chapter 33:</h4>
      <p><a id="footnotemain33-1"></a>[1] There are ways to avoid stack overflows even in the presence of left-recursion, but this requires a more refined parsing combinator framework, which to date has not been implemented.</p>
      <p><a id="footnotemain33-2"></a>[2] Aho, <i>et. al.</i>, <em>Compilers: Principles, Techniques, and Tools</em>. <a href="#aho-sethi-ullman">[Aho86]</a><a id="i1109104818-2"></a></p>
      <p><a id="footnotemain33-3"></a>[3] Aho, <i>et. al.</i>, <em>Compilers: Principles, Techniques, and Tools</em>. <a href="#aho-sethi-ullman">[Aho86]</a><a id="i-1383802058-1"></a></p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-gui-programming">Chapter 34</a></h2>
      <h1>GUI Programming</h1>
      <p>In this chapter you'll learn how to develop in Scala applications that use a graphical user interface (GUI). The applications we'll develop are based on a Scala library that provides access to Java's Swing framework of GUI classes.<a id="i80301790-1"></a><a id="i1756438818-1"></a> Conceptually, the Scala library resembles the underlying Swing classes, but hides much of their complexity. You'll find out that developing GUI applications using the framework is actually quite easy.<a id="i1275390415-1"></a></p>
      <p>Even with Scala's simplifications, a framework like Swing is quite rich, with many different classes and many methods in each class. To find your way in such a rich library, it helps to use an IDE such as Scala's Eclipse plugin.<a id="i-1327804143-2"></a> The advantage is that the IDE can show you interactively with its command completion which classes are available in a package and which methods are available for objects you reference. This speeds up your learning considerably when you first explore an unknown library space.</p>
      <div class="figure">
        <a id="fig-swing1"></a>
        <table style="border-collapse: collapse">
          <tbody>
            <tr>
              <td> <img src="firstSwingAppLittleGray96.png" alt="images/firstSwingAppLittleGray96.png"> </td>
              <td> <img src="firstSwingAppBigGray96.png" alt="images/firstSwingAppBigGray96.png"> </td>
            </tr>
          </tbody>
        </table>
      </div>
      <h5> Figure 34.1 - A simple Swing application: initial (left) and resized (right).</h5>
      <h3>34.1 A first Swing application</h3>
      <p>As a first Swing application, we'll start with a window containing a single button. To program with Swing, you need to import various classes from Scala's Swing API package:</p> <pre>  <code class="vem">import</code>&nbsp;scala.swing._
</pre>
      <p><a href="#lst-first-swing-app">Listing 34.1</a> shows the code of your first Swing application in Scala. If you compile and run that file, you should see a window as shown on the left of <a href="#fig-swing1">Figure 34.1</a>. The window can be resized to a larger size as shown on the right of <a href="#fig-swing1">Figure 34.1</a>. <a id="lst-first-swing-app"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.swing._
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">FirstSwingApp</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">SimpleSwingApplication</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;top&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MainFrame</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;<code class="quotedstring">"First&nbsp;Swing&nbsp;App"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Button</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;<code class="quotedstring">"Click&nbsp;me"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 34.1 - A simple Swing application in Scala.</h5>
      <p>If you analyze the code in <a href="#lst-first-swing-app">Listing 34.1</a> line by line, you'll notice the following elements:</p> <pre>  <code class="vem">object</code>&nbsp;<code class="typename">FirstSwingApp</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">SimpleSwingApplication</code>&nbsp;{
</pre>
      <p>In the first line after the import, the <span class="code">FirstSwingApp</span> object inherits from <span class="code">scala.swing.SimpleSwingApplication</span>.<a id="i980116412-1"></a> This application differs from traditional command-line applications, which may inherit from <span class="code">scala.App</span>.<a id="i2043724591-2"></a> The <span class="code">SimpleSwingApplication</span> class already defines a <span class="code">main</span> method that contains some setup code for Java's Swing framework. The <span class="code">main</span> method then proceeds to call the <span class="code">top</span> method, which you supply:<a id="i673279455-1"></a><a id="i1222409213-1"></a></p> <pre>  <code class="vem">def</code>&nbsp;top&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MainFrame</code>&nbsp;{
</pre>
      <p>The next line implements the <span class="code">top</span> method. This method contains the code that defines your top-level GUI component. This is usually some kind of <span class="code">Frame</span>—<i>i.e.</i>, a window that can contain arbitrary data. In <a href="#lst-first-swing-app">Listing 34.1</a>, we chose a <span class="code">MainFrame</span> as the top-level component. A <span class="code">MainFrame</span> is like a normal Swing <span class="code">Frame</span> except that closing it will also close the whole GUI application.<a id="i1729789716-1"></a></p> <pre>  title&nbsp;=&nbsp;<code class="quotedstring">"First&nbsp;Swing&nbsp;App"</code>
</pre>
      <p>Frames have a number of attributes. Two of the most important are the frame's <span class="code">title</span>, which will be written in the title bar, and its <span class="code">contents</span>, which will be displayed in the window itself.<a id="i-1539619709-1"></a><a id="i872532101-1"></a> In Scala's Swing API, such attributes are modeled as properties. You know from <a href="#sec-properties">Section 18.2</a> that properties are encoded in Scala as pairs of getter and setter methods. For instance, the <span class="code">title</span> property of a <span class="code">Frame</span> object is modeled as a getter method:<a id="i553650449-4"></a><a id="i-1969580643-5"></a><a id="i-926053069-3"></a></p> <pre>  <code class="vem">def</code>&nbsp;title:&nbsp;<code class="typename">String</code>
</pre>
      <p>and a setter method:</p> <pre>  <code class="vem">def</code>&nbsp;title_=(s:&nbsp;<code class="typename">String</code>)
</pre>
      <p>It is this setter method that gets invoked by the above assignment to <span class="code">title</span>. The effect of the assignment is that the chosen title is shown in the header of the window. If you leave it out, the window will have an empty title.</p> <pre>  contents&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Button</code>&nbsp;{
</pre>
      <p>The <span class="code">top</span> frame is the root component of the Swing application. It is a <span class="code">Container</span>, which means that further components can be defined in it.<a id="i-2044598897-1"></a><a id="i1014658637-1"></a> Every Swing container has a <span class="code">contents</span> property, which allows you to get and set the components it contains. The getter <span class="code">contents</span> of this property has type <span class="code">Seq[Component]</span>,<a id="i1009131637-1"></a> indicating that a component can in general have several objects as its contents. Frames, however, always have just a single component as their <span class="code">contents</span>. This component is set and potentially changed using the setter <span class="code">contents_=</span>. For example, in <a href="#lst-first-swing-app">Listing 34.1</a> a single <span class="code">Button</span> constitutes the <span class="code">contents</span> of the <span class="code">top</span> frame.</p> <pre>  text&nbsp;=&nbsp;<code class="quotedstring">"Click&nbsp;me"</code>
</pre>
      <p>The button also gets a title, in this case "Click me."</p>
      <h3>34.2 Panels and layouts</h3>
      <p>As next step, we'll add some text as a second content element to the <span class="code">top</span> frame of the application. The left part of <a href="#fig-swing2">Figure 34.2</a> shows what the application should look like.</p>
      <div class="figure">
        <a id="fig-swing2"></a>
        <table style="border-collapse: collapse">
          <tbody>
            <tr>
              <td> <img src="noClicks2Gray96.png" alt="images/noClicks2Gray96.png"> </td>
              <td> <img src="sevenClicks2Gray96.png" alt="images/sevenClicks2Gray96.png"> </td>
            </tr>
          </tbody>
        </table>
      </div>
      <h5> Figure 34.2 - A reactive Swing application: initial (left) after clicks (right).</h5>
      <p><a id="lst-first-swing-app-modified"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.swing._
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">SecondSwingApp</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">SimpleSwingApplication</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;top&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MainFrame</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;<code class="quotedstring">"Second&nbsp;Swing&nbsp;App"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;button&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Button</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;<code class="quotedstring">"Click&nbsp;me"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;label&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Label</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;<code class="quotedstring">"No&nbsp;button&nbsp;clicks&nbsp;registered"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}	
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BoxPanel</code>(<code class="typename">Orientation.Vertical</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;+=&nbsp;button
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;+=&nbsp;label
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border&nbsp;=&nbsp;<code class="typename">Swing.EmptyBorder</code>(<code class="literal">30</code>,&nbsp;<code class="literal">30</code>,&nbsp;<code class="literal">10</code>,&nbsp;<code class="literal">30</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}&nbsp;&nbsp;
</pre>
      <h5>Listing 34.2 - Component assembly on a panel.</h5>
      <p>You saw in the last section that a frame contains exactly one child component. Hence, to make a frame with both a button and a label, you need to create a different container component that holds both. That's what <span style="font-style:italic">panels</span> are used for.<a id="i76880356-1"></a> A <span class="code">Panel</span> is a container that displays all the components it contains according to some fixed layout rules. There are a number of different possible layouts that are implemented by various subclasses of class <span class="code">Panel</span>, ranging from simple to quite intricate. In fact, one of the hardest parts of a complex GUI application can be getting the layouts right—it's not easy to come up with something that displays reasonably well on all sorts of devices and for all window sizes.<a id="i51441782-1"></a></p>
      <p><a href="#lst-first-swing-app-modified">Listing 34.2</a> shows a complete implementation. In this class, the two sub-components of the <span class="code">top</span> frame are named <span class="code">button</span> and <span class="code">label</span>. The <span class="code">button</span> is defined as before. The <span class="code">label</span> is a displayed text field that can't be edited:</p> <pre>  <code class="vem">val</code>&nbsp;label&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Label</code>&nbsp;{
  &nbsp;&nbsp;text&nbsp;=&nbsp;<code class="quotedstring">"No&nbsp;button&nbsp;clicks&nbsp;registered"</code>
  }	
</pre>
      <p>The code in <a href="#lst-first-swing-app-modified">Listing 34.2</a> picks a simple vertical layout where components are stacked on top of each other in a <span class="code">BoxPanel</span>:</p> <pre>  contents&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BoxPanel</code>(<code class="typename">Orientation.Vertical</code>)&nbsp;{
</pre>
      <p>The <span class="code">contents</span> property of the <span class="code">BoxPanel</span> is an (initially empty) buffer, to which the <span class="code">button</span> and <span class="code">label</span> elements are added with the <span class="code">+=</span> operator:</p> <pre>  &nbsp;&nbsp;contents&nbsp;+=&nbsp;button
  &nbsp;&nbsp;contents&nbsp;+=&nbsp;label
</pre>
      <p>We also add a border around the two objects by assigning to the <span class="code">border</span> property of the panel:</p> <pre>  &nbsp;&nbsp;border&nbsp;=&nbsp;<code class="typename">Swing.EmptyBorder</code>(<code class="literal">30</code>,&nbsp;<code class="literal">30</code>,&nbsp;<code class="literal">10</code>,&nbsp;<code class="literal">30</code>)
</pre>
      <p>As is the case with other GUI components, borders are represented as objects. <span class="code">EmptyBorder</span> is a factory method in object <span class="code">Swing</span> that takes four parameters indicating the width of the borders on the top, right, bottom, and left sides of the objects to be drawn.<a id="i80301790-2"></a><a id="i1673765513-1"></a></p>
      <p>Simple as it is, the example has already shown the basic way to structure a GUI application. It is built from components, which are instances of <span class="code">scala.swing</span> classes such as <span class="code">Frame</span>, <span class="code">Panel</span>, <span class="code">Label</span> or <span class="code">Button</span>. Components have properties, which can be customized by the application. <span class="code">Panel</span> components can contain several other components in their <span class="code">contents</span> property, so that in the end a GUI application consists of a tree of components.</p>
      <h3>34.3 Handling events</h3>
      <p>On the other hand, the application still misses an essential property.<a id="i1245010859-1"></a> If you run the code in <a href="#lst-first-swing-app-modified">Listing 34.2</a> and click on the displayed button, nothing happens. In fact, the application is completely static; it does not react in any way to user events except for the close button of the <span class="code">top</span> frame, which terminates the application. So as a next step, we'll refine the application so that it displays together with the button a label that indicates how often the button was clicked. The right part of <a href="#fig-swing2">Figure 34.2</a> contains a snapshot of what the application should look like after a few button clicks.</p>
      <p>To achieve this behavior, you need to connect a user-input event (the button was clicked) with an action (the displayed label is updated). Java and Scala have fundamentally the same "publish/subscribe" approach to event handling: Components may be publishers and/or subscribers. A publisher publishes events. A subscriber subscribes with a publisher to be notified of any published events. Publishers are also called "event sources," and subscribers are also called "event listeners".<a id="i-1342345159-1"></a><a id="i547853576-1"></a> For instance a <span class="code">Button</span> is an event source, which publishes an event, <span class="code">ButtonClicked</span>, indicating that the button was clicked.<a id="i-1378806667-1"></a></p>
      <p>In Scala, subscribing to an event source <span class="code">source</span> is done by the call <span class="code">listenTo(source)</span>. There's also a way to unsubscribe from an event source using <span class="code">deafTo(source)</span>.<a id="i-1549919358-1"></a><a id="i-2118281873-1"></a><a id="i-1623449564-1"></a> In the current example application, the first thing to do is to get the <span class="code">top</span> frame to listen to its button, so that it gets notified of any events that the button issues. To do that you need to add the following call to the body of the <span class="code">top</span> frame:</p> <pre>  listenTo(button)
</pre>
      <p>Being notified of events is only half the story; the other half is handling them. It is here that the Scala Swing framework is most different from (and radically simpler than) the Java Swing API's. In Java, signaling an event means calling a "notify" method in an object that has to implement some <span class="code">Listener</span> interfaces. Usually, this involves a fair amount of indirection and boiler-plate code, which makes event-handling applications hard to write and read. By contrast, in Scala, an event is a real object that gets sent to subscribing components much like messages are sent to actors. For instance, pressing a button will create an event which is an instance of the following case class:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ButtonClicked</code>(source:&nbsp;<code class="typename">Button</code>)
</pre>
      <p>The parameter of the case class refers to the button that was clicked. As with all other Scala Swing events, this event class is contained in a package named <span class="code">scala.swing.event</span>.</p>
      <p>To have your component react to incoming events you need to add a handler to a property called <span class="code">reactions</span>.<a id="i-49046473-1"></a> Here's the code that does this:</p> <pre>  <code class="vem">var</code>&nbsp;nClicks&nbsp;=&nbsp;<code class="literal">0</code>
  reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">ButtonClicked</code>(b)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;nClicks&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;label.text&nbsp;=&nbsp;<code class="quotedstring">"Number&nbsp;of&nbsp;button&nbsp;clicks:&nbsp;"</code>&nbsp;+&nbsp;nClicks
  }
</pre>
      <p>The first line above defines a variable, <span class="code">nClicks</span>, which holds the number of times a button was clicked. The remaining lines add the code between braces as a <span style="font-style:italic">handler</span> to the <span class="code">reactions</span> property of the <span class="code">top</span> frame. Handlers are functions defined by pattern matching on events, much like Akka actor <span class="code">receive</span> methods are defined by pattern matching on messages.<a id="i-729007015-1"></a><a id="i-1422944994-5"></a><a id="i2042656-5"></a> The handler above matches events of the form <span class="code">ButtonClicked(b)</span>, <i>i.e.</i>, any event which is an instance of class <span class="code">ButtonClicked</span>. The pattern variable <span class="code">b</span> refers to the actual button that was clicked. The action that corresponds to this event in the code above increments <span class="code">nClicks</span> and updates the text of the label.</p>
      <p>Generally, a handler is a <span class="code">PartialFunction</span> that matches on events and performs some actions.<a id="i-33298553-2"></a> It is also possible to match on more than one kind of event in a single handler by using multiple cases.</p>
      <p><a id="listing-reactive-swing-app"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.swing._
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;scala.swing.event._
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">ReactiveSwingApp</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">SimpleSwingApplication</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;top&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MainFrame</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;<code class="quotedstring">"Reactive&nbsp;Swing&nbsp;App"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;button&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Button</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;<code class="quotedstring">"Click&nbsp;me"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;label&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Label</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;<code class="quotedstring">"No&nbsp;button&nbsp;clicks&nbsp;registered"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}	
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">BoxPanel</code>(<code class="typename">Orientation.Vertical</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;+=&nbsp;button
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;+=&nbsp;label
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border&nbsp;=&nbsp;<code class="typename">Swing.EmptyBorder</code>(<code class="literal">30</code>,&nbsp;<code class="literal">30</code>,&nbsp;<code class="literal">10</code>,&nbsp;<code class="literal">30</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listenTo(button)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;nClicks&nbsp;=&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">ButtonClicked</code>(b)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nClicks&nbsp;+=&nbsp;<code class="literal">1</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label.text&nbsp;=&nbsp;<code class="quotedstring">"Number&nbsp;of&nbsp;button&nbsp;clicks:&nbsp;"</code>&nbsp;+&nbsp;nClicks
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}&nbsp;&nbsp;
</pre>
      <h5>Listing 34.3 - Implementing a reactive Swing application.</h5>
      <p>The <span class="code">reactions</span> property implements a collection, just like the <span class="code">contents</span> property does. Some components come with predefined reactions. For instance, a <span class="code">Frame</span> has a predefined reaction that it will close if the user presses the close button on the upper right. If you install your own reactions by adding them with <span class="code">+=</span> to the <span class="code">reactions</span> property, the reactions you define will be considered in addition to the standard ones. Conceptually, the handlers installed in <span class="code">reactions</span> form a stack. In the current example, if the <span class="code">top</span> frame receives an event, the first handler tried will be the one that matches on <span class="code">ButtonClicked</span>, because it was the last handler installed for the frame. If the received event is of type <span class="code">ButtonClicked</span>, the code associated with the pattern will be invoked. After that code has completed, the system will search for further handlers in the event stack that might also be applicable. If the received event is not of type <span class="code">ButtonClicked</span>, the event is immediately propagated to the rest of the installed handler stack. It's also possible to remove handlers from the <span class="code">reaction</span> property, using the <span class="code">-=</span> operator.</p>
      <p><a href="#listing-reactive-swing-app">Listing 34.3</a> shows the completed application, including reactions. The code illustrates the essential elements of a GUI application in Scala's Swing framework: The application consists of a tree of components, starting with the <span class="code">top</span> frame. The components shown in the code are <span class="code">Frame</span>, <span class="code">BoxPanel</span>, <span class="code">Button</span>, and <span class="code">Label</span>, but there are many other kinds of components defined in the Swing libraries. Each component is customized by setting attributes. Two important attributes are <span class="code">contents</span>, which fixes the children of a component in the tree, and <span class="code">reactions</span>, which determines how the component reacts to events.</p>
      <div class="figure">
        <a id="fig-swing3"></a>
        <p><img src="tempConverterGray112.png" alt="images/tempConverterGray112.png"></p>
      </div>
      <h5> Figure 34.3 - A converter between degrees Celsius and Fahrenheit.</h5>
      <p><a id="listing-converter"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;swing._
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;event._
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">TempConverter</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">SimpleSwingApplication</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;top&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MainFrame</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;<code class="quotedstring">"Celsius/Fahrenheit&nbsp;Converter"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;celsius&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">TextField</code>&nbsp;{&nbsp;columns&nbsp;=&nbsp;<code class="literal">5</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">object</code>&nbsp;fahrenheit&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">TextField</code>&nbsp;{&nbsp;columns&nbsp;=&nbsp;<code class="literal">5</code>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">FlowPanel</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;+=&nbsp;celsius
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;+=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Label</code>(<code class="quotedstring">"&nbsp;Celsius&nbsp;&nbsp;=&nbsp;&nbsp;"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;+=&nbsp;fahrenheit
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;+=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Label</code>(<code class="quotedstring">"&nbsp;Fahrenheit"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border&nbsp;=&nbsp;<code class="typename">Swing.EmptyBorder</code>(<code class="literal">15</code>,&nbsp;<code class="literal">10</code>,&nbsp;<code class="literal">10</code>,&nbsp;<code class="literal">10</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listenTo(celsius,&nbsp;fahrenheit)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EditDone</code>(`fahrenheit`)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;fahrenheit.text.toInt
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;c&nbsp;=&nbsp;(f&nbsp;-&nbsp;<code class="literal">32</code>)&nbsp;*&nbsp;<code class="literal">5</code>&nbsp;/&nbsp;<code class="literal">9</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;celsius.text&nbsp;=&nbsp;c.toString
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">EditDone</code>(`celsius`)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;c&nbsp;=&nbsp;celsius.text.toInt
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;f&nbsp;=&nbsp;c&nbsp;*&nbsp;<code class="literal">9</code>&nbsp;/&nbsp;<code class="literal">5</code>&nbsp;+&nbsp;<code class="literal">32</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fahrenheit.text&nbsp;=&nbsp;f.toString
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 34.4 - An implementation of the temperature converter.</h5>
      <h3>34.4 Example: Celsius/Fahrenheit converter</h3>
      <p>As another example, we'll write a GUI program that converts between temperature degrees in Celsius and Fahrenheit. The user interface of the program is shown in <a href="#fig-swing3">Figure 34.3</a>. It consists of two text fields (shown in white) with a label following each. One text field shows temperatures in degrees Celsius, the other in degrees Fahrenheit. Each of the two fields can be edited by the user of the application. Once the user has changed the temperature in either field, the temperature in the other field should automatically update.</p>
      <p><a href="#listing-converter">Listing 34.4</a> shows the complete code that implements this application. The imports at the top of the code use a short-hand:</p> <pre>  <code class="vem">import</code>&nbsp;swing._
  <code class="vem">import</code>&nbsp;event._
</pre>
      <p>This is in fact equivalent to the imports used before:</p> <pre>  <code class="vem">import</code>&nbsp;scala.swing._
  <code class="vem">import</code>&nbsp;scala.swing.event._
</pre>
      <p>The reason you can use the shorthand is that packages nest in Scala. Because package <span class="code">scala.swing</span> is contained in package <span class="code">scala</span>, and everything in that package imported automatically, you can write just <span class="code">swing</span> to refer to the package. Likewise, package <span class="code">scala.swing.event</span>, is contained as subpackage <span class="code">event</span> in package <span class="code">scala.swing</span>. Because you have imported everything in <span class="code">scala.swing</span> in the first import, you can refer to the event package with just <span class="code">event</span> thereafter.</p>
      <p>The two components <span class="code">celsius</span> and <span class="code">fahrenheit</span> in <span class="code">TempConverter</span> are objects of class <span class="code">TextField</span>. A <span class="code">TextField</span> in Swing is a component that lets you edit a single line of text. It has a default width, which is given in the <span class="code">columns</span> property measured in characters (set to 5 for both fields).</p>
      <p>The <span class="code">contents</span> of <span class="code">TempConverter</span> are assembled into a panel, which includes the two text fields and two labels that explain what the fields are. The panel is of class <span class="code">FlowPanel</span>, which means it displays all its elements one after another, in one or more rows, depending on the width of the frame.</p>
      <p>The <span class="code">reactions</span> of <span class="code">TempConverter</span> are defined by a handler that contains two cases. Each case matches an <span class="code">EditDone</span> event for one of the two text fields.<a id="i1666208972-1"></a> Such an event gets issued when a text field has been edited by the user. Note the form of the patterns, which include back ticks around the element names:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="typename">EditDone</code>(`celsius`)
</pre>
      <p>As was explained in <a href="#sec-kinds-of-patterns">Section 15.2</a>, the back ticks around <span class="code">celsius</span> ensure that the pattern matches only if the source of the event was the <span class="code">celsius</span> object. If you had omitted the back ticks and just written <span class="code">case</span>&nbsp;<span class="code">EditDone(celsius)</span>, the pattern would have matched every event of class <span class="code">EditDone</span>. The changed field would then be stored in the pattern variable <span class="code">celsius</span>. Obviously, this is not what you want. Alternatively, you could have defined the two <span class="code">TextField</span> objects starting with upper case characters, <i>i.e.</i>, <span class="code">Celsius</span> and <span class="code">Fahrenheit</span>. In that case you could have matched them directly without back ticks, as in <span class="code">case</span>&nbsp;<span class="code">EditDone(Celsius)</span>.</p>
      <p>The two actions of the <span class="code">EditDone</span> events convert one quantity to another. Each starts by reading out the contents of the modified field and converting it to an <span class="code">Int</span>. It then applies the formula for converting one temperature degree to the other, and stores the result back as a string in the other text field.</p>
      <h3>34.5 Conclusion</h3>
      <p>This chapter has given you a first taste of GUI programming, using Scala's wrappers for the Swing framework. It has shown how to assemble GUI components, how to customize their properties, and how to handle events. For space reasons, we could discuss only a small number of simple components. There are many more kinds of components. You can find out about them by consulting the Scala documentation of the package <span class="code">scala.swing</span>. The next section will develop an example of a more complicated Swing application.</p>
      <p>There are also many tutorials on the original Java Swing framework, on which the Scala wrapper is based.<a href="#footnotemain34-1">[1]</a> The Scala wrappers resemble the underlying Swing classes, but try to simplify concepts where possible and make them more uniform. The simplification makes extensive use of the properties of the Scala language. For instance, Scala's emulation of properties and its operator overloading allow convenient property definitions using assignments and <span class="code">+=</span> operations. Its "everything is an object" philosophy makes it possible to inherit the main method of a GUI application. The method can thus be hidden from user applications, including the boilerplate code for setting things up that comes with it. Finally, and most importantly, Scala's first-class functions and pattern matching make it possible to formulate event handling as the <span class="code">reactions</span> component property, which greatly simplifies life for the application developer.</p>
      <hr>
      <h4>Footnotes for Chapter 34:</h4>
      <p><a id="footnotemain34-1"></a>[1] See, for instance, <em>The Java Tutorials</em>. <a href="#JavaTutorials">[Jav]</a></p>
    </div>
    <div class="h annotator-wrapper cover">
      <h2><a id="chap-the-scells-spreadsheet">Chapter 35</a></h2>
      <h1>The <span class="code">SCells</span> Spreadsheet</h1>
      <p>In the previous chapters you saw many different constructs of the Scala programming language. In this chapter you'll see how these constructs play together in the implementation of a sizable application. The task is to write a spreadsheet application, which will be named <span class="code">SCells</span>.<a id="i-1325982169-1"></a></p>
      <p>There are several reasons why this task is interesting. First, everybody knows spreadsheets, so it is easy to understand what the application should do. Second, spreadsheets are programs that exercise a large range of different computing tasks. There's the visual aspect, where a spreadsheet is seen as a rich GUI application.<a id="i1275390415-2"></a> There's the symbolic aspect, having to do with formulas and how to parse and interpret them. There's the calculational aspect, dealing with how to update possibly large tables incrementally. There's the reactive aspect, where spreadsheets are seen as programs that react in intricate ways to events. Finally, there's the component aspect where the application is constructed as a set of reusable components.<a id="i-421431555-1"></a> All these aspects will be treated in depth in this chapter.</p>
      <div class="figure">
        <a id="fig-scells1"></a>
        <p><img src="scells1Gray96.png" alt="images/scells1Gray96.png"></p>
      </div>
      <h5> Figure 35.1 - A simple spreadsheet table.</h5>
      <h3>35.1 The visual framework</h3>
      <p>We'll start by writing the basic visual framework of the application. <a href="#fig-scells1">Figure 35.1</a> shows the first iteration of the user interface. You can see that a spreadsheet is a scrollable table. It has rows going from <span class="code">0</span> to <span class="code">99</span> and columns going from <span class="code">A</span> to <span class="code">Z</span>. You express this in Swing by defining a spreadsheet as a <span class="code">ScrollPane</span> containing a <span class="code">Table</span>. <a href="#lst-scells-Spreadsheet1">Listing 35.1</a> shows the code.<a id="i870227341-1"></a><a id="i455478918-1"></a></p>
      <p><a id="lst-scells-Spreadsheet1"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;swing._
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ScrollPane</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;table&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Table</code>(height,&nbsp;width)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rowHeight&nbsp;=&nbsp;<code class="literal">25</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoResizeMode&nbsp;=&nbsp;<code class="typename">Table.AutoResizeMode.Off</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showGrid&nbsp;=&nbsp;<code class="vem">true</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gridColor&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">java.awt.Color</code>(<code class="literal">150</code>,&nbsp;<code class="literal">150</code>,&nbsp;<code class="literal">150</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;rowHeader&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ListView</code>((<code class="literal">0</code>&nbsp;until&nbsp;height)&nbsp;map&nbsp;(_.toString))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellWidth&nbsp;=&nbsp;<code class="literal">30</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellHeight&nbsp;=&nbsp;table.rowHeight
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;viewportView&nbsp;=&nbsp;table
  &nbsp;&nbsp;&nbsp;&nbsp;rowHeaderView&nbsp;=&nbsp;rowHeader
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 35.1 - Code for spreadsheet in <a href="#fig-scells1">Figure 35.1</a>.</h5>
      <p>The spreadsheet component shown in <a href="#lst-scells-Spreadsheet1">Listing 35.1</a> is defined in package <span class="code">org.stairwaybook.scells</span>, which will contain all classes, traits, and objects needed for the application. It imports from package <span class="code">scala.swing</span> essential elements of Scala's Swing wrapper. <span class="code">Spreadsheet</span> itself is a class that takes <span class="code">height</span> and <span class="code">width</span> (in numbers of cells) as parameters. The class extends <span class="code">ScrollPane</span>, which gives it the scroll-bars at the bottom and right in <a href="#fig-scells1">Figure 35.1</a>. It contains two sub-components named <span class="code">table</span> and <span class="code">rowHeader</span>.</p>
      <p>The <span class="code">table</span> component is an instance of an anonymous subclass of class <span class="code">scala.swing.Table</span>. The four lines in its body set some of its attributes: <span class="code">rowHeight</span> for the height of a table row in points, <span class="code">autoResizeMode</span> to turn auto-sizing the table off, <span class="code">showGrid</span> to show a grid of lines between cells, and <span class="code">gridColor</span> to set the color of the grid to a dark gray.</p>
      <p>The <span class="code">rowHeader</span> component, which contains the row-number headers at the left of the spreadsheet in <a href="#fig-scells1">Figure 35.1</a>, is a <span class="code">ListView</span> that displays in its elements the strings <span class="code">0</span> through <span class="code">99</span>.<a id="i1410352259-1"></a> The two lines in its body fix the width of a cell to be 30 points and the height to be the same as the <span class="code">table</span>'s <span class="code">rowHeight</span>.</p>
      <p>The whole spreadsheet is assembled by setting two fields in <span class="code">ScrollPane</span>. The field <span class="code">viewportView</span> is set to the <span class="code">table</span>, and the field <span class="code">rowHeaderView</span> is set to the <span class="code">rowHeader</span> list.<a id="i-184785362-1"></a><a id="i-1248398867-1"></a><a id="i870227341-2"></a> The difference between the two views is that a view port of a scroll pane is the area that scrolls with the two bars, whereas the row header on the left stays fixed when you move the horizontal scroll bar. By some quirk, Swing already supplies by default a column header at the top of the table, so there's no need to define one explicitly.</p>
      <p><a id="lst-scells-Main"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;swing._
  <br>  &nbsp;&nbsp;<code class="vem">object</code>&nbsp;<code class="typename">Main</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">SimpleSwingApplication</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;top&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">MainFrame</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;<code class="quotedstring">"ScalaSheet"</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="literal">100</code>,&nbsp;<code class="literal">26</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 35.2 - The main program for the spreadsheet application.</h5>
      <p>To try out the rudimentary spreadsheet shown in <a href="#lst-scells-Spreadsheet1">Listing 35.1</a>, you just need to define a main program that creates the <span class="code">Spreadsheet</span> component. Such a program is shown in <a href="#lst-scells-Main">Listing 35.2</a>.</p>
      <p>Program <span class="code">Main</span> inherits from <span class="code">SimpleSwingApplication</span>, which takes care of all the low-level details that need to be set up before a Swing application can be run.<a id="i980116412-2"></a> You only need to define the top-level window of the application in the <span class="code">top</span> method. In our example, <span class="code">top</span> is a <span class="code">MainFrame</span> that has two elements defined: its <span class="code">title</span>, set to "ScalaSheet," and its <span class="code">contents</span>, set to an instance of class <span class="code">Spreadsheet</span> with <span class="code">100</span> rows and <span class="code">26</span> columns. That's all. If you launch this application with <span class="code">scala</span>&nbsp;<span class="code">org.stairwaybook.scells.Main</span>, you should see the spreadsheet in <a href="#fig-scells1">Figure 35.1</a>.</p>
      <h3>35.2 Disconnecting data entry and display</h3>
      <p>If you play a bit with the spreadsheet written so far, you'll quickly notice that the output that's displayed in a cell is always exactly what you entered in the cell. A real spreadsheet does not behave like that. In a real spreadsheet, you would enter a formula and you'd see its value. So what is entered into a cell is different from what is displayed.</p>
      <p><a id="lst-scells-Spreadsheet2"></a></p> <pre>  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <code class="vem">import</code>&nbsp;swing._
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ScrollPane</code>&nbsp;{
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;cellModel&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Model</code>(height,&nbsp;width)
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;cellModel._
  <br>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;table&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Table</code>(height,&nbsp;width)&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="comment">//&nbsp;settings&nbsp;as&nbsp;before...&nbsp;</code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;rendererComponent(isSelected:&nbsp;<code class="typename">Boolean</code>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasFocus:&nbsp;<code class="typename">Boolean</code>,&nbsp;row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">Component</code>&nbsp;=
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(hasFocus)&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">TextField</code>(userData(row,&nbsp;column))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">else</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Label</code>(cells(row)(column).toString)&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xAlignment&nbsp;=&nbsp;<code class="typename">Alignment.Right</code>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;userData(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;v&nbsp;=&nbsp;<code class="vem">this</code>(row,&nbsp;column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">if</code>&nbsp;(v&nbsp;==&nbsp;<code class="vem">null</code>)&nbsp;<code class="quotedstring">""</code>&nbsp;<code class="vem">else</code>&nbsp;v.toString
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<code class="comment">//&nbsp;rest&nbsp;as&nbsp;before...&nbsp;</code>
  }&nbsp;
</pre>
      <h5>Listing 35.3 - A spreadsheet with a <span class="code">rendererComponent</span> method.</h5>
      <p>As a first step to a real spreadsheet application, you should concentrate on disentangling data entry and display. The basic mechanism for display is contained in the <span class="code">rendererComponent</span> method of class <span class="code">Table</span>.<a id="i455478918-2"></a><a id="i-1871849869-1"></a> By default, <span class="code">rendererComponent</span> always displays what's entered. If you want to change that, you need to override <span class="code">rendererComponent</span> to do something different. <a href="#lst-scells-Spreadsheet2">Listing 35.3</a> shows a new version of <span class="code">Spreadsheet</span> with a <span class="code">rendererComponent</span> method.</p>
      <p>The <span class="code">rendererComponent</span> method overrides a default method in class <span class="code">Table</span>. It takes four parameters. The <span class="code">isSelected</span> and <span class="code">hasFocus</span> parameters are <span class="code">Boolean</span>s that indicate whether the cell has been selected and whether it has focus, meaning that keyboard events will go into the cell. The remaining two parameters, <span class="code">row</span> and <span class="code">column</span>, give the cell's coordinates.</p>
      <p>The new <span class="code">rendererComponent</span> method checks whether the cell has input focus. If <span class="code">hasFocus</span> is true, the cell is used for editing. In this case you want to display an editable <span class="code">TextField</span> that contains the data the user has entered so far.<a id="i942981037-1"></a> This data is returned by the helper method <span class="code">userData</span>, which displays the contents of the table at a given <span class="code">row</span> and <span class="code">column</span>. The contents are retrieved by the call <span class="code">this(row,</span>&nbsp;<span class="code">column)</span>.<a href="#footnotemain35-1">[1]</a> The <span class="code">userData</span> method also takes care to display a <span class="code">null</span> element as the empty string instead of "<span class="code">null</span>."</p>
      <p>So far so good. But what should be displayed if the cell does not have focus? In a real spreadsheet this would be the value of a cell. Thus, there are really two tables at work. The first table, named <span class="code">table</span> contains what the user entered. A second "shadow" table contains the internal representation of cells and what should be displayed. In the spreadsheet example, this table is a two-dimensional array called <span class="code">cells</span>. If a cell at a given <span class="code">row</span> and <span class="code">column</span> does not have editing focus, the <span class="code">rendererComponent</span> method will display the element <span class="code">cells(row)(column)</span>. The element cannot be edited, so it should be displayed in a <span class="code">Label</span> instead of in an editable <span class="code">TextField</span>.<a id="i73174740-1"></a></p>
      <p>It remains to define the internal array of cells. You could do this directly in the <span class="code">Spreadsheet</span> class, but it's generally preferable to separate the view of a GUI component from its internal model. That's why in the example above the <span class="code">cells</span> array is defined in a separate class named <span class="code">Model</span>. The model is integrated into the <span class="code">Spreadsheet</span> by defining a value <span class="code">cellModel</span> of type <span class="code">Model</span>. The <span class="code">import</span> clause that follows this <span class="code">val</span> definition makes the members of <span class="code">cellModel</span> available inside <span class="code">Spreadsheet</span> without having to prefix them. <a href="#lst-scells-Model1">Listing 35.4</a> shows a first simplified version of a <span class="code">Model</span> class. The class defines an inner class,<a id="i178325035-1"></a> <span class="code">Cell</span>, and a two-dimensional array, <span class="code">cells</span>, of <span class="code">Cell</span> elements. Each element is initialized to be a fresh <span class="code">Cell</span>.</p>
      <p><a id="lst-scells-Model1"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Model</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;{&nbsp;
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;cells&nbsp;=&nbsp;Array.ofDim[<code class="typename">Cell</code>](height,&nbsp;width)&nbsp;
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;height;&nbsp;j&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;width)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(i)(j)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cell</code>(i,&nbsp;j)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 35.4 - First version of the <span class="code">Model</span> class.</h5>
      <div class="figure">
        <a id="fig-scells2"></a>
        <p><img src="scells2Gray96.png" alt="images/scells2Gray96.png"></p>
      </div>
      <h5> Figure 35.2 - Cells displaying themselves.</h5>
      <p>That's it. If you compile the modified <span class="code">Spreadsheet</span> class with the <span class="code">Model</span> class and run the <span class="code">Main</span> application you should see a window as in <a href="#fig-scells2">Figure 35.2</a>.</p>
      <p>The objective of this section was to arrive at a design where the displayed value of a cell is different from the string that was entered into it. This objective has clearly been met, albeit in a very crude way. In the new spreadsheet you can enter anything you want into a cell, but it will always display just its coordinates once it loses focus. Clearly, we are not done yet.</p>
      <h3>35.3 Formulas</h3>
      <p>In reality, a spreadsheet cell holds two things: An actual <span style="font-style:italic">value</span> and a <span style="font-style:italic">formula</span> to compute this value. There are three types of formulas in a spreadsheet:</p>
      <ol>
        <li>Numeric values such as <span class="code">1.22</span>, <span class="code">-3</span>, or <span class="code">0</span>. </li>
        <li>Textual labels such as <span class="code">Annual</span>&nbsp;<span class="code">sales</span>, <span class="code">Deprecation</span>, or <span class="code">total</span>. </li>
        <li>Formulas that compute a new value from the contents of cells, such as "<span class="code">=add(A1,B2)</span>", or "<span class="code">=sum(mul(2,</span>&nbsp;<span class="code">A2),</span>&nbsp;<span class="code">C1:D16)</span>" </li>
      </ol>
      <p>A formula that computes a value always starts with an equals sign and is followed by an arithmetic expression. The <span class="code">SCells</span> spreadsheet has a particularly simple and uniform convention for arithmetic expressions: every expression is an application of some function to a list of arguments. The function name is an identifier such as <span class="code">add</span> for binary addition, or <span class="code">sum</span> for summation of an arbitrary number of operands. A function argument can be a number, a reference to a cell, a reference to a range of cells such as <span class="code">C1:D16</span>, or another function application. You'll see later that <span class="code">SCells</span> has an open architecture that makes it easy to install your own functions via mixin composition.</p>
      <p>The first step to handling formulas is writing down the types that represent them. As you might expect, the different kinds of formulas are represented by case classes. <a href="#lst-scells-Formulas">Listing 35.5</a> shows the contents of a file named <span class="code">Formulas.scala</span>, where these case classes are defined:<a id="i1927236622-1"></a></p>
      <p><a id="lst-scells-Formulas"></a></p> <pre>  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <br>  <code class="vem">trait</code>&nbsp;<code class="typename">Formula</code>&nbsp;&nbsp;
  <br>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Coord</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;(<code class="quotedstring">'A'</code>&nbsp;+&nbsp;column).toChar.toString&nbsp;+&nbsp;row
  }
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Range</code>(c1:&nbsp;<code class="typename">Coord</code>,&nbsp;c2:&nbsp;<code class="typename">Coord</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;c1.toString&nbsp;+&nbsp;<code class="quotedstring">":"</code>&nbsp;+&nbsp;c2.toString
  }
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Number</code>(value:&nbsp;<code class="typename">Double</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;value.toString&nbsp;
  }
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Textual</code>(value:&nbsp;<code class="typename">String</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{&nbsp;
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;value
  }
  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Application</code>(function:&nbsp;<code class="typename">String</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;arguments:&nbsp;<code class="typename">List[Formula]</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Formula</code>&nbsp;{&nbsp;
  <br>  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;+&nbsp;arguments.mkString(<code class="quotedstring">"("</code>,&nbsp;<code class="quotedstring">","</code>,&nbsp;<code class="quotedstring">")"</code>)
  }
  <code class="vem">object</code>&nbsp;<code class="typename">Empty</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Textual</code>(<code class="quotedstring">""</code>)
</pre>
      <h5>Listing 35.5 - Classes representing formulas.</h5>
      <p>Trait <span class="code">Formula</span>, shown in <a href="#lst-scells-Formulas">Listing 35.5</a>, has five case classes as children:</p>
      <table style="border-collapse: collapse">
        <tbody>
          <tr>
            <td> <span class="code">Coord</span> </td>
            <td> for cell coordinates such as <span class="code">A3</span>, </td>
          </tr>
          <tr>
            <td> <span class="code">Range</span> </td>
            <td> for cell ranges such as <span class="code">A3:B17</span>, </td>
          </tr>
          <tr>
            <td> <span class="code">Number</span> </td>
            <td> for floating-point numbers such as <span class="code">3.1415</span>, </td>
          </tr>
          <tr>
            <td> <span class="code">Textual</span> </td>
            <td> for textual labels such as <span class="code">Deprecation</span>, </td>
          </tr>
          <tr>
            <td> <span class="code">Application</span> </td>
            <td> for function applications such as <span class="code">sum(A1,A2)</span>. </td>
          </tr>
        </tbody>
      </table>
      <p>Each case class overrides the <span class="code">toString</span> method so that it displays its kind of formula in the standard way shown above. For convenience there's also an <span class="code">Empty</span> object that represents the contents of an empty cell. The <span class="code">Empty</span> object is an instance of the <span class="code">Textual</span> class with an empty string argument.</p>
      <h3>35.4 Parsing formulas</h3>
      <p>In the previous section you saw the different kinds of formulas and how they display as strings.<a id="i-2095840458-2"></a> In this section you'll see how to reverse the process: to transform a user input string into a <span class="code">Formula</span> tree. The rest of this section explains one by one the different elements of a class <span class="code">FormulaParsers</span>, which contains the parsers that do the transformation. The class builds on the combinator framework given in <a href="#chap-combinator-parsing">Chapter 33</a>. Specifically, formula parsers are an instance of the <span class="code">RegexParsers</span> class explained in that chapter:<a id="i519257659-3"></a></p> <pre>  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <code class="vem">import</code>&nbsp;scala.util.parsing.combinator._
  <br>  <code class="vem">object</code>&nbsp;<code class="typename">FormulaParsers</code>&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">RegexParsers</code>&nbsp;{&nbsp;
</pre>
      <p>The first two elements of object <span class="code">FormulaParsers</span> are auxiliary parsers for identifiers and decimal numbers:</p> <pre>  <code class="vem">def</code>&nbsp;ident:&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;<code class="quotedstring">"""[a-zA-Z_]\w*"""</code>.r
  <code class="vem">def</code>&nbsp;decimal:&nbsp;<code class="typename">Parser[String]</code>&nbsp;=&nbsp;<code class="quotedstring">"""-?\d+(\.\d*)?"""</code>.r
</pre>
      <p>As you can see from the first regular expression above, an identifier starts with a letter or underscore.<a id="i-2139156663-2"></a> This is followed by an arbitrary number of "word" characters represented by the regular expression code <span class="code">\w</span>, which recognizes letters, digits or underscores. The second regular expression describes decimal numbers, which consist of an optional minus sign, one or more digits that are represented by regular expression code <span class="code">\d</span>, and an optional decimal part consisting of a period followed by zero or more digits.</p>
      <p>The next element of object <span class="code">FormulaParsers</span> is the <span class="code">cell</span> parser, which recognizes the coordinates of a cell, such as <span class="code">C11</span> or <span class="code">B2</span>. It first calls a regular expression parser that determines the form of a coordinate: a single letter followed by one or more digits. The string returned from that parser is then converted to a cell coordinate by separating the letter from the numerical part and converting the two parts to indices for the cell's column and row:</p> <pre>  <code class="vem">def</code>&nbsp;cell:&nbsp;<code class="typename">Parser[Coord]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="quotedstring">"""[A-Za-z]\d+"""</code>.r&nbsp;^^&nbsp;{&nbsp;s&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;column&nbsp;=&nbsp;s.charAt(<code class="literal">0</code>).toUpper&nbsp;-&nbsp;<code class="quotedstring">'A'</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;row&nbsp;=&nbsp;s.substring(<code class="literal">1</code>).toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">Coord</code>(row,&nbsp;column)
  &nbsp;&nbsp;}
</pre>
      <p>Note that the <span class="code">cell</span> parser is a bit restrictive in that it allows only column coordinates consisting of a single letter. Hence the number of spreadsheet columns is in effect restricted to be at most 26, because further columns cannot be parsed. It's a good idea to generalize the parser so that it accepts cells with several leading letters. This is left as an exercise to you.</p>
      <p>The <span class="code">range</span> parser recognizes a range of cells. Such a range is composed of two cell coordinates with a colon between them:</p> <pre>  <code class="vem">def</code>&nbsp;range:&nbsp;<code class="typename">Parser[Range]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;cell<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>cell&nbsp;^^&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;c1<code style="font-size:large">~</code><code class="quotedstring">":"</code><code style="font-size:large">~</code>c2&nbsp;=&gt;&nbsp;<code class="typename">Range</code>(c1,&nbsp;c2)&nbsp;
  &nbsp;&nbsp;}
</pre>
      <p>The <span class="code">number</span> parser recognizes a decimal number, which is converted to a <span class="code">Double</span> and wrapped in an instance of the <span class="code">Number</span> class:</p> <pre>  <code class="vem">def</code>&nbsp;number:&nbsp;<code class="typename">Parser[Number]</code>&nbsp;=
  &nbsp;&nbsp;decimal&nbsp;^^&nbsp;(d&nbsp;=&gt;&nbsp;<code class="typename">Number</code>(d.toDouble))
</pre>
      <p>The <span class="code">application</span> parser recognizes a function application. Such an application is composed of an identifier followed by a list of argument expressions in parentheses:</p> <pre>  <code class="vem">def</code>&nbsp;application:&nbsp;<code class="typename">Parser[Application]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;ident<code style="font-size:large">~</code><code class="quotedstring">"("</code><code style="font-size:large">~</code>repsep(expr,&nbsp;<code class="quotedstring">","</code>)<code style="font-size:large">~</code><code class="quotedstring">")"</code>&nbsp;^^&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;f<code style="font-size:large">~</code><code class="quotedstring">"("</code><code style="font-size:large">~</code>ps<code style="font-size:large">~</code><code class="quotedstring">")"</code>&nbsp;=&gt;&nbsp;<code class="typename">Application</code>(f,&nbsp;ps)&nbsp;
  &nbsp;&nbsp;}
</pre>
      <p>The <span class="code">expr</span> parser recognizes a formula expression—either a top-level formula following an `<span class="code">=</span>', or an argument to a function. Such a formula expression is defined to be a cell, a range of cells, a number, or an application:</p> <pre>  <code class="vem">def</code>&nbsp;expr:&nbsp;<code class="typename">Parser[Formula]</code>&nbsp;=
  &nbsp;&nbsp;range&nbsp;|&nbsp;cell&nbsp;|&nbsp;number&nbsp;|&nbsp;application
</pre>
      <p>This definition of the <span class="code">expr</span> parser contains a slight oversimplification because ranges of cells should only appear as function arguments; they should not be allowed as top-level formulas. You could change the formula grammar so that the two uses of expressions are separated, and ranges are excluded syntactically from top-level formulas. In the spreadsheet presented here such an error is instead detected once an expression is evaluated.</p>
      <p>The <span class="code">textual</span> parser recognizes an arbitrary input string, as long as it does not start with an equals sign (recall that strings that start with `<span class="code">=</span>' are considered to be formulas):</p> <pre>  <code class="vem">def</code>&nbsp;textual:&nbsp;<code class="typename">Parser[Textual]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;<code class="quotedstring">"""[^=].*"""</code>.r&nbsp;^^&nbsp;<code class="typename">Textual</code>
</pre>
      <p>The <span class="code">formula</span> parser recognizes all kinds of legal inputs into a cell. A formula is either a <span class="code">number</span>, or a <span class="code">textual</span> entry, or a formula starting with an equals sign:</p> <pre>  <code class="vem">def</code>&nbsp;formula:&nbsp;<code class="typename">Parser[Formula]</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;number&nbsp;|&nbsp;textual&nbsp;|&nbsp;<code class="quotedstring">"="</code><code style="font-size:large">~</code>&gt;expr
</pre>
      <p>This concludes the grammar for spreadsheet cells. The final method <span class="code">parse</span> uses this grammar in a method that converts an input string into a <span class="code">Formula</span> tree:</p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;parse(input:&nbsp;<code class="typename">String</code>):&nbsp;<code class="typename">Formula</code>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;parseAll(formula,&nbsp;input)&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Success</code>(e,&nbsp;_)&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;f:&nbsp;<code class="typename">NoSuccess</code>&nbsp;=&gt;&nbsp;<code class="typename">Textual</code>(<code class="quotedstring">"["</code>&nbsp;+&nbsp;f.msg&nbsp;+&nbsp;<code class="quotedstring">"]"</code>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }&nbsp;<code class="comment">//end&nbsp;FormulaParsers</code>
</pre>
      <p>The <span class="code">parse</span> method parses all of the input with the <span class="code">formula</span> parser. If that succeeds, the resulting formula is returned. If it fails, a <span class="code">Textual</span> object with an error message is returned instead.</p>
      <p><a id="lst-spreadsheet-parses-formulas"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;swing._
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;event._
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;...&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;table&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Table</code>(height,&nbsp;width)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">TableUpdated</code>(table,&nbsp;rows,&nbsp;column)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;rows)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(row)(column).formula&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormulaParsers.parse(userData(row,&nbsp;column))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 35.6 - A spreadsheet that parses formulas.</h5>
      <p>That's everything there is to parsing formulas. The only thing that remains is to integrate the parser into the spreadsheet. To do this, you can enrich the <span class="code">Cell</span> class in class <span class="code">Model</span> by a <span class="code">formula</span> field:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;<code class="vem">var</code>&nbsp;formula:&nbsp;<code class="typename">Formula</code>&nbsp;=&nbsp;<code class="typename">Empty</code>
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;formula.toString
  }
</pre>
      <p>In the new version of the <span class="code">Cell</span> class, the <span class="code">toString</span> method is defined to display the cell's <span class="code">formula</span>. That way you can check whether formulas have been correctly parsed.</p>
      <p>The last step in this section is to integrate the parser into the spreadsheet. Parsing a formula happens as a reaction to the user's input into a cell. A completed cell input is modeled in the Swing library by a <span class="code">TableUpdated</span> event.<a id="i1392790829-1"></a> The <span class="code">TableUpdated</span> class is contained in package <span class="code">scala.swing.event</span>. The event is of the form:</p> <pre>  <code class="typename">TableUpdated</code>(table,&nbsp;rows,&nbsp;column)
</pre>
      <p>It contains the <span class="code">table</span> that was changed, as well as a set of coordinates of affected cells given by <span class="code">rows</span> and <span class="code">column</span>. The <span class="code">rows</span> parameter is a range value of type <span class="code">Range[Int]</span>.<a href="#footnotemain35-2">[2]</a> The <span class="code">column</span> parameter is an integer. So in general a <span class="code">TableUpdated</span> event can refer to several affected cells, but they would be on a consecutive range of rows and share the same column.</p>
      <div class="figure">
        <a id="fig-scells3"></a>
        <p><img src="scells3Gray96.png" alt="images/scells3Gray96.png"></p>
      </div>
      <h5> Figure 35.3 - Cells displaying their formulas.</h5>
      <p>Once a table is changed, the affected cells need to be re-parsed. To react to a <span class="code">TableUpdated</span> event, you add a case to the <span class="code">reactions</span> value of the <span class="code">table</span> component, as is shown in <a href="#lst-spreadsheet-parses-formulas">Listing 35.6</a>.<a id="i-1242645043-1"></a> Now, whenever the table is edited the formulas of all affected cells will be updated by parsing the corresponding user data. When compiling the classes discussed so far and launching the <span class="code">scells.Main</span> application you should see a spreadsheet application like the one shown in <a href="#fig-scells3">Figure 35.3</a>. You can edit cells by typing into them. After editing is done, a cell displays the formula it contains. You can also try to type some illegal input such as the one reading <span class="code">=add(1,</span>&nbsp;<span class="code">X)</span> in the field that has the editing focus in <a href="#fig-scells3">Figure 35.3</a>. Illegal input will show up as an error message. For instance, once you'd leave the edited field in <a href="#fig-scells3">Figure 35.3</a> you should see the error message <span class="code">[`('</span>&nbsp;<span class="code">expected]</span> in the cell (to see all of the error message you might need to widen the column by dragging the separation between the column headers to the right).</p>
      <h3>35.5 Evaluation</h3>
      <p>Of course, in the end a spreadsheet should evaluate formulas, not just display them. In this section, we'll add the necessary components to achieve this.</p>
      <p>What's needed is a method, <span class="code">evaluate</span>, which takes a formula and returns the value of that formula in the current spreadsheet, represented as a <span class="code">Double</span>. We'll place this method in a new trait, <span class="code">Evaluator</span>. The method needs to access the <span class="code">cells</span> field in class <span class="code">Model</span> to find out about the current values of cells that are referenced in a formula. On the other hand, the <span class="code">Model</span> class needs to call <span class="code">evaluate</span>. Hence, there's a mutual dependency between the <span class="code">Model</span> and the <span class="code">Evaluator</span>. A good way to express such mutual dependencies between classes was shown in <a href="#chap-modular-programming-using-objects">Chapter 29</a>: you use inheritance in one direction and self types in the other.<a id="i1009253694-1"></a><a id="i1609470629-1"></a><a id="i-560124499-2"></a></p>
      <p>In the spreadsheet example, class <span class="code">Model</span> inherits from <span class="code">Evaluator</span> and thus gains access to its <span class="code">evaluation</span> method. To go the other way, class <span class="code">Evaluator</span> defines its self type to be <span class="code">Model</span>, like this:</p> <pre>  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <code class="vem">trait</code>&nbsp;<code class="typename">Evaluator</code>&nbsp;{&nbsp;<code class="vem">this</code>:&nbsp;<code class="typename">Model</code>&nbsp;=&gt;&nbsp;...
</pre>
      <p>That way, the <span class="code">this</span> value inside class <span class="code">Evaluator</span> is assumed to be <span class="code">Model</span> and the <span class="code">cells</span> array is accessible by writing either <span class="code">cells</span> or <span class="code">this.cells</span>.</p>
      <p>Now that the wiring is done, we'll concentrate on defining the contents of class <span class="code">Evaluator</span>. <a href="#lst-evaluate-method">Listing 35.7</a> shows the implementation of the <span class="code">evaluate</span> method. As you might expect, the method contains a pattern match over the different types of formulas.<a id="i1154860961-2"></a> For a coordinate <span class="code">Coord(row,</span>&nbsp;<span class="code">column)</span>, it returns the value of the <span class="code">cells</span> array at that coordinate. For a number <span class="code">Number(v)</span>, it returns the value <span class="code">v</span>. For a textual label <span class="code">Textual(s)</span>, it returns zero. Finally, for an application <span class="code">Application(function,</span>&nbsp;<span class="code">arguments)</span>, it computes the values of all arguments, retrieves a function object corresponding to the <span class="code">function</span> name from an <span class="code">operations</span> table and applies that function to all argument values. <a id="lst-evaluate-method"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;evaluate(e:&nbsp;<code class="typename">Formula</code>):&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;<code class="vem">try</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Coord</code>(row,&nbsp;column)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(row)(column).value
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Number</code>(v)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Textual</code>(_)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">0</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Application</code>(function,&nbsp;arguments)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;argvals&nbsp;=&nbsp;arguments&nbsp;flatMap&nbsp;evalList
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operations(function)(argvals)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}&nbsp;<code class="vem">catch</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;ex:&nbsp;<code class="typename">Exception</code>&nbsp;=&gt;&nbsp;<code class="typename">Double.NaN</code>
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 35.7 - The <span class="code">evaluate</span> method of trait <span class="code">Evaluator</span>.</h5>
      <p>The <span class="code">operations</span> table maps function names to function objects. It is defined as follows:</p> <pre>  <code class="vem">type</code>&nbsp;<code class="typename">Op</code>&nbsp;=&nbsp;<code class="typename">List[Double]</code>&nbsp;=&gt;&nbsp;<code class="typename">Double</code>
  <code class="vem">val</code>&nbsp;operations&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">collection.mutable.HashMap[String,&nbsp;Op]</code>
</pre>
      <p>As you can see from this definition, operations are modeled as functions from lists of values to values. The <span class="code">Op</span> type introduces a convenient alias for the type of an operation.</p>
      <p>The computation in <span class="code">evaluate</span> is wrapped in a try-catch to guard against input errors. There are actually quite a few things that can go wrong when evaluating a cell formula: coordinates might be out of range; function names might be undefined; functions might have the wrong number of arguments; arithmetic operations might be illegal or overflow. The reaction to any of these errors is the same: a "not-a-number" value is returned. The returned value, <span class="code">Double.NaN</span>, is the IEEE representation for a computation that does not have a representable floating-point value.<a id="i995050225-1"></a> This might happen because of an overflow or a division by zero, for example. The <span class="code">evaluate</span> method of <a href="#lst-evaluate-method">Listing 35.7</a> chooses to return the same value also for all other kinds of errors. The advantage of this scheme is that it's simple to understand and doesn't require much code to implement. Its disadvantage is that all kinds of errors are lumped together, so a spreadsheet user does not get any detailed feedback on what went wrong. If you wish you can experiment with more refined ways of representing errors in the <span class="code">SCells</span> application.</p>
      <p>The evaluation of arguments is different from the evaluation of top-level formulas. Arguments may be lists whereas top-level functions may not. For instance, the argument expression <span class="code">A1:A3</span> in <span class="code">sum(A1:A3)</span> returns the values of cells <span class="code">A1</span>, <span class="code">A2</span>, <span class="code">A3</span> in a list. This list is then passed to the <span class="code">sum</span> operation. It's also possible to mix lists and single values in argument expressions, for instance the operation <span class="code">sum(A1:A3,</span>&nbsp;<span class="code">1.0,</span>&nbsp;<span class="code">C7)</span>, which would sum up five values. To handle arguments that might evaluate to lists, there's another evaluation function, called <span class="code">evalList</span>, which takes a formula and returns a list of values:</p> <pre>  <code class="vem">private</code>&nbsp;<code class="vem">def</code>&nbsp;evalList(e:&nbsp;<code class="typename">Formula</code>):&nbsp;<code class="typename">List[Double]</code>&nbsp;=&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Range</code>(_,&nbsp;_)&nbsp;=&gt;&nbsp;references(e)&nbsp;map&nbsp;(_.value)
  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;<code class="typename">List</code>(evaluate(e))
  }
</pre>
      <p>If the formula argument passed to <span class="code">evalList</span> is a <span class="code">Range</span>, the returned value is a list consisting of the values of all cells referenced by the range. For every other formula the result is a list consisting of the single result value of that formula. The cells referenced by a formula are computed by a third function, <span class="code">references</span>. Here is its definition:</p> <pre>  &nbsp;&nbsp;<code class="vem">def</code>&nbsp;references(e:&nbsp;<code class="typename">Formula</code>):&nbsp;<code class="typename">List[Cell]</code>&nbsp;=&nbsp;e&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Coord</code>(row,&nbsp;column)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>(cells(row)(column))
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Range</code>(<code class="typename">Coord</code>(r1,&nbsp;c1),&nbsp;<code class="typename">Coord</code>(r2,&nbsp;c2))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;(r1&nbsp;to&nbsp;r2).toList;&nbsp;column&nbsp;&lt;-&nbsp;c1&nbsp;to&nbsp;c2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">yield</code>&nbsp;cells(row)(column)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Application</code>(function,&nbsp;arguments)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments&nbsp;flatMap&nbsp;references
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="typename">List</code>()
  &nbsp;&nbsp;}
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;Evaluator</code>
</pre>
      <p>The <span class="code">references</span> method is actually more general than needed right now in that it computes the list of cells referenced by any sort of formula, not just a <span class="code">Range</span> formula. It will turn out later that the added functionality is needed to compute the sets of cells that need updating. The body of the method is a straightforward pattern match on kinds of formulas. For a coordinate <span class="code">Coord(row,</span>&nbsp;<span class="code">column)</span>, it returns a single-element list containing the cell at that coordinate. For a range expression <span class="code">Range(coord1,</span>&nbsp;<span class="code">coord2)</span>, it returns all cells between the two coordinates, computed by a <span class="code">for</span> expression. For a function application <span class="code">Application(function,</span>&nbsp;<span class="code">arguments)</span>, it returns the cells referenced by each argument expression, concatenated via <span class="code">flatMap</span> into a single list. For the other two types of formulas, <span class="code">Textual</span> and <span class="code">Number</span>, it returns an empty list.</p>
      <h3>35.6 Operation libraries</h3>
      <p>The class <span class="code">Evaluator</span> itself defines no operations that can be performed on cells: its <span class="code">operations</span> table is initially empty. The idea is to define such operations in other traits, which are then mixed into the <span class="code">Model</span> class.<a id="i464307868-1"></a> <a href="#lst-scells-Arithmetic">Listing 35.8</a> shows an example trait that implements common arithmetic operations:</p>
      <p><a id="lst-scells-Arithmetic"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">trait</code>&nbsp;<code class="typename">Arithmetic</code>&nbsp;{&nbsp;<code class="vem">this</code>:&nbsp;<code class="typename">Evaluator</code>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;operations&nbsp;++=&nbsp;<code class="typename">List</code>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"add"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"sub"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;-&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"div"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;/&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"mul"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"mod"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;<code class="texttt">%</code>&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"sum"</code>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;xs&nbsp;=&gt;&nbsp;xs.foldLeft(<code class="literal">0.0</code>)(_&nbsp;+&nbsp;_)&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="quotedstring">"prod"</code>&nbsp;-&gt;&nbsp;{&nbsp;xs&nbsp;=&gt;&nbsp;xs.foldLeft(<code class="literal">1.0</code>)(_&nbsp;*&nbsp;_)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre>
      <h5>Listing 35.8 - A library for arithmetic operations.</h5>
      <p>Interestingly, this trait has no exported members. The only thing it does is populate the <span class="code">operations</span> table during its initialization. It gets access to that table by using a self type <span class="code">Evaluator</span>, <i>i.e.</i>, by the same technique the <span class="code">Arithmetic</span> class uses to get access to the model.<a id="i1609470629-2"></a><a id="i-560124499-3"></a></p>
      <p>Of the seven operations that are defined by the <span class="code">Arithmetic</span> trait, five are binary operations and two take an arbitrary number of arguments. The binary operations all follow the same schema. For instance, the addition operation <span class="code">add</span> is defined by the expression:</p> <pre>  {&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">List</code>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y&nbsp;}
</pre>
      <p>That is, it expects an argument list consisting of two elements <span class="code">x</span> and <span class="code">y</span> and returns the sum of <span class="code">x</span> and <span class="code">y</span>. If the argument list contains a number of elements different from two, a <span class="code">MatchError</span> is thrown. This corresponds to the general "let it crash" philosophy of <span class="code">SCell</span>'s evaluation model, where incorrect input is expected to lead to a runtime exception that then gets caught by the try-catch inside the <span class="code">evaluation</span> method.</p>
      <p>The last two operations, <span class="code">sum</span> and <span class="code">prod</span>, take a list of arguments of arbitrary length and insert a binary operation between successive elements. So they are instances of the "fold left" schema that's expressed in class <span class="code">List</span> by the <span class="code">/:</span> operation. For instance, to <span class="code">sum</span> a list of numbers <span class="code">List(x,</span>&nbsp;<span class="code">y,</span>&nbsp;<span class="code">z)</span>, the operation computes <span class="code">0</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">z</span>. The first operand, <span class="code">0</span>, is the result if the list is empty.</p>
      <p>You can integrate this operation library into the spreadsheet application by mixing the <span class="code">Arithmetic</span> trait into the <span class="code">Model</span> class, like this:</p> <pre>  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">Model</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Evaluator</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Arithmetic</code>&nbsp;{&nbsp;
  <br>  &nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">var</code>&nbsp;formula:&nbsp;<code class="typename">Formula</code>&nbsp;=&nbsp;<code class="typename">Empty</code>
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;value&nbsp;=&nbsp;evaluate(formula)
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;formula&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Textual</code>(s)&nbsp;=&gt;&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;value.toString
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;rest&nbsp;as&nbsp;before</code>
  }
</pre>
      <p>Another change in the <span class="code">Model</span> class concerns the way cells display themselves. In the new version, the displayed value of a cell depends on its formula. If the formula is a <span class="code">Textual</span> field, the contents of the field are displayed literally. In all other cases, the formula is evaluated and the result <span class="code">value</span> of that evaluation is displayed.</p>
      <div class="figure">
        <a id="fig-scells4"></a>
        <p><img src="scells4Gray96.png" alt="images/scells4Gray96.png"></p>
      </div>
      <h5> Figure 35.4 - Cells that evaluate.</h5>
      <p>If you compile the changed traits and classes and relaunch the <span class="code">Main</span> program you get something that starts to resemble a real spreadsheet. <a href="#fig-scells4">Figure 35.4</a> shows an example. You can enter formulas into cells and get them to evaluate themselves. For instance, once you close the editing focus on cell <span class="code">C5</span> in <a href="#fig-scells4">Figure 35.4</a>, you should see <span class="code">86.0</span>, the result of evaluating the formula <span class="code">sum(C1:C4)</span>.</p>
      <p>However, there's a crucial element still missing. If you change the value of cell <span class="code">C1</span> in <a href="#fig-scells4">Figure 35.4</a> from 20 to 100, the sum in cell <span class="code">C5</span> will not be automatically updated to 166. You'll have to click on <span class="code">C5</span> manually to see a change in its value. What's still missing is a way to have cells recompute their values automatically after a change.</p>
      <h3>35.7 Change propagation</h3>
      <p>If a cell's value has changed, all cells that depend on that value should have their results recomputed and redisplayed. The simplest way to achieve this would be to recompute the value of every cell in the spreadsheet after each change. However such an approach does not scale well as the spreadsheet grows in size.</p>
      <p>A better approach is to recompute the values of only those cells that refer to a changed cell in their formula. The idea is to use an event-based publish/subscribe framework for change propagation: once a cell gets assigned a formula, it will subscribe to be notified of all value changes in cells to which the formula refers. A value change in one of these cells will trigger a re-evaluation of the subscriber cell. If such a re-evaluation causes a change in the value of the cell, it will in turn notify all cells that depend on it. The process continues until all cell values have stabilized, <i>i.e.</i>, there are no more changes in the values of any cell.<a href="#footnotemain35-3">[3]</a></p>
      <p>The publish/subscribe framework is implemented in class <span class="code">Model</span> using the standard event mechanism of Scala's Swing framework. Here's a new (and final) version of this class:</p> <pre>  <code class="vem">package</code>&nbsp;org.stairwaybook.scells
  <code class="vem">import</code>&nbsp;swing._
  <br>  <code class="vem">class</code>&nbsp;<code class="typename">Model</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  <code class="vem">extends</code>&nbsp;<code class="typename">Evaluator</code>&nbsp;<code class="vem">with</code>&nbsp;<code class="typename">Arithmetic</code>&nbsp;{&nbsp;
</pre>
      <p>Compared to the previous version of <span class="code">Model</span>, this version adds a new import of <span class="code">swing._</span>, which makes Swing's event abstractions directly available.<a id="i1245010859-2"></a></p>
      <p>The main modifications of class <span class="code">Model</span> concern the nested class <span class="code">Cell</span>. Class <span class="code">Cell</span> now inherits from <span class="code">Publisher</span>, so that it can publish events.<a id="i-843595300-1"></a> The event-handling logic is completely contained in the setters of two properties: <span class="code">value</span> and <span class="code">formula</span>. Here is <span class="code">Cell</span>'s new version:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Cell</code>(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">Publisher</code>&nbsp;{
  &nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;toString&nbsp;=&nbsp;formula&nbsp;<code class="vem">match</code>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">Textual</code>(s)&nbsp;=&gt;&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;_&nbsp;=&gt;&nbsp;value.toString
  &nbsp;&nbsp;}
</pre>
      <p>To the outside, it looks like <span class="code">value</span> and <span class="code">formula</span> are two variables in class <span class="code">Cell</span>. Their actual implementation is in terms of two private fields that are equipped with public getters, <span class="code">value</span> and <span class="code">formula</span>, and setters, <span class="code">value_=</span> and <span class="code">formula_=</span>. Here are the definitions implementing the <span class="code">value</span> property:</p> <pre>  <code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;v:&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;<code class="literal">0</code>
  <code class="vem">def</code>&nbsp;value:&nbsp;<code class="typename">Double</code>&nbsp;=&nbsp;v
  <code class="vem">def</code>&nbsp;value_=(w:&nbsp;<code class="typename">Double</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">if</code>&nbsp;(!(v&nbsp;==&nbsp;w&nbsp;||&nbsp;v.isNaN&nbsp;&amp;&amp;&nbsp;w.isNaN))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;w
  &nbsp;&nbsp;&nbsp;&nbsp;publish(<code class="typename">ValueChanged</code>(<code class="vem">this</code>))
  &nbsp;&nbsp;}
  }
</pre>
      <p>The <span class="code">value_=</span> setter assigns a new value <span class="code">w</span> to the private field <span class="code">v</span>. If the new value is different from the old one, it also publishes a <span class="code">ValueChanged</span> event with the cell itself as argument.<a id="i1571974179-1"></a> Note that the test whether the value has changed is a bit tricky because it involves the value <span class="code">NaN</span>.<a id="i995050225-2"></a> The Java spec says that <span class="code">NaN</span> is different from every other value, including itself! Therefore, a test whether two values are the same has to treat <span class="code">NaN</span> specially: two values <span class="code">v</span>, <span class="code">w</span> are the same if they are equal with respect to <span class="code">==</span>, or they are both the value <span class="code">NaN</span>, <i>i.e.</i>, <span class="code">v.isNaN</span> and <span class="code">w.isNaN</span> both yield <span class="code">true</span>.</p>
      <p>Whereas the <span class="code">value_=</span> setter does the publishing in the publish/subscribe framework, the <span class="code">formula_=</span> setter does the subscribing:</p> <pre>  <code class="vem">private</code>&nbsp;<code class="vem">var</code>&nbsp;f:&nbsp;<code class="typename">Formula</code>&nbsp;=&nbsp;<code class="typename">Empty</code>
  <code class="vem">def</code>&nbsp;formula:&nbsp;<code class="typename">Formula</code>&nbsp;=&nbsp;f
  <code class="vem">def</code>&nbsp;formula_=(f:&nbsp;<code class="typename">Formula</code>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(c&nbsp;&lt;-&nbsp;references(formula))&nbsp;deafTo(c)
  &nbsp;&nbsp;<code class="vem">this</code>.f&nbsp;=&nbsp;f
  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(c&nbsp;&lt;-&nbsp;references(formula))&nbsp;listenTo(c)
  &nbsp;&nbsp;value&nbsp;=&nbsp;evaluate(f)
  }
</pre>
      <p>If a cell is assigned a new formula, it first unsubscribes with <span class="code">deafTo</span> from all cells referenced by the previous <span class="code">formula</span> value. It then stores the new formula in the private variable <span class="code">f</span> and subscribes with <span class="code">listenTo</span> to all cells referenced by it.<a id="i-2118281873-2"></a> Finally, it recomputes its <span class="code">value</span> using the new formula.</p>
      <p>The last piece of code in the revised class <span class="code">Cell</span> specifies how to react to a <span class="code">ValueChanged</span> event:</p> <pre>  &nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">ValueChanged</code>(_)&nbsp;=&gt;&nbsp;value&nbsp;=&nbsp;evaluate(formula)
  &nbsp;&nbsp;}
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;class&nbsp;Cell</code>
</pre>
      <p>The <span class="code">ValueChanged</span> class is also contained in class <span class="code">Model</span>:</p> <pre>  <code class="vem">case</code>&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">ValueChanged</code>(cell:&nbsp;<code class="typename">Cell</code>)&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">event.Event</code>
</pre>
      <p>The rest of class <span class="code">Model</span> is as before:</p> <pre>  &nbsp;&nbsp;<code class="vem">val</code>&nbsp;cells&nbsp;=&nbsp;Array.ofDim[<code class="typename">Cell</code>](height,&nbsp;width)&nbsp;
  <br>  &nbsp;&nbsp;<code class="vem">for</code>&nbsp;(i&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;height;&nbsp;j&nbsp;&lt;-&nbsp;<code class="literal">0</code>&nbsp;until&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;cells(i)(j)&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Cell</code>(i,&nbsp;j)
  }&nbsp;<code class="comment">//&nbsp;end&nbsp;class&nbsp;Model</code>
</pre>
      <p><a id="lst-scells-Spreadsheet3"></a></p> <pre>  &nbsp;&nbsp;<code class="vem">package</code>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<code class="vem">import</code>&nbsp;swing._,&nbsp;event._
  <br>  &nbsp;&nbsp;<code class="vem">class</code>&nbsp;<code class="typename">Spreadsheet</code>(<code class="vem">val</code>&nbsp;height:&nbsp;<code class="typename">Int</code>,&nbsp;<code class="vem">val</code>&nbsp;width:&nbsp;<code class="typename">Int</code>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">extends</code>&nbsp;<code class="typename">ScrollPane</code>&nbsp;{
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;cellModel&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Model</code>(height,&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">import</code>&nbsp;cellModel._
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;table&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">Table</code>(height,&nbsp;width)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;settings&nbsp;as&nbsp;in&nbsp;<a href="#lst-scells-Spreadsheet1">Listing ???</a></code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">override</code>&nbsp;<code class="vem">def</code>&nbsp;rendererComponent(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSelected:&nbsp;<code class="typename">Boolean</code>,&nbsp;hasFocus:&nbsp;<code class="typename">Boolean</code>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;as&nbsp;in&nbsp;<a href="#lst-scells-Spreadsheet2">Listing ???</a></code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">def</code>&nbsp;userData(row:&nbsp;<code class="typename">Int</code>,&nbsp;column:&nbsp;<code class="typename">Int</code>):&nbsp;<code class="typename">String</code>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<code class="comment">//&nbsp;as&nbsp;in&nbsp;<a href="#lst-scells-Spreadsheet2">Listing ???</a></code>
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">TableUpdated</code>(table,&nbsp;rows,&nbsp;column)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;rows)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(row)(column).formula&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormulaParsers.parse(userData(row,&nbsp;column))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">case</code>&nbsp;<code class="typename">ValueChanged</code>(cell)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateCell(cell.row,&nbsp;cell.column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">for</code>&nbsp;(row&nbsp;&lt;-&nbsp;cells;&nbsp;cell&nbsp;&lt;-&nbsp;row)&nbsp;listenTo(cell)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;<code class="vem">val</code>&nbsp;rowHeader&nbsp;=&nbsp;<code class="vem">new</code>&nbsp;<code class="typename">ListView</code>(<code class="literal">0</code>&nbsp;until&nbsp;height)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellWidth&nbsp;=&nbsp;<code class="literal">30</code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellHeight&nbsp;=&nbsp;table.rowHeight
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <br>  &nbsp;&nbsp;&nbsp;&nbsp;viewportView&nbsp;=&nbsp;table
  &nbsp;&nbsp;&nbsp;&nbsp;rowHeaderView&nbsp;=&nbsp;rowHeader
  &nbsp;&nbsp;}</pre>
      <h5>Listing 35.9 - The finished spreadsheet component.</h5>
      <p>The spreadsheet code is now almost complete. The final piece missing is the re-display of modified cells. So far, all value propagation concerned the internal <span class="code">Cell</span> values only; the visible table was not affected. One way to change this would be to add a redraw command to the <span class="code">value_=</span> setter. However, this would undermine the strict separation between model and view that you have seen so far. A more modular solution is to notify the table of all <span class="code">ValueChanged</span> events and let it do the redrawing itself. <a href="#lst-scells-Spreadsheet3">Listing 35.9</a> shows the final spreadsheet component, which implements this scheme.</p>
      <p>Class <span class="code">Spreadsheet</span> of <a href="#lst-scells-Spreadsheet3">Listing 35.9</a> has only two new revisions. First, the <span class="code">table</span> component now subscribes with <span class="code">listenTo</span> to all cells in the model. Second, there's a new case in the table's reactions: if it is notified of a <span class="code">ValueChanged(cell)</span> event, it demands a redraw of the corresponding cell with a call of <span class="code">updateCell(cell.row,</span>&nbsp;<span class="code">cell.column)</span>.</p>
      <h3>35.8 Conclusion</h3>
      <p>The spreadsheet developed in this chapter is fully functional, even though at some points it adopts the simplest solution to implement rather than the most convenient one for the user. That way, it could be written in just under 200 lines of code. Nevertheless, the architecture of the spreadsheet makes modifications and extensions easy. In case you would like to experiment with the code a bit further, here are some suggestions of what you could change or add:</p>
      <ol>
        <li> You could make the spreadsheet resizable, so that the number of rows and columns can be changed interactively. </li>
        <li> You could add new kinds of formulas, for instance binary operations, or other functions. </li>
        <li> You might think about what to do when cells refer recursively to themselves. For instance, if cell <span class="code">A1</span> holds the formula <span class="code">add(B1,</span>&nbsp;<span class="code">1)</span> and cell <span class="code">B1</span> holds the formula <span class="code">mul(A1,</span>&nbsp;<span class="code">2)</span>, a re-evaluation of either cell will trigger a stack-overflow. Clearly, that's not a very good solution. As alternatives, you could either disallow such a situation, or just compute one iteration each time one of the cells is touched. </li>
        <li> You could enhance error handling, giving more detailed messages describing what went wrong. </li>
        <li> You could add a formula entry field at the top of the spreadsheet, so that long formulas could be entered more conveniently. </li>
      </ol>
      <p>At the beginning of this book we stressed the scalability aspect of Scala.<a id="i-885663216-3"></a><a id="i-2079231610-1"></a> We claimed that the combination of Scala's object-oriented and functional constructs makes it suitable for programs ranging from small scripts to very large systems. The spreadsheet presented here is clearly still a small system, even though it would probably take up much more than 200 lines in most other languages. Nevertheless, you can see many of the details that make Scala scalable at play in this application.</p>
      <p>The spreadsheet uses Scala's classes and traits with their mixin composition to combine its components in flexible ways.<a id="i1953973959-1"></a> Recursive dependencies between components are expressed using self types. The need for static state is completely eliminated—the only top-level components that are not classes are formula trees and formula parsers, and both of these are purely functional. The application also uses higher-order functions and pattern matching extensively, both for accessing formulas and for event handling. So it is a good showcase of how functional and object-oriented programming can be combined smoothly.</p>
      <p>One important reason why the spreadsheet application is so concise is that it can base itself on powerful libraries. The parser combinator library provides in effect an internal domain-specific language for writing parsers.<a id="i-218658218-1"></a><a id="i-640692980-1"></a> Without it, parsing formulas would have been much more difficult. The event handling in Scala's Swing libraries is a good example of the power of control abstractions. If you know Java's Swing libraries, you probably appreciate the conciseness of Scala's reactions concept, particularly when compared to the tedium of writing notify methods and implementing listener interfaces in the classical publish/subscribe design pattern.<a id="i851179987-1"></a> So the spreadsheet demonstrates the benefits of extensibility, where high-level libraries can be made to look just like language extensions.</p>
      <hr>
      <h4>Footnotes for Chapter 35:</h4>
      <p><a id="footnotemain35-1"></a>[1] Although "<span class="code">this(row,</span>&nbsp;<span class="code">column)</span>" may look similar to a constructor invocation, it is in this case an invocation of the <span class="code">apply</span> method on the current <span class="code">Table</span> instance.</p>
      <p><a id="footnotemain35-2"></a>[2] <span class="code">Range[Int]</span> is also the type of a Scala expression such as "<span class="code">1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">N</span>".</p>
      <p><a id="footnotemain35-3"></a>[3] This assumes that there are no cyclic dependencies between cells. We discuss dropping this assumption at the end of this chapter.</p>
    </div>
    <div class="h annotator-wrapper">
      <h2><a id="appen-scala-scripts-on-unix-and-windows">Appendix A</a></h2>
      <h1>Scala Scripts on Unix and Windows</h1>
      <p>If you're on some flavor of Unix, you can run a Scala script as a shell script by prepending a "pound bang" directive at the top of the file.<a id="i345477272-1"></a> For example, type the following into a file named <span class="code">helloarg</span>:</p> <pre>  #!/bin/sh
  exec&nbsp;scala&nbsp;"$0"&nbsp;"$@"
  !#
  //&nbsp;Say&nbsp;hello&nbsp;to&nbsp;the&nbsp;first&nbsp;argument
  println("Hello,&nbsp;"&nbsp;+&nbsp;args(0)&nbsp;+&nbsp;"!")
</pre>
      <p>The initial <span class="code">#!/bin/sh</span> must be the very first line in the file. Once you set its execute permission:</p> <pre>  $&nbsp;chmod&nbsp;+x&nbsp;helloarg
</pre>
      <p>You can run the Scala script as a shell script by simply saying:</p> <pre>  $&nbsp;./helloarg&nbsp;globe
</pre>
      <p>If you're on Windows,<a id="i-1287204493-1"></a> you can achieve the same effect by naming the file <span class="code">helloarg.bat</span> and placing this at the top of your script:</p> <pre>  ::#!
  @echo&nbsp;off
  call&nbsp;scala&nbsp;<code class="texttt">%</code>0&nbsp;<code class="texttt">%</code>*
  goto&nbsp;:eof
  ::!#
</pre>
    </div>
    <div class="h annotator-wrapper cover">
      <h1><a id="glossaryanchor">Glossary</a></h1>
      <div id="glossary">
        <p> <a id="g-725411438"></a><span class="glossaryname">algebraic data type</span>&nbsp;&nbsp; A type defined by providing several alternatives, each of which comes with its own constructor. It usually comes with a way to decompose the type through pattern matching. The concept is found in specification languages and functional programming languages. Algebraic data types can be emulated in Scala with case classes. </p>
        <p> <a id="g-196794451"></a><span class="glossaryname">alternative</span>&nbsp;&nbsp; A branch of a <span class="code">match</span> expression. It has the form "<span class="code">case</span> <em>pattern</em> <span class="code">=&gt;</span> <em>expression</em>." Another name for alternative is <em>case</em>.<a id="i1197489584-1"></a> </p>
        <p> <a id="g-1555043537"></a><span class="glossaryname">annotation</span>&nbsp;&nbsp; An <em>annotation</em> appears in source code and is attached to some part of the syntax. Annotations are computer processable, so you can use them to effectively add an extension to Scala. </p>
        <p> <a id="g-113939451"></a><span class="glossaryname">anonymous class</span>&nbsp;&nbsp;An anonymous class is a synthetic subclass generated by the Scala compiler from a <span class="code">new</span> expression in which the class or trait name is followed by curly braces. The curly braces contains the body of the anonymous subclass, which may be empty. However, if the name following <span class="code">new</span> refers to a trait or class that contains abstract members, these must be made concrete inside the curly braces that define the body of the anonymous subclass. </p>
        <p> <a id="g-657421781"></a><span class="glossaryname">anonymous function</span>&nbsp;&nbsp;Another name for function literal. </p>
        <p> <a id="g93029230"></a><span class="glossaryname">apply</span>&nbsp;&nbsp; You can <em>apply</em> a method, function, or closure <em>to</em> arguments, which means you invoke it on those arguments. </p>
        <p> <a id="g-1589682499"></a><span class="glossaryname">argument</span>&nbsp;&nbsp; When a function is invoked, an <em>argument</em> is passed for each parameter of that function. The parameter is the variable that refers to the argument. The argument is the object passed at invocation time. In addition, applications can take (command line) arguments that show up in the <span class="code">Array[String]</span> passed to <span class="code">main</span> methods of singleton objects. </p>
        <p> <a id="g-1408204561"></a><span class="glossaryname">assign</span>&nbsp;&nbsp; You can <em>assign</em> an object <em>to</em> a variable. Afterwards, the variable will refer to the object. </p>
        <p> <a id="g729406368"></a><span class="glossaryname">auxiliary constructor</span>&nbsp;&nbsp;Extra constructors defined inside the curly braces of the class definition, which look like method definitions named <span class="code">this</span>, but with no result type. </p>
        <p> <a id="g93832333"></a><span class="glossaryname">block</span>&nbsp;&nbsp; One or more expressions and declarations<a id="i824842378-1"></a> surrounded by curly braces. When the block evaluates, all of its expressions and declarations are processed in order, and then the block returns the value of the last expression as its own value. Blocks are commonly used as the bodies of functions, <span class="code">for</span> expressions, <span class="code">while</span> loops, and any other place where you want to group a number of statements together. More formally, a block is an encapsulation construct for which you can only see side effects and a result value. The curly braces in which you define a class or object do not, therefore, form a block, because fields and methods (which are defined inside those curly braces) are visible from the outside. Such curly braces form a <em>template</em>. </p>
        <p> <a id="g183453406"></a><span class="glossaryname">bound variable</span>&nbsp;&nbsp; A <em>bound variable</em> of an expression is a variable that's both used and defined inside the expression. For instance, in the function literal expression <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">(x,</span>&nbsp;<span class="code">y)</span>, both variables <span class="code">x</span> and <span class="code">y</span> are used, but only <span class="code">x</span> is bound, because it is defined in the expression as an <span class="code">Int</span> and the sole argument to the function described by the expression. </p>
        <p> <a id="g-1173919606"></a><span class="glossaryname">by-name parameter</span>&nbsp;&nbsp; A parameter that is marked with a <span class="code">=&gt;</span> in front of the parameter type, <i>e.g.</i>, <span class="code">(x:</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Int)</span>. The argument corresponding to a by-name parameter is evaluated not before the method is invoked, but each time the parameter is referenced <em>by name</em> inside the method. If a parameter is not by-name, it is <em>by-value</em>. </p>
        <p> <a id="g-430862780"></a><span class="glossaryname">by-value parameter</span>&nbsp;&nbsp; A parameter that is <em>not</em> marked with a <span class="code">=&gt;</span> in front of the parameter type, <i>e.g.</i>, <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>. The argument corresponding to a by-value parameter is evaluated before the method is invoked. By-value parameters contrast with <em>by-name</em> parameters. </p>
        <p> <a id="g94742904"></a><span class="glossaryname">class</span>&nbsp;&nbsp; Defined with the <span class="code">class</span> keyword, a <em>class</em> may either be abstract or concrete, and may be parameterized with types and values when instantiated. In "<span class="code">new</span>&nbsp;<span class="code">Array[String](2)</span>", the class being instantiated is <span class="code">Array</span> and the type of the value that results is <span class="code">Array[String]</span>. A class that takes type parameters is called a <em>type constructor</em>. A type can be said to have a class as well, as in: the class of type <span class="code">Array[String]</span> is <span class="code">Array</span>. </p>
        <p> <a id="g866552379"></a><span class="glossaryname">closure</span>&nbsp;&nbsp; A function object that captures free variables, and is said to be "closed" over the variables visible at the time it is created. </p>
        <p> <a id="g-828430492"></a><span class="glossaryname">companion class</span>&nbsp;&nbsp;A class that shares the same name with a singleton object defined in the same source file. The class is the singleton object's companion class. </p>
        <p> <a id="g423027411"></a><span class="glossaryname">companion object</span>&nbsp;&nbsp;A singleton object that shares the same name with a class defined in the same source file. Companion objects and classes have access to each other's private members. In addition, any implicit conversions defined in the companion object will be in scope anywhere the class is used. </p>
        <p> <a id="g-1356412796"></a><span class="glossaryname">contravariant</span>&nbsp;&nbsp; A <em>contravariant</em> annotation can be applied to a type parameter of a class or trait by putting a minus sign (<span class="code">-</span>) before the type parameter. The class or trait then subtypes contravariantly with—in the opposite direction as—the type annotated parameter. For example, <span class="code">Function1</span> is contravariant in its first type parameter, and so <span class="code">Function1[Any,</span>&nbsp;<span class="code">Any]</span> is a subtype of <span class="code">Function1[String,</span>&nbsp;<span class="code">Any]</span>. </p>
        <p> <a id="g1865839257"></a><span class="glossaryname">covariant</span>&nbsp;&nbsp; A <em>covariant</em> annotation can be applied to a type parameter of a class or trait by putting a plus sign (<span class="code">+</span>) before the type parameter. The class or trait then subtypes covariantly with—in the same direction as—the type annotated parameter. For example, <span class="code">List</span> is covariant in its type parameter, so <span class="code">List[String]</span> is a subtype of <span class="code">List[Any]</span>. </p>
        <p> <a id="g575993339"></a><span class="glossaryname">currying</span>&nbsp;&nbsp; A way to write functions with multiple parameter lists. For instance <span class="code">def</span>&nbsp;<span class="code">f(x:</span>&nbsp;<span class="code">Int)(y:</span>&nbsp;<span class="code">Int)</span> is a curried function with two parameter lists. A curried function is applied by passing several arguments lists, as in: <span class="code">f(3)(4)</span>. However, it is also possible to write a <em>partial application</em> of a curried function, such as <span class="code">f(3)</span>. </p>
        <p> <a id="g1542341994"></a><span class="glossaryname">declare</span>&nbsp;&nbsp;You can <em>declare</em> an abstract field, method, or type, which gives an entity a name but not an implementation. The key difference between declarations<a id="i1190494299-1"></a> and definitions is that definitions establish an implementation for the named entity, declarations do not. </p>
        <p> <a id="g-1335633477"></a><span class="glossaryname">define</span>&nbsp;&nbsp; To <em>define</em> something in a Scala program is to give it a name and an implementation. You can define classes, traits, singleton objects,<a id="i-1265372713-1"></a> fields, methods, local functions, local variables, <i>etc.</i> Because definitions always involve some kind of implementation, abstract members are <em>declared</em> not defined. </p>
        <p> <a id="g1336110479"></a><span class="glossaryname">direct subclass</span>&nbsp;&nbsp; A class is a <em>direct subclass</em> of its direct superclass. </p>
        <p> <a id="g384896884"></a><span class="glossaryname">direct superclass</span>&nbsp;&nbsp; The class from which a class or trait is immediately derived, the nearest class above it in its inheritance hierarchy. If a class <span class="code">Parent</span> is mentioned in a class <span class="code">Child</span>'s optional extends clause, then <span class="code">Parent</span> is the direct superclass of <span class="code">Child</span>. If a trait is mentioned in <span class="code">Child</span>'s extends clause, the trait's direct superclass is the <span class="code">Child</span>'s direct superclass. If <span class="code">Child</span> has no extends clause, then <span class="code">AnyRef</span> is the direct superclass of <span class="code">Child</span>. If a class's direct superclass takes type parameters, for example <span class="code">class</span>&nbsp;<span class="code">Child</span>&nbsp;<span class="code">extends</span>&nbsp;<span class="code">Parent[String]</span>, the direct superclass of <span class="code">Child</span> is still <span class="code">Parent</span>, not <span class="code">Parent[String]</span>. On the other hand, <span class="code">Parent[String]</span> would be the direct <em>supertype</em> of <span class="code">Child</span>. See <em>supertype</em> for more discussion of the distinction between class and type. </p>
        <p> <a id="g581399802"></a><span class="glossaryname">equality</span>&nbsp;&nbsp; When used without qualification, <em>equality</em> is the relation between values expressed by `<span class="code">==</span>'. See also <em>reference equality</em>. </p>
        <p> <a id="g-1795452264"></a><span class="glossaryname">expression</span>&nbsp;&nbsp; Any bit of Scala code that yields a result. You can also say that an expression <em>evaluates to</em> a result or <em>results in</em> a value. </p>
        <p> <a id="g-1274492040"></a><span class="glossaryname">filter</span>&nbsp;&nbsp; An <span class="code">if</span> followed by a boolean expression in a <span class="code">for</span> expression. In <span class="code">for(i</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">10;</span>&nbsp;<span class="code">if</span>&nbsp;<span class="code">i</span>&nbsp;<span class="code"><span class="texttt">%</span></span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">0)</span>, the filter is "<span class="code">if</span>&nbsp;<span class="code">i</span>&nbsp;<span class="code"><span class="texttt">%</span></span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">0</span>". The value to the right of the <span class="code">if</span> is the <em>filter expression</em>. </p>
        <p> <a id="g-1577991104"></a><span class="glossaryname">filter expression</span>&nbsp;&nbsp; A <em>filter expression</em> is the boolean expression following an <span class="code">if</span> in a <span class="code">for</span> expression. In <span class="code">for(i</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">10;</span>&nbsp;<span class="code">if</span>&nbsp;<span class="code">i</span>&nbsp;<span class="code"><span class="texttt">%</span></span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">0)</span>, the filter expression is "<span class="code">i</span>&nbsp;<span class="code"><span class="texttt">%</span></span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">0</span>". </p>
        <p> <a id="g1589563862"></a><span class="glossaryname">first-class function</span>&nbsp;&nbsp; Scala supports <em>first-class functions</em>, which means you can express functions in <em>function literal</em> syntax, <i>i.e.</i>, <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span>, and that functions can be represented by objects, which are called <em>function values</em>. </p>
        <p> <a id="g1007002221"></a><span class="glossaryname">for comprehension</span>&nbsp;&nbsp; Another name for <em><span class="code">for</span> expression</em>. </p>
        <p> <a id="g-761850448"></a><span class="glossaryname">free variable</span>&nbsp;&nbsp; A <em>free variable</em> of an expression is a variable that's used inside the expression but not defined inside the expression. For instance, in the function literal expression <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">(x,</span>&nbsp;<span class="code">y)</span>, both variables <span class="code">x</span> and <span class="code">y</span> are used, but only <span class="code">y</span> is a free variable, because it is not defined inside the expression. </p>
        <p> <a id="g1380938712"></a><span class="glossaryname">function</span>&nbsp;&nbsp;A <em>function</em> can be <em>invoked</em> with a list of arguments to produce a result. A function has a parameter list, a body, and a result type. Functions that are members of a class, trait, or singleton object are called <em>methods</em>. Functions defined inside other functions are called <em>local functions</em>. Functions with the result type of <span class="code">Unit</span> are called <em>procedures</em>. Anonymous functions in source code are called <em>function literals</em>. At run time, function literals are instantiated into objects called <em>function values</em>. </p>
        <p> <a id="g1911543911"></a><span class="glossaryname">function literal</span>&nbsp;&nbsp;A function with no name in Scala source code, specified with function literal syntax. For example, <span class="code">(x:</span>&nbsp;<span class="code">Int,</span>&nbsp;<span class="code">y:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">y</span>. </p>
        <p> <a id="g1731647273"></a><span class="glossaryname">function value</span>&nbsp;&nbsp; A function object that can be invoked just like any other function. A function value's class extends one of the <span class="code">FunctionN</span> traits (<i>e.g.</i>, <span class="code">Function0</span>, <span class="code">Function1</span>) from package <span class="code">scala</span>, and is usually expressed in source code via <em>function literal</em> syntax. A function value is "invoked" when its <span class="code">apply</span> method is called. A function value that captures free variables is a <em>closure</em>. </p>
        <p> <a id="g1434668372"></a><span class="glossaryname">functional style</span>&nbsp;&nbsp; The <em>functional style</em> of programming emphasizes functions and evaluation results and deemphasizes the order in which operations occur. The style is characterized by passing function values into looping methods, immutable data, methods with no side effects. It is the dominant paradigm of languages such as Haskell and Erlang, and contrasts with the <em>imperative style</em>. </p>
        <p> <a id="g286956243"></a><span class="glossaryname">generator</span>&nbsp;&nbsp; A <em>generator</em> defines a named <span class="code">val</span> and assigns to it a series of values in a <span class="code">for</span> expression. For example, in <span class="code">for(i</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">10)</span>, the generator is "<span class="code">i</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">10</span>". The value to the right of the <span class="code">&lt;-</span> is the <em>generator expression</em>. </p>
        <p> <a id="g-2128716283"></a><span class="glossaryname">generator expression</span>&nbsp;&nbsp; A <em>generator expression</em> generates a series of values in a <span class="code">for</span> expression. For example, in <span class="code">for(i</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">10)</span>, the generator expression is "<span class="code">1</span>&nbsp;<span class="code">to</span>&nbsp;<span class="code">10</span>". </p>
        <p> <a id="g-1372927505"></a><span class="glossaryname">generic class</span>&nbsp;&nbsp; A class that takes type parameters. For example, because <span class="code">scala.List</span> takes a type parameter, <span class="code">scala.List</span> is a generic class. </p>
        <p> <a id="g-1357049211"></a><span class="glossaryname">generic trait</span>&nbsp;&nbsp; A trait that takes type parameters. For example, because trait <span class="code">scala.collection.Set</span> takes a type parameter, it is a generic trait. </p>
        <p> <a id="g-59832310"></a><span class="glossaryname">helper function</span>&nbsp;&nbsp; A function whose purpose is to provide a service to one or more other functions nearby. Helper functions are often implemented as local functions. </p>
        <p> <a id="g-1128216173"></a><span class="glossaryname">helper method</span>&nbsp;&nbsp; A helper function that's a member of a class. Helper methods are often private. </p>
        <p> <a id="g1596987778"></a><span class="glossaryname">immutable</span>&nbsp;&nbsp; An object is <em>immutable</em> if its value cannot be changed after it is created in any way visible to clients. Objects may or may not be immutable. </p>
        <p> <a id="g148663933"></a><span class="glossaryname">imperative style</span>&nbsp;&nbsp; The <em>imperative style</em> of programming emphasizes careful sequencing of operations so that their effects happen in the right order. The style is characterized by iteration with loops, mutating data in place, and methods with side effects. It is the dominant paradigm of languages such as C, C++, C# and Java, and contrasts with the <em>functional style</em>. </p>
        <p> <a id="g871091088"></a><span class="glossaryname">initialize</span>&nbsp;&nbsp; When a variable is defined in Scala source code, you must <em>initialize</em> it with an object. </p>
        <p> <a id="g555127957"></a><span class="glossaryname">instance</span>&nbsp;&nbsp; An <em>instance</em>, or class instance, is an object, a concept that exists only at run time. </p>
        <p> <a id="g-2086173974"></a><span class="glossaryname">instantiate</span>&nbsp;&nbsp; To <em>instantiate</em> a class is to make a new object from the class, an action that happens only at run time. </p>
        <p> <a id="g-2131763264"></a><span class="glossaryname">invariant</span>&nbsp;&nbsp; <em>Invariant</em> is used in two ways. It can mean a property that always holds true when a data structure is well-formed. For example, it is an invariant of a sorted binary tree that each node is ordered before its right subnode, if it has a right subnode. <em>Invariant</em> is also sometimes used as a synonym for nonvariant: "class <span class="code">Array</span> is invariant in its type parameter." </p>
        <p> <a id="g-1183693704"></a><span class="glossaryname">invoke</span>&nbsp;&nbsp; You can <em>invoke</em> a method, function, or closure <em>on</em> arguments, meaning its body will be executed with the specified arguments. </p>
        <p> <a id="g73857"></a><span class="glossaryname">JVM</span>&nbsp;&nbsp; The <em>JVM</em> is the Java Virtual Machine, or <em>runtime</em>, that hosts a running Scala program. </p>
        <p> <a id="g182460591"></a><span class="glossaryname">literal</span>&nbsp;&nbsp;<span class="code">1</span>, <span class="code">"One"</span>, and <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span> are examples of <em>literals</em>. A literal is a shorthand way to describe an object, where the shorthand exactly mirrors the structure of the created object. </p>
        <p> <a id="g43293933"></a><span class="glossaryname">local function</span>&nbsp;&nbsp; A <em>local function</em> is a <span class="code">def</span> defined inside a block. To contrast, a <span class="code">def</span> defined as a member of a class, trait, or singleton object is called a <em>method</em>. </p>
        <p> <a id="g1707735953"></a><span class="glossaryname">local variable</span>&nbsp;&nbsp; A <em>local variable</em> is a <span class="code">val</span> or <span class="code">var</span> defined inside a block. Although similar to local variables, parameters to functions are not referred to as local variables, but simply as parameters or "variables" without the "local." </p>
        <p> <a id="g-1077769574"></a><span class="glossaryname">member</span>&nbsp;&nbsp; A <em>member</em> is any named element of the template of a class, trait, or singleton object. A member may be accessed with the name of its owner, a dot, and its simple name. For example, top-level fields and methods defined in a class are members of that class. A trait defined inside a class is a member of its enclosing class. A type defined with the <span class="code">type</span> keyword in a class is a member of that class. A class is a member of the package in which is it defined. By contrast, a local variable or local function is not a member of its surrounding block. </p>
        <p> <a id="g954925063"></a><span class="glossaryname">message</span>&nbsp;&nbsp; Actors communicate with each other by sending each other <em>messages</em>. Sending a message does not interrupt what the receiver is doing. The receiver can wait until it has finished its current activity and its invariants have been reestablished. </p>
        <p> <a id="g-850220783"></a><span class="glossaryname">meta-programming</span>&nbsp;&nbsp; Meta-programming software is software whose input is itself software. Compilers are meta-programs, as are tools like <span class="code">scaladoc</span>. Meta-programming software is required in order to do anything with an <em>annotation</em>. </p>
        <p> <a id="g-1077554975"></a><span class="glossaryname">method</span>&nbsp;&nbsp; A <em>method</em> is a function that is a member of some class, trait, or singleton object. </p>
        <p> <a id="g103910529"></a><span class="glossaryname">mixin</span>&nbsp;&nbsp; <em>Mixin</em> is what a trait is called when it is being used in a mixin composition. In other words, in "<span class="code">trait</span>&nbsp;<span class="code">Hat</span>," <span class="code">Hat</span> is just a trait, but in "<span class="code">new</span>&nbsp;<span class="code">Cat</span>&nbsp;<span class="code">extends</span>&nbsp;<span class="code">AnyRef</span>&nbsp;<span class="code">with</span>&nbsp;<span class="code">Hat</span>," <span class="code">Hat</span> can be called a mixin. When used as a verb, "mix in" is two words. For example, you can <em>mix</em> traits <em>in</em>to classes or other traits. </p>
        <p> <a id="g-528906101"></a><span class="glossaryname">mixin composition</span>&nbsp;&nbsp; The process of mixing traits into classes or other traits. <em>Mixin composition</em> differs from traditional multiple inheritance in that the type of the <span class="code">super</span> reference is not known at the point the trait is defined, but rather is determined anew each time the trait is mixed into a class or other trait. </p>
        <p> <a id="g-615513385"></a><span class="glossaryname">modifier</span>&nbsp;&nbsp; A keyword that qualifies a class, trait, field, or method definition in some way. For example, the <span class="code">private</span> modifier indicates that a class, trait, field, or method being defined is private. </p>
        <p> <a id="g-181260432"></a><span class="glossaryname">multiple definitions</span>&nbsp;&nbsp; The same expression can be assigned in <em>multiple definitions</em> if you use the syntax <span class="code">val</span>&nbsp;<span class="code"><i>v1</i>,</span>&nbsp;<span class="code"><i>v2</i>,</span>&nbsp;<span class="code"><i>v3</i></span>&nbsp;<span class="code">=</span>&nbsp;<span class="code"><i>exp</i></span>. </p>
        <p> <a id="g-233237224"></a><span class="glossaryname">nonvariant</span>&nbsp;&nbsp; A type parameter of a class or trait is by default <em>nonvariant</em>. The class or trait then does not subtype when that parameter changes. For example, because class <span class="code">Array</span> is nonvariant in its type parameter, <span class="code">Array[String]</span> is neither a subtype nor a supertype of <span class="code">Array[Any]</span>. </p>
        <p> <a id="g1662702951"></a><span class="glossaryname">operation</span>&nbsp;&nbsp; In Scala, every <em>operation</em> is a method call. Methods may be invoked in <em>operator notation</em>, such as <span class="code">b</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span>, and when in that notation, <span class="code">+</span> is an <em>operator</em>. </p>
        <p> <a id="g1954460585"></a><span class="glossaryname">parameter</span>&nbsp;&nbsp; Functions may take zero to many <em>parameters</em>. Each parameter has a name and a type. The<a id="i-1413740950-1"></a><a id="i-1309185960-1"></a> distinction between parameters and arguments is that arguments refer to the actual objects passed when a function is invoked. Parameters are the variables that refer to those passed arguments. </p>
        <p> <a id="g-1701137034"></a><span class="glossaryname">parameterless function</span>&nbsp;&nbsp; A function that takes no parameters, which is defined without any empty parentheses. Invocations of parameterless functions may not supply parentheses. This supports the <em>uniform access principle</em>, which enables the <span class="code">def</span> to be changed into a <span class="code">val</span> without requiring a change to client code. </p>
        <p> <a id="g-1903107585"></a><span class="glossaryname">parameterless method</span>&nbsp;&nbsp; A <em>parameterless method</em> is a parameterless function that is a member of a class, trait, or singleton object. </p>
        <p> <a id="g-1177929110"></a><span class="glossaryname">parametric field</span>&nbsp;&nbsp; A field defined as a class parameter. </p>
        <p> <a id="g-1880499411"></a><span class="glossaryname">partially applied function</span>&nbsp;&nbsp; A function that's used in an expression and that misses some of its arguments. For instance, if function <span class="code">f</span> has type <span class="code">Int</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Int</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Int</span>, then <span class="code">f</span> and <span class="code">f(1)</span> are <em>partially applied functions</em>. </p>
        <p> <a id="g1121900131"></a><span class="glossaryname">path-dependent type</span>&nbsp;&nbsp; A type like <span class="code">swiss.cow.Food</span>. The <span class="code">swiss.cow</span> part is a <em>path</em> that forms a reference to an object. The meaning of the type is sensitive to the path you use to access it. The types <span class="code">swiss.cow.Food</span> and <span class="code">fish.Food</span>, for example, are different types. </p>
        <p> <a id="g-791090288"></a><span class="glossaryname">pattern</span>&nbsp;&nbsp; In a <span class="code">match</span> expression alternative, a <em>pattern</em> follows each <span class="code">case</span> keyword and precedes either a <em>pattern guard</em> or the <span class="code">=&gt;</span> symbol. </p>
        <p> <a id="g624636437"></a><span class="glossaryname">pattern guard</span>&nbsp;&nbsp; In a <span class="code">match</span> expression alternative, a <em>pattern guard</em> can follow a <em>pattern</em>. For example, in "<span class="code">case</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">if</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code"><span class="texttt">%</span></span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">0</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span>", the pattern guard is "<span class="code">if</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code"><span class="texttt">%</span></span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">0</span>". A case with a pattern guard will only be selected if the pattern matches and the pattern guard yields true. </p>
        <p> <a id="g-1348032073"></a><span class="glossaryname">predicate</span>&nbsp;&nbsp; A <em>predicate</em> is a function with a <span class="code">Boolean</span> result type. </p>
        <p> <a id="g-1733976356"></a><span class="glossaryname">primary constructor</span>&nbsp;&nbsp; The main constructor of a class, which invokes a superclass constructor, if necessary, initializes fields to passed values, and executes any top-level code defined between the curly braces of the class. Fields are initialized only for value parameters not passed to the superclass constructor, except for any that are not used in the body of the class and can therefore be optimized away. </p>
        <p> <a id="g-1095204141"></a><span class="glossaryname">procedure</span>&nbsp;&nbsp; A <em>procedure</em> is a function with result type of <span class="code">Unit</span>, which is therefore executed solely for its side effects. </p>
        <p> <a id="g1752969532"></a><span class="glossaryname">reassignable</span>&nbsp;&nbsp; A variable may or may not be <em>reassignable</em>. A <span class="code">var</span> is reassignable while a <span class="code">val</span> is not. </p>
        <p> <a id="g1165780018"></a><span class="glossaryname">recursive</span>&nbsp;&nbsp; A function is <em>recursive</em> if it calls itself. If the only place the function calls itself is the last expression of the function, then the function is <em>tail recursive</em>. </p>
        <p> <a id="g-925155509"></a><span class="glossaryname">reference</span>&nbsp;&nbsp; A <em>reference</em> is the Java abstraction of a pointer, which uniquely identifies an object that resides on the JVM's heap. Reference type variables hold references to objects, because reference types (instances of <span class="code">AnyRef</span>) are implemented as Java objects that reside on the JVM's heap.<a id="i-396510763-1"></a> Value type variables, by contrast, may sometimes hold a reference (to a boxed wrapper type) and sometimes not (when the object is being represented as a primitive value). Speaking generally, a Scala variable <em>refers</em> to an object. The term "refers" is more abstract than "holds a reference." If a variable of type <span class="code">scala.Int</span> is currently represented as a primitive Java <span class="code">int</span> value, then that variable still refers to the <span class="code">Int</span> object, but no reference is involved. </p>
        <p> <a id="g1293228591"></a><span class="glossaryname">reference equality</span>&nbsp;&nbsp; <em>Reference equality</em> means that two references identify the very same Java object. Reference equality can be determined, for reference types only, by calling <span class="code">eq</span> in <span class="code">AnyRef</span>. (In Java programs, reference equality can be determined using <span class="code">==</span> on Java reference types.) </p>
        <p> <a id="g-1958144273"></a><span class="glossaryname">reference type</span>&nbsp;&nbsp; A <em>reference type</em> is a subclass of <span class="code">AnyRef</span>. Instances of reference types always reside on the JVM's heap at run time. </p>
        <p> <a id="g-1825668081"></a><span class="glossaryname">referential transparency</span>&nbsp;&nbsp; A property of functions that are independent of temporal context and have no side effects. For a particular input, an invocation of a referentially transparent function can be replaced by its result without changing the program semantics. </p>
        <p> <a id="g-934829069"></a><span class="glossaryname">refers</span>&nbsp;&nbsp; A variable in a running Scala program always <em>refers</em> to some object. Even if that variable is assigned to <span class="code">null</span>, it conceptually refers to the <span class="code">Null</span> object. At runtime, an object may be implemented by a Java object or a value of a primitive type, but Scala allows programmers to think at a higher level of abstraction about their code as they imagine it running. See also <em>reference</em>. </p>
        <p> <a id="g1264110831"></a><span class="glossaryname">refinement type</span>&nbsp;&nbsp; A type formed by supplying a base type a number of members inside curly braces. The members in the curly braces refine the types that are present in the base type. For example, the type of "animal that eats grass" is <span class="code">Animal</span>&nbsp;<span class="code">{</span>&nbsp;<span class="code">type</span>&nbsp;<span class="code">SuitableFood</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">Grass</span>&nbsp;<span class="code">}</span>. </p>
        <p> <a id="g-934426595"></a><span class="glossaryname">result</span>&nbsp;&nbsp; An expression in a Scala program yields a <em>result</em>. The result of every expression in Scala is an object. </p>
        <p> <a id="g-595246755"></a><span class="glossaryname">result type</span>&nbsp;&nbsp; A method's <em>result type</em> is the type of the value that results from calling the method. (In Java, this concept is called the return type.) </p>
        <p> <a id="g-934396624"></a><span class="glossaryname">return</span>&nbsp;&nbsp; A function in a Scala program <em>returns</em> a value. You can call this value the <em>result</em> of the function. You can also say the function <em>results in</em> the value. The result of every function in Scala is an object. </p>
        <p> <a id="g1550962648"></a><span class="glossaryname">runtime</span>&nbsp;&nbsp; The Java Virtual Machine, or JVM, that hosts a running Scala program. <em>Runtime</em> encompasses both the virtual machine, as defined by the Java Virtual Machine Specification, and the runtime libraries of the Java API and the standard Scala API. The phrase <em>at run time</em> (with a space between <em>run</em> and <em>time</em>) means when the program is running, and contrasts with compile time. </p>
        <p> <a id="g1877464706"></a><span class="glossaryname">runtime type</span>&nbsp;&nbsp; The type of an object at run time. To contrast, a <em>static type</em> is the type of an expression at compile time. Most runtime types are simply bare classes with no type parameters. For example, the runtime type of <span class="code">"Hi"</span> is <span class="code">String</span>, and the runtime type of <span class="code">(x:</span>&nbsp;<span class="code">Int)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">1</span> is <span class="code">Function1</span>. Runtime types can be tested with<a id="i-901220338-1"></a> <span class="code">isInstanceOf</span>. </p>
        <p> <a id="g-907685685"></a><span class="glossaryname">script</span>&nbsp;&nbsp; A file containing top level definitions and statements, which can be run directly with <span class="code">scala</span> without explicitly compiling. A script must end in an expression, not a definition. </p>
        <p> <a id="g1191572447"></a><span class="glossaryname">selector</span>&nbsp;&nbsp; The value being matched on in a <span class="code">match</span> expression. For example, in "<span class="code">s</span>&nbsp;<span class="code">match</span>&nbsp;<span class="code">{</span>&nbsp;<span class="code">case</span>&nbsp;<span class="code">_</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">}</span>", the selector is <span class="code">s</span>. </p>
        <p> <a id="g-1749196914"></a><span class="glossaryname">self type</span>&nbsp;&nbsp; A <em>self type</em> of a trait is the assumed type of <span class="code">this</span>, the receiver, to be used within the trait. Any concrete class that mixes in the trait must ensure that its type conforms to the trait's self type. The most common use of self types is for dividing a large class into several traits as described in <a href="#chap-modular-programming-using-objects">Chapter 29</a>. </p>
        <p> <a id="g-408699718"></a><span class="glossaryname">semi-structured data</span>&nbsp;&nbsp; XML data is semi-structured. It is more structured than a flat binary file or text file, but it does not have the full structure of a programming language's data structures. </p>
        <p> <a id="g922807280"></a><span class="glossaryname">serialization</span>&nbsp;&nbsp; You can <em>serialize</em> an object into a byte stream which can then be saved to files or transmitted over the network. You can later <em>deserialize</em> the byte stream, even on different computer, and obtain an object that is the same as the original serialized object. </p>
        <p> <a id="g-903579360"></a><span class="glossaryname">shadow</span>&nbsp;&nbsp; A new declaration of a local variable <em>shadows</em> one of the same name in an enclosing scope. </p>
        <p> <a id="g1073584312"></a><span class="glossaryname">signature</span>&nbsp;&nbsp; <em>Signature</em> is short for <em>type signature</em>. </p>
        <p> <a id="g775061748"></a><span class="glossaryname">singleton object</span>&nbsp;&nbsp; An object defined with the <span class="code">object</span> keyword. Each singleton object has one and only one instance. A singleton object that shares its name with a class, and is defined in the same source file as that class, is that class's <em>companion object</em>. The class is its <em>companion class</em>. A singleton object that doesn't have a companion class is a <em>standalone object</em>. </p>
        <p> <a id="g1856979834"></a><span class="glossaryname">standalone object</span>&nbsp;&nbsp;A singleton object that has no companion class. </p>
        <p> <a id="g-2085148305"></a><span class="glossaryname">statement</span>&nbsp;&nbsp; An expression, definition, or import, <i>i.e.</i>, things that can go into a template or a block in Scala source code. </p>
        <p> <a id="g827426220"></a><span class="glossaryname">static type</span>&nbsp;&nbsp;See <em>type</em>. </p>
        <p> <a id="g-2076126408"></a><span class="glossaryname">subclass</span>&nbsp;&nbsp; A class is a <em>subclass</em> of all of its superclasses and supertraits. </p>
        <p> <a id="g-2060248114"></a><span class="glossaryname">subtrait</span>&nbsp;&nbsp; A trait is a <em>subtrait</em> of all of its supertraits. </p>
        <p> <a id="g-1867567750"></a><span class="glossaryname">subtype</span>&nbsp;&nbsp; The Scala compiler will allow any of a type's <em>subtypes</em> to be used as a substitute wherever that type is required. For classes and traits that take no type<a id="i-155377413-1"></a> parameters, the subtype relationship mirrors the subclass relationship. For example, if class <span class="code">Cat</span> is a subclass of abstract class <span class="code">Animal</span>, and neither takes type parameters, type <span class="code">Cat</span> is a subtype of type <span class="code">Animal</span>. Likewise, if trait <span class="code">Apple</span> is a subtrait of trait <span class="code">Fruit</span>, and neither takes type parameters, type <span class="code">Apple</span> is a subtype of type <span class="code">Fruit</span>. For classes and traits that take type parameters, however, variance comes into play. For example, because abstract class <span class="code">List</span> is declared to be covariant in its lone type parameter (<i>i.e.</i>, <span class="code">List</span> is declared <span class="code">List[+A]</span>), <span class="code">List[Cat]</span> is a subtype of <span class="code">List[Animal]</span>, and <span class="code">List[Apple]</span> a subtype of <span class="code">List[Fruit]</span>. These subtype relationships exist even though the class of each of these types is <span class="code">List</span>. By contrast, because <span class="code">Set</span> is not declared to be covariant in its type parameter (<i>i.e.</i>, <span class="code">Set</span> is declared <span class="code">Set[A]</span> with no plus sign), <span class="code">Set[Cat]</span> is <em>not</em> a subtype of <span class="code">Set[Animal]</span>. A subtype should correctly implement the contracts of its supertypes, so that the Liskov Substitution Principle applies, but the compiler only verifies this property at the level of type checking. </p>
        <p> <a id="g-1714704675"></a><span class="glossaryname">superclass</span>&nbsp;&nbsp; A class's <em>superclasses</em> include its direct superclass, its direct superclass's direct superclass, and so on, all the way up to <span class="code">Any</span>. </p>
        <p> <a id="g-1698826381"></a><span class="glossaryname">supertrait</span>&nbsp;&nbsp; A class's or trait's <em>supertraits</em>, if any, include all traits directly mixed into the class or trait or any of its superclasses, plus any supertraits of those traits. </p>
        <p> <a id="g-331888331"></a><span class="glossaryname">supertype</span>&nbsp;&nbsp; A type is a <em>supertype</em> of all of its subtypes. </p>
        <p> <a id="g1908038877"></a><span class="glossaryname">synthetic class</span>&nbsp;&nbsp; A <em>synthetic class</em> is generated automatically by the compiler rather than being written by hand by the programmer. </p>
        <p> <a id="g2133301346"></a><span class="glossaryname">tail recursive</span>&nbsp;&nbsp; A function is <em>tail recursive</em> if the only place the function calls itself is the last operation of the function. </p>
        <p> <a id="g-1884158234"></a><span class="glossaryname">target typing</span>&nbsp;&nbsp; <em>Target typing</em> is a form of type inference that takes into account the type that's expected. In <span class="code">nums.filter((x)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">0)</span>, for example, the Scala compiler infers type of <span class="code">x</span> to be the element type of <span class="code">nums</span>, because the <span class="code">filter</span> method invokes the function on each element of <span class="code">nums</span>. </p>
        <p> <a id="g-1321546630"></a><span class="glossaryname">template</span>&nbsp;&nbsp; A <em>template</em> is the body of a class, trait, or singleton object definition.<a id="i-1722035434-1"></a> It defines the type signature, behavior, and initial state of the class, trait, or object. </p>
        <p> <a id="g110621198"></a><span class="glossaryname">trait</span>&nbsp;&nbsp; A <em>trait</em>, which is defined with the <span class="code">trait</span> keyword, is like an abstract class that cannot take any value parameters and can be "mixed into" classes or other traits via the process known as <em>mixin composition</em>. When a trait is being mixed into a class or trait, it is called a <em>mixin</em>. A trait may be parameterized with one or more types. When parameterized with types, the trait constructs a type. For example, <span class="code">Set</span> is a trait that takes a single type parameter, whereas <span class="code">Set[Int]</span> is a type. Also, <span class="code">Set</span> is said to be "the trait of" type <span class="code">Set[Int]</span>. </p>
        <p> <a id="g3575610"></a><span class="glossaryname">type</span>&nbsp;&nbsp; Every variable and expression in a Scala program has a <em>type</em> that is known at compile time. A type restricts the possible values to which a variable can refer, or an expression can produce, at run time. A variable or expression's type can also<a id="i-1395189617-1"></a><a id="i-1148073513-1"></a> be referred to as a <em>static type</em> if necessary to differentiate it from an object's <em>runtime type</em>. In other words, "type" by itself means static type. Type is distinct from class because a class that takes type parameters can construct many types. For example, <span class="code">List</span> is a class, but not a type. <span class="code">List[T]</span> is a type with a free type parameter. <span class="code">List[Int]</span> and <span class="code">List[String]</span> are also types (called <em>ground types</em> because they have no free type parameters).<a id="i-1740168280-1"></a> A type can have a "class" or "trait." For example, the class of type <span class="code">List[Int]</span> is <span class="code">List</span>. The trait of type <span class="code">Set[String]</span> is <span class="code">Set</span>. </p>
        <p> <a id="g1827075715"></a><span class="glossaryname">type constraint</span>&nbsp;&nbsp; Some annotations are <em>type constraints</em>, meaning that they add additional limits, or constraints, on what values the type includes. For example, <span class="code">@positive</span> could be a type constraint on the type <span class="code">Int</span>, limiting the type of 32-bit integers down to those that are positive. Type constraints are not checked by the standard Scala compiler, but must instead be checked by an extra tool or by a compiler plugin. </p>
        <p> <a id="g823069716"></a><span class="glossaryname">type constructor</span>&nbsp;&nbsp; A class or trait that takes type parameters. </p>
        <p> <a id="g772613699"></a><span class="glossaryname">type parameter</span>&nbsp;&nbsp; A parameter to a generic class or generic method that must be filled in by a type. For example, class <span class="code">List</span> is defined as "<span class="code">class</span> <span class="code">List[T]</span> { ...", and method <span class="code">identity</span>, a member of object <span class="code">Predef</span>, is defined as "<span class="code">def</span> <span class="code">identity[T](x:T)</span> <span class="code">=</span> <span class="code">x</span>". The <span class="code">T</span> in both cases is a type parameter. </p>
        <p> <a id="g-108262574"></a><span class="glossaryname">type signature</span>&nbsp;&nbsp; A method's <em>type signature</em> comprises its name, the number, order, and types of its parameters, if any, and its result type. The type signature of a class, trait, or singleton object comprises its name, the type signatures of all of its members and constructors, and its declared inheritance and mixin relations. </p>
        <p> <a id="g729932460"></a><span class="glossaryname">uniform access principle</span>&nbsp;&nbsp; The <em>uniform access principle</em> states that variables and parameterless functions should be accessed using the same syntax. Scala supports this principle by not allowing parentheses to be placed at call sites of parameterless functions. As a result, a parameterless function definition can be changed to a <span class="code">val</span>, or <i>vice versa</i>, without affecting client code. </p>
        <p> <a id="g-1065891116"></a><span class="glossaryname">unreachable</span>&nbsp;&nbsp; At the Scala level, objects can become <em>unreachable</em>, at which point the memory they occupy may be reclaimed by the runtime. Unreachable does not necessarily mean unreferenced. Reference types (instances of <span class="code">AnyRef</span>) are implemented as objects that reside on the JVM's heap. When an instance of a reference type becomes unreachable, it indeed becomes unreferenced, and is available for garbage collection. Value types (instances of <span class="code">AnyVal</span>) are implemented as both primitive type values and as instances of Java wrapper types (such as <span class="code">java.lang.Integer</span>), which reside on the heap. Value type instances can be boxed (converted from a primitive value to a wrapper object) and unboxed (converted from a wrapper object to a primitive value) throughout the lifetime of the variables that refer to them. If a value type instance currently represented as a wrapper object on the JVM's heap becomes unreachable, it indeed becomes unreferenced, and is available for garbage collection. But if a value type currently represented as a primitive value becomes unreachable, then it does not become unreferenced, because it does not exist as an object on the JVM's heap at that point in time. The runtime may reclaim memory occupied by unreachable objects, but if an <span class="code">Int</span>, for example, is implemented at run time by a primitive Java <span class="code">int</span> that occupies some memory in the stack frame of an executing method, then the memory for that object is "reclaimed" when the stack frame is popped as the method completes. Memory for reference types, such as <span class="code">String</span>s, may be reclaimed by the JVM's garbage collector after they become unreachable. </p>
        <p> <a id="g-788394542"></a><span class="glossaryname">unreferenced</span>&nbsp;&nbsp; See <em>unreachable</em>. </p>
        <p> <a id="g111972721"></a><span class="glossaryname">value</span>&nbsp;&nbsp; The result of any computation or expression in Scala is a <em>value</em>, and in Scala, every value is an object. The term value essentially means the image of an object in memory (on the JVM's heap or stack). </p>
        <p> <a id="g1985162377"></a><span class="glossaryname">value type</span>&nbsp;&nbsp; A <em>value type</em> is any subclass of <span class="code">AnyVal</span>, such as <span class="code">Int</span>, <span class="code">Double</span>, or <span class="code">Unit</span>. This term has meaning at the level of Scala source code. At runtime, instances of value types that correspond to Java primitive types may be implemented in terms of primitive type values or instances of wrapper types, such as <span class="code">java.lang.Integer</span>. Over the lifetime of a value type instance, the runtime may transform it back and forth between primitive and wrapper types (<i>i.e.</i>, to box and unbox it). </p>
        <p> <a id="g-1249586564"></a><span class="glossaryname">variable</span>&nbsp;&nbsp; A named entity that refers to an object. A variable is either a <span class="code">val</span> or a <span class="code">var</span>. Both <span class="code">val</span>s and <span class="code">var</span>s must be initialized when defined, but only <span class="code">var</span>s can be later reassigned to refer to a different object. </p>
        <p> <a id="g-1249575311"></a><span class="glossaryname">variance</span>&nbsp;&nbsp; A type parameter of a class or trait can be marked with a <em>variance</em> annotation, either <em>covariant</em> (<span class="code">+</span>) or <em>contravariant</em> (<span class="code">-</span>). Such variance annotations indicate how subtyping works for a generic class or trait. For example, the generic class <span class="code">List</span> is covariant in its type parameter, and thus <span class="code">List[String]</span> is a subtype of <span class="code">List[Any]</span>. By default, <i>i.e.</i>, absent a <span class="code">+</span> or <span class="code">-</span> annotation, type parameters are <em>nonvariant</em>. </p>
        <p> <a id="g836624832"></a><span class="glossaryname">wildcard type</span>&nbsp;&nbsp; A wildcard type includes references to type variables that are unknown. For example, <span class="code">Array[_]</span> is a wildcard type. It is an array where the element type is completely unknown. </p>
        <p> <a id="g114974605"></a><span class="glossaryname">yield</span>&nbsp;&nbsp; An expression can <em>yield</em> a result. The <span class="code">yield</span> keyword designates the result of a <span class="code">for</span> expression. </p>
      </div>
    </div>
    <div class="h annotator-wrapper">
      <h1><a id="biblioanchor">Bibliography</a></h1>
      <div id="bibliography"> <!-- This document was automatically generated with bibtex2html 1.99
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -s /Users/bv/nobkp/delus/book-prog-in-scala/target/work/artima -nodoc -nofooter -nobibsource -nokeywords /Users/bv/nobkp/delus/book-prog-in-scala/target/work/bibliodata.bib  -->
        <table>
          <tbody>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="raymond-cathedral">Ray99</a>] </td>
              <td class="bibtexitem"> Raymond, Eric. <em>The Cathedral &amp; the Bazaar: Musings on Linux and Open Source by an Accidental Revolutionary</em>. O'Reilly, 1999. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="bloch-effective-java">Blo08</a>] </td>
              <td class="bibtexitem"> Bloch, Joshua. <em>Effective Java Second Edition</em>. Addison-Wesley, 2008. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="redblack">Bay72</a>] </td>
              <td class="bibtexitem"> Bayer, Rudolf. Symmetric binary B-Trees: Data structure and maintenance algorithms. <em>Acta Informatica</em>, 1(4):290--306, 1972. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="patricia">Mor68</a>] </td>
              <td class="bibtexitem"> Morrison, Donald&nbsp;R. PATRICIA---Practical Algorithm To Retrieve Information Coded in Alphanumeric. <em>J. ACM</em>, 15(4):514--534, 1968. ISSN 0004-5411. http://doi.acm.org/10.1145/321479.321481. [&nbsp;<a href="http://doi.acm.org/10.1145/321479.321481">DOI</a>&nbsp;] </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="deremer-large-small">DeR75</a>] </td>
              <td class="bibtexitem"> DeRemer, Frank and Hans Kron. Programming-in-the large versus programming-in-the-small. In <em>Proceedings of the international conference on Reliable software</em>, pages 114--121. ACM, New York, NY, USA, 1975. http://doi.acm.org/10.1145/800027.808431. [&nbsp;<a href="http://doi.acm.org/10.1145/800027.808431">DOI</a>&nbsp;] </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="haskell98">SPJ02</a>] </td>
              <td class="bibtexitem"> Simon Peyton&nbsp;Jones, et.al. Haskell 98 Language and Libraries, Revised Report. Technical report, http://www.haskell.org/onlinereport, 2002. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="vaziri-tip-2007">Vaz07</a>] </td>
              <td class="bibtexitem"> Vaziri, Mandana, Frank Tip, Stephen Fink, and Julian Dolby. Declarative Object Identity Using Relation Types. In <em>Proc. ECOOP 2007</em>, pages 54--78. 2007. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="meyers-effective-cpp">Mey91</a>] </td>
              <td class="bibtexitem"> Meyers, Scott. <em>Effective C++</em>. Addison-Wesley, 1991. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="rumbaugh-uml">Rum04</a>] </td>
              <td class="bibtexitem"> Rumbaugh, James, Ivar Jacobson, and Grady Booch. <em>The Unified Modeling Language Reference Manual (2nd Edition)</em>. Addison-Wesley, 2004. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="goetz-java-con-in-prac">Goe06</a>] </td>
              <td class="bibtexitem"> Goetz, Brian, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Homes, and Doug Lea. <em>Java Concurrency in Practice</em>. Addison Wesley, 2006. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="meyer-oo-soft-con">Mey00</a>] </td>
              <td class="bibtexitem"> Meyer, Bertrand. <em>Object-Oriented Software Construction</em>. Prentice Hall, 2000. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="eckel-thinking-in-java">Eck98</a>] </td>
              <td class="bibtexitem"> Eckel, Bruce. <em>Thinking in Java</em>. Prentice Hall, 1998. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="evans-domain-driven-design">Eva03</a>] </td>
              <td class="bibtexitem"> Evans, Eric. <em>Domain-Driven Design: Tackling Complexity in the Heart of Software</em>. Addison-Wesley Professional, 2003. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="aho-sethi-ullman">Aho86</a>] </td>
              <td class="bibtexitem"> Aho, Alfred&nbsp;V., Ravi Sethi, and Jeffrey&nbsp;D. Ullman. <em>Compilers: Principles, Techniques, and Tools</em>. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 1986. ISBN 0-201-10088-6. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="abelson-sussman-structure">Abe96</a>] </td>
              <td class="bibtexitem"> Abelson, Harold and Gerald&nbsp;Jay Sussman. <em>Structure and Interpretation of Computer Programs</em>. The MIT Press, second edition, 1996. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="odersky-et-al-ecoop03">Ode03</a>] </td>
              <td class="bibtexitem"> Odersky, Martin, Vincent Cremet, Christine Röckl, and Matthias Zenger. A Nominal Theory of Objects with Dependent Types. In <em>Proc. ECOOP'03</em>, Springer LNCS, pages 201--225. July 2003. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="sls">Ode11</a>] </td>
              <td class="bibtexitem"> Odersky, Martin. <em>The Scala Language Specification, Version 2.9</em>. EPFL, May 2011. Available on the web at http://www.scala-lang.org/docu/manuals.html (accessed April 20, 2014). </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="odersky-sca">Ode05</a>] </td>
              <td class="bibtexitem"> Odersky, Martin and Matthias Zenger. Scalable Component Abstractions. In <em>Proceedings of OOPSLA</em>, pages 41--58. October 2005. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="scala-ecoop07">Emi07</a>] </td>
              <td class="bibtexitem"> Emir, Burak, Martin Odersky, and John Williams. Matching Objects With Patterns. In <em>Proc. ECOOP</em>, Springer LNCS, pages 273--295. July 2007. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="steele-growing">Ste99</a>] </td>
              <td class="bibtexitem"> Steele, Jr., Guy&nbsp;L. Growing a Language. <em>Higher-Order and Symbolic Computation</em>, 12:221--223, 1999. Transcript of a talk given at OOPSLA 1998. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="kay-early">Kay96</a>] </td>
              <td class="bibtexitem"> Kay, Alan&nbsp;C. The Early History of Smalltalk. In <em>History of programming languages---II</em>, pages 511--598. ACM, New York, NY, USA, 1996. ISBN 0-201-89502-1. http://doi.acm.org/10.1145/234286.1057828. [&nbsp;<a href="http://doi.acm.org/10.1145/234286.1057828">DOI</a>&nbsp;] </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="JavaTutorials">Jav</a>] </td>
              <td class="bibtexitem"> <em>The Java Tutorials: Creating a GUI with JFC/Swing</em>. Available on the web at http://java.sun.com/docs/books/tutorial/uiswing. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="landin-next">Lan66</a>] </td>
              <td class="bibtexitem"> Landin, Peter&nbsp;J. The Next 700 Programming Languages. <em>Communications of the ACM</em>, 9(3):157--166, 1966. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="fowler-dependency">Fow04</a>] </td>
              <td class="bibtexitem"> Fowler, Martin. Inversion of Control Containers and the Dependency Injection pattern. January 2004. Available on the web at http://martinfowler.com/articles/injection.html (accesssed August 6, 2008). </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="gang-of-four">Gam95</a>] </td>
              <td class="bibtexitem"> Gamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. <em>Design Patterns : Elements of Reusable Object-Oriented Software</em>. Addison-Wesley, 1995. </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="kay-dynamic">Kay03</a>] </td>
              <td class="bibtexitem"> Kay, Alan&nbsp;C. An email to Stefan Ram on the meaning of the term “object-oriented programming”, July 2003. The email is published on the web at http://www.purl.org/stefan_ram/pub/doc_kay_oop_en (accesssed June 6, 2008). </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="dijkstra-notes">Dij70</a>] </td>
              <td class="bibtexitem"> Dijkstra, Edsger&nbsp;W. Notes on Structured Programming., April 1970. Circulated privately. Available at http://www.cs.utexas.edu /users/EWD/ewd02xx/EWD249.PDF as EWD249 (accessed June 6, 2008). </td>
            </tr>
            <tr valign="top">
              <td align="right" class="bibtexnumber"> [<a id="steindorfer-champ">Ste15</a>] </td>
              <td class="bibtexitem"> Steindorfer, Michael&nbsp;J and Jurgen&nbsp;J Vinju. Optimizing hash-array mapped tries for fast and lean immutable JVM collections. In <em>ACM SIGPLAN Notices</em>, volume&nbsp;50, pages 783--800. ACM, 2015. </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <div class="h annotator-wrapper">
      <h2><a id="chap-about-the-authors"></a></h2>
      <h1>About the Authors</h1>
      <p><span class="textbf">Martin Odersky</span> is the creator of the Scala language. He is a professor at EPFL in Lausanne, Switzerland, and a founder of Lightbend, Inc. He works on programming languages and systems, more specifically on the topic of how to combine object-oriented and functional programming. Since 2001 he has concentrated on designing, implementing, and refining Scala. Previously, he has influenced the development of Java as a co-designer of Java generics and as the original author of the current <span class="code">javac</span> reference compiler. He is a fellow of the ACM.</p>
      <p><span class="textbf">Lex Spoon</span> is a software engineer at Semmle, Ltd. He worked on Scala for two years as a post-doc at EPFL. He has a Ph.D. from Georgia Tech, where he worked on static analysis of dynamic languages. In addition to Scala, he has helped develop a wide variety of programming languages, including the dynamic language Smalltalk, the scientific language X10, and the logic language that powers Semmle. He and his wife live in Atlanta with two cats and a chihuahua.</p>
      <p><span class="textbf">Bill Venners</span> is president of Artima, Inc., publisher of the Artima website (www.artima.com) and provider of Scala consulting, training, books, and tools. He is author of the book, <em>Inside the Java Virtual Machine</em>, a programmer-oriented survey of the Java platform's architecture and internals. His popular columns in JavaWorld magazine covered Java internals, object-oriented design, and Jini. Bill is a community representative on the Scala Center advisory board, and is the lead developer and designer of the ScalaTest test framework and the Scalactic library for functional, object-oriented programming.</p>
      <p><a id="theIndex"></a></p>
    </div>
    <div class="h annotator-wrapper cover">
      <h1><a id="indexanchor">Index</a></h1>
      <div id="index">
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br>
        <h3 class="indexh3">Symbols</h3> <span class="code">!</span> (invert)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1211007643-1">on class <span class="code">Boolean</span></a>
        <br> <span class="code">!</span> (message send)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1971465955-1">on trait <span class="code">Actor</span></a>
        <br> <span class="code">!=</span> (not equals)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;method on <span class="code">Any</span> <a href="#i-1108611945-1" class="totri-footnote">1</a> <a href="#i-1108611945-2" class="totri-footnote">2</a>
        <br> <a href="#i1483927337-1"><span class="code">"</span> (string delimiter)</a>
        <br> <a href="#i-1356616527-1"><span class="code">"""</span> (raw string delimiter)</a>
        <br> <span class="code">@</span> (at sign)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i526469630-1">in annotations</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i404534857-1">in patterns</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1417487143-1">to extract XML attributes</a>
        <br> <span class="code">&amp;</span> (bitwise-and)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1795120479-1">on integral types</a>
        <br> <span class="code">&amp;</span> (intersect)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Set</span> traits <a href="#i617863161-1" class="totri-footnote">1</a> <a href="#i617863161-2" class="totri-footnote">2</a>
        <br> <span class="code">&amp;&amp;</span> (logical-and)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-991245277-1">on class <span class="code">Boolean</span></a>
        <br> <span class="code">&amp;<span class="code"><span style="font-size:large">~</span></span></span> (diff)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2003546905-1">on <span class="code">Set</span> traits</a>
        <br> <span class="code">&gt;</span> (greater than)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i990790573-1">on numeric types</a>
        <br> <span class="code">&gt;&gt;</span> (shift right)
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i683040431-1">on integral types</a>
        <br> <span class="code">&gt;&gt;&gt;</span> (unsigned shift right)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1817662978-1">on integral types</a>
        <br> <a href="#i1800766244-1"><span class="code">&gt;:</span> (lower bound)</a>
        <br> <span class="code">&gt;=</span> (greater than or equal to)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-248849346-1">on numeric types</a>
        <br> <span class="code">&lt;</span> (less than)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i220203625-1">on numeric types</a>
        <br> <span class="code">&lt;&lt;</span> (shift left)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1503282158-1">on integral types</a>
        <br> <span class="code">&lt;-</span> (in)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1528740659-1">in <span class="code">for</span> expressions</a>
        <br> <a href="#i1850759422-1"><span class="code">&lt;:</span> (upper bound)</a>
        <br> <span class="code">&lt;=</span> (less than or equal to)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i529909354-1">on numeric types</a>
        <br> <a href="#i-2096980664-1"><span class="code">'</span> (character delimiter)</a>
        <br> <span class="code">()</span> (empty parentheses)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1343251059-1">on method definitions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-760757566-1">shorthand for <span class="code">apply</span> method invocation</a>
        <br> <a href="#i-1932805493-1"><span class="code">()</span> (unit value)</a>
        <br> <span class="code">*</span> (repeat)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-880685326-1">on class <span class="code">String</span></a>
        <br> <a href="#i2051741460-1"><span class="code">*</span> (repeated parameter)</a>
        <br> <span class="code">*</span> (times)
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1513393110-1">on numeric types</a>
        <br> <span class="code">+</span> (add element)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">immutable.Map</span> <a href="#i57882484-1" class="totri-footnote">1</a> <a href="#i57882484-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">immutable.Set</span> <a href="#i58065198-1" class="totri-footnote">1</a> <a href="#i58065198-2" class="totri-footnote">2</a> <a href="#i58065198-3" class="totri-footnote">3</a>
        <br> <span class="code">+</span> (covariant in)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1315578930-1">variance annotation</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-588033271-1"><span class="code">List</span>'s type parameter</a>
        <br> <span class="code">+</span> (plus)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i983413923-1">on numeric types</a>
        <br> <span class="code">++</span> (add elements)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1810495967-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Map</span> traits <a href="#i-2098881509-1" class="totri-footnote">1</a> <a href="#i-2098881509-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i758428245-1">on <span class="code">Set</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1112322562-1">on trait <span class="code">immutable.Set</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-387881431-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">++:</span> (prependedAll)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1142654823-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">++=</span> (add elements to)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">mutable.Map</span> <a href="#i-1693229076-1" class="totri-footnote">1</a> <a href="#i-1693229076-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">mutable.Set</span> <a href="#i-1693046362-1" class="totri-footnote">1</a> <a href="#i-1693046362-2" class="totri-footnote">2</a>
        <br> <span class="code">++=</span> (appendAll)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1975933948-1">on trait <span class="code">Buffer</span></a>
        <br> <span class="code">++=:</span> (prependAll)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2007284108-1">on trait <span class="code">Buffer</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">+:</span> (prepended)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1215087300-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">+=</span> (add element to)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">mutable.Map</span> <a href="#i1314809716-1" class="totri-footnote">1</a> <a href="#i1314809716-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">mutable.Set</span> <a href="#i1314992430-1" class="totri-footnote">1</a> <a href="#i1314992430-2" class="totri-footnote">2</a>
        <br> <span class="code">+=</span> (add to)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i518995282-1">on trait <span class="code">mutable.Set</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i877592417-1">reassignment with immutable sets and <span class="code">var</span>s</a>
        <br> <span class="code">+=</span> (append)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-69907863-1">on class <span class="code">ArrayBuffer</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">ListBuffer</span> <a href="#i714754650-1" class="totri-footnote">1</a> <a href="#i714754650-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1747820940-1">on trait <span class="code">Buffer</span></a>
        <br> <span class="code">+=:</span> (prepend)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i35509127-1">on class <span class="code">ListBuffer</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1505564645-1">on trait <span class="code">Buffer</span></a>
        <br> <span class="code">-</span> (contravariant in)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i973833207-1">variance annotation</a>
        <br> <span class="code">-</span> (minus)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i716347441-1">on numeric types</a>
        <br> <span class="code">-</span> (remove element)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">immutable.Map</span> <a href="#i1951772319-1" class="totri-footnote">1</a> <a href="#i1951772319-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">immutable.Set</span> <a href="#i1951955033-1" class="totri-footnote">1</a> <a href="#i1951955033-2" class="totri-footnote">2</a>
        <br> <a href="#i42793141-1"><span class="code">-&gt;</span> (map to)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i483527409-1">in implicit conversion</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">—</span> (remove elements)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">immutable.Map</span> <a href="#i-1311662347-1" class="totri-footnote">1</a> <a href="#i-1311662347-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">immutable.Set</span> <a href="#i-1311479633-1" class="totri-footnote">1</a> <a href="#i-1311479633-2" class="totri-footnote">2</a>
        <br> <span class="code">—=</span> (remove elements from)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">mutable.Map</span> <a href="#i-610325776-1" class="totri-footnote">1</a> <a href="#i-610325776-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">mutable.Set</span> <a href="#i-610143062-1" class="totri-footnote">1</a> <a href="#i-610143062-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-440851548-1">on trait <span class="code">Buffer</span></a>
        <br> <span class="code">-=</span> (remove element from)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">mutable.Map</span> <a href="#i1816489082-1" class="totri-footnote">1</a> <a href="#i1816489082-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">mutable.Set</span> <a href="#i1816671796-1" class="totri-footnote">1</a> <a href="#i1816671796-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2053756078-1">on trait <span class="code">Buffer</span></a>
        <br> <span class="code">/</span> (divided by)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1085968089-1">on numeric types</a>
        <br> <span class="code">:</span> (colon)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1836523111-1">in type annotations</a>
        <br> <span class="code">:+</span> (appended)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1421606018-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">:++</span> (appendedAll)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1170976857-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">::</span> (cons) class
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-986649610-1">as pattern constructor</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i304418243-1">subclass of <span class="code">List</span></a>
        <br> <span class="code">::</span> (cons) method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i1674095775-1" class="totri-footnote">1</a> <a href="#i1674095775-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;right associativity of <a href="#i-1491182453-1" class="totri-footnote">1</a> <a href="#i-1491182453-2" class="totri-footnote">2</a>
        <br> <span class="code">:::</span> (concatenation)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i55390901-1" class="totri-footnote">1</a> <a href="#i55390901-2" class="totri-footnote">2</a> <a href="#i55390901-3" class="totri-footnote">3</a>
        <br> <span class="code">;</span> (semicolon)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-491339878-1">inference</a>
        <br> <a href="#i61-1"><span class="code">=</span> (variable assignment)</a>
        <br> <span class="code">=&gt;</span> (right arrow, or "rocket")
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i443322727-1">in function literals</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-252838726-1">in <span class="code">import</span> statements</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-178750838-1">in self types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1689875656-1">in <span class="code">match</span> alternatives</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-206823911-1">in <span class="code">this</span> aliasing</a>
        <br> <span class="code">==</span> (equals)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1401108821-1">in set membership</a>
        <br> <span class="code">==</span> (equals)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-383144457-1">in Scala versus Java</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2046772853-1">in-depth treatment</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;method on <span class="code">Any</span> <a href="#i1095465388-1" class="totri-footnote">1</a> <a href="#i1095465388-2" class="totri-footnote">2</a> <a href="#i1095465388-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i46092869-1">quick introduction</a>
        <br> <span class="code">???</span> (unimplemented)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i883954855-1">on object <span class="code">Predef</span></a>
        <br> <span class="code">#</span> (pound sign)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1229370884-1">in inner class type names</a>
        <br> <span class="code">%</span> (remainder)
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i277713802-1">on numeric types</a>
        <br> <span class="code">_</span> (underscore)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-877041491-1">in curried functions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;in function literals <a href="#i788093512-1" class="totri-footnote">1</a> <a href="#i788093512-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1978221382-1">in identifiers</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i91932059-1">in <span class="code">import</span> statements</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1628802775-1">in wildcard types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2028498488-1">in <span class="code">match</span> expressions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i769452465-1">used to initialize a field to its default value</a>
        <br> <span class="code">_*</span> (underscore asterisk)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i521514024-1">in XML pattern matching</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-170392618-1">repeated parameter</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-563003136-1">sequence wildcard pattern</a>
        <br> <a href="#i-837880330-1"><span class="code">_1</span>, <span class="code">_2</span>, <i>etc.</i>(tuple accessors)</a>
        <br> <span class="code">_=</span> (underscore equals)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1901486033-1">in setter method names</a>
        <br> <span class="code">^</span> (exclusive-or)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i608439332-1">on integral types</a>
        <br> <span class="code">^^</span> (result conversion, or "eyebrows")
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1109178044-1">parser combinator</a>
        <br> <span class="code">&nbsp;</span> (bitwise complement)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-788169784-1">on integral types</a>
        <br> <span class="code">&nbsp;</span> (sequential composition, or "squiggle")
        <br> &nbsp;&nbsp;&nbsp;&nbsp;parser combinator <a href="#i-1259402311-1" class="totri-footnote">1</a> <a href="#i-1259402311-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">&nbsp;!</span> (committed sequential composition)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1119621308-1">parser combinator</a>
        <br> <span class="code">&nbsp;&gt;</span> (sequential composition right)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;parser combinator <a href="#i1302279396-1" class="totri-footnote">1</a> <a href="#i1302279396-2" class="totri-footnote">2</a>
        <br> <span class="code">&lt;&nbsp;</span> (sequential composition left)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;parser combinator <a href="#i1234233109-1" class="totri-footnote">1</a> <a href="#i1234233109-2" class="totri-footnote">2</a>
        <br> <span class="code">\</span> (extract)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1322432817-1">on class <span class="code">Elem</span></a>
        <br> <span class="code">\\</span> (deep extract)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i32859236-1"> on class <span class="code">Elem</span></a>
        <br> <span class="code">|</span> (alternative composition)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1808209135-1">parser combinator</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1608533927-1">parser combinator</a>
        <br> <span class="code">|</span> (bitwise-or)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i824307652-1">on integral types</a>
        <br> <span class="code">|</span> (union)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1836511958-1">on <span class="code">Set</span> traits</a>
        <br> <span class="code">||</span> (logical-or)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-821581301-1">on class <span class="code">Boolean</span></a>
        <br> <span class="code">{}</span> (curly braces)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1385018222-1">and variable scope</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1274918996-1">in class definitions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1981623788-1">in imports</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2088304360-1">in XML patterns</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1212676591-1">in XML literals</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2010619769-1">instead of parentheses in method invocations</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-597205837-1">instead of parentheses in <span class="code">for</span> expressions</a>
        <br> <span class="code">`</span> (back tick)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1325362414-1">in constants</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1517246665-1">in identifiers</a>
        <br>
        <h3 id="iia" class="indexh3">A</h3> Abelson, Harold <a href="#i471924076-1" class="totri-footnote">1</a> <a href="#i471924076-2" class="totri-footnote">2</a>
        <br> <span class="code">abs</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-995240575-1">on class <span class="code">Double</span> (via <span class="code">RichDouble</span>)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">Int</span> (via <span class="code">RichInt</span>) <a href="#i-1171773097-1" class="totri-footnote">1</a> <a href="#i-1171773097-2" class="totri-footnote">2</a>
        <br> <a href="#i785070065-1">abstract members</a>
        <br> <span class="code">abstract</span> modifier
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1171687261-1">not needed on abstract methods, fields, or types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1463644999-1">not needed on abstract methods, fields, or types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1203833450-1">on classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1048822646-1">with <span class="code">override</span> modifier on members of traits</a>
        <br> <a href="#i669006587-1">abstract types</a>
        <br> <a href="#i436061376-1">access modifiers</a>
        <br> <a href="#i696953561-1">accessor methods</a>
        <br> <span class="code">Actor</span> trait
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1037720528-1"><span class="code">!</span> (message send)</a>
        <br> actors <a href="#i-1422944994-1" class="totri-footnote">1</a> <a href="#i-1422944994-2" class="totri-footnote">2</a> <a href="#i-1422944994-3" class="totri-footnote">3</a> <a href="#i-1422944994-4" class="totri-footnote">4</a> <a href="#i-1422944994-5" class="totri-footnote">5</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">add</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i381468769-1">on trait <span class="code">mutable.Set</span></a>
        <br> <span class="code">addString</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1095177571-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1233224602-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2043006297-1">on trait <span class="code">Iterator</span></a>
        <br> Aho, Alfred <a href="#i1109104818-1" class="totri-footnote">1</a> <a href="#i1109104818-2" class="totri-footnote">2</a>
        <br> Akka <a href="#i2042656-1" class="totri-footnote">1</a> <a href="#i2042656-2" class="totri-footnote">2</a> <a href="#i2042656-3" class="totri-footnote">3</a> <a href="#i2042656-4" class="totri-footnote">4</a> <a href="#i2042656-5" class="totri-footnote">5</a>
        <br> aliases
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-786400333-1"><span class="code">AnyRef</span> for <span class="code">Object</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;type <a href="#i1803174454-1" class="totri-footnote">1</a> <a href="#i1803174454-2" class="totri-footnote">2</a> <a href="#i1803174454-3" class="totri-footnote">3</a>
        <br> aliasing
        <br> &nbsp;&nbsp;&nbsp;&nbsp;object, <i>see</i> defensive copies
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i427194646-1"><span class="code">this</span></a>
        <br> <a href="#i-252867623-1">alphabetic versus symbolic names</a>
        <br> alternatives
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-149672069-1">catch-all</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1197489584-1">definition of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;in <span class="code">match</span> expressions <a href="#i1524854239-1" class="totri-footnote">1</a> <a href="#i1524854239-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1329663144-1">in <span class="code">catch</span> clauses</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i844888422-1">in partial function literals</a>
        <br> <span class="code">andThen</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-522076688-1">on trait <span class="code">Future</span></a>
        <br> annotations
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-244877014-1">and reflection</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i726662607-1">applied to expressions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1204896229-1">arguments to</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1595748955-1"><span class="code">@BeanProperty</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">@deprecated</span> <a href="#i86494153-1" class="totri-footnote">1</a> <a href="#i86494153-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i544128342-1">in meta-programming</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-311881081-1">Java-specific</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1448620333-1"><span class="code">@native</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1452294669-1">nested</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-897281643-1"><span class="code">@serializable</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-744810718-1"><span class="code">@SerialVersionUID</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-178318765-1">standard</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2008427102-1">syntax of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1317428246-1"><span class="code">@tailrec</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">@Test</span>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1737029383-1">in JUnit 4</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1626806115-1"><span class="code">@throws</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2078024116-1"><span class="code">@transient</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;type <a href="#i-2107785776-1" class="totri-footnote">1</a> <a href="#i-2107785776-2" class="totri-footnote">2</a> <a href="#i-2107785776-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-250763219-1">for debugging</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">@unchecked</span> <a href="#i-815574504-1" class="totri-footnote">1</a> <a href="#i-815574504-2" class="totri-footnote">2</a> <a href="#i-815574504-3" class="totri-footnote">3</a> <a href="#i-815574504-4" class="totri-footnote">4</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i463927682-1">used with named arguments</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1554444807-1">variance</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i915992882-1"><span class="code">@volatile</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-2121626765-1">anonymous classes</a>
        <br> anonymous functions, <i>see</i> function literals
        <br> <a href="#i62435725-1">ANTLR</a>
        <br> <a href="#i-2060175836-1"><span class="code">Any</span> class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-395909855-1">in Scala class hierarchy diagram</a>
        <br> <a href="#i785702719-1"><span class="code">AnyRef</span> class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1076915945-1">as alias of <span class="code">Object</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1570311014-1">in Scala class hierarchy diagram</a>
        <br> <a href="#i499600205-1"><span class="code">AnyVal</span> class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1398855960-1">in Scala class hierarchy diagram</a>
        <br> <span class="code">App</span> trait <a href="#i2043724591-1" class="totri-footnote">1</a> <a href="#i2043724591-2" class="totri-footnote">2</a>
        <br> application
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1914165903-1">function to arguments</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;partial function <a href="#i1842232449-1" class="totri-footnote">1</a> <a href="#i1842232449-2" class="totri-footnote">2</a>
        <br> <a href="#i558250415-1">applications, Scala</a>
        <br> <span class="code">apply</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1032551708-1">called with parentheses</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-649058493-1">in extractors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Array</span>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1841919811-1">class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-930370406-1">object</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1663030400-1">on <span class="code">Iterable</span> objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">List</span>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1534184650-1">class</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object <a href="#i19484993-1" class="totri-footnote">1</a> <a href="#i19484993-2" class="totri-footnote">2</a> <a href="#i19484993-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Map</span>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1948600164-1">objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;traits <a href="#i648989597-1" class="totri-footnote">1</a> <a href="#i648989597-2" class="totri-footnote">2</a> <a href="#i648989597-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-702563230-1">on object <span class="code">Future</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i972576416-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1634739460-1">on <span class="code">Set</span> objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-711183731-1">on trait <span class="code">PartialFunction</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-132187383-1">on <span class="code">Function<em>N</em></span> traits</a>
        <br> <span class="code">args</span> variable
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i515731402-1">in scripts</a>
        <br> arguments
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i337914190-1">command line, in scripts</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-700806123-1">named</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1567203046-1">variable length</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1309185960-1">versus parameters</a>
        <br> arithmetic operations (<span class="code">+</span>, <span class="code">-</span>, <span class="code">*</span>, <span class="code">/</span>, <span class="code">%</span>)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i63774984-1">on numeric types</a>
        <br> <a href="#i916713681-1"><span class="code">Array</span> class</a>
        <br> <a href="#i1906553817-1"><span class="code">ArrayBuffer</span> class</a>
        <br> <a href="#i-703804417-1"><span class="code">ArrayDeque</span> class</a>
        <br> arrays <a href="#i-1409164998-1" class="totri-footnote">1</a> <a href="#i-1409164998-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i580437291-1">accessed with <span class="code">()</span> not <span class="code">[]</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1406547745-1">converting to lists</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1162394563-1">creating and initializing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i953627543-1">generic</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1726482861-1">quick introduction</a>
        <br> <a href="#i-2113240002-1"><span class="code">ArraySeq</span> class</a>
        <br> <span class="code">asInstanceOf</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1385408228-1">on class <span class="code">Any</span></a>
        <br> <span class="code">assert</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on object <span class="code">Predef</span> <a href="#i1445339835-1" class="totri-footnote">1</a> <a href="#i1445339835-2" class="totri-footnote">2</a>
        <br> <a href="#i-1578657506-1"><span class="code">AssertionError</span> class</a>
        <br> assertions <a href="#i2091567537-1" class="totri-footnote">1</a> <a href="#i2091567537-2" class="totri-footnote">2</a>
        <br> assignment
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1918232661-1">result is unit value</a>
        <br> <a href="#i1812392602-1">associativity</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;right versus left <a href="#i-1085593547-1" class="totri-footnote">1</a> <a href="#i-1085593547-2" class="totri-footnote">2</a>
        <br> attributes
        <br> &nbsp;&nbsp;&nbsp;&nbsp;XML <a href="#i-1944660140-1" class="totri-footnote">1</a> <a href="#i-1944660140-2" class="totri-footnote">2</a>
        <br> automatic
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1431094886-1">boxing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;conversion, <i>see</i> implicit conversion
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1027603681-1">imports</a>
        <br> <a href="#i1136761043-1">auxiliary constructors</a>
        <br>
        <h3 id="iib" class="indexh3">B</h3> <a href="#i426003614-1">backtracking</a>
        <br> base classes, <i>see</i> superclasses
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> BDD, <i>see</i> behavior-driven development
        <br> <a href="#i732073940-1"><span class="code">BeanProperty</span> annotation</a>
        <br> <a href="#i-146150294-1"><span class="code">BeanProperty</span> annotation</a>
        <br> <a href="#i2079947888-1">behavior-driven development</a>
        <br> <a href="#i1989635823-1"><span class="code">BigInt</span> class</a>
        <br> <a href="#i1854396478-1"><span class="code">BigInteger</span> class</a>
        <br> <a href="#i-1391235183-1">binary compatibility</a>
        <br> <a href="#i64194507-1">Bison</a>
        <br> bitwise operations, on integral types
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-354658411-1">logical (<span class="code">&amp;</span>, <span class="code">|</span>, <span class="code">^</span>, <span class="code">&nbsp;</span>)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1799112486-1">shift (<span class="code">&lt;&lt;</span>, <span class="code">&gt;&gt;</span>, <span class="code">&gt;&gt;&gt;</span>)</a>
        <br> blank finals (Java)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-388295396-1">not in Scala</a>
        <br> Bloch, Joshua <a href="#i-64318620-1" class="totri-footnote">1</a> <a href="#i-64318620-2" class="totri-footnote">2</a> <a href="#i-64318620-3" class="totri-footnote">3</a>
        <br> <a href="#i824842378-1">blocks, definition of</a>
        <br> <span class="code">Boolean</span> class <a href="#i1148427104-1" class="totri-footnote">1</a> <a href="#i1148427104-2" class="totri-footnote">2</a>
        <br> <a href="#i594122396-1">boolean literals</a>
        <br> <a href="#i794065476-1">bottom types</a>
        <br> bound variables <a href="#i1392088405-1" class="totri-footnote">1</a> <a href="#i1392088405-2" class="totri-footnote">2</a>
        <br> <a href="#i292516588-1">boxing, of value types</a>
        <br> <a href="#i-1202190098-1">Bracha, Gilad</a>
        <br> <span class="code">break</span> keyword (Java)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1665067476-1">living without</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i544483331-1">not in <span class="code">match</span> expressions</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">break</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1125528421-1">on class <span class="code">Breaks</span></a>
        <br> <span class="code">breakable</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i168968267-1">on class <span class="code">Breaks</span></a>
        <br> <a href="#i1129777612-1"><span class="code">Breaks</span> class</a>
        <br> buffer
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i95832031-1">members</a>
        <br> <span class="code">Buffer</span> trait
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2002561959-1"><span class="code">clear</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2002551959-1"><span class="code">clone</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1775835603-1"><span class="code">insert</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1488769076-1"><span class="code">insertAll</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i717210888-1"><span class="code">padToInPlace</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1211178478-1"><span class="code">patchInPlace</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">remove</span> <a href="#i-1526653960-1" class="totri-footnote">1</a> <a href="#i-1526653960-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2061753445-1"><span class="code">trimEnd</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1378245996-1"><span class="code">trimStart</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1646877859-1"><span class="code">++=:</span> (prependAll)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1809113823-1"><span class="code">++=</span> (appendAll)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-52217715-1"><span class="code">+=:</span> (prepend)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2090973295-1"><span class="code">+=</span> (append)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-864802283-1"><span class="code">--=</span> (remove elements from)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i703208191-1"><span class="code">-=</span> (remove element from)</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">buffered</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1907025783-1">on trait <span class="code">Iterator</span></a>
        <br> <a href="#i-720583383-1"><span class="code">Builder</span> trait</a>
        <br> <a href="#i-1378806667-1"><span class="code">ButtonClicked</span> class</a>
        <br> by-name parameters <a href="#i-2031769303-1" class="totri-footnote">1</a> <a href="#i-2031769303-2" class="totri-footnote">2</a>
        <br> <a href="#i-471844177-1">by-value parameters</a>
        <br> <a href="#i1013322880-1"><span class="code">Byte</span> class</a>
        <br>
        <h3 id="iic" class="indexh3">C</h3> C language
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-679763866-1">parser generators</a>
        <br> <a href="#i395906709-1">C language</a>
        <br> C++ language <a href="#i916374005-1" class="totri-footnote">1</a> <a href="#i916374005-2" class="totri-footnote">2</a>
        <br> <a href="#i337211374-1">C# language</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1297750808-1">enumerations</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1153498175-1">properties</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1246302635-1">static extension methods</a>
        <br> <a href="#i81954455-1">camel casing</a>
        <br> <a href="#i-917788527-1">capitalization, of identifiers</a>
        <br> <span class="code">capitalize</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1813550033-1">on class <span class="code">Int</span> (via <span class="code">RichInt</span>)</a>
        <br> <a href="#i-502971380-1">case classes</a>
        <br> case classes
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-910914787-1">versus extractors</a>
        <br> cases, <i>see</i> alternatives
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> casting, <i>see also</i> <span class="code">toInt</span>, <span class="code">toChar</span>, <i>etc.</i>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1504091967-1">with <span class="code">asInstanceOf</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-378444118-1">with typed patterns (the preferred style)</a>
        <br> <a href="#i-2116566913-1"><span class="code">catch</span> clauses</a>
        <br> <a href="#i294325658-1"><em>Cathedral and the Bazaar, The</em> (Raymond)</a>
        <br> <a href="#i2070019594-1">chained package clauses</a>
        <br> <a href="#i1377752142-1"><span class="code">Char</span> class</a>
        <br> character encoding
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1598423906-1">in XML</a>
        <br> <a href="#i-197420869-1">character literals</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1682237230-1">escape sequences</a>
        <br> checked exceptions <a href="#i1490895901-1" class="totri-footnote">1</a> <a href="#i1490895901-2" class="totri-footnote">2</a>
        <br> <a href="#i1963891034-1">Church, Alonzo</a>
        <br> <span class="code">Class</span> class, <i>see</i> <span class="code">classOf</span> method
        <br> class hierarchy diagram
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1073460856-1">for <span class="code">Try</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-322128956-1">for lists</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-703105912-1">for maps</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-345413291-1">for Scala</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-702923198-1">for sets</a>
        <br> <a href="#i177886610-1">class parameters</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-17530359-1">initialization order compared to abstract fields</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-614433232-1">not legal on singleton objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1467639728-1">used to implement abstract fields</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i853620774-1">classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;abstract <a href="#i-860903178-1" class="totri-footnote">1</a> <a href="#i-860903178-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1177206493-1">annotating</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-899295719-1">anonymous</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1163509252-1">case</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-216316744-1">companion</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1083106947-1">generic</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1275741881-1">implicit</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;inner, <i>see</i> inner classes
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1968015105-1">nesting of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i848757295-1">private</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1902128432-1">sealed</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1629420471-1">virtual</a>
        <br> <span class="code">classOf</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1433885554-1">on object <span class="code">Predef</span></a>
        <br> <span class="code">clear</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-914297593-1">on trait <span class="code">mutable.Map</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">mutable.Set</span> <a href="#i-914291699-1" class="totri-footnote">1</a> <a href="#i-914291699-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-240297909-1">on trait <span class="code">Buffer</span></a>
        <br> <span class="code">clone</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1974543337-1">on trait <span class="code">mutable.Map</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1974537443-1">on trait <span class="code">mutable.Set</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1251822395-1">on trait <span class="code">Buffer</span></a>
        <br> closures <a href="#i1093320088-1" class="totri-footnote">1</a> <a href="#i1093320088-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i706520282-1">versus Java's inner classes</a>
        <br> code duplication
        <br> &nbsp;&nbsp;&nbsp;&nbsp;reducing <a href="#i-1950695486-1" class="totri-footnote">1</a> <a href="#i-1950695486-2" class="totri-footnote">2</a>
        <br> <span class="code">collect</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i160873094-1">on trait <span class="code">Future</span></a>
        <br> <span class="code">collect</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1841780469-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i538616478-1">on trait <span class="code">Iterator</span></a>
        <br> <a href="#i1853891989-1">collections</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1077226165-1">api</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-512346344-1">architecture</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i884164092-1">conversion between Java and Scala</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;parallel <a href="#i-1964267956-1" class="totri-footnote">1</a> <a href="#i-1964267956-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1938971378-1">views of</a>
        <br> <a href="#i-649047625-1">combinators</a>
        <br> <a href="#i541826262-1">companion objects</a>
        <br> <a href="#i-1552749806-1">companion classes</a>
        <br> <a href="#i228947968-1">companion objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1755659460-1">and implicit conversion</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-861331495-1">and factory methods</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-565810484-1">visibility</a>
        <br> <span class="code">compare</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;of trait <span class="code">Ordered</span> <a href="#i1970675952-1" class="totri-footnote">1</a> <a href="#i1970675952-2" class="totri-footnote">2</a>
        <br> compatibility, Scala with Java <a href="#i239541118-1" class="totri-footnote">1</a> <a href="#i239541118-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> compiler errors
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1458364982-1">class ...needs to be abstract, since method ...in class ...of type ...is not defined</a>
        <br> compiler errors
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i869323971-1"> overloaded method value ...with alternatives ...cannot be applied to ...</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i724160184-1">';' expected but ',' found</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1430878475-1">...is already defined as ...</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-480808313-1">...is not a legal prefix for a constructor</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-983091129-1">class ...is abstract; cannot be instantiated</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1457961297-1">class type required</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1604722710-1">constructor ...cannot be accessed in ...</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i497448815-1">could not find implicit value for parameter <span class="code">asIterable</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-517711887-1">covariant type ...occurs in contravariant position in type ...of parameter of setter ...</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;covariant type ...occurs in contravariant position in type ...of value ... <a href="#i-1072664655-1" class="totri-footnote">1</a> <a href="#i-1072664655-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2133711083-1">error overriding method ...in class ...of type ...method ...needs 'override' modifier</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-44166214-1">error overriding method ...in class ...of type ...method ... cannot override final member</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1180851066-1">illegal inheritance from final class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1803074733-1">inferred type arguments ...do not conform to method ...type parameter bounds ...</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;method ...overrides nothing <a href="#i934798591-1" class="totri-footnote">1</a> <a href="#i934798591-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i732535273-1">missing arguments for method ...follow this method with '_' if you want to treat it as a partially applied function</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1802169132-1">no implicit argument matching parameter type ...was found</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;no implicit argument matching parameter type ...was found <a href="#i-1437022486-1" class="totri-footnote">1</a> <a href="#i-1437022486-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;not found: value ... <a href="#i138103638-1" class="totri-footnote">1</a> <a href="#i138103638-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1859455133-1">overloaded method value ...with alternatives ...cannot be applied to ...</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-237149939-1">pattern is unchecked since it is eliminated by erasure</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;reassignment to val <a href="#i1301665902-1" class="totri-footnote">1</a> <a href="#i1301665902-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i935521398-1">trait ...takes type parameters</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;type mismatch <a href="#i-677980410-1" class="totri-footnote">1</a> <a href="#i-677980410-2" class="totri-footnote">2</a> <a href="#i-677980410-3" class="totri-footnote">3</a> <a href="#i-677980410-4" class="totri-footnote">4</a> <a href="#i-677980410-5" class="totri-footnote">5</a> <a href="#i-677980410-6" class="totri-footnote">6</a> <a href="#i-677980410-7" class="totri-footnote">7</a> <a href="#i-677980410-8" class="totri-footnote">8</a> <a href="#i-677980410-9" class="totri-footnote">9</a> <a href="#i-677980410-10">10</a> <a href="#i-677980410-11">11</a> <a href="#i-677980410-12">12</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1756802201-1">unreachable code</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;value ...is not a member of ... <a href="#i988779894-1" class="totri-footnote">1</a> <a href="#i988779894-2" class="totri-footnote">2</a>
        <br> compiler warnings
        <br> &nbsp;&nbsp;&nbsp;&nbsp;match is not exhaustive <a href="#i-160448460-1" class="totri-footnote">1</a> <a href="#i-160448460-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1285804133-1">non variable type-argument ... in type pattern is unchecked since it is eliminated by erasure</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1582199503-1">non variable type-argument ...in type pattern is unchecked since it is eliminated by erasure</a>
        <br> <a href="#i-1383802058-1"><em>Compilers: Principles, Techniques, and Tools</em> (Aho, <i>et. al.</i>)</a>
        <br> <a href="#i-1405503952-1">compiling</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i990690315-1">Scala and Java together</a>
        <br> <a href="#i1866035935-1">complete function</a>
        <br> <span class="code">complete</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1338121824-1">on trait <span class="code">Promise</span></a>
        <br> <span class="code">completeWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-909785018-1">on trait <span class="code">Promise</span></a>
        <br> <a href="#i1993414356-1">complexity, managing</a>
        <br> <a href="#i1009131637-1"><span class="code">Component</span> class</a>
        <br> composition <a href="#i-838923862-1" class="totri-footnote">1</a> <a href="#i-838923862-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;mixin, <i>see</i> mixin composition
        <br> <span class="code">concat</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1362483777-1">on <span class="code">Iterable</span> objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i340156760-1">on <span class="code">Iterable</span> traits</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-214121608-1">on object <span class="code">List</span></a>
        <br> conciseness
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-486479055-1">Scala versus Java</a>
        <br> concurrency
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1338746414-1">actors model</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-670497952-1">and testing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2146835927-1">futures</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1225979037-1">shared data and locks</a>
        <br> concurrentmap
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1337741596-1">members</a>
        <br> <span class="code">ConcurrentMap</span> trait
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-218120845-1"><span class="code">remove</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1830849445-1"><span class="code">replace</span></a>
        <br> <span class="code">ConcurrentMap</span> trait
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1114573962-1"><span class="code">putIfAbsent</span></a>
        <br> configuring
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2145337984-1">to wire modules together</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i475125994-1">with Scala code</a>
        <br> cons (<span class="code">::</span>) method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i1411857630-1" class="totri-footnote">1</a> <a href="#i1411857630-2" class="totri-footnote">2</a> <a href="#i1411857630-3" class="totri-footnote">3</a> <a href="#i1411857630-4" class="totri-footnote">4</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i192988404-1">right associativity of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1732245321-1">short for <em>construct</em></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-1925017016-1"><span class="code">Console</span> object</a>
        <br> constant patterns <a href="#i-1897505825-1" class="totri-footnote">1</a> <a href="#i-1897505825-2" class="totri-footnote">2</a>
        <br> <a href="#i-422276785-1">constants</a>
        <br> constructor patterns <a href="#i-881203127-1" class="totri-footnote">1</a> <a href="#i-881203127-2" class="totri-footnote">2</a>
        <br> <a href="#i-1995954247-1">constructors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-717257147-1">auxiliary</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i263298648-1">in Java versus Scala</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1670701927-1">invoking superclass</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i161912641-1">primary</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2093291082-1">private</a>
        <br> <a href="#i-2044598897-1"><span class="code">Container</span> trait</a>
        <br> <span class="code">contains</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Map</span> traits <a href="#i-1171514126-1" class="totri-footnote">1</a> <a href="#i-1171514126-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i752331919-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Set</span> traits <a href="#i1685795628-1" class="totri-footnote">1</a> <a href="#i1685795628-2" class="totri-footnote">2</a>
        <br> <span class="code">containsSlice</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1416645509-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">contents</span> property
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1014658637-1">on trait <span class="code">Container</span></a>
        <br> context bounds <a href="#i-956942778-1" class="totri-footnote">1</a> <a href="#i-956942778-2" class="totri-footnote">2</a>
        <br> <a href="#i-581215934-1">context-free grammars</a>
        <br> <span class="code">continue keyword (Java)</span>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i656795516-1">living without</a>
        <br> contravariance <a href="#i900875858-1" class="totri-footnote">1</a> <a href="#i900875858-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> control abstraction <a href="#i14092899-1" class="totri-footnote">1</a> <a href="#i14092899-2" class="totri-footnote">2</a>
        <br> <a href="#i857734909-1">conventions, identifier capitalization</a>
        <br> conversion
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1787774928-1">between Java and Scala collections</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1962569096-1">between mutable and immutable collections</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;implicit <a href="#i-1068906551-1" class="totri-footnote">1</a> <a href="#i-1068906551-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;to specific collection types <a href="#i595962916-1" class="totri-footnote">1</a> <a href="#i595962916-2" class="totri-footnote">2</a> <a href="#i595962916-3" class="totri-footnote">3</a> <a href="#i595962916-4" class="totri-footnote">4</a>
        <br> <span class="code">copyToArray</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1315859366-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-913984797-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i172626160-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">corresponds</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1866218038-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">count</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i607267229-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-365002086-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1575808601-1">on trait <span class="code">Iterator</span></a>
        <br> <a href="#i2006441693-1">covariance</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1807481219-1">of arrays in Java</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1806331359-1">of function result type</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;of lists <a href="#i-1469695991-1" class="totri-footnote">1</a> <a href="#i-1469695991-2" class="totri-footnote">2</a>
        <br> creating and initializing
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1891034327-1">arrays</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i486535256-1">lists</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1124095348-1">maps</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;objects with factories <a href="#i-640194953-1" class="totri-footnote">1</a> <a href="#i-640194953-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1663070161-1">objects with <span class="code">new</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1124278062-1">sets</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1705632190-1">singleton objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1857258168-1">tuples</a>
        <br> curly braces
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i32772000-1">and variable scope</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1738295964-1">in class definitions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1574838534-1">in imports</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i544063905-1">in XML literals</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i428757728-1">in XML patterns</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i798707221-1">instead of parentheses in method invocations</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1905470655-1">instead of parentheses in <span class="code">for</span> expressions</a>
        <br> currying <a href="#i575993339-1" class="totri-footnote">1</a> <a href="#i575993339-2" class="totri-footnote">2</a>
        <br>
        <h3 id="iid" class="indexh3">D</h3> data structures
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1691614745-1">fully persistent</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-158920554-1">semi-structured</a>
        <br> deadlock <a href="#i503639951-1" class="totri-footnote">1</a> <a href="#i503639951-2" class="totri-footnote">2</a>
        <br> <span class="code">deafTo</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1623449564-1">on <span class="code">Reactor</span></a>
        <br> <a href="#i1190494299-1">declarations, versus definitions</a>
        <br> decrementing
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;with <span class="code">-= 1</span>, not <span class="code">—</span>, <i>see</i> incrementing
        <br> <span class="code">def</span> keyword <a href="#i1764649166-1" class="totri-footnote">1</a> <a href="#i1764649166-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1767118133-1">annotating</a>
        <br> default methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-520965298-1">in Java 8</a>
        <br> default values
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1897052361-1">of fields</a>
        <br> <a href="#i-1422525536-1">defensive copies</a>
        <br> <a href="#i-1265372713-1">definitions, versus declarations</a>
        <br> <a href="#i10210882-1">dependency injection</a>
        <br> <span class="code">deprecated</span> annotation <a href="#i-1632344653-1" class="totri-footnote">1</a> <a href="#i-1632344653-2" class="totri-footnote">2</a>
        <br> <span class="code">dequeue</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2031764716-1">on class <span class="code">Queue</span></a>
        <br> <a href="#i1056566638-1">DeRemer, Frank</a>
        <br> derived classes, <i>see</i> subclasses
        <br> deserialization
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1744729332-1">XML</a>
        <br> <a href="#i-37693691-1"><em>Design Patterns</em> (Gamma, <i>et. al.</i>)</a>
        <br> <span class="code">diff</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1220877719-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-287414010-1">on <span class="code">Set</span> traits</a>
        <br> <a href="#i-765987414-1">Dijkstra, Edsger</a>
        <br> <span class="code">distinct</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i868552658-1">on <span class="code">Seq</span> traits</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-839670516-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">distinctBy</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i17577659-1">on <span class="code">Seq</span> traits</a>
        <br> <a href="#i673902975-1">divide and conquer principle</a>
        <br> <a href="#i846768734-1"><span class="code">do</span>-<span class="code">while</span> loops</a>
        <br> <a href="#i-679595592-1">domain objects</a>
        <br> <a href="#i-1497241897-1"><em>Domain-Driven Design</em> (Evans)</a>
        <br> <a href="#i-218658218-1">domain-specific languages</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1851490486-1">a little language for digital circuits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i49254319-1">and implicit conversions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1395246279-1">defining an external DSL with parser combinators</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-837225081-1">in Smalltalk and Lisp</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1137790491-1">parser combinators as an internal DSL</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i367427817-1">rich wrappers and internal versus external DSLs</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1267542082-1">ScalaTest's matchers DSL</a>
        <br> <a href="#i-265180023-1"><span class="code">Double</span> class</a>
        <br> downloading
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i314057734-1">Scala</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i742232475-1">source code for book examples</a>
        <br> <span class="code">drop</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-673511213-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1134266499-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1550502010-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1271894919-1">on trait <span class="code">Iterator</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">dropRight</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i915202043-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i636434552-1">on <span class="code">Iterable</span> traits</a>
        <br> <span class="code">dropWhile</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-648573139-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-241169366-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1718350537-1">on trait <span class="code">Iterator</span></a>
        <br> DSLs, <i>see</i> domain-specific languages
        <br> <span class="code">duplicate</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1453185571-1">on trait <span class="code">Iterator</span></a>
        <br> dynamic
        <br> &nbsp;&nbsp;&nbsp;&nbsp;binding <a href="#i-1297249718-1" class="totri-footnote">1</a> <a href="#i-1297249718-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;typing <a href="#i2012339474-1" class="totri-footnote">1</a> <a href="#i2012339474-2" class="totri-footnote">2</a> <a href="#i2012339474-3" class="totri-footnote">3</a>
        <br>
        <h3 id="iie" class="indexh3">E</h3> <a href="#i1711840479-1">Eckel, Bruce</a>
        <br> Eclipse IDE <a href="#i-1327804143-1" class="totri-footnote">1</a> <a href="#i-1327804143-2" class="totri-footnote">2</a>
        <br> <a href="#i1666208972-1"><span class="code">EditDone</span> class</a>
        <br> <em>Effective Java, Second Edition</em> (Bloch) <a href="#i166435877-1" class="totri-footnote">1</a> <a href="#i166435877-2" class="totri-footnote">2</a>
        <br> <a href="#i-1839614926-1"><em>Effective C++</em> (Meyers)</a>
        <br> <a href="#i186753339-1"><em>Effective Java, Second Edition</em> (Bloch)</a>
        <br> efficiency
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1337872025-1">and hash consing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i991539031-1">of abstract classes versus traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;of arrays <a href="#i341425106-1" class="totri-footnote">1</a> <a href="#i341425106-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2031931761-1">of case classes versus extractors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;of class <span class="code">ListBuffer</span> <a href="#i-737429794-1" class="totri-footnote">1</a> <a href="#i-737429794-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1099454431-1">of fold left and right</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-381431720-1">of functional on the outside, imperative on the inside approach</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-222173474-1">of immutable objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-394736131-1">of lists</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1119687476-1">of LL(1) versus backtracking parsers</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1671917386-1">of looping versus recursion</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1372761903-1">of maps</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2095646335-1">of merge versus insertion sort</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1372944617-1">of sets</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-666165524-1">of tail versus non-tail recursion</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;of value types <a href="#i884498802-1" class="totri-footnote">1</a> <a href="#i884498802-2" class="totri-footnote">2</a> <a href="#i884498802-3" class="totri-footnote">3</a> <a href="#i884498802-4" class="totri-footnote">4</a>
        <br> <a href="#i-357661779-1">Eiffel language</a>
        <br> <span class="code">Elem</span> class <a href="#i583597511-1" class="totri-footnote">1</a> <a href="#i583597511-2" class="totri-footnote">2</a>
        <br> <span class="code">Elem</span> type
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2008629102-1">in trait <span class="code">Parsers</span></a>
        <br> <a href="#i-84923540-1">elements, XML</a>
        <br> <a href="#i1150746877-1"><span class="code">else</span> clauses</a>
        <br> embedded DSLs, <i>see</i> domain-specific languages
        <br> <span class="code">empty</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-916064703-1">on <span class="code">Iterable</span> objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Map</span> objects <a href="#i-1094653291-1" class="totri-footnote">1</a> <a href="#i-1094653291-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Set</span> objects <a href="#i1582603163-1" class="totri-footnote">1</a> <a href="#i1582603163-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1039994046-1">on <span class="code">Set</span> traits</a>
        <br> <a href="#i1617330716-1">empty-paren methods</a>
        <br> enclosing instances, <i>see</i> inner classes
        <br> <span class="code">endsWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i455738416-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">enqueue</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i432237508-1">on class <span class="code">Queue</span></a>
        <br> <span class="code">ensuring</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1797680614-1">on object <span class="code">Predef</span></a>
        <br> <a href="#i-2102114367-1">entities</a>
        <br> <span class="code">enum</span> keyword (Java), <i>see</i> <span class="code">Enumeration</span> class
        <br> <a href="#i-1102794201-1"><span class="code">Enumeration</span> class</a>
        <br> <span class="code">eq</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">AnyRef</span> <a href="#i-795280463-1" class="totri-footnote">1</a> <a href="#i-795280463-2" class="totri-footnote">2</a> <a href="#i-795280463-3" class="totri-footnote">3</a>
        <br> equality, <i>see also</i> <span class="code">equals</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">!=</span> (not equals) method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">Any</span> <a href="#i15383763-1" class="totri-footnote">1</a> <a href="#i15383763-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">==</span> (equals) method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">Any</span> <a href="#i-1583721442-1" class="totri-footnote">1</a> <a href="#i-1583721442-2" class="totri-footnote">2</a> <a href="#i-1583721442-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">eq</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">AnyRef</span> <a href="#i2030434891-1" class="totri-footnote">1</a> <a href="#i2030434891-2" class="totri-footnote">2</a> <a href="#i2030434891-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1422354335-1">in Scala versus Java</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1785676493-1">in-depth treatment</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">ne</span> method
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">AnyRef</span> <a href="#i1319501024-1" class="totri-footnote">1</a> <a href="#i1319501024-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;quick introduction <a href="#i307189229-1" class="totri-footnote">1</a> <a href="#i307189229-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1877185224-1">value versus reference</a>
        <br> <span class="code">equals</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1939382283-1">on class <span class="code">Any</span></a>
        <br> <span class="code">equals</span> method, <i>see also</i> equality
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i311333302-1">generated for case classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">Any</span> <a href="#i-342464093-1" class="totri-footnote">1</a> <a href="#i-342464093-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i358320206-1">contract of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-145701109-1">recipe for writing</a>
        <br> <a href="#i-1494561943-1">erasure</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-735891161-1">and pattern matching</a>
        <br> Erlang language <a href="#i-1028679267-1" class="totri-footnote">1</a> <a href="#i-1028679267-2" class="totri-footnote">2</a> <a href="#i-1028679267-3" class="totri-footnote">3</a>
        <br> <a href="#i-1149733563-1">errata, viewing and reporting</a>
        <br> errors, <i>see also</i> compiler errors
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-60007022-1">handling with exceptions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1725890298-1">in parsing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1761697159-1">preventing</a>
        <br> <a href="#i576133849-1">escape sequences, for character literals</a>
        <br> <a href="#i-1668052528-1">Evans, Eric</a>
        <br> <a href="#i547853576-1">event sources</a>
        <br> event handling <a href="#i1245010859-1" class="totri-footnote">1</a> <a href="#i1245010859-2" class="totri-footnote">2</a>
        <br> <a href="#i-1342345159-1">event listeners</a>
        <br> <span class="code">eventually</span> method
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i903380834-1">on trait <span class="code">Eventually</span></a>
        <br> example code, for book
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1840350167-1">downloading</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1878821113-1">license of</a>
        <br> exception handling
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i993633856-1">and checked exceptions</a>
        <br> <a href="#i668047766-1">exception handling</a>
        <br> <a href="#i-89859177-1"><span class="code">ExecutionContext</span></a>
        <br> <span class="code">exists</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1794232640-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i556038843-1">on class <span class="code">StringOps</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i339085162-1" class="totri-footnote">1</a> <a href="#i339085162-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1900638119-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i679062444-1">on trait <span class="code">Iterator</span></a>
        <br> <a href="#i-1305664359-1"><span class="code">extends</span> keyword</a>
        <br> external DSLs, <i>see</i> domain-specific languages
        <br> <a href="#i751564495-1">extractors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1478477936-1">and injections</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1101999489-1">extractor pattern</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1414877783-1">extractor pattern</a>
        <br>
        <h3 id="iif" class="indexh3">F</h3> <a href="#i-1457473092-1"><span class="code">f</span> string interpolator</a>
        <br> F# language <a href="#i724459531-1" class="totri-footnote">1</a> <a href="#i724459531-2" class="totri-footnote">2</a>
        <br> <a href="#i867568852-1">factory objects</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> factory methods <a href="#i-1125093732-1" class="totri-footnote">1</a> <a href="#i-1125093732-2" class="totri-footnote">2</a>
        <br> <a href="#i835909464-1"><span class="code">Factory</span> trait</a>
        <br> <span class="code">collect</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2053859225-1">on trait <span class="code">Future</span></a>
        <br> <span class="code">failed</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i329824497-1">on object <span class="code">Future</span></a>
        <br> <a href="#i1670336322-1"><span class="code">Failure</span> class</a>
        <br> <span class="code">failure</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2044691727-1">on trait <span class="code">Promise</span></a>
        <br> <span class="code">fallbackTo</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-17509287-1">on trait <span class="code">Future</span></a>
        <br> <a href="#i907417652-1"><span class="code">false</span> value</a>
        <br> <a href="#i-1274708295-1">fields</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1356458045-1">abstract</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1857067865-1">defining</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i969211487-1">initializing to default values with an underscore</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1471166698-1">overriding</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;parametric <a href="#i-590826255-1" class="totri-footnote">1</a> <a href="#i-590826255-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1387085847-1">pre-initialized</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;private <a href="#i694224322-1" class="totri-footnote">1</a> <a href="#i694224322-2" class="totri-footnote">2</a>
        <br> <a href="#i1651665815-1"><span class="code">FileReader</span> class</a>
        <br> files
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-330150415-1">ensuring closed with <span class="code">finally</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i972936021-1">opening</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i539380770-1">reading lines from</a>
        <br> <span class="code">fill</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1991390416-1">on <span class="code">Iterable</span> objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2061749081-1">on object <span class="code">List</span></a>
        <br> <span class="code">filter</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1823852756-1">on trait <span class="code">Future</span></a>
        <br> <span class="code">filter</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i1807572102-1" class="totri-footnote">1</a> <a href="#i1807572102-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1784980541-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1114360848-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">filterInPlace</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-857192060-1">on trait <span class="code">mutable.Map</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-857186166-1">on trait <span class="code">mutable.Set</span></a>
        <br> <span class="code">filterKeys</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1402917267-1">on <span class="code">MapView</span> trait</a>
        <br> <span class="code">filterNot</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1795201338-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1252578477-1">on trait <span class="code">Iterator</span></a>
        <br> filters
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i331566550-1">in <span class="code">for</span> expressions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1946581356-1">in <span class="code">for</span> expressions</a>
        <br> <a href="#i-34445759-1"><span class="code">final</span> modifier</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on variables (Java), <i>see</i> <span class="code">val</span>s
        <br> <a href="#i-86518969-1"><span class="code">finally</span> clauses</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">find</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i383310678-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1339535725-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1544372032-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">findAllIn</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1535162589-1">on class <span class="code">Regex</span></a>
        <br> <span class="code">findFirstIn</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i945174444-1">on class <span class="code">Regex</span></a>
        <br> <span class="code">findPrefixOf</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1068388242-1">on class <span class="code">Regex</span></a>
        <br> first-order methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-570225502-1">on class <span class="code">List</span></a>
        <br> <span class="code">flatMap</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i535160876-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1033804009-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-212724097-1">on trait <span class="code">Future</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1343836714-1">on trait <span class="code">Iterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1499753963-1">translating <span class="code">for</span> expressions to invocations of</a>
        <br> <span class="code">flatten</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1187330208-1">on trait <span class="code">Future</span></a>
        <br> <span class="code">flatten</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-652692760-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2107840238-1">on class <span class="code">List</span></a>
        <br> <a href="#i2192409-1">Flex</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-1609149804-1"><span class="code">Float</span> class</a>
        <br> <a href="#i2064554715-1">floating-point literals</a>
        <br> <span class="code">floatingPointNumber</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;in trait <span class="code">JavaTokenParsers</span> <a href="#i1891349662-1" class="totri-footnote">1</a> <a href="#i1891349662-2" class="totri-footnote">2</a>
        <br> fold
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i487604192-1">left</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2058478237-1">right</a>
        <br> <span class="code">foldLeft</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1740081977-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-85880764-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2000454511-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">foldLeft</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-946155748-1">on object <span class="code">Future</span></a>
        <br> <span class="code">foldRight</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i411005876-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1598724495-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-542198878-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">for</span> expressions
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i746576009-1">translated before type checking</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2076162232-1">types valid after <span class="code">-&gt;</span></a>
        <br> <span class="code">for</span> expressions <a href="#i-207940604-1" class="totri-footnote">1</a> <a href="#i-207940604-2" class="totri-footnote">2</a> <a href="#i-207940604-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1523429976-1">and extractors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1506494671-1">and <span class="code">Futures</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-96590517-1">and XML patterns</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1851175608-1">notation</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;using patterns in <a href="#i371386352-1" class="totri-footnote">1</a> <a href="#i371386352-2" class="totri-footnote">2</a>
        <br> <a href="#i-382847944-1"><span class="code">for</span> loops</a>, <i>see also</i> <span class="code">for</span> expressions
        <br> <span class="code">forall</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i260029766-1" class="totri-footnote">1</a> <a href="#i260029766-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1140780163-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-453827760-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">foreach</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1367928747-1">on class <span class="code">Array</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i331113560-1" class="totri-footnote">1</a> <a href="#i331113560-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i184430613-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1188146899-1">on trait <span class="code">Future</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-493461951-1">translating <span class="code">for</span> expressions to invocations of</a>
        <br> <span class="code">formatted</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1143614518-1">on <span class="code">Any</span> (via <span class="code">StringAdd)</span></a>
        <br> <a href="#i1659928775-1">formatting strings</a>
        <br> <a href="#i1138419364-1">Fortran language</a>
        <br> <a href="#i-110883654-1">Fowler, Martin</a>
        <br> <a href="#i-2142527293-1">free variables</a>
        <br> <span class="code">fromTry</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-987153563-1">on object <span class="code">Future</span></a>
        <br> <a href="#i1477728746-1"><span class="code">fsc</span> (fast Scala compiler)</a>
        <br> <a href="#i-2107109778-1">fully qualified names</a>
        <br> function literals
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1101169360-1">underscores in</a>
        <br> function literals
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-940840561-1">and closures</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1629064105-1">and single abstract method types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i525081623-1">for partial functions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;placeholder syntax <a href="#i-383997826-1" class="totri-footnote">1</a> <a href="#i-383997826-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-995341786-1">syntax of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-372979206-1">underscores in</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1850091418-1">versus function values</a>
        <br> function values <a href="#i2141458026-1" class="totri-footnote">1</a> <a href="#i2141458026-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-698028847-1">and closures</a>
        <br> <a href="#i-1150036974-1">functional programming</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1860042908-1">lazy initialization</a>
        <br> functional programming <a href="#i1689782844-1" class="totri-footnote">1</a> <a href="#i1689782844-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1849814556-1">main ideas of</a>
        <br> <a href="#i1434668372-1">functional style</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i982015373-1">combining with imperative style</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1568373391-1">in parsing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-86904923-1">methods without side effects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1384669019-1">recognizing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-496550431-1">refactoring functional style to</a>
        <br> functions
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1058128094-1">basic form of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;first-class <a href="#i-1098728772-1" class="totri-footnote">1</a> <a href="#i-1098728772-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i319271759-1">higher-order</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1082301132-1">local</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-422039390-1">partial</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;partially applied <a href="#i1128745740-1" class="totri-footnote">1</a> <a href="#i1128745740-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-468400421-1">predicates</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1220669121-1">procedures</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-242056329-1">pure</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1113229075-1">recursive</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1640045089-1">tail recursive</a>
        <br> <span class="code">future</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1314558614-1">on trait <span class="code">Promise</span></a>
        <br> <span class="code">Future</span> object
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2121330216-1"><span class="code">apply</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1043356583-1"><span class="code">failed</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1316728868-1"><span class="code">foldLeft</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i359181829-1"><span class="code">fromTry</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-728492073-1"><span class="code">reduceLeft</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1360532195-1"><span class="code">sequence</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1338824042-1"><span class="code">successful</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-551617710-1"><span class="code">traverse</span></a>
        <br> <span class="code">Future</span> trait
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i776534149-1"><span class="code">foreach</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-886602953-1"><span class="code">andThen</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-557339295-1"><span class="code">collect</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1132575058-1"><span class="code">failed</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-431989870-1"><span class="code">fallbackTo</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1364617591-1"><span class="code">filter</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1700331144-1"><span class="code">flatMap</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1701496775-1"><span class="code">flatten</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1388404182-1"><span class="code">isCompleted</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1389984145-1"><span class="code">map</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1655500727-1"><span class="code">onComplete</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1046291647-1"><span class="code">recoverWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-724473753-1"><span class="code">recover</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i968615609-1"><span class="code">transformWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1282076639-1"><span class="code">transform</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i217604474-1"><span class="code">value</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1286210351-1"><span class="code">withFilter</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-62204252-1"><span class="code">zipWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1389589174-1"><span class="code">zip</span></a>
        <br> <a href="#i-503567600-1">futures</a>
        <br>
        <h3 id="iig" class="indexh3">G</h3> <a href="#i978021020-1">Gamma, Erich</a>
        <br> <a href="#i1422302298-1">generator, in <span class="code">for</span> expressions</a>
        <br> <a href="#i-1986667706-1">generic types</a>
        <br> <a href="#i337692579-1">generic arrays</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-1356826384-1">generic types</a>
        <br> <span class="code">get</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1160987621-1">on <span class="code">Map</span> traits</a>
        <br> <span class="code">getLines</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1243928720-1">on object <span class="code">Source</span></a>
        <br> <span class="code">getOrElse</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1472564161-1">on <span class="code">Map</span> traits</a>
        <br> <span class="code">getOrElseUpdate</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1864005077-1">on trait <span class="code">mutable.Map</span></a>
        <br> getter methods <a href="#i-1969580643-1" class="totri-footnote">1</a> <a href="#i-1969580643-2" class="totri-footnote">2</a> <a href="#i-1969580643-3" class="totri-footnote">3</a> <a href="#i-1969580643-4" class="totri-footnote">4</a> <a href="#i-1969580643-5" class="totri-footnote">5</a>
        <br> Gosling, James <a href="#i1512661551-1" class="totri-footnote">1</a> <a href="#i1512661551-2" class="totri-footnote">2</a>
        <br> graphical user interfaces, <i>see</i> user interfaces
        <br> <span class="code">groupBy</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i479566337-1">on <span class="code">Iterable</span> traits</a>
        <br> <span class="code">grouped</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1434663977-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1552726294-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">groupMap</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2108767848-1">on <span class="code">Iterable</span> traits</a>
        <br> <span class="code">groupMapReduce</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1214031186-1">on <span class="code">Iterable</span> traits</a>
        <br> <a href="#i-1799668152-1">"Growing a language" (Steele)</a>
        <br> GUI programming, <i>see</i> user interfaces
        <br> <a href="#i69159613-1">Guice</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br>
        <h3 id="iih" class="indexh3">H</h3> handlers, exception, <i>see</i> <span class="code">catch</span> clauses
        <br> <a href="#i-1199948289-1">hash consing</a>
        <br> hash tries <a href="#i-794402297-1" class="totri-footnote">1</a> <a href="#i-794402297-2" class="totri-footnote">2</a>
        <br> <span class="code">hashCode</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1757872331-1">caching</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-567433454-1">generated for case classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-579193195-1">if overriding <span class="code">equals</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1926521799-1">on class <span class="code">Any</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i668953714-1">contract of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1457981337-1">recipe for writing</a>
        <br> <span class="code">HashMap</span> class
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-335955175-1">in class hierarchy diagram</a>
        <br> <a href="#i1649804972-1"><span class="code">HashSet</span> class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2121468463-1">creating and initializing immutable</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i894901459-1">in class hierarchy diagram</a>
        <br> <a href="#i-140820978-1">Haskell language</a>
        <br> Haskell language <a href="#i-1250113500-1" class="totri-footnote">1</a> <a href="#i-1250113500-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-156161824-1">as a lazy functional language</a>
        <br> <span class="code">hasNext</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2058143621-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">head</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i-735890706-1" class="totri-footnote">1</a> <a href="#i-735890706-2" class="totri-footnote">2</a> <a href="#i-735890706-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1792257067-1">on <span class="code">Iterable</span> traits</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">headOption</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-872351616-1">on <span class="code">Iterable</span> traits</a>
        <br> <a href="#i1588987823-1">Hejlsberg, Anders</a>
        <br> <a href="#i1100003378-1">Hibernate</a>
        <br> hiding
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-236944399-1">names in <span class="code">import</span> clauses</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-33124968-1">names in nested packages</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-141883422-1">variables in nested blocks</a>
        <br> higher-kinded types, <i>see</i> <span class="code">http://</span> <span class="code">booksites.artima.com/</span> <span class="code">programming_in_scala_4ed</span>
        <br> <a href="#i1069366433-1">higher-order functions</a>
        <br> higher-order methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1450817245-1">on class <span class="code">List</span></a>
        <br>
        <h3 id="iii" class="indexh3">I</h3> <a href="#i1368189162-1">identifiers</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-890920833-1">alphanumeric</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i350029111-1">capitalization conventions for</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1204364761-1">literal (with back ticks)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1641787755-1">mixed</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-12268236-1">operator</a>
        <br> identity
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-644344128-1">of objects, testing with <span class="code">eq</span> method</a>
        <br> idioms, <i>see</i> patterns and idioms
        <br> <span class="code">if</span> expressions <a href="#i-1395149224-1" class="totri-footnote">1</a> <a href="#i-1395149224-2" class="totri-footnote">2</a> <a href="#i-1395149224-3" class="totri-footnote">3</a>
        <br> <a href="#i507699202-1">immutability</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2043021322-1">as functional style</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1445844177-1">selecting mutable versus immutable collections</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1835948581-1">trade-offs</a>
        <br> <span class="code">immutable.ArraySeq</span> class
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1241280955-1">in Scala</a>
        <br> <a href="#i148663933-1">imperative style</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1924040307-1">combining with functional style</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i975391822-1">recognizing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2064017764-1">refactoring to functional style</a>
        <br> <span class="code">implements</span> keyword (Java), <i>see</i> mixin composition
        <br> <a href="#i-425423387-1"><span class="code">implicit</span> keyword</a>
        <br> implicit conversion
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-174456078-1">in-depth treatment</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-108634082-1">to rich wrappers</a>
        <br> <a href="#i-2080002837-1">implicit classes</a>
        <br> implicit conversion <a href="#i456777265-1" class="totri-footnote">1</a> <a href="#i456777265-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i771080752-1">a word of caution</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1972624620-1">implicit classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2127602858-1">quick introduction</a>
        <br> implicit conversions
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2142988268-1">when multiple apply</a>
        <br> <a href="#i-1127720187-1">implicit parameters</a>
        <br> imports <a href="#i1926037870-1" class="totri-footnote">1</a> <a href="#i1926037870-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1258079951-1">hiding clauses</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;implicit <a href="#i586706545-1" class="totri-footnote">1</a> <a href="#i586706545-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1858203568-1">on-demand (<i>i.e.</i>, wildcard)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1444404533-1">renaming clauses</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-303565265-1">selector clauses</a>
        <br> incrementing
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1984818667-1">with <span class="code">+= 1</span>, not <span class="code">++</span></a>
        <br> <span class="code">indexOf</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1954773669-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1628073567-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">indexOfSlice</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i580863013-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">indexWhere</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1308063033-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i337051379-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">indices</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i552445480-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1361723020-1">on <span class="code">Seq</span> traits</a>
        <br> inference
        <br> &nbsp;&nbsp;&nbsp;&nbsp;semicolon <a href="#i1984943760-1" class="totri-footnote">1</a> <a href="#i1984943760-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i561868586-1">turning off</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;type <a href="#i-24732165-1" class="totri-footnote">1</a> <a href="#i-24732165-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-402843137-1">Hindley-Milner style</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2062825537-1">the algorithm</a>
        <br> <a href="#i145517742-1">infix operator notation</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> information hiding <a href="#i374717171-1" class="totri-footnote">1</a> <a href="#i374717171-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i593484137-1">with factory methods</a>
        <br> <a href="#i-1992074038-1">inheritance</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1009253694-1">and self types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1408184354-1">extending classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-917586794-1">mixing in traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-613838584-1">versus composition</a>
        <br> inheritance hierarchy diagram, <i>see</i> class hierarchy diagram
        <br> <span class="code">init</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i-1293540834-1" class="totri-footnote">1</a> <a href="#i-1293540834-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-85416101-1">on <span class="code">Iterable</span> traits</a>
        <br> initialization
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1386009102-1">lazy</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1767979071-1">of abstract <span class="code">val</span>s</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1766069577-1">of arrays</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;of classes, <i>see</i> constructors
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1853080782-1">of fields to default values</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;of instance variables with constructor parameters, <i>see</i> class parameters
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-625874522-1">of lists</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1503853158-1">of maps</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;of sets <a href="#i1504035872-1" class="totri-footnote">1</a> <a href="#i1504035872-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1985442764-1">of traits</a>
        <br> <a href="#i-400083503-1">initializers</a>
        <br> <a href="#i2031936124-1">injections</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> inner classes
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1909060649-1">accessing outer class members with a <span class="code">this</span> alias</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1286205047-1">and path-dependent types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-698337515-1">and private members</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i178325035-1">example of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i570723644-1">granting access to private members of inner classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1543098108-1">private, to hide implementation</a>
        <br> <span class="code">insert</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1767492769-1">on trait <span class="code">Buffer</span></a>
        <br> <span class="code">insertAll</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1499228240-1">on trait <span class="code">Buffer</span></a>
        <br> insertion sort <a href="#i-1814033297-1" class="totri-footnote">1</a> <a href="#i-1814033297-2" class="totri-footnote">2</a>
        <br> <a href="#i-1571995732-1">instance variables</a>
        <br> <span class="code">instanceOf</span> (Java), <i>see</i> type tests
        <br> <a href="#i517506535-1"><span class="code">Int</span> class</a>
        <br> <a href="#i208067142-1">integer literals</a>
        <br> <a href="#i933444833-1">IntelliJ IDE</a>
        <br> interfaces (Java), <i>see</i> traits
        <br> internal DSLs, <i>see</i> domain-specific languages
        <br> <a href="#i648458520-1">interoperability, Scala with Java</a>
        <br> <a href="#i544577078-1">interpolated string literals</a>
        <br> <a href="#i-2008009094-1">interpreter</a>
        <br> <span class="code">intersect</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1738203761-1">on <span class="code">Seq</span> traits</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-804740052-1">on <span class="code">Set</span> traits</a>
        <br> <a href="#i-1862849439-1">invoking a superclass constructor</a>
        <br> <a href="#i-422624999-1"><em>is-a</em> relationships</a>
        <br> <span class="code">isCompleted</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1126777268-1">on trait <span class="code">Future</span></a>
        <br> <span class="code">isDefinedAt</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2055622367-1">on <span class="code">Map</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-315498884-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1604479281-1">on trait <span class="code">PartialFunction</span></a>
        <br> <span class="code">isEmpty</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i1657074897-1" class="totri-footnote">1</a> <a href="#i1657074897-2" class="totri-footnote">2</a> <a href="#i1657074897-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i900893390-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-576053426-1">on <span class="code">Map</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-461566043-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">isInstanceOf</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1701093140-1">on class <span class="code">Any</span></a>
        <br> <span class="code">Iterable</span> objects
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1185790130-1"><span class="code">apply</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1838945712-1"><span class="code">concat</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1189395089-1"><span class="code">empty</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i454035391-1"><span class="code">fill</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-7406402-1"><span class="code">iterate</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1201041025-1"><span class="code">range</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1995938402-1"><span class="code">tabulate</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1324770986-1"><span class="code">unfold</span></a>
        <br> <span class="code">Iterable</span> traits
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i596183555-1"><span class="code">addString</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1235408037-1"><span class="code">collect</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-924181222-1"><span class="code">copyToArray</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i168555392-1"><span class="code">count</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1113848414-1"><span class="code">drop</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i69509726-1"><span class="code">dropRight</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i74099571-1"><span class="code">dropWhile</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i995467275-1"><span class="code">exists</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1010333479-1"><span class="code">filter</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-286058964-1"><span class="code">filterNot</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1113899304-1"><span class="code">find</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1331272020-1"><span class="code">flatMap</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1282388887-1"><span class="code">foldLeft</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1105010828-1"><span class="code">foldRight</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1016035303-1"><span class="code">forall</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1432431739-1"><span class="code">foreach</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1891424921-1"><span class="code">groupBy</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1891423857-1"><span class="code">grouped</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1495379532-1"><span class="code">groupMap</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-22239534-1"><span class="code">groupMapReduce</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1113954639-1"><span class="code">head</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1672833372-1"><span class="code">headOption</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1113993343-1"><span class="code">init</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-126813068-1"><span class="code">isEmpty</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1654748823-1"><span class="code">iterableFactory</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2123398051-1"><span class="code">iterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2146533333-1"><span class="code">knownSize</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1114070533-1"><span class="code">last</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1198032166-1"><span class="code">lastOption</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2069655870-1"><span class="code">lazyZip</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-379703283-1"><span class="code">map</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-379703275-1"><span class="code">max</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-379703037-1"><span class="code">min</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i642295614-1"><span class="code">mkString</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1925374353-1"><span class="code">nonEmpty</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1204480805-1"><span class="code">partition</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1764173441-1"><span class="code">partitionMap</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1800640288-1"><span class="code">product</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i59384508-1"><span class="code">reduceLeft</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1846580743-1"><span class="code">reduceRight</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1057289236-1"><span class="code">sameElements</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1114286960-1"><span class="code">size</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1984795819-1"><span class="code">sizeCompare</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1382914234-1"><span class="code">sizeIs</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i183230467-1"><span class="code">slice</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-9143201-1"><span class="code">sliding</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1114292921-1"><span class="code">span</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i108302110-1"><span class="code">splitAt</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-379696900-1"><span class="code">sum</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1114308543-1"><span class="code">tail</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1114308598-1"><span class="code">take</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2082036678-1"><span class="code">takeRight</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2086626523-1"><span class="code">takeWhile</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-427890262-1"><span class="code">to</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i927732431-1"><span class="code">toArray</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i188072696-1"><span class="code">toIndexedSeq</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1857173444-1"><span class="code">toIterable</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1415719272-1"><span class="code">toList</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i184216402-1"><span class="code">toMap</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i184222293-1"><span class="code">toSeq</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i184222296-1"><span class="code">toSet</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">view</span> <a href="#i1114375700-1" class="totri-footnote">1</a> <a href="#i1114375700-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1221101555-1"><span class="code">withFilter</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-379690542-1"><span class="code">zip</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1582986863-1"><span class="code">zipAll</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1524777478-1"><span class="code">zipWithIndex</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i850530942-1"><span class="code">++</span> (add elements)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1517341511-1"><span class="code">concat</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">iterableFactory</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i437231747-1">on <span class="code">Iterable</span> traits</a>
        <br> <a href="#i1530579974-1"><span class="code">IterableFactory</span> trait</a>
        <br> <a href="#i-163913042-1"><span class="code">IterableOps</span> trait</a>
        <br> <span class="code">iterate</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1866981108-1">on <span class="code">Iterable</span> objects</a>
        <br> <span class="code">iterator</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1527861747-1">members</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2075720641-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1960545726-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1062529325-1">on mutable map</a>
        <br> <span class="code">Iterator</span> trait
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-613121460-1"><span class="code">addString</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1783293797-1"><span class="code">buffered</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i640426468-1"><span class="code">collect</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i869836579-1"><span class="code">copyToArray</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1158215753-1"><span class="code">count</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-700938878-1"><span class="code">distinct</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i314488949-1"><span class="code">drop</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1135205444-1"><span class="code">dropWhile</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i587712325-1"><span class="code">duplicate</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1610167394-1"><span class="code">exists</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1625033598-1"><span class="code">filter</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1495363979-1"><span class="code">filterNot</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i314539839-1"><span class="code">find</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1087860771-1"><span class="code">flatMap</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-696283602-1"><span class="code">foldLeft</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-104294187-1"><span class="code">foldRight</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1630735422-1"><span class="code">forall</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-15589352-1"><span class="code">grouped</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i387741031-1"><span class="code">hasNext</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1634273027-1"><span class="code">indexOf</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1113971653-1"><span class="code">indexWhere</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1749021437-1"><span class="code">isEmpty</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i937228318-1"><span class="code">knownSize</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1793161964-1"><span class="code">length</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1949815574-1"><span class="code">map</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1949815582-1"><span class="code">max</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1949815820-1"><span class="code">min</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1336376875-1"><span class="code">mkString</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i314774649-1"><span class="code">next</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i390920454-1"><span class="code">nonEmpty</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1169787304-1"><span class="code">padTo</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1881181476-1"><span class="code">partition</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1169803138-1"><span class="code">patch</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-618492503-1"><span class="code">product</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1225634707-1"><span class="code">reduceLeft</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-654368752-1"><span class="code">reduceRight</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1277312253-1"><span class="code">sameElements</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i314927495-1"><span class="code">size</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1172890828-1"><span class="code">slice</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1866691304-1"><span class="code">sliding</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1949821957-1"><span class="code">sum</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i314949133-1"><span class="code">take</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i877321508-1"><span class="code">takeWhile</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1171276161-1"><span class="code">to</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1491400360-1"><span class="code">toArray</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-31950321-1"><span class="code">toIndexedSeq</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-690923245-1"><span class="code">toIterable</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2030419391-1"><span class="code">toList</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1173876763-1"><span class="code">toMap</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1173882654-1"><span class="code">toSeq</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1173882657-1"><span class="code">toSet</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-54851356-1"><span class="code">withFilter</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1949828315-1"><span class="code">zip</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2097280314-1"><span class="code">zipAll</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1744800495-1"><span class="code">zipWithIndex</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-456055993-1"><span class="code">++</span> (add elements)</a>
        <br>
        <h3 id="iij" class="indexh3">J</h3> Java language <a href="#i2012001632-1" class="totri-footnote">1</a> <a href="#i2012001632-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-606539021-1">ANTLR</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1522908125-1">concurrency utilities</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-767472144-1">exception handling</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1756438818-1">Swing framework</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-364469185-1">wildcards</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1137870217-1"><span class="code">javac</span></a>
        <br> <a href="#i-2083218982-1">Java 8</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1435359027-1">default methods</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1059833762-1">lambda expressions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2022123097-1"><span class="code">Stream</span> interface</a>
        <br> Java language
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1806853862-1">bytecodes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1284266897-1">collections</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i82401984-1">compiling with Scala</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1590614948-1">covariance of arrays</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1768195241-1">dependency injection in</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-469710704-1">enumerations</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1051202392-1">inner classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i286095114-1">interfaces and Scala traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i373161214-1">interoperability with Scala</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;interoperability with Scala <a href="#i1003002536-1" class="totri-footnote">1</a> <a href="#i1003002536-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;raw types <a href="#i1163979645-1" class="totri-footnote">1</a> <a href="#i1163979645-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1734369148-1">static methods</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2035919517-1">threading model</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1515336401-1"><span class="code">throws</span> keyword</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i840866566-1">value types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-119763145-1">wildcard types</a>
        <br> <a href="#i555287182-1">Java Native Interface</a>
        <br> <a href="#i-1968727662-1">Java Persistence Architecture</a>
        <br> <a href="#i1133571489-1">JavaBeans</a>
        <br> <a href="#i-1017099510-1"><span class="code">JavaConverters</span> object</a>
        <br> JavaScript Object Notation, <i>see</i> JSON
        <br> <a href="#i-585361525-1"><span class="code">JavaTokenParsers</span> trait</a>
        <br> <a href="#i70532963-1">JFlex</a>
        <br> <a href="#i73605-1">JNI</a>
        <br> <a href="#i875843663-1">Joy, Bill</a>
        <br> <a href="#i2286824-1">JSON</a>
        <br> <a href="#i70981870-1">JUnit</a>
        <br>
        <h3 id="iik" class="indexh3">K</h3> Kay, Alan <a href="#i438821039-1" class="totri-footnote">1</a> <a href="#i438821039-2" class="totri-footnote">2</a>
        <br> <span class="code">keys</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Map</span> traits <a href="#i1213467709-1" class="totri-footnote">1</a> <a href="#i1213467709-2" class="totri-footnote">2</a>
        <br> <span class="code">keySet</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Map</span> traits <a href="#i891405326-1" class="totri-footnote">1</a> <a href="#i891405326-2" class="totri-footnote">2</a>
        <br> <span class="code">keysIterator</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1344362607-1">on <span class="code">Map</span> traits</a>
        <br> <a href="#i-1241489226-1">keywords, using as identifiers</a>
        <br> <span class="code">knownSize</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-622813393-1">on <span class="code">Iterable</span> traits</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1896191196-1">on trait <span class="code">Iterator</span></a>
        <br>
        <h3 id="iil" class="indexh3">L</h3> <a href="#i73174740-1"><span class="code">Label</span> class</a>
        <br> <a href="#i-572333127-1">LALR(1) parsers</a>
        <br> <a href="#i878901123-1">lambda calculus</a>
        <br> lambda expressions
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-758602307-1">in Java 8</a>
        <br> <a href="#i-440292728-1">Landin, Peter</a>
        <br> <span class="code">last</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i1113811620-1" class="totri-footnote">1</a> <a href="#i1113811620-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1275746657-1">on <span class="code">Iterable</span> traits</a>
        <br> <span class="code">lastIndexOf</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1061813157-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">lastIndexOfSlice</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1540596689-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">lastOption</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i726820150-1">on <span class="code">Iterable</span> traits</a>
        <br> <a href="#i3314449-1">laws</a>
        <br> <a href="#i51441782-1">layouts, in GUIs</a>
        <br> <a href="#i3314548-1"><span class="code">lazy</span> modifier</a>
        <br> <a href="#i-748662080-1">lazy functional languages</a>
        <br> <span class="code">LazyList</span> class
        <br> &nbsp;&nbsp;&nbsp;&nbsp;in Scala <a href="#i-2092792389-1" class="totri-footnote">1</a> <a href="#i-2092792389-2" class="totri-footnote">2</a>
        <br> <span class="code">lazyZip</span> method
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-764279812-1">on class <span class="code">List</span></a>
        <br> <span class="code">lazyZip</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1905510632-1">on <span class="code">Iterable</span> traits</a>
        <br> <span class="code">length</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i1353349876-1" class="totri-footnote">1</a> <a href="#i1353349876-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i510850146-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">lengthCompare</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i473798543-1">on <span class="code">Seq</span> traits</a>
        <br> <a href="#i76287-1">Lex</a>
        <br> <a href="#i1371644930-1">lexical analysis</a>
        <br> <a href="#i262352408-1">lexical analysis</a>
        <br> <a href="#i-1280910181-1">linearization, of traits</a>
        <br> <a href="#i594306766-1">linked lists</a>
        <br> linking
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1259075515-1">of modules at runtime</a>
        <br> <a href="#i1033900893-1">Liskov Substitution Principle</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1527452340-1">and <span class="code">equals</span> method</a>
        <br> Lisp language <a href="#i-503250946-1" class="totri-footnote">1</a> <a href="#i-503250946-2" class="totri-footnote">2</a>
        <br> <span class="code">List</span> class, <i>see also</i> lists <a href="#i882498454-1" class="totri-footnote">1</a> <a href="#i882498454-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i254621440-1">first-order methods on</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1952802169-1">higher-order methods on</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i124289382-1">immutability</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2054390305-1">implementation of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">:::</span> (concatenation) <a href="#i-1839436249-1" class="totri-footnote">1</a> <a href="#i-1839436249-2" class="totri-footnote">2</a> <a href="#i-1839436249-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-454878362-1"><span class="code">addString</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1854381886-1"><span class="code">apply</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1677368899-1"><span class="code">copyToArray</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">count</span> <a href="#i-1852559773-1" class="totri-footnote">1</a> <a href="#i-1852559773-2" class="totri-footnote">2</a> <a href="#i-1852559773-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">drop</span> <a href="#i1464293147-1" class="totri-footnote">1</a> <a href="#i1464293147-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-981552191-1"><span class="code">dropRight</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-976962346-1"><span class="code">dropWhile</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">exists</span> <a href="#i-1529560696-1" class="totri-footnote">1</a> <a href="#i-1529560696-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">filter</span> <a href="#i-1514694492-1" class="totri-footnote">1</a> <a href="#i-1514694492-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1464344037-1"><span class="code">find</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i364816247-1"><span class="code">flatMap</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">flatten</span> <a href="#i364853848-1" class="totri-footnote">1</a> <a href="#i364853848-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1387030996-1"><span class="code">foldLeft</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i53948911-1"><span class="code">foldRight</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">forall</span> <a href="#i-1508992668-1" class="totri-footnote">1</a> <a href="#i-1508992668-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">foreach</span> <a href="#i465975966-1" class="totri-footnote">1</a> <a href="#i465975966-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">head</span> <a href="#i1464399372-1" class="totri-footnote">1</a> <a href="#i1464399372-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1207917573-1"><span class="code">indices</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">init</span> <a href="#i1464438076-1" class="totri-footnote">1</a> <a href="#i1464438076-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">isEmpty</span> <a href="#i-1093268841-1" class="totri-footnote">1</a> <a href="#i-1093268841-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2018755942-1"><span class="code">iterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">last</span> <a href="#i1464515266-1" class="totri-footnote">1</a> <a href="#i1464515266-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1103200097-1"><span class="code">lazyZip</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1346566126-1"><span class="code">length</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">map</span> <a href="#i1986906032-1" class="totri-footnote">1</a> <a href="#i1986906032-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">mkString</span> <a href="#i746937723-1" class="totri-footnote">1</a> <a href="#i746937723-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2039424574-1"><span class="code">partition</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1836203449-1"><span class="code">reduceLeft</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1174813264-1"><span class="code">remove</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">reverse</span> <a href="#i-2051462346-1" class="totri-footnote">1</a> <a href="#i-2051462346-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1464737226-1"><span class="code">sort</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1539355216-1"><span class="code">sortWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1464737654-1"><span class="code">span</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-858153663-1"><span class="code">splitAt</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">tail</span> <a href="#i1464753276-1" class="totri-footnote">1</a> <a href="#i1464753276-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1464753331-1"><span class="code">take</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1035564606-1"><span class="code">takeWhile</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-38723342-1"><span class="code">toArray</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-683244392-1"><span class="code">toString</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1835961540-1"><span class="code">unzip</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1986918773-1"><span class="code">zip</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i896208311-1"><span class="code">zipWithIndex</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">::</span> (cons) <a href="#i620923488-1" class="totri-footnote">1</a> <a href="#i620923488-2" class="totri-footnote">2</a>
        <br> <span class="code">List</span> object
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">apply</span> <a href="#i1305057997-1" class="totri-footnote">1</a> <a href="#i1305057997-2" class="totri-footnote">2</a> <a href="#i1305057997-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1858358165-1"><span class="code">concat</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1204685244-1"><span class="code">fill</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">range</span> <a href="#i1320308892-1" class="totri-footnote">1</a> <a href="#i1320308892-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1127956889-1"><span class="code">tabulate</span></a>
        <br> <span class="code">ListBuffer</span> class <a href="#i-1815843466-1" class="totri-footnote">1</a> <a href="#i-1815843466-2" class="totri-footnote">2</a> <a href="#i-1815843466-3" class="totri-footnote">3</a>
        <br> <span class="code">listenTo</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Reactor</span> <a href="#i-2118281873-1" class="totri-footnote">1</a> <a href="#i-2118281873-2" class="totri-footnote">2</a>
        <br> lists, <i>see also</i> <span class="code">List</span> class <a href="#i102982549-1" class="totri-footnote">1</a> <a href="#i102982549-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i51698754-1">appending to</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-490886053-1">class hierarchy diagram</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1436258358-1">concatenation (<span class="code">:::</span>)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-218379511-1">converting to arrays</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-205371607-1">converting to strings</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-797883688-1">creating and initializing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1313439186-1">diagram showing linked-list structure</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2038506824-1">in-depth treatment</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2101376046-1">passing elements as arguments with <span class="code">_*</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-262118592-1">table of methods</a>
        <br> <a href="#i1410352259-1"><span class="code">ListView</span> class</a>
        <br> <span class="code">literal</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1803313949-1">on trait <span class="code">RegexParsers</span></a>
        <br> <a href="#i1361311140-1">literals</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1302049027-1">array</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2062178222-1">boolean</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2027394259-1">character</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;class, <i>see</i> <span class="code">classOf</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1661236620-1">floating point</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-144177089-1">identifier</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-168837784-1">integer</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1017781128-1">interpolated string</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i457962676-1">list</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;string <a href="#i-2068973913-1" class="totri-footnote">1</a> <a href="#i-2068973913-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2064511954-1">symbol</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1924909791-1">XML</a>
        <br> little languages, <i>see</i> domain-specific languages
        <br> <a href="#i-2138187530-1">LL(1) grammars</a>
        <br> <span class="code">loadFile</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1775530286-1">on XML</a>
        <br> loan pattern <a href="#i-531276704-1" class="totri-footnote">1</a> <a href="#i-531276704-2" class="totri-footnote">2</a>
        <br> <a href="#i1342112038-1">local functions</a>
        <br> <a href="#i1400207106-1">local variables</a>
        <br> <a href="#i1954917920-1">locks, and shared data</a>
        <br> logical operations (<span class="code">&amp;&amp;</span>, <span class="code">||</span>, <span class="code">!</span>)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-206208280-1">on class <span class="code">Boolean</span></a>
        <br> <a href="#i-149056780-1"><span class="code">Long</span> class</a>
        <br> <a href="#i1742340276-1">lower bounds</a>
        <br> <a href="#i-486218258-1"><span class="code">LowPriorityImplicits</span> class</a>
        <br> LSP, <i>see</i> Liskov Substitution Principle
        <br>
        <h3 id="iim" class="indexh3">M</h3> <a href="#i1838929623-1">magic numbers</a>
        <br> <span class="code">main</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i673279455-1">of GUI applications</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i40729076-1">of Scala applications</a>
        <br> <a href="#i1729789716-1"><span class="code">MainFrame</span> class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;attributes
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i872532101-1"><span class="code">contents</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1539619709-1"><span class="code">title</span></a>
        <br> map
        <br> &nbsp;&nbsp;&nbsp;&nbsp;members <a href="#i-1799914245-1" class="totri-footnote">1</a> <a href="#i-1799914245-2" class="totri-footnote">2</a>
        <br> <span class="code">map</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i395196522-1" class="totri-footnote">1</a> <a href="#i395196522-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i519692455-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1166599508-1">on trait <span class="code">Iterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1273958009-1">on trait <span class="code">Future</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-482121133-1">translating <span class="code">for</span> expressions to invocations of</a>
        <br> <span class="code">Map</span> objects <a href="#i-809004496-1" class="totri-footnote">1</a> <a href="#i-809004496-2" class="totri-footnote">2</a>
        <br> <span class="code">Map</span> traits, <i>see</i> maps
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1877298566-1"><span class="code">+</span> (add element)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1132988814-1"><span class="code">++</span> (add elements)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-191488371-1"><span class="code">-</span> (remove element)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2074410039-1"><span class="code">—</span> (remove elements)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1998745739-1"><span class="code">apply</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1997028780-1"><span class="code">clear</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1997018780-1"><span class="code">clone</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-955049800-1"><span class="code">contains</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1653287599-1"><span class="code">filterInPlace</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1633357539-1"><span class="code">get</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1555511609-1"><span class="code">getOrElse</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1498468194-1"><span class="code">getOrElseUpdate</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1960441049-1"><span class="code">isDefinedAt</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i905643277-1"><span class="code">keys</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1555199396-1"><span class="code">keySet</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i854987931-1"><span class="code">keysIterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1633348394-1"><span class="code">put</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1355125411-1"><span class="code">remove</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1259360862-1"><span class="code">update</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-385480958-1"><span class="code">updated</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1492114152-1"><span class="code">updatedWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i879047048-1"><span class="code">updateWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1244327429-1"><span class="code">values</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1168331657-1"><span class="code">valuesIterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1544177818-1"><span class="code">++=</span> (add elements to)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2003257106-1"><span class="code">+=</span> (add element to)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1837007177-1"><span class="code">—=</span> (remove elements from)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1608234298-1"><span class="code">-=</span> (remove element from)</a>
        <br> <a href="#i-404870244-1"><span class="code">MapFactory</span> trait</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">mapInPlace</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1962373715-1">on <span class="code">mutable.IndexedSeq</span> traits</a>
        <br> <a href="#i-814121660-1"><span class="code">MapOps</span> trait</a>
        <br> maps <a href="#i3344023-1" class="totri-footnote">1</a> <a href="#i3344023-2" class="totri-footnote">2</a> <a href="#i3344023-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i691333469-1">class hierarchy diagram</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1742365636-1">creating and initializing immutable</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1682530400-1">creating and initializing mutable</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i733051324-1">in library, not language</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1702928719-1">mutability modeled in hierarchy</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-498146178-1">table of methods</a>
        <br> <span class="code">mapValues</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1966867365-1">on <span class="code">MapView</span> trait</a>
        <br> <span class="code">MapView</span> trait
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-356465537-1"><span class="code">filterKeys</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1850948683-1"><span class="code">mapValues</span></a>
        <br> <span class="code">match</span> expressions
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1124185517-1">in-depth coverage</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-440612313-1">quick introduction</a>
        <br> <a href="#i1620352635-1"><span class="code">MatchError</span> class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i738442815-1">and "not exhaustive" warning</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2067503209-1">and extractors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;not thrown in <span class="code">for</span> expressions <a href="#i797126047-1" class="totri-footnote">1</a> <a href="#i797126047-2" class="totri-footnote">2</a>
        <br> <a href="#i2020741259-1">Matsumoto, Yukihiro</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">max</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">Int</span> (via <span class="code">RichInt</span>) <a href="#i-256644535-1" class="totri-footnote">1</a> <a href="#i-256644535-2" class="totri-footnote">2</a> <a href="#i-256644535-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-377330001-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-918441052-1">on trait <span class="code">Iterator</span></a>
        <br> member functions, <i>see</i> methods
        <br> member variables, <i>see</i> fields
        <br> members
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i184187235-1">abstract</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1842841433-1">field</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1695985614-1">initialization order of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1490663010-1">method</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-100664180-1">no static</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i475521275-1">type</a>
        <br> <a href="#i-1149295482-1">merge sort</a>
        <br> <a href="#i-122023144-1">message passing</a>
        <br> <a href="#i-850220783-1">meta-programming</a>
        <br> methods, <i>see also</i> functions <a href="#i955534258-1" class="totri-footnote">1</a> <a href="#i955534258-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-141831446-1">abstract</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1126677335-1">as operators</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-163214618-1">as procedures</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1755483330-1">empty-paren</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-461147607-1">first-order</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2091795679-1">native</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1636832800-1">overloading</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i496223825-1">overriding</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1448211194-1">parameterless</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overriding with <span class="code">val</span>s <a href="#i748048051-1" class="totri-footnote">1</a> <a href="#i748048051-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1448353285-1">parameters of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1621898821-1">private</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i119623890-1">return from</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;when to invoke with empty parentheses <a href="#i-1718164274-1" class="totri-footnote">1</a> <a href="#i-1718164274-2" class="totri-footnote">2</a>
        <br> <a href="#i730601900-1">Meyer, Bertrand</a>
        <br> <a href="#i-1960871386-1">Meyers, Scott</a>
        <br> <span class="code">min</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">Int</span> (via <span class="code">RichInt</span>) <a href="#i-2103371977-1" class="totri-footnote">1</a> <a href="#i-2103371977-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i853539357-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2125661578-1">on trait <span class="code">Iterator</span></a>
        <br> <a href="#i-1955463099-1">mixed identifiers</a>
        <br> mixin composition
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1953973959-1">and self types</a>
        <br> mixin composition, <i>see also</i> traits
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1634645853-1">and self types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i464307868-1">example of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1415422629-1">syntax for</a>
        <br> <span class="code">mkString</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i1357784029-1" class="totri-footnote">1</a> <a href="#i1357784029-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Iterable</span> traits <a href="#i1043598554-1" class="totri-footnote">1</a> <a href="#i1043598554-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-872604647-1">on trait <span class="code">Iterator</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-536383362-1">mock objects</a>
        <br> <a href="#i1227433863-1">modules</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i775929709-1">runtime linking</a>
        <br> <a href="#i-1068505564-1">monads</a>
        <br> <a href="#i-328798631-1">monitors</a>
        <br> <a href="#i-1250478654-1">Multi-Java language</a>
        <br> multi-threaded programming, <i>see</i> concurrency
        <br> <a href="#i-1206501288-1">multicore</a>
        <br> multiple return values <a href="#i651595778-1" class="totri-footnote">1</a> <a href="#i651595778-2" class="totri-footnote">2</a>
        <br> <a href="#i1286114796-1">multiple variable definitions</a>
        <br> <a href="#i-1344376109-1">multiple-line statements</a>
        <br> mutability
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1325523688-1">and <span class="code">equals</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i650543080-1">of collections</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1391607683-1">of object state</a>
        <br> <span class="code">mutable.IndexedSeq</span>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2045714777-1">members</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1700369504-1"><span class="code">mapInPlace</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1190787114-1"><span class="code">sortInPlace</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1885117985-1"><span class="code">sortInPlaceBy</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-877201392-1"><span class="code">sortInPlaceWith</span></a>
        <br>
        <h3 id="iin" class="indexh3">N</h3> <a href="#i23167279-1">named arguments</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> namespaces
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-999496559-1">in C#</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i765341585-1">Scala's two instead of Java's four</a>
        <br> <a href="#i-1611050102-1">naming conventions</a>
        <br> <span class="code">NaN</span> (not a number) <a href="#i995050225-1" class="totri-footnote">1</a> <a href="#i995050225-2" class="totri-footnote">2</a>
        <br> <a href="#i-1241002280-1"><span class="code">native</span> annotation</a>
        <br> <span class="code">ne</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">AnyRef</span> <a href="#i-1620977796-1" class="totri-footnote">1</a> <a href="#i-1620977796-2" class="totri-footnote">2</a>
        <br> <a href="#i1513606523-1">nested annotations</a>
        <br> nesting
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1545427464-1">of classes and objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1153551486-1">of functions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1775661018-1">of packages</a>
        <br> .NET <a href="#i77181-1" class="totri-footnote">1</a> <a href="#i77181-2" class="totri-footnote">2</a> <a href="#i77181-3" class="totri-footnote">3</a>
        <br> <a href="#i-899073402-1">NetBeans IDE</a>
        <br> <a href="#i313049961-1"><span class="code">new</span> keyword</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1249757433-1">not needed when calling factory methods</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1645439037-1">not needed with case classes</a>
        <br> <span class="code">next</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i569433333-1">on trait <span class="code">Iterator</span></a>
        <br> <a href="#i-241957733-1">Nice language</a>
        <br> <span class="code">Nil</span> object <a href="#i1899558990-1" class="totri-footnote">1</a> <a href="#i1899558990-2" class="totri-footnote">2</a> <a href="#i1899558990-3" class="totri-footnote">3</a> <a href="#i1899558990-4" class="totri-footnote">4</a>
        <br> <a href="#i568084816-1">Nilsson, Rickard</a>
        <br> <a href="#i1729641978-1"><span class="code">Node</span> class</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i808041077-1"><span class="code">NodeSeq</span> class</a>
        <br> <a href="#i1065377139-1">nominal subtyping</a>
        <br> <a href="#i-342672962-1">non-strict collections</a>
        <br> <a href="#i1519187207-1"><span class="code">None</span> object</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2129711991-1">in extractors</a>
        <br> <span class="code">nonEmpty</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1015678773-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1077580280-1">on trait <span class="code">Iterator</span></a>
        <br> <a href="#i1359580222-1">nonvariance</a>
        <br> <a href="#i-597441587-1"><span class="code">Nothing</span> type</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i958036312-1">as result type of <span class="code">throw</span> expressions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-727376847-1">as type parameter of <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1276473496-1">in Scala class hierarchy diagram</a>
        <br> <a href="#i-1844978241-1"><span class="code">Null</span> class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1121985306-1">in Scala class hierarchy diagram</a>
        <br> <a href="#i473754008-1"><span class="code">null</span> value</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-677123658-1">in <span class="code">equals</span> methods</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-906570700-1">using <span class="code">Option</span> instead for optional values</a>
        <br> <a href="#i-2004250537-1"><span class="code">NullPointerException</span>, preventing</a>
        <br>
        <h3 id="iio" class="indexh3">O</h3> <span class="code">Object</span> class, <i>see also</i> <span class="code">AnyRef</span> class
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2002716718-1">in Scala class hierarchy diagram</a>
        <br> <a href="#i-1642091000-1"><span class="code">object</span> keyword</a>
        <br> <a href="#i-2121954815-1">object-oriented programming</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> object-oriented programming <a href="#i717865003-1" class="totri-footnote">1</a> <a href="#i717865003-2" class="totri-footnote">2</a>
        <br> <a href="#i1013925756-1"><em>Object-Oriented Software Construction</em> (Meyer)</a>
        <br> <a href="#i623710400-1">object-private access with <span class="code">private[this]</span></a>
        <br> objects
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i911241519-1">annotating</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;companion, <i>see</i> companion objects
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i701062634-1">domain</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i728984841-1">entity</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;equality of, <i>see</i> equality
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i47852440-1">functional (immutable)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-124569956-1">immutable</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i955954873-1">mock, in testing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-166063424-1">mutable</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2082703927-1">serializing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;singleton, <i>see</i> singleton objects
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1181640299-1">standalone</a>
        <br> OCaml language <a href="#i-1496851060-1" class="totri-footnote">1</a> <a href="#i-1496851060-2" class="totri-footnote">2</a> <a href="#i-1496851060-3" class="totri-footnote">3</a>
        <br> <a href="#i-410901588-1">on-demand import</a>
        <br> <span class="code">onComplete</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1956458092-1">on trait <span class="code">Future</span></a>
        <br> operator
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1109054020-1">associativity</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1789856-1">example: class <span class="code">Rational</span> with operator methods</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1206563604-1">identifiers</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1245815134-1">when to use</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;notation <a href="#i-614149608-1" class="totri-footnote">1</a> <a href="#i-614149608-2" class="totri-footnote">2</a> <a href="#i-614149608-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-74898194-1">infix</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1299180525-1">postfix</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2117778892-1">prefix</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-189261806-1">"overloading"</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;precedence <a href="#i1955596960-1" class="totri-footnote">1</a> <a href="#i1955596960-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1679614205-1">table of</a>
        <br> <span class="code">opt</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1315224406-1">on trait <span class="code">Parsers</span></a>
        <br> optimization
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1086960686-1">of tail recursion</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1882129636-1">turning off with <span class="code">notailcalls</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-911544850-1">of value types</a>
        <br> <a href="#i118074925-1"><span class="code">Option</span> class</a>
        <br> <span class="code">Ordered</span> trait <a href="#i2068605051-1" class="totri-footnote">1</a> <a href="#i2068605051-2" class="totri-footnote">2</a>
        <br> <a href="#i1791314146-1"><span class="code">Ordering</span> trait</a>
        <br> outer classes, <i>see</i> inner classes
        <br> overloading
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1656673269-1">constructors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1178969056-1">methods</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2049320438-1">"operator"</a>
        <br> <span class="code">override</span> modifier <a href="#i1201360043-1" class="totri-footnote">1</a> <a href="#i1201360043-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1623377591-1">on parametric fields</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> overriding
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<span class="code">def</span>s with <span class="code">val</span>s <a href="#i84167179-1" class="totri-footnote">1</a> <a href="#i84167179-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1224666293-1">methods and fields</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1623576437-1"><span class="code">equals</span> method</a>
        <br>
        <h3 id="iip" class="indexh3">P</h3> <a href="#i-853360368-1">package objects</a>
        <br> <span class="code">package</span> clauses <a href="#i-1154528502-1" class="totri-footnote">1</a> <a href="#i-1154528502-2" class="totri-footnote">2</a>
        <br> <a href="#i908525335-1">package-private access (Java)</a>
        <br> <a href="#i750867693-1">packages</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1777778106-1">as modules</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-370748244-1">hiding</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1384274725-1">implicitly imported</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i305704921-1">unnamed package</a>
        <br> <a href="#i1802065795-1">packaging</a>
        <br> <span class="code">padTo</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1863493728-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1257723354-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">padToInPlace</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1098047332-1">on trait <span class="code">Buffer</span></a>
        <br> <a href="#i1832062192-1">pair, name for <span class="code">Tuple2</span></a>
        <br> <a href="#i76880356-1"><span class="code">Panel</span> class</a>
        <br> <a href="#i-1261817322-1">parallel programming</a>
        <br> parallel collections <a href="#i-1874383620-1" class="totri-footnote">1</a> <a href="#i-1874383620-2" class="totri-footnote">2</a>
        <br> parameterization
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-676617420-1">with types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i534686151-1">with values</a>
        <br> <a href="#i1621984850-1">parameterized types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i511396682-1">and object equality</a>
        <br> <a href="#i1133207124-1">parameterless methods</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;overriding with <span class="code">val</span>s <a href="#i1692897037-1" class="totri-footnote">1</a> <a href="#i1692897037-2" class="totri-footnote">2</a>
        <br> parameters
        <br> &nbsp;&nbsp;&nbsp;&nbsp;by-name <a href="#i-1931276111-1" class="totri-footnote">1</a> <a href="#i-1931276111-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i267370507-1">by-value</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;class, <i>see</i> class parameters
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i869856667-1">default values</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;implicit <a href="#i-568821387-1" class="totri-footnote">1</a> <a href="#i-568821387-2" class="totri-footnote">2</a> <a href="#i-568821387-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1416238505-1">named</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;repeated <a href="#i-580179190-1" class="totri-footnote">1</a> <a href="#i-580179190-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1008880962-1">vararg matching</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1292813002-1">type</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1413740950-1">versus arguments</a>
        <br> parametric fields <a href="#i2138903369-1" class="totri-footnote">1</a> <a href="#i2138903369-2" class="totri-footnote">2</a>
        <br> parentheses
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1201222106-1">using curly braces instead of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;when to use on method calls <a href="#i1976561855-1" class="totri-footnote">1</a> <a href="#i1976561855-2" class="totri-footnote">2</a>
        <br> <a href="#i-640692980-1">parser combinators</a>
        <br> <a href="#i-1495136757-1">parser generators</a>
        <br> <a href="#i-63210921-1"><span class="code">Parser</span> class</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> parser combinators <a href="#i-2095840458-1" class="totri-footnote">1</a> <a href="#i-2095840458-2" class="totri-footnote">2</a>
        <br> <a href="#i-27560472-1"><span class="code">ParseResult</span> class</a>
        <br> <a href="#i-792967116-1">parsers</a>
        <br> <span class="code">Parsers</span> trait <a href="#i1073514242-1" class="totri-footnote">1</a> <a href="#i1073514242-2" class="totri-footnote">2</a>
        <br> <a href="#i773900220-1">partial functions</a>
        <br> <span class="code">PartialFunction</span> trait <a href="#i-33298553-1" class="totri-footnote">1</a> <a href="#i-33298553-2" class="totri-footnote">2</a>
        <br> partially applied functions <a href="#i1834060518-1" class="totri-footnote">1</a> <a href="#i1834060518-2" class="totri-footnote">2</a>
        <br> <span class="code">partition</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-944990523-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i4331970-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-351940047-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">partitionMap</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1135350170-1">on <span class="code">Iterable</span> traits</a>
        <br> passing arguments
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i685242324-1">to superclass a constructor</a>
        <br> <span class="code">patch</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-62511610-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1495891648-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">patchInPlace</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-71124930-1">on trait <span class="code">Buffer</span></a>
        <br> <a href="#i419165808-1">path-dependent types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1290990775-1">and inner classes</a>
        <br> <a href="#i732713786-1">Patricia tries</a>
        <br> pattern matching
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-83872229-1">and extractors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i692796846-1">in exception handling</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1817770109-1">in lists</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-591223748-1">in <span class="code">equals</span> method</a>
        <br> <a href="#i-2111106818-1">pattern guards</a>
        <br> pattern matching
        <br> &nbsp;&nbsp;&nbsp;&nbsp;constant patterns <a href="#i-612986830-1" class="totri-footnote">1</a> <a href="#i-612986830-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;constructor patterns <a href="#i-1934430442-1" class="totri-footnote">1</a> <a href="#i-1934430442-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;examples of <a href="#i1154860961-1" class="totri-footnote">1</a> <a href="#i1154860961-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1742228676-1">in <span class="code">equals</span> method</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-729007015-1">in event handling</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;in <span class="code">for</span> expressions <a href="#i-1272952554-1" class="totri-footnote">1</a> <a href="#i-1272952554-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1357014823-1">in lists</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1873919990-1">in variable definitions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-174768992-1">in-depth coverage</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1974282179-1">on XML</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1073471110-1">quick introduction</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1679405899-1">sequence patterns</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2090433336-1">tuple patterns</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i921193062-1">typed patterns</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;variable patterns <a href="#i-256060326-1" class="totri-footnote">1</a> <a href="#i-256060326-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-199464286-1">variable-binding patterns</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;wildcard patterns <a href="#i669211324-1" class="totri-footnote">1</a> <a href="#i669211324-2" class="totri-footnote">2</a>
        <br> patterns and idioms
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1224006146-1">divide and conquer principle</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1122723055-1">ensuring a resource is closed</a>
        <br> patterns and idioms
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1218979943-1">conditional initialization</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i536175291-1">functional on the outside, imperative on the inside</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;loan pattern <a href="#i850457101-1" class="totri-footnote">1</a> <a href="#i850457101-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-379989681-1">reading lines, characters, <i>etc.</i>, with <span class="code">do-while</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;rich wrappers pattern <a href="#i681737575-1" class="totri-footnote">1</a> <a href="#i681737575-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i508928486-1">using <span class="code">Option</span> not <span class="code">null</span> to indicate optional values</a>
        <br> performance
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2128194469-1">and multi-core processors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1597641046-1">of collection types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1751980831-1">of Scala compared to Java</a>
        <br> Perl language <a href="#i389811529-1" class="totri-footnote">1</a> <a href="#i389811529-2" class="totri-footnote">2</a>
        <br> <a href="#i-1058604016-1">Pizza language</a>
        <br> placeholder syntax
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1194775874-1">in wildcards</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;in function literals <a href="#i603770043-1" class="totri-footnote">1</a> <a href="#i603770043-2" class="totri-footnote">2</a>
        <br> <a href="#i383911262-1">PLT-Scheme language</a>
        <br> pointers, <i>see</i> references
        <br> <a href="#i63796807-1">polymorphism</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1510488017-1">and type inference</a>
        <br> postconditions, <i>see</i> <span class="code">ensuring</span> method
        <br> <a href="#i797797395-1">postfix operator notation</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i483675481-1">pre-initialized fields</a>
        <br> precedence, operator <a href="#i2084616098-1" class="totri-footnote">1</a> <a href="#i2084616098-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1002965951-1">table of</a>
        <br> <a href="#i1294809499-1">preconditions</a>
        <br> <span class="code">Predef</span> object
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1008284442-1"><span class="code">???</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">assert</span> <a href="#i-176392533-1" class="totri-footnote">1</a> <a href="#i-176392533-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i385195690-1"><span class="code">classOf</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i538992544-1"><span class="code">ensuring</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-783142358-1"><span class="code">println</span></a>
        <br> <a href="#i1160678812-1">predicates</a>
        <br> <a href="#i711311856-1">prefix operator notation</a>
        <br> <a href="#i2081307927-1">primary constructors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1528003040-1">private</a>
        <br> <a href="#i-1876955136-1">primitive types</a>
        <br> <span class="code">private</span> modifier
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i835454125-1">and inner classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i488929967-1">augmented with qualifiers, <i>i.e.</i>, <span class="code">private[meeting]</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1579182668-1">granting access to private members of inner classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-107999758-1">in modules</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1909160422-1">object-private access with <span class="code">private[this]</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1958480308-1">on constructors</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on fields <a href="#i1692219636-1" class="totri-footnote">1</a> <a href="#i1692219636-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1558980393-1">on methods</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-23781736-1">on parametric fields</a>
        <br> <a href="#i408410112-1">procedures</a>
        <br> <a href="#i479175681-1">processed string literals</a>
        <br> <span class="code">product</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i950003322-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i232754809-1">on trait <span class="code">Iterator</span></a>
        <br> programming style
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i341176230-1">imperative</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1528987536-1">modular</a>
        <br> <a href="#i-915286664-1">programming in the large</a>
        <br> <a href="#i-908480700-1">programming in the small</a>
        <br> programming style
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1837133869-1">functional</a>
        <br> <a href="#i515731113-1"><span class="code">Promise</span> trait</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i689370776-1"><span class="code">completeWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i172934974-1"><span class="code">complete</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i726772761-1"><span class="code">failure</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2130471540-1"><span class="code">future</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1996854080-1"><span class="code">success</span></a>
        <br> <a href="#i341209608-1">pronunciation of Scala</a>
        <br> properties <a href="#i-926053069-1" class="totri-footnote">1</a> <a href="#i-926053069-2" class="totri-footnote">2</a> <a href="#i-926053069-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1721532539-1">verifiable with static typing</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-711542007-1"><span class="code">protected</span> modifier</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1026131843-1">on parametric fields</a>
        <br> <a href="#i807441147-1">public access</a>
        <br> <a href="#i-843595300-1"><span class="code">Publisher</span> trait</a>
        <br> <span class="code">put</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-254405943-1">on trait <span class="code">mutable.Map</span></a>
        <br> <span class="code">putIfAbsent</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-432133008-1">on trait <span class="code">ConcurrentMap</span></a>
        <br> Python language <a href="#i-1190645252-1" class="totri-footnote">1</a> <a href="#i-1190645252-2" class="totri-footnote">2</a>
        <br>
        <h3 id="iiq" class="indexh3">Q</h3> <a href="#i-705909367-1"><span class="code">Queue</span> class</a>
        <br>
        <h3 id="iir" class="indexh3">R</h3> <span class="code">r</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-208750214-1">on class <span class="code">String</span> (via <span class="code">StringOps)</span></a>
        <br> <span class="code">range</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-835498927-1">on <span class="code">Iterable</span> objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2103556958-1">on object <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i648409480-1">on object <span class="code">List</span></a>
        <br> <a href="#i608338568-1">ranges, of basic types</a>
        <br> <a href="#i-2113209218-1"><span class="code">raw</span> string interpolator</a>
        <br> <a href="#i1433882250-1">raw strings</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2061400628-1">in regular expressions</a>
        <br> raw types (Java) <a href="#i414933374-1" class="totri-footnote">1</a> <a href="#i414933374-2" class="totri-footnote">2</a>
        <br> Raymond, Eric <a href="#i-1761921411-1" class="totri-footnote">1</a> <a href="#i-1761921411-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">reactions</span> property
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-49046473-1">on <span class="code">Reactor</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1242645043-1">on <span class="code">Reactor</span></a>
        <br> <a href="#i-1549919358-1"><span class="code">Reactor</span> trait</a>
        <br> <a href="#i1984859131-1"><span class="code">Reader</span> class</a>
        <br> reading
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-504023058-1">from standard input with <span class="code">do-while</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i855616002-1">lines from a file</a>
        <br> <span class="code">receive</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1209206976-1">on trait <span class="code">Actor</span></a>
        <br> recommended style, <i>see</i> style recommendations
        <br> <span class="code">recover</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-152382784-1">on trait <span class="code">Future</span></a>
        <br> <span class="code">recoverWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1242555994-1">on trait <span class="code">Future</span></a>
        <br> recursion, <i>see</i> recursion
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i999036029-1">in combinator parsers</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1651241320-1">tail</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2022023743-1">optimization</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-981382311-1">using <span class="code">ListBuffer</span> to prevent stack overflow</a>
        <br> <span class="code">reduceLeft</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2086106882-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1370613055-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-723508460-1">on trait <span class="code">Iterator</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">reduceLeft</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-465887423-1">on object <span class="code">Future</span></a>
        <br> <span class="code">reduceRight</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1161010399-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2104320242-1">on trait <span class="code">Iterator</span></a>
        <br> refactoring
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1149458246-1">and static typing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i204271861-1">and <span class="code">val</span>s</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i892284799-1">imperative to functional style</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i532436688-1">reducing code duplication with closures</a>
        <br> reference
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1054988553-1">classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-396510763-1">definition of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;equality <a href="#i1544052809-1" class="totri-footnote">1</a> <a href="#i1544052809-2" class="totri-footnote">2</a> <a href="#i1544052809-3" class="totri-footnote">3</a>
        <br> <a href="#i-1825668081-1">referential transparency</a>
        <br> <a href="#i532730212-1">refinement types</a>
        <br> <a href="#i-1366299605-1">reflection</a>
        <br> <a href="#i78839847-1"><span class="code">Regex</span> class</a>
        <br> <span class="code">regex</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i961731205-1">on trait <span class="code">RegexParsers</span></a>
        <br> <span class="code">RegexParsers</span> trait <a href="#i519257659-1" class="totri-footnote">1</a> <a href="#i519257659-2" class="totri-footnote">2</a> <a href="#i519257659-3" class="totri-footnote">3</a>
        <br> <a href="#i1678705239-1">regular expressions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;as parsers <a href="#i-2139156663-1" class="totri-footnote">1</a> <a href="#i-2139156663-2" class="totri-footnote">2</a>
        <br> relational operations (<span class="code">&gt;</span>, <span class="code">&lt;</span>, <span class="code">&gt;=</span>, <span class="code">&lt;=</span>)
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1517365894-1">on numeric types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i795809807-1">on trait <span class="code">Ordered</span></a>
        <br> <span class="code">remove</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1676197778-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-573548081-1">on trait <span class="code">ConcurrentMap</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1270433470-1">on trait <span class="code">mutable.Map</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1270439364-1">on trait <span class="code">mutable.Set</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on trait <span class="code">Buffer</span> <a href="#i-1233111692-1" class="totri-footnote">1</a> <a href="#i-1233111692-2" class="totri-footnote">2</a>
        <br> <span class="code">rendererComponent</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1871849869-1">on class <span class="code">Table</span></a>
        <br> <span class="code">rep</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i476382634-1">on trait <span class="code">Parsers</span></a>
        <br> repeated parameters <a href="#i-1544402352-1" class="totri-footnote">1</a> <a href="#i-1544402352-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1018791428-1">vararg matching</a>
        <br> <span class="code">replace</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-400154625-1">on trait <span class="code">ConcurrentMap</span></a>
        <br> <a href="#i886727311-1">representation independence</a>
        <br> <span class="code">repsep</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1251140526-1">on trait <span class="code">Parsers</span></a>
        <br> <span class="code">require</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2113140869-1">on object <span class="code">Predef</span></a>
        <br> resources, ensuring release of <a href="#i193663324-1" class="totri-footnote">1</a> <a href="#i193663324-2" class="totri-footnote">2</a>
        <br> <a href="#i-595246755-1">result type</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-921885027-1">covariance of</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-2127509767-1"><span class="code">return</span> keyword</a>
        <br> <a href="#i-1544421334-1">return type</a>
        <br> returning multiple values <a href="#i2120520132-1" class="totri-footnote">1</a> <a href="#i2120520132-2" class="totri-footnote">2</a>
        <br> <span class="code">reverse</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i1817641200-1" class="totri-footnote">1</a> <a href="#i1817641200-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i162887596-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">reverseIterator</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1214590498-1">on <span class="code">Seq</span> traits</a>
        <br> rich wrappers pattern <a href="#i807731316-1" class="totri-footnote">1</a> <a href="#i807731316-2" class="totri-footnote">2</a>
        <br> <span class="code">RichInt</span> class, <i>see</i> <span class="code">Int</span> class
        <br> <span class="code">rowHeaderView</span> property
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1248398867-1">on class <span class="code">ScrollPane</span></a>
        <br> Ruby language <a href="#i-1999895874-1" class="totri-footnote">1</a> <a href="#i-1999895874-2" class="totri-footnote">2</a> <a href="#i-1999895874-3" class="totri-footnote">3</a>
        <br> <a href="#i-1072078781-1">Rumbaugh, James</a>
        <br> running a Scala program, <i>see</i> <span class="code">scala</span>
        <br> <a href="#i-901220338-1">runtime type, definition of</a>
        <br>
        <h3 id="iis" class="indexh3">S</h3> <a href="#i1290088777-1"><span class="code">s</span> string interpolator</a>
        <br> SAM types, <i>see</i> single abstract method types
        <br> <span class="code">sameElements</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2017721464-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-278620245-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">save</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2053547351-1">on XML</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> Scala language
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2092005582-1">compiling</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2079231610-1">scalability of</a>
        <br> <span class="code">scala</span> (Scala launcher)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1944711780-1">to launch applications</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1342830375-1">to launch scripts</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1638768746-1">to launch the interpreter</a>
        <br> Scala language
        <br> &nbsp;&nbsp;&nbsp;&nbsp;2.12 release <a href="#i88737196-1" class="totri-footnote">1</a> <a href="#i88737196-2" class="totri-footnote">2</a> <a href="#i88737196-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i695215832-1">class hierarchy diagram</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1157110682-1">compatibility with Java</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;compatibility with Java <a href="#i1128780868-1" class="totri-footnote">1</a> <a href="#i1128780868-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;compiling
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i18472490-1">with Java</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1605476771-1">conciseness versus Java</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i840520690-1">downloading</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1715822447-1">IDEs</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1148185415-1">influences on</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2032368478-1">interpreter shell</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i982997419-1">naming of source files</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-269622320-1">pronunciation of "Scala"</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;scalability of <a href="#i741587120-1" class="totri-footnote">1</a> <a href="#i741587120-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;scripts, <i>see</i> scripts, Scala
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1552805019-1">specification</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> Scala.js <a href="#i-827373807-1" class="totri-footnote">1</a> <a href="#i-827373807-2" class="totri-footnote">2</a>
        <br> scalability
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-578074568-1">of configuration</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;of Scala language <a href="#i-885663216-1" class="totri-footnote">1</a> <a href="#i-885663216-2" class="totri-footnote">2</a> <a href="#i-885663216-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1145716472-1">of teams</a>
        <br> <a href="#i-674656853-1"><span class="code">scalac</span> (Scala compiler)</a>
        <br> ScalaCheck <a href="#i-517954686-1" class="totri-footnote">1</a> <a href="#i-517954686-2" class="totri-footnote">2</a>
        <br> <a href="#i-827321774-1">Scaladoc</a>
        <br> ScalaTest <a href="#i122343128-1" class="totri-footnote">1</a> <a href="#i122343128-2" class="totri-footnote">2</a>
        <br> <a href="#i-693168286-1">scanner generators</a>
        <br> <a href="#i1475575635-1">Scheme language</a>
        <br> scope
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1011304421-1">of implicit conversions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-250564140-1">of variables</a>
        <br> scripts, Scala <a href="#i1047419434-1" class="totri-footnote">1</a> <a href="#i1047419434-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i345477272-1">running on Unix</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1287204493-1">running on Windows</a>
        <br> <span class="code">ScrollPane</span> class <a href="#i870227341-1" class="totri-footnote">1</a> <a href="#i870227341-2" class="totri-footnote">2</a>
        <br> <a href="#i-975567006-1">sealed classes</a>
        <br> <span class="code">sealed</span> modifier <a href="#i-1485759717-1" class="totri-footnote">1</a> <a href="#i-1485759717-2" class="totri-footnote">2</a>
        <br> <span class="code">search</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Seq</span> traits <a href="#i-1353253722-1" class="totri-footnote">1</a> <a href="#i-1353253722-2" class="totri-footnote">2</a>
        <br> <span class="code">segmentLength</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1262494987-1">on <span class="code">Seq</span> traits</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> selectors
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-451801752-1">in <span class="code">match</span> expressions</a>
        <br> <a href="#i-1172048805-1">selectors, in imports</a>
        <br> <a href="#i979629307-1">self types</a>
        <br> <a href="#i423816156-1">self references</a>
        <br> self types <a href="#i1609470629-1" class="totri-footnote">1</a> <a href="#i1609470629-2" class="totri-footnote">2</a>
        <br> <a href="#i-408699718-1">semi-structured data</a>
        <br> <a href="#i794983274-1">semicolon inference</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-615670524-1">turning off</a>
        <br> seq
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-36026129-1">factory</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2004738302-1">members</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1842939016-1">passing elements as arguments with <span class="code">_*</span></a>
        <br> <a href="#i-161349850-1"><span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1188392303-1"><span class="code">++:</span> (prependedAll)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1318634927-1"><span class="code">+:</span> (prepended)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1848561691-1"><span class="code">:+</span> (appended)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2107222009-1"><span class="code">:++</span> (appendedAll)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i540215378-1"><span class="code">apply</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1433463109-1"><span class="code">contains</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1699558295-1"><span class="code">containsSlice</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2021984280-1"><span class="code">corresponds</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i433150625-1"><span class="code">diff</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-577319016-1"><span class="code">distinct</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-752791025-1"><span class="code">distinctBy</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i877141114-1"><span class="code">endsWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2102517203-1"><span class="code">indexOf</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1348829029-1"><span class="code">indexOfSlice</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1720598737-1"><span class="code">indexWhere</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2102417525-1"><span class="code">indices</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-573712381-1"><span class="code">intersect</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i251040758-1"><span class="code">isDefinedAt</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-115105609-1"><span class="code">lastIndexOf</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1993636069-1"><span class="code">lastIndexOfSlice</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1000272893-1"><span class="code">lengthCompare</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i553609042-1"><span class="code">padTo</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i553624876-1"><span class="code">patch</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1349004998-1"><span class="code">reverse</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1415678636-1"><span class="code">reverseIterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">search</span> <a href="#i71531844-1" class="totri-footnote">1</a> <a href="#i71531844-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1801931555-1"><span class="code">segmentLength</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i81274417-1"><span class="code">sortBy</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i81275481-1"><span class="code">sorted</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i795917344-1"><span class="code">sortWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-574339501-1"><span class="code">startsWith</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i139022437-1"><span class="code">update</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i14728351-1"><span class="code">updated</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">sequence</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1604674187-1">on object <span class="code">Future</span></a>
        <br> <a href="#i1331042402-1">sequence patterns</a>
        <br> <a href="#i-534731536-1"><span class="code">serializable</span> annotation</a>
        <br> serialization
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1448460597-1">binary</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-426160987-1">to and from XML</a>
        <br> <a href="#i-1236272573-1"><span class="code">SerialVersionUID</span> annotation</a>
        <br> set
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i877342209-1">members</a>
        <br> <span class="code">Set</span> objects <a href="#i1868251958-1" class="totri-footnote">1</a> <a href="#i1868251958-2" class="totri-footnote">2</a>
        <br> <span class="code">Set</span> traits, <i>see</i> sets
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1766692446-1"><span class="code">add</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1277269234-1"><span class="code">clear</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1277259234-1"><span class="code">clone</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i924843454-1"><span class="code">contains</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1067203364-1"><span class="code">diff</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1275381234-1"><span class="code">empty</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i619455499-1"><span class="code">filterInPlace</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-480652960-1"><span class="code">intersect</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-517415965-1"><span class="code">remove</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-569252040-1"><span class="code">subsetOf</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1260582000-1"><span class="code">union</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-421651416-1"><span class="code">update</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i562147141-1"><span class="code">| </span> (union)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1861524116-1"><span class="code">&amp;<span class="code"><span style="font-size:large">~</span></span></span> (diff)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1830753682-1"><span class="code">&amp;</span> (intersect)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1254892180-1"><span class="code">++=</span> (add elements to)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1209846120-1"><span class="code">+=</span> (add element to)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1485797315-1"><span class="code">—=</span> (remove elements from)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i640851374-1"><span class="code">—</span> (remove elements)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-282687116-1"><span class="code">-=</span> (remove element from)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1593467087-1"><span class="code">-</span> (remove element)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i129531150-1"><span class="code">++</span> (add elements)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1858879238-1"><span class="code">+</span> (add element)</a>
        <br> <a href="#i576449790-1"><span class="code">SetOps</span> trait</a>
        <br> sets <a href="#i3526737-1" class="totri-footnote">1</a> <a href="#i3526737-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-906912898-1">and generic types</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1161517801-1">class hierarchy diagram</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1277661430-1">creating and initializing immutable</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-875218022-1">creating and initializing mutable</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-472072085-1">mutability modeled in hierarchy</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i51742212-1">table of methods</a>
        <br> setter methods <a href="#i553650449-1" class="totri-footnote">1</a> <a href="#i553650449-2" class="totri-footnote">2</a> <a href="#i553650449-3" class="totri-footnote">3</a> <a href="#i553650449-4" class="totri-footnote">4</a>
        <br> <a href="#i1857790361-1">shadowing variables</a>
        <br> <a href="#i1837693870-1">shared data and locks</a>
        <br> <a href="#i-162949284-1">shell, Scala interpreter</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> shift operations (<span class="code">&lt;&lt;</span>, <span class="code">&gt;&gt;</span>, <span class="code">&gt;&gt;&gt;</span>)
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1037331510-1">on integral types</a>
        <br> <a href="#i682407483-1">short circuiting, of logical operations</a>
        <br> <a href="#i1149344948-1"><span class="code">Short</span> class</a>
        <br> side effects <a href="#i18918201-1" class="totri-footnote">1</a> <a href="#i18918201-2" class="totri-footnote">2</a> <a href="#i18918201-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i255589052-1">minimizing</a>
        <br> <span class="code">SimpleSwingApplication</span> class <a href="#i980116412-1" class="totri-footnote">1</a> <a href="#i980116412-2" class="totri-footnote">2</a>
        <br> <a href="#i1623537733-1">Simula language</a>
        <br> <a href="#i701753824-1">single abstract method types</a>
        <br> singleton objects
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1060016990-1">as modules</a>
        <br> <a href="#i-1742889473-1">singleton objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-855208314-1">as seen from Java</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i181822064-1">in testing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1357897992-1">initialization semantics</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1315254152-1">nesting of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i164593921-1">shown with rounded corners in hierarchy diagrams</a>
        <br> singleton types <a href="#i-108236764-1" class="totri-footnote">1</a> <a href="#i-108236764-2" class="totri-footnote">2</a>
        <br> <span class="code">size</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-717658356-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-217240950-1">on <span class="code">Set</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i178959271-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">sizeCompare</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1999564049-1">on <span class="code">Iterable</span> traits</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">sizeIs</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i4578198-1">on <span class="code">Iterable</span> traits</a>
        <br> <span class="code">slice</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1840578211-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i281283382-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">sliding</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2085639431-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i966114842-1">on trait <span class="code">Iterator</span></a>
        <br> Smalltalk language <a href="#i-817657147-1" class="totri-footnote">1</a> <a href="#i-817657147-2" class="totri-footnote">2</a>
        <br> <a href="#i-175084922-1">SML language</a>
        <br> <a href="#i3535215-1">snoc</a>
        <br> <a href="#i-747501716-1"><span class="code">Some</span> class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-467709668-1">in extractors</a>
        <br> sort
        <br> &nbsp;&nbsp;&nbsp;&nbsp;insertion <a href="#i132601811-1" class="totri-footnote">1</a> <a href="#i132601811-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1435795620-1">merge</a>
        <br> <span class="code">sort</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i532902316-1">on class <span class="code">List</span></a>
        <br> <span class="code">sortBy</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-544663079-1">on <span class="code">Seq</span> traits</a>
        <br> <span class="code">sorted</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-78070095-1">on <span class="code">Seq</span> traits</a>
        <br> <a href="#i1172619245-1"><span class="code">SortedMap</span> trait</a>
        <br> <a href="#i-159573855-1"><span class="code">SortedMapOps</span> trait</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i849148531-1"><span class="code">SortedSet</span> trait</a>
        <br> <a href="#i1230997595-1"><span class="code">SortedSetOps</span> trait</a>
        <br> <span class="code">sortInPlace</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i339044395-1">on <span class="code">mutable.IndexedSeq</span> traits</a>
        <br> <span class="code">sortInPlaceBy</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1619195938-1">on <span class="code">mutable.IndexedSeq</span> traits</a>
        <br> <span class="code">sortInPlaceWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i420429841-1">on <span class="code">mutable.IndexedSeq</span> traits</a>
        <br> <span class="code">sortWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i866528360-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1923205194-1">on <span class="code">Seq</span> traits</a>
        <br> source code, downloading, <i>see</i> example code
        <br> <a href="#i-1061147639-1">source files, naming of</a>
        <br> <a href="#i835817156-1"><span class="code">Source</span> object</a>
        <br> <span class="code">span</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i772550245-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1964828318-1">on <span class="code">Iterable</span> traits</a>
        <br> <a href="#i-2078710284-1"><span class="code">SpecificIterableFactory</span> trait</a>
        <br> specifiers, access, <i>see</i> access modifiers
        <br> specs2 <a href="#i-896072934-1" class="totri-footnote">1</a> <a href="#i-896072934-2" class="totri-footnote">2</a>
        <br> <span class="code">split</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-456038910-1">on class <span class="code">String</span></a>
        <br> <span class="code">splitAt</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-567585630-1">on class <span class="code">List</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1809798433-1">on <span class="code">Iterable</span> traits</a>
        <br> <a href="#i-1325982169-1">spreadsheets</a>
        <br> <a href="#i872568577-1">Spring Framework</a>
        <br> <a href="#i844238763-1">Spring Framework</a>
        <br> stack, the
        <br> &nbsp;&nbsp;&nbsp;&nbsp;and tail-recursive functions <a href="#i10962622-1" class="totri-footnote">1</a> <a href="#i10962622-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2050330638-1">and thrown exceptions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-243919082-1">and variables captured by closures</a>
        <br> <a href="#i-590612839-1">stackable modifications</a>
        <br> <a href="#i1731800121-1">standalone objects</a>
        <br> <a href="#i517167387-1">standard error stream</a>
        <br> <span class="code">startsWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2129701641-1">on <span class="code">Seq</span> traits</a>
        <br> statements
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1115343227-1">multiple-line</a>
        <br> <a href="#i-1455692441-1">static members</a>
        <br> <a href="#i587655017-1">static typing</a>
        <br> Steele, Guy <a href="#i1916394333-1" class="totri-footnote">1</a> <a href="#i1916394333-2" class="totri-footnote">2</a>
        <br> <span class="code">Stream</span> interface
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1435343948-1">in Java 8</a>
        <br> <a href="#i-112375106-1">strict collections</a>
        <br> <a href="#i-1210707408-1"><span class="code">StrictOptimizedIterableOps</span> trait</a>
        <br> <a href="#i-1818148641-1"><span class="code">StrictOptimizedSeqOps</span> trait</a>
        <br> <a href="#i-1230806839-1"><span class="code">String</span> class</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1128222747-1"><span class="code">r</span> (via <span class="code">StringOps)</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1176903119-1"><span class="code">stripMargin</span> (via <span class="code">StringOps</span>)</a>
        <br> <a href="#i-2123413502-1"><span class="code">StringBuilder</span> class</a>
        <br> <span class="code">stringLiteral</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-826062925-1">in trait <span class="code">JavaTokenParsers</span></a>
        <br> <a href="#i84163557-1"><em>stringly typed</em> code</a>
        <br> <span class="code">StringOps</span> class, <i>see also</i> <span class="code">String</span> class <a href="#i1341725017-1" class="totri-footnote">1</a> <a href="#i1341725017-2" class="totri-footnote">2</a>
        <br> strings
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1886523229-1">formatting</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1883760226-1">interpolated (processed)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1394554846-1">iterating through the characters of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;literals <a href="#i1349528476-1" class="totri-footnote">1</a> <a href="#i1349528476-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i943241332-1">long</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;raw <a href="#i-1493588176-1" class="totri-footnote">1</a> <a href="#i-1493588176-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-260905957-1">treating as a sequence (via <span class="code">WrappedString</span>)</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;treating like a sequence (via <span class="code">StringOps</span>) <a href="#i-1007334645-1" class="totri-footnote">1</a> <a href="#i-1007334645-2" class="totri-footnote">2</a>
        <br> <a href="#i1855899700-1">structural subtyping</a>
        <br> <a href="#i-72492243-1"><em>Structure and Interpretation of Computer Programs</em> (Abelson, <i>et. al.</i>)</a>
        <br> style recommendations
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i27050837-1">prefer alphabetic names unless symbolic names have established meaning</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-516778869-1">prefer classes to tuples when data combination has meaning</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1618156815-1">prefer <span class="code">val</span>s, immutable objects, and methods without side effects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-506868082-1">use implicit conversions with restraint</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> subclasses
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-8484895-1">and <span class="code">equals</span> method</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1485346100-1">defining</a>
        <br> <span class="code">subsetOf</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i12573170-1">on <span class="code">Set</span> traits</a>
        <br> subtyping
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1780437500-1">and type parameters</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1419394611-1">nominal vs. structural</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-155377413-1">versus subclassing</a>
        <br> <a href="#i367948816-1">subtyping polymorphism</a>
        <br> <a href="#i240639739-1"><span class="code">Success</span> class</a>
        <br> <span class="code">success</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-623661142-1">on trait <span class="code">Promise</span></a>
        <br> <span class="code">successful</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1310847346-1">on object <span class="code">Future</span></a>
        <br> <span class="code">sum</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i993696982-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-735667043-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">super</span> references
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-718179772-1">special treatment in traits</a>
        <br> <a href="#i1436252235-1">superclasses</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2005725727-1">invoking constructor on</a>
        <br> <a href="#i-331888331-1">supertype</a>
        <br> Sussman, Gerald J. <a href="#i-1712702061-1" class="totri-footnote">1</a> <a href="#i-1712702061-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> Swing <a href="#i80301790-1" class="totri-footnote">1</a> <a href="#i80301790-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1673765513-1"><span class="code">EmptyBorder</span></a>
        <br> <a href="#i-1502876100-1"><span class="code">switch</span> statement (Java)</a>
        <br> <a href="#i386345772-1">symbol literals</a>
        <br> <a href="#i760884015-1">symbolic versus alphabetic names</a>
        <br> <a href="#i1779690801-1">syntactical analysis</a>
        <br>
        <h3 id="iit" class="indexh3">T</h3> <span class="code">Table</span> class <a href="#i455478918-1" class="totri-footnote">1</a> <a href="#i455478918-2" class="totri-footnote">2</a>
        <br> <a href="#i1392790829-1"><span class="code">TableUpdated</span> class</a>
        <br> <span class="code">tabulate</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-243454893-1">on <span class="code">Iterable</span> objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1627924214-1">on object <span class="code">List</span></a>
        <br> <a href="#i-1699783286-1">tags, XML</a>
        <br> <a href="#i-2133336344-1">tail recursion</a>
        <br> <span class="code">tail</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">List</span> <a href="#i849842526-1" class="totri-footnote">1</a> <a href="#i849842526-2" class="totri-footnote">2</a> <a href="#i849842526-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i515696283-1">on <span class="code">Iterable</span> traits</a>
        <br> tail recursion <a href="#i2133301138-1" class="totri-footnote">1</a> <a href="#i2133301138-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i46846037-1">optimization</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2131054531-1">turning off with <span class="code">notailcalls</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i726527906-1">verifying with <span class="code">@tailrec</span></a>
        <br> <a href="#i-135595761-1"><span class="code">tailrec</span> annotation</a>
        <br> <span class="code">take</span> method
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i425822536-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1283969285-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1767548558-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">takeRight</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1293058080-1">on <span class="code">Iterable</span> traits</a>
        <br> <span class="code">takeWhile</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-334215483-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2060831170-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-147054031-1">on trait <span class="code">Iterator</span></a>
        <br> <a href="#i-1884158234-1">target typing</a>
        <br> <a href="#i-1722035434-1">template, definition of</a>
        <br> <a href="#i1045501329-1">term, in function literals</a>
        <br> <span class="code">Test</span> annotation
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-380372540-1">in JUnit 4</a>
        <br> <a href="#i-318258231-1">test suites</a>
        <br> testing <a href="#i-1422446064-1" class="totri-footnote">1</a> <a href="#i-1422446064-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i324568938-1">integration</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i808305838-1">unit</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1006990674-1">with mock objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i534212600-1">with singletons</a>
        <br> <a href="#i1739516731-1"><span class="code">Text</span> class</a>
        <br> <span class="code">text</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-620325929-1">on class <span class="code">Node</span></a>
        <br> <a href="#i-892340276-1">text processing in XML</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-891684874-1">text processing in XML</a>
        <br> <a href="#i942981037-1"><span class="code">TextField</span> class</a>
        <br> <a href="#i-107465203-1"><em>Thinking in Java</em> (Eckel)</a>
        <br> <a href="#i3559070-1"><span class="code">this</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i198894-1">aliasing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1139406016-1">and self types</a>
        <br> <a href="#i44952225-1"><span class="code">throw</span> expressions</a>
        <br> <a href="#i-1229583646-1"><span class="code">throws</span> annotation</a>
        <br> <a href="#i1646427993-1">tiny types</a>
        <br> <span class="code">to</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">Int</span> (via <span class="code">RichInt</span>) <a href="#i574171488-1" class="totri-footnote">1</a> <a href="#i574171488-2" class="totri-footnote">2</a> <a href="#i574171488-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1004785832-1">on collections</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i774377734-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1889657453-1">on trait <span class="code">Iterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1722437569-1">on views</a>
        <br> <span class="code">toArray</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1473690452-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1609624215-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-681097814-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">toChar</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1927236622-1">on class <span class="code">Int</span></a>
        <br> <span class="code">toIndexedSeq</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1069759596-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i721790495-1">on trait <span class="code">Iterator</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">toInt</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2133819883-1">on class <span class="code">String</span> (via <span class="code">StringOps)</span></a>
        <br> <span class="code">toIterable</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1067113496-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1426035429-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">toList</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-330065859-1">on class <span class="code">ListBuffer</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">Array</span> <a href="#i-1723195748-1" class="totri-footnote">1</a> <a href="#i-1723195748-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1804214425-1">on class <span class="code">ListBuffer</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1203752644-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i240940271-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">toMap</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1185515540-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-667416889-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">top</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1222409213-1">on class <span class="code">SimpleSwingApplication</span></a>
        <br> <a href="#i774197993-1">Torreborre, Eric</a>
        <br> <span class="code">toSeq</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1379204817-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1681639716-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">toSet</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1505637234-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1774699137-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">toString</span> method <a href="#i-720005867-1" class="totri-footnote">1</a> <a href="#i-720005867-2" class="totri-footnote">2</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i811694371-1">generated for case classes</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1787342122-1">on class <span class="code">Any</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-189935346-1">overriding</a>
        <br> total function, <i>see</i> complete function
        <br> traits, <i>see also</i> mixin composition <a href="#i-865710043-1" class="totri-footnote">1</a> <a href="#i-865710043-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1371895904-1">and abstract parameters</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1983011802-1">and Java interfaces</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1756036738-1">annotating</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;generic <a href="#i1530367874-1" class="totri-footnote">1</a> <a href="#i1530367874-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-280981118-1">initializing</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1595934381-1">linearization of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1672969622-1">mixing in</a>
        <br> <span class="code">transform</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1345650888-1">on trait <span class="code">Future</span></a>
        <br> <a href="#i-1856481670-1">transformers</a>
        <br> <span class="code">transformWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-488373330-1">on trait <span class="code">Future</span></a>
        <br> <a href="#i875595397-1"><span class="code">transient</span> annotation</a>
        <br> <span class="code">traverse</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1636098202-1">on object <span class="code">Future</span></a>
        <br> <a href="#i623901590-1"><span class="code">TreeMap</span> class</a>
        <br> <a href="#i300430876-1"><span class="code">TreeSet</span> class</a>
        <br> <a href="#i2026030746-1"><span class="code">TrieMap</span> class</a>
        <br> <span class="code">trimEnd</span> method
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1472686271-1">on trait <span class="code">Buffer</span></a>
        <br> <span class="code">trimStart</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1528855016-1">on trait <span class="code">Buffer</span></a>
        <br> <a href="#i1304901727-1"><span class="code">true</span> value</a>
        <br> <a href="#i634201779-1"><span class="code">Try</span> class</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i532116857-1">class hierarchy diagram</a>
        <br> <a href="#i147418614-1"><span class="code">try</span> expressions</a>
        <br> <a href="#i-1134485445-1">tuple patterns</a>
        <br> <a href="#i-862490197-1">tuples</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2050968957-1">creating and using</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-188293365-1">one-based element access</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-316383483-1">result of <span class="code">-&gt;</span> operation</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-726189942-1">when to use a class instead</a>
        <br> <a href="#i1905256393-1">type constructors</a>
        <br> <a href="#i-940554758-1">type parameters</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1770535476-1">lower bounds</a>
        <br> type aliases <a href="#i22781976-1" class="totri-footnote">1</a> <a href="#i22781976-2" class="totri-footnote">2</a> <a href="#i22781976-3" class="totri-footnote">3</a>
        <br> type annotations <a href="#i1449766718-1" class="totri-footnote">1</a> <a href="#i1449766718-2" class="totri-footnote">2</a> <a href="#i1449766718-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2128117477-1">for debugging</a>
        <br> type casts, <i>see</i> casting
        <br> type constructors <a href="#i-254642465-1" class="totri-footnote">1</a> <a href="#i-254642465-2" class="totri-footnote">2</a>
        <br> <a href="#i-557245309-1">type erasure</a>
        <br> type inference <a href="#i-219390285-1" class="totri-footnote">1</a> <a href="#i-219390285-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i281902151-1">Hindley-Milner style</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2147374841-1">the algorithm</a>
        <br> <span class="code">type</span> keyword
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1431142691-1">in singleton types, such as <span class="code">db.type</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;in type alias definitions <a href="#i-1569140754-1" class="totri-footnote">1</a> <a href="#i-1569140754-2" class="totri-footnote">2</a>
        <br> <a href="#i1886198323-1">type members</a>
        <br> type parameterization, <i>see</i> parameterized types
        <br> <a href="#i-1818778992-1">type parameters</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-370701594-1">in parser results</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1036774557-1">upper bounds</a>
        <br> type tests
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-316974287-1">with <span class="code">isInstanceOf</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1486257235-1">with typed patterns (preferred style)</a>
        <br> <a href="#i819829841-1">type-driven design</a>
        <br> <a href="#i1877140953-1">typed patterns</a>
        <br> types
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-332843517-1">abstract</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1885936564-1">bottom</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i101369192-1">erasure</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1515783126-1">generic</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1740168280-1">ground</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1430360982-1">in <span class="code">for</span> expressions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1495655539-1">integral</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-404482804-1">numeric</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2033041288-1">path-dependent</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1448312026-1">primitive</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-378070292-1">refinement</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1437134274-1">result</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1437104303-1">return</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1148073513-1">runtime</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;self <a href="#i-560124499-1" class="totri-footnote">1</a> <a href="#i-560124499-2" class="totri-footnote">2</a> <a href="#i-560124499-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1108021686-1">singleton</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1395189617-1">static</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;wildcard <a href="#i1056209851-1" class="totri-footnote">1</a> <a href="#i1056209851-2" class="totri-footnote">2</a>
        <br> typing
        <br> &nbsp;&nbsp;&nbsp;&nbsp;dynamic <a href="#i716433724-1" class="totri-footnote">1</a> <a href="#i716433724-2" class="totri-footnote">2</a> <a href="#i716433724-3" class="totri-footnote">3</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1417392593-1">static</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1428968692-1">target</a>
        <br>
        <h3 id="iiu" class="indexh3">U</h3> <a href="#i-601321358-1">Ullman, Jeffrey</a>
        <br> <span class="code">unapply</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1869714895-1">in extractors</a>
        <br> <span class="code">unapplySeq</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1953385690-1">in extractors</a>
        <br> unary operations <a href="#i-1088310403-1" class="totri-footnote">1</a> <a href="#i-1088310403-2" class="totri-footnote">2</a>
        <br> <span class="code">unchecked</span> annotation <a href="#i-2035290207-1" class="totri-footnote">1</a> <a href="#i-2035290207-2" class="totri-footnote">2</a> <a href="#i-2035290207-3" class="totri-footnote">3</a> <a href="#i-2035290207-4" class="totri-footnote">4</a>
        <br> <span class="code">unfold</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2013412692-1">on <span class="code">Iterable</span> objects</a>
        <br> <a href="#i1377637053-1">Unicode</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-1488083405-1"><em>Unified Modeling Language Reference Manual, The</em> (Rumbaugh, <i>et. al.</i>)</a>
        <br> <a href="#i758262274-1">uniform access principle</a>
        <br> <span class="code">union</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1056923524-1">on <span class="code">Set</span> traits</a>
        <br> <a href="#i-1581694980-1"><span class="code">Unit</span> class</a>
        <br> unit testing <a href="#i-2030836876-1" class="totri-footnote">1</a> <a href="#i-2030836876-2" class="totri-footnote">2</a> <a href="#i-2030836876-3" class="totri-footnote">3</a>
        <br> <a href="#i737037269-1">unit value</a>
        <br> <a href="#i38834278-1">unnamed package</a>
        <br> <span class="code">until</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on class <span class="code">Int</span> (via <span class="code">RichInt</span>) <a href="#i-1690228669-1" class="totri-footnote">1</a> <a href="#i-1690228669-2" class="totri-footnote">2</a> <a href="#i-1690228669-3" class="totri-footnote">3</a>
        <br> <span class="code">unzip</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1730867960-1">on class <span class="code">List</span></a>
        <br> <span class="code">update</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1392004210-1">on class <span class="code">Array</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1619007525-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2073501059-1">on trait <span class="code">mutable.Map</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i2073506953-1">on trait <span class="code">mutable.Set</span></a>
        <br> <span class="code">updated</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2090714253-1">on <span class="code">Seq</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1981412563-1">on trait <span class="code">immutable.Map</span></a>
        <br> <span class="code">updatedWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1818572663-1">on trait <span class="code">immutable.Map</span></a>
        <br> <span class="code">updateWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2081046295-1">on trait <span class="code">mutable.Map</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <a href="#i-1812239373-1">upper bounds</a>
        <br> user interfaces
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i851179987-1">reactive programming</a>
        <br> user interfaces <a href="#i1275390415-1" class="totri-footnote">1</a> <a href="#i1275390415-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-421431555-1">reactive programming</a>
        <br>
        <h3 id="iiv" class="indexh3">V</h3> <span class="code">val</span>s, <i>see also</i> variables
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1727592746-1">abstract</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1935725073-1">annotating</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i521418335-1">as fields</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-168967627-1">conditional initialization of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i646151360-1">defining</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-861970308-1">lazy</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-687482648-1">preferring over <span class="code">var</span>s</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1513931462-1">referencing mutable objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i763174956-1">"<span class="code">val</span>" on class parameters</a>
        <br> <a href="#i-1232708119-1"><span class="code">Value</span> class</a>
        <br> <a href="#i-20487049-1">value classes</a>
        <br> <span class="code">value</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i971355780-1">on trait <span class="code">Future</span></a>
        <br> <a href="#i-780439702-1">value parameterization</a>
        <br> <a href="#i1571974179-1"><span class="code">ValueChanged</span> class</a>
        <br> <span class="code">values</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-563805575-1">on class <span class="code">Enumeration</span></a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Map</span> traits <a href="#i-546077233-1" class="totri-footnote">1</a> <a href="#i-546077233-2" class="totri-footnote">2</a>
        <br> <span class="code">valuesIterator</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1069490177-1">on <span class="code">Map</span> traits</a>
        <br> <a href="#i717131072-1">van Rossum, Guido</a>
        <br> <a href="#i1383700270-1">vararg matching</a>
        <br> variable patterns <a href="#i-1540579321-1" class="totri-footnote">1</a> <a href="#i-1540579321-2" class="totri-footnote">2</a>
        <br> <a href="#i1053833551-1">variable-binding patterns</a>
        <br> variable-length arguments, or "varargs", <i>see</i> repeated parameters
        <br> variables
        <br> &nbsp;&nbsp;&nbsp;&nbsp;bound <a href="#i31167931-1" class="totri-footnote">1</a> <a href="#i31167931-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1976863198-1">captured by closures</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-717204901-1">defining</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using patterns <a href="#i-467993090-1" class="totri-footnote">1</a> <a href="#i-467993090-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1074702876-1">fields</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;final (Java), <i>see</i> <span class="code">val</span>s
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-968704369-1">free</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-813534408-1">instance</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i40385448-1">local</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i664504196-1">multiple definitions of</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i717358687-1">reassignable</a>, <i>see also</i> <span class="code">var</span>s
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i46504593-1">scope</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1451425665-1">shadowing</a>
        <br> <a href="#i-1249575311-1">variance</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1555746715-1">annotations</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compiler checking of <a href="#i-245097893-1" class="totri-footnote">1</a> <a href="#i-245097893-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i358663587-1">declaration-site</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1971613366-1">use-site</a>
        <br> <span class="code">var</span>s, <i>see also</i> variables
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-464180816-1">abstract</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i176085891-1">and mutable objects</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i175307031-1">annotating</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1295914649-1">as fields</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1545622202-1">defining</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i332825445-1">on class parameters</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-96078285-1">programming without</a>
        <br> <a href="#i-1289707631-1"><span class="code">VectorMap</span> class</a>
        <br> <a href="#i-1604465616-1">verifiable properties</a>
        <br> <span class="code">view</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;on <span class="code">Iterable</span> traits <a href="#i499973296-1" class="totri-footnote">1</a> <a href="#i499973296-2" class="totri-footnote">2</a>
        <br> <span class="code">viewportView</span> property
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-184785362-1">on class <span class="code">ScrollPane</span></a>
        <br> <a href="#i112204398-1">views</a>
        <br> <a href="#i439466001-1">virtual classes</a>
        <br> <span class="code">volatile</span> annotation <a href="#i-882906061-1" class="totri-footnote">1</a> <a href="#i-882906061-2" class="totri-footnote">2</a>
        <br>
        <h3 id="iiw" class="indexh3">W</h3> <a href="#i-604737946-1">Wall, Larry</a>
        <br> warnings, <i>see</i> compiler warnings
        <br> <a href="#i-707232831-1">weak hash maps</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> <span class="code">while</span> loops <a href="#i852231328-1" class="totri-footnote">1</a> <a href="#i852231328-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-334114095-1">as imperative style</a>
        <br> wildcard patterns <a href="#i-615307671-1" class="totri-footnote">1</a> <a href="#i-615307671-2" class="totri-footnote">2</a>
        <br> wildcard types <a href="#i165566131-1" class="totri-footnote">1</a> <a href="#i165566131-2" class="totri-footnote">2</a>
        <br> <a href="#i-315542260-1">wildcard types (Java)</a>
        <br> <a href="#i134333723-1">Wirth, Niklaus</a>
        <br> <a href="#i1578124431-1"><span class="code">with</span> keyword</a>
        <br> <span class="code">withFilter</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1712949079-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1671672129-1">on trait <span class="code">Future</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-545883542-1">on trait <span class="code">Iterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i582713813-1">translating <span class="code">for</span> expressions to invocations of</a>
        <br> <a href="#i-61010514-1"><span class="code">WrappedString</span> class</a>
        <br>
        <h3 id="iix" class="indexh3">X</h3> <a href="#i87031-1">XML</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;attributes <a href="#i2120320186-1" class="totri-footnote">1</a> <a href="#i2120320186-2" class="totri-footnote">2</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1840683213-1">character encoding</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1866586400-1">configuration files</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1798539574-1">configuration files</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1294189452-1">deserialization</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1968563942-1">elements</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-598913593-1">literals</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1884986778-1">pattern matching</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1549258323-1">serialization</a>
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i599725500-1">tags</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i599729872-1">text</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-2110526308-1">using an at sign (<span class="code">@</span>) to extract attributes </a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1428654986-1">using curly braces (<span class="code">{}</span>) in pattern matching</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1385250650-1">XPath</a>
        <br> <span class="code">XML</span> object
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1708565962-1"><span class="code">loadFile</span></a>
        <br> <span class="code">XML</span> object
        <br> &nbsp;&nbsp;&nbsp;&nbsp;methods
        <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1587478341-1"><span class="code">save</span></a>
        <br> <a href="#i83750045-1">XPath</a>
        <br>
        <h3 id="iiy" class="indexh3">Y</h3> <a href="#i2747784-1">Yacc</a>
        <br> <span class="code">yield</span> keyword
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1145887345-1">in <span class="code">for</span> expressions</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1534065145-1">in <span class="code">for</span> expressions</a>
        <br>
        <h3 id="iiz" class="indexh3">Z</h3> <span class="code">zip</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i751157423-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1097812436-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-1080229753-1">on trait <span class="code">Iterator</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-576155948-1">on trait <span class="code">Future</span></a>
        <br> <span class="code">zipAll</span> method
        <br>
        <br> <a href="#iia" class="totri-footnote">a</a> <a href="#iib" class="totri-footnote">b</a> <a href="#iic" class="totri-footnote">c</a> <a href="#iid" class="totri-footnote">d</a> <a href="#iie" class="totri-footnote">e</a> <a href="#iif" class="totri-footnote">f</a> <a href="#iig" class="totri-footnote">g</a> <a href="#iih" class="totri-footnote">h</a> <a href="#iii" class="totri-footnote">i</a> <a href="#iij" class="totri-footnote">j</a> <a href="#iik" class="totri-footnote">k</a> <a href="#iil" class="totri-footnote">l</a> <a href="#iim" class="totri-footnote">m</a> <a href="#iin" class="totri-footnote">n</a> <a href="#iio" class="totri-footnote">o</a> <a href="#iip" class="totri-footnote">p</a> <a href="#iiq" class="totri-footnote">q</a> <a href="#iir" class="totri-footnote">r</a> <a href="#iis" class="totri-footnote">s</a> <a href="#iit" class="totri-footnote">t</a> <a href="#iiu" class="totri-footnote">u</a> <a href="#iiv" class="totri-footnote">v</a> <a href="#iiw" class="totri-footnote">w</a> <a href="#iix" class="totri-footnote">x</a> <a href="#iiy" class="totri-footnote">y</a> <a href="#iiz" class="totri-footnote">z</a>
        <br>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i1056526603-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i374738376-1">on trait <span class="code">Iterator</span></a>
        <br> <span class="code">zipWith</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i996770531-1">on trait <span class="code">Future</span></a>
        <br> <span class="code">zipWithIndex</span> method
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-735272059-1">on class <span class="code">List</span></a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i628301846-1">on <span class="code">Iterable</span> traits</a>
        <br> &nbsp;&nbsp;&nbsp;&nbsp;<a href="#i-886001315-1">on trait <span class="code">Iterator</span></a>
        <br>
      </div>
      <div style="text-align: center">
        <p><span style="font-size:xx-large">Take the fun path to deeper understanding<br> <span style="font-size:x-large">with this new book from Artima Press:<br> </span></span></p>
        <p><img src="Book-Ads/scalaPuzzlersJustFrontWithBorder64.png" alt="images/Book-Ads/scalaPuzzlersJustFrontWithBorder64.png"> <br></p>
      </div>
      <p><em>Scala Puzzlers</em> is a collection of enigmatic Scala code examples that behave highly contrary to expectations. Working through these code examples and the subsequent explanations will provide important and often fundamental insights into Scala. Get ready for a fun journey that will take you further down the road to Scala mastery.</p>
      <p><span class="textbf"><span style="font-size:large">Scala Puzzlers: The fun path to deeper understanding</span></span><br> by Andrew Phillips and Nerin Šerifović<br> <span style="font-size:small">ISBN: 978-0-9815316-7-0</span><br> <span style="font-size:small">$38.95 paper book / $25.00 PDF eBook</span><br></p>
      <div style="text-align: center">
        <p><span style="font-size:x-large">Order your copy now at:</span><br> <span style="font-size:large"><a href="https://www.artima.com/shop/scala_puzzlers">https://www.artima.com/shop/scala_puzzlers</a></span></p>
      </div>
      <div style="font-size:medium">
        <div style="text-align: center">
          <p><span style="font-size:xx-large">Other titles from Artima Press</span></p>
        </div>
        <p><img src="Book-Ads/scalaCheckCoverJustFrontWithBorder32.png" alt="images/Book-Ads/scalaCheckCoverJustFrontWithBorder32.png"></p>
        <p><br>Property-based testing allows you to express your tests in terms of functions called "properties" that describe your code's behavior, leaving the task of test case generation and evaluation to the testing tool. <em>ScalaCheck: The Definitive Guide</em> is the authoritative guide to ScalaCheck, a property-based testing tool for Scala. Written by the creator of ScalaCheck, this book will help you learn how to take advantage of this valuable complement to traditional testing techniques.</p>
        <p><span class="textbf"><span style="font-size:large">ScalaCheck: The Definitive Guide</span></span><br> by Rickard Nilsson<br> <span style="font-size:small">ISBN: 978-0-9815316-9-4</span><br> <span style="font-size:small">$24.95 paper book / $15.00 PDF eBook</span><br> Order it now at: <a href="https://www.artima.com/shop/scalacheck">https://www.artima.com/shop/scalacheck</a></p>
        <div style="font-size:medium">
          <p><img src="Book-Ads/akkaConcurrencyCoverJustFrontWithBorder32.png" alt="images/Book-Ads/akkaConcurrencyCoverJustFrontWithBorder32.png"></p>
          <p><br> <em>Akka Concurrency</em> is the authoritative guide to concurrent programming with Akka. Written as a practical guide, it will teach you not just the "what" and "how" of Akka, but also the "why." Akka isn't just a toolkit you can use to write your concurrent applications: it embodies a set of paradigms you can use to <em>reason</em> about those applications. This book will give you a whole new perspective on how you design, build, and think about concurrent applications on the JVM.</p>
          <p><span class="textbf"><span style="font-size:large">Akka Concurrency</span></span><br> by Derek Wyatt<br> <span style="font-size:small">ISBN: 978-0-9815316-6-3</span><br> <span style="font-size:small">$45.95 paper book / $26.95 PDF eBook</span><br> Order it now at: <a href="https://www.artima.com/shop/akka_concurrency">https://www.artima.com/shop/akka_concurrency</a></p>
        </div>
      </div>
    </div>
  </body>
</html>